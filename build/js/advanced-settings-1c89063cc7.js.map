{"version":3,"sources":["js/advanced-settings.js","js/node_modules/_browser-pack@5.0.1@browser-pack/_prelude.js","js/assets/js/advanced-settings.js","js/node_modules/_codemirror@5.65.16@codemirror/mode/htmlmixed/htmlmixed.js","js/node_modules/_codemirror@5.65.16@codemirror/mode/xml/xml.js","js/node_modules/_codemirror@5.65.16@codemirror/mode/javascript/javascript.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/selection/active-line.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/lint/lint.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/lint/json-lint.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/lint/javascript-lint.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/lint/html-lint.js","js/node_modules/_htmlhint@1.1.4@htmlhint/dist/htmlhint.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/lint/css-lint.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/hint/show-hint.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/hint/javascript-hint.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/hint/html-hint.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/hint/xml-hint.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/hint/css-hint.js","js/node_modules/_codemirror@5.65.16@codemirror/mode/css/css.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/hint/anyword-hint.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/edit/trailingspace.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/edit/matchtags.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/edit/matchbrackets.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/edit/continuelist.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/edit/closetag.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/fold/xml-fold.js","js/node_modules/_codemirror@5.65.16@codemirror/addon/edit/closebrackets.js","js/node_modules/_codemirror@5.65.16@codemirror/lib/codemirror.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_toPropertyKey","key","_createClass","protoProps","staticProps","prototype","t","_toPrimitive","_typeof","String","r","e","Symbol","toPrimitive","call","Number","o","iterator","constructor","require","n","s","u","a","f","Error","code","l","exports","module","$","CodeMirror","debounce","$preview","$editor","cm","fromTextArea","get","theme","mode","lineNumbers","lineWrapping","spellcheck","autocorrect","showTrailingSpace","styleActiveLine","continueComments","autoRefresh","readOnly","window","IS_CUSTOM_VERIFICATION_DISABLED","lint","gutters","change","val","getValue","contents","find","html","on","mod","defaultTags","script","style","attrRegexpCache","getAttrValue","text","attr","match","regexp","RegExp","getAttrRegexp","exec","getTagRegexp","tagName","anchored","addTags","from","to","tag","dest","source","unshift","defineMode","config","parserConfig","htmlMode","getMode","name","multilineTagIndentFactor","multilineTagIndentPastTag","allowMissingTagName","tags","configTags","configScript","scriptTypes","matches","stream","state","token","htmlState","test","current","toLowerCase","hasOwnProperty","inTag","modeSpec","tagInfo","tagText","spec","findMatchingMode","endTagA","endTag","localState","localMode","pat","cur","close","search","backUp","maybeBackup","startState","indent","eol","copyState","local","textAfter","line","Pass","innerMode","defineMIME","define","amd","htmlConfig","autoSelfClosers","area","base","br","col","command","embed","frame","hr","img","input","keygen","link","meta","param","track","wbr","menuitem","implicitlyClosed","dd","li","optgroup","option","p","rp","rt","tbody","td","tfoot","th","tr","contextGrabbers","dt","address","article","aside","blockquote","dir","div","dl","fieldset","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","menu","nav","ol","pre","section","table","ul","thead","doNotIndent","allowUnquoted","allowMissing","caseFold","xmlConfig","editorConf","config_","type","setStyle","indentUnit","defaults","prop","inText","chain","parser","tokenize","ch","next","eat","inBlock","eatWhile","doctype","quote","closure","baseState","tagStart","isInAttribute","stringStartCol","column","terminator","depth","lower","Context","startOfLine","this","prev","context","indented","noIndent","popContext","maybePopContext","nextTagName","parentTagName","tagNameState","closeTagNameState","attrState","matchClosing","closeState","closeStateErr","_stream","attrEqState","attrValueState","attrContinuedState","isInText","baseIndent","sol","indentation","eatSpace","fullLine","alignCDATA","tagAfter","grabbers","electricInput","blockCommentStart","blockCommentEnd","configuration","helperType","skipAttribute","xmlCurrentTag","xmlCurrentContext","cx","push","reverse","mimeModes","content","statementIndent","jsonldMode","jsonld","jsonMode","json","trackScope","isTS","typescript","wordRE","wordCharacters","keywords","kw","A","B","C","D","operator","atom","if","while","with","else","do","try","finally","return","break","continue","new","delete","void","throw","debugger","var","const","let","function","catch","for","switch","case","default","in","typeof","instanceof","true","false","null","undefined","NaN","Infinity","class","super","yield","export","import","extends","await","isOperatorChar","isJsonldKeyword","ret","tp","cont","tokenBase","escaped","peek","tokenComment","skipToEnd","expressionAllowed","inSet","readRegexp","tokenQuasi","string","slice","start","lexical","word","lastType","propertyIsEnumerable","maybeEnd","brackets","findFatArrow","fatArrowAt","arrow","indexOf","m","index","sawSomething","pos","charAt","bracket","atomicTypes","number","variable","JSLexical","align","info","inScope","varname","v","localVars","vars","parseJS","cc","marked","pop","expression","statement","lex","pass","arguments","apply","inList","list","register","block","newContext","registerVarScoped","Var","globalVars","inner","isModifier","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","result","outer","poplex","expect","wanted","exp","value","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","className","enumdef","typename","typeexpr","pattern","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","body","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","arrayLiteral","contCommasep","objprop","quasi","targetNoComma","maybeTypeArgs","maybeTarget","me","expr","property","continueQuasi","_","getterSetter","afterprop","maybetype","what","end","sep","proceed","maybetypeOrIn","mayberettype","isKW","afterType","typeprops","typearg","maybeReturnType","quasiType","typeprop","functiondecl","continueQuasiType","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","basecolumn","top","firstChar","c","closing","isContinuedStatement","doubleIndentSwitch","blockCommentContinue","lineComment","fold","closeBrackets","skipExpression","StringStream","registerHelper","WRAP_CLASS","BACK_CLASS","GUTT_CLASS","clearActiveLines","activeLines","removeLineClass","updateActiveLines","ranges","active","range","getOption","nonEmpty","anchor","head","empty","getLineHandleVisualStart","b","sameArray","operation","addLineClass","selectionChange","sel","defineOption","old","Init","off","listSelections","GUTTER_ID","LINT_LINE_ID","rm","elt","parentNode","removeChild","showTooltipFor","node","tooltip","tt","document","createElement","position","Math","max","clientY","offsetHeight","left","min","clientX","ownerDocument","defaultView","innerWidth","offsetWidth","options","appendChild","cloneNode","selfContain","getWrapperElement","opacity","showTooltip","hide","setTimeout","poll","setInterval","nodeType","host","clearInterval","LintState","conf","hasGutter","Function","getAnnotations","linterOptions","timeout","onMouseOver","srcElement","box","getBoundingClientRect","x","right","y","bottom","spans","findMarksAt","coordsChar","annotations","ann","__annotation","createDocumentFragment","annotationTooltip","popupTooltips","waitingFor","highlightLines","tooltips","delay","lintOnChange","async","formatAnnotation","onUpdateLinting","clearMarks","clearGutter","eachLine","has","wrapClass","clearErrorLines","clear","makeMarker","labels","severity","multiple","marker","tip","messageHTML","innerHTML","createTextNode","message","startLinting","getHelper","Pos","id","abort","arg2","updateLinting","lintAsync","then","issues","annotationsNotSorted","lines","groupByLine","anns","maxSeverity","tipLabel","markText","setGutterMarker","onChange","clearTimeout","hasLintGutter","defineExtension","found","jsonlint","console","error","parseError","str","hash","loc","first_line","first_column","last_line","last_column","parse","JSHINT","globals","errors","data","output","warn","character","evidence","substring","hint","reason","startsWith","parseErrors","HTMLHint","defaultRules","verify","messages","rules","startLine","endLine","startCol","endCol","global","factory","core$1","htmlparser","HTMLParser","_listeners","_mapCdataTags","makeMap","_arrBlocks","lastEvent","obj","items","split","matchIndex","arrAttrs","attrsCDATA","_this","mapCdataTags","regTag","regAttr","regLine","lastIndex","tagCDATA","arrCDATA","lastCDATAIndex","lastLineIndex","arrBlocks","fire","attrType","saveBlock","raw","join","attrs","attrMatch","attrMatchCount","concat","long","types","listener","arrTypes","listeners","listenersType","listenersAll","splice","event","arrLines","substr","lineCount","mapAttrs","reporter","Reporter","ruleset","brLen","rule","report","evidenceLen","description","altRequire","init","_this2","addListener","selector","getMapAttrs","attrLowercase","svgIgnores","_this3","exceptions","Array","isArray","_loop","attrName","comparison","firstComparisonChar","lastComparisonChar","secondToLastComparisonChar","comparisonIsRegex","testAgainstStringOrRegExp","attrSorted","_this4","orderMap","sortOrder","listOfAttributes","originalAttrs","JSON","stringify","sort","localeCompare","attrNoDuplication","_this5","mapAttrName","attrUnsafeChars","_this6","regUnsafe","unsafeCode","escape","replace","attrValueDoubleQuotes","_this7","attrValueNotEmpty","_this8","attrValueSingleQuotes","_this9","attrWhitespace","_this10","forEach","elem","trim","doctypeFirst","_this11","allEvent","removeListener","doctypeHtml5","_this12","onComment","onTagStart","headScriptDisabled","_this13","reScript","isInHead","onTagEnd","hrefAbsOrRel","_this14","hrefMode","htmlLangRequire","grandfathered","extension","language","langtag","languageTag","_this15","langValidityPattern","idClassAdDisabled","_this16","idClassValue","_this17","underline","regId","dash","hump","l1","arrClass","classValue","j","l2","idUnique","_this18","mapIdCount","inlineScriptDisabled","_this19","reEvent","inlineStyleDisabled","_this20","inputRequiresLabel","_this21","labelTags","inputTags","forValue","inputTag","labelTag","hasMatchingLabelTag","scriptDisabled","_this22","spaceTabMixedDisabled","_this23","indentMode","spaceLengthRequire","parseInt","reMixed","fixedPos","fixPos","whiteSpace","specCharEscape","_this24","reSpecChar","srcNotEmpty","_this25","styleDisabled","_this26","tagPair","_this27","stack","mapEmptyTags","arrTags","tagSelfClose","_this28","emptyTagNotSelfClosed","_this29","tagnameLowercase","_this30","tagnameSpecialchars","_this31","specialchars","titleRequire","_this32","headBegin","hasTitle","tagsCheck","tagsTypings","selfclosing","attrsRequired","redundantAttrs","main","attrsOptional","_this33","assign","currentTagType","copyOfId","map","realID","shift","values","some","attrNoUnnecessaryWhitespace","_this34","tagnameSpecialChars","idClsasAdDisabled","doctypeHTML5","attrSort","alt_require_1","attr_lowercase_1","attr_sorted_1","attr_no_duplication_1","attr_unsafe_chars_1","attr_value_double_quotes_1","attr_value_not_empty_1","attr_value_single_quotes_1","attr_whitespace_1","doctype_first_1","doctype_html5_1","head_script_disabled_1","href_abs_or_rel_1","html_lang_require_1","id_class_ad_disabled_1","id_class_value_1","id_unique_1","inline_script_disabled_1","inline_style_disabled_1","input_requires_label_1","script_disabled_1","space_tab_mixed_disabled_1","spec_char_escape_1","src_not_empty_1","style_disabled_1","tag_pair_1","tag_self_close_1","empty_tag_not_self_closed_1","tagname_lowercase_1","tagname_specialchars_1","title_require_1","tags_check_1","attr_no_unnecessary_whitespace_1","HTMLRules","htmlparser_1","reporter_1","HTMLHintCore","defaultRuleset","keys","all","strRuleset","ruleId","arrMessages","arrLogs","colors","white","grey","red","reset","evidenceCount","leftCol","leftWindow","rightCol","repeatStr","pointCol","addRule","__esModule","globalThis","self","CSSLint","ACTIVE_HINT_ELEMENT_CLASS","Completion","widget","tick","startPos","getCursor","startLen","getLine","getSelection","updateOnCursorActivity","activityFunc","cursorActivity","showHint","getHints","newOpts","editor","hintOptions","out","defaultOptions","resolve","parseOptions","selections","somethingSelected","supportsSelection","completionActive","completion","signal","update","requestAnimationFrame","fn","cancelAnimationFrame","getText","getHintElement","hintsElement","el","nodeName","toUpperCase","Widget","floor","random","picked","getInputField","parentWindow","hints","setAttribute","selectedHint","completions","render","displayText","hintId","container","cursorCoords","alignWithWord","below","offsetLeft","offsetTop","offsetParent","getComputedStyle","offsetParentPosition","bodyPosition","scrollLeft","scrollTop","winW","documentElement","winH","innerHeight","startScroll","moveOnOverlap","DOMRect","scrolls","paddingForScrollbar","scrollHeight","clientHeight","getScrollInfo","height","spaceAbove","closingOnBlur","overlapX","display","nativeBarWidth","width","firstChild","nextSibling","paddingRight","addKeyMap","keyMap","handle","baseMap","Up","moveFocus","Down","PageUp","menuSize","PageDown","Home","setFocus","End","Enter","pick","Tab","Esc","navigator","platform","custom","customKeys","ourMap","addBinding","bound","extra","extraKeys","buildKeyMap","avoidWrap","changeActive","screenAmount","closeOnUnfocus","onBlur","onFocus","onScroll","curScroll","newTop","point","pageYOffset","completeOnSingleClick","focus","selectedHintRange","getSelectedHintRange","scrollToActive","childNodes","fetchHints","callback","replaceRange","scrollIntoView","closeOnPick","identStart","closeCharacters","disable","first","myTick","finishUpdate","completeSingle","removeKeyMap","removeAttribute","node1","node2","firstNode","margin","scrollMargin","words","helpers","getHelpers","resolved","app","applicableHelpers","run","fromList","anyword","term","getTokenAt","commands","autocomplete","auto","arr","scriptHint","getToken","tprop","getCompletions","getCoffeeScriptToken","javascriptKeywords","coffeescriptKeywords","stringProps","arrayProps","funcProps","globalScope","maybeAdd","lastIndexOf","item","arrayContains","gatherCompletions","getOwnPropertyNames","getPrototypeOf","forAllProps","additionalContext","useGlobalScope","jQuery","langs","targets","charsets","methods","encs","media","href","ping","hreflang","abbr","acronym","applet","alt","coords","shape","audio","src","mediagroup","crossorigin","preload","autoplay","loop","controls","basefont","bdi","bdo","big","cite","button","formaction","autofocus","disabled","formenctype","formmethod","formnovalidate","formtarget","canvas","caption","center","span","colgroup","label","icon","radiogroup","title","checked","datagrid","datalist","del","datetime","details","open","dfn","dialog","em","eventsource","figcaption","figure","font","action","enctype","method","novalidate","frameset","children","manifest","iframe","srcdoc","sandbox","seamless","ismap","usemap","dirname","maxlength","placeholder","size","step","accept","readonly","required","ins","kbd","challenge","keytype","legend","sizes","mark","charset","meter","low","high","optimum","noframes","noscript","object","typemustmatch","reversed","selected","progress","q","ruby","samp","defer","select","small","strike","strong","scoped","sub","summary","sup","colspan","rowspan","headers","textarea","rows","cols","wrap","scope","time","kind","srclang","video","poster","muted","globalAttrs","accesskey","contenteditable","contextmenu","draggable","dropzone","hidden","inert","itemid","itemprop","itemref","itemscope","itemtype","lang","autocapitalize","tabindex","translate","onclick","rel","populate","htmlSchema","schemaInfo","opt","xml","typed","matchInMiddle","quoteChar","prefix","replaceToken","before","tagType","curTag","childList","set","nm","atValues","atName","getRange","len","returnHintsFromAtValues","returnHints","pseudoClasses","after","enabled","hover","indeterminate","invalid","not","optional","root","selection","valid","visited","resolveMode","st","add","propertyKeywords","valueKeywords","colorKeywords","mediaTypes","mediaFeatures","keySet","array","inline","override","tokenHooks","documentTypes","mediaValueKeywords","nonStandardPropertyKeywords","fontProperties","counterDescriptors","allowNested","supportsAtComponent","highlightNonStandardPropertyKeywords","tokenString","tokenParenthesized","pushContext","states","popAndPass","wordAsValue","stateArg","atBlock","electricChars","documentTypes_","mediaTypes_","mediaFeatures_","mediaValueKeywords_","propertyKeywords_","nonStandardPropertyKeywords_","colorKeywords_","valueKeywords_","allWords","tokenCComment","WORD","curLine","curWord","seen","re","firstLine","lastLine","removeOverlay","addOverlay","tagHit","tagOther","doMatchTags","failedTagMatch","getViewport","findMatchingTag","matchBothTags","hit","at","other","maybeUpdateMatch","bothTags","toMatchingTag","extendSelection","ie_lt8","userAgent","documentMode","matching","bracketRegex","findMatchingBracket","where","getLineHandle","afterCursor","strict","getTokenTypeAt","scanForBracket","forward","maxScanLen","maxScanLineLength","maxScanLines","lineEnd","lineNo","matchBrackets","autoclear","maxHighlightLen","maxHighlightLineLength","highlightNonMatching","marks","focused","doMatchBrackets","currentlyHighlighted","clearHighlighted","oldConfig","listRE","emptyListRE","unorderedListRE","incrementRemainingMarkdownListNumbers","lookAhead","skipCount","startItem","startIndent","nextLineNumber","nextLine","nextItem","nextIndent","newNumber","nextNumber","itemNumber","isNaN","newlineAndIndentContinueMarkdownList","replacements","eolState","getStateAfter","execCommand","inQuote","cursorBeforeBullet","endOfQuote","endOfList","numbered","bullet","replaceSelections","whenClosing","autoCloseCurrent","autoCloseSlash","whenOpening","tok","dontCloseTags","htmlDontClose","indentTags","htmlIndent","lowerTagName","closingTagExists","emptyTags","newPos","dontIndentOnAutoClose","setSelections","indentLine","autoCloseGT","typingSlash","dontIndentOnSlash","replacement","mixed","collection","newTag","scanForClosingTag","nextClose","onCx","closeTag","cmp","nameStartChar","xmlTagStart","Iter","tagAt","iter","prevLine","toTagEnd","gt","lastSlash","selfClose","toTagStart","lt","toNextTag","toPrevTag","findMatchingClose","startCh","findMatchingOpen","endCh","openTag","endPos","here","findEnclosingTag","pairs","closeBefore","triples","explode","ensureBound","Backspace","getConfig","around","charsAround","linesep","lineSeparator","replaceSelection","moveSel","chars","handler","identical","opening","curType","isWordChar","stringStartsAfter","sels","getSelections","contractSelection","triggerElectric","handleChar","deflt","getModeAt","newRanges","primary","inverted","cmpPos","gecko","ie_upto10","ie_11up","edge","ie","ie_version","webkit","qtwebkit","chrome","chrome_version","presto","safari","vendor","mac_geMountainLion","phantom","ios","maxTouchPoints","android","mobile","mac","chromeOS","windows","presto_version","flipCtrlCmd","captureRightClick","classTest","cls","rmClass","removeChildren","count","removeChildrenAndAdd","parent","cssText","eltP","contains","child","activeElt","rootNode","activeElement","doc","shadowRoot","addClass","joinClasses","as","createRange","endNode","setEnd","setStart","createTextRange","moveToElementText","collapse","moveEnd","moveStart","selectInput","wrapper","element","getRootNode","win","bind","args","copyObj","overwrite","countColumn","tabSize","startIndex","startValue","nextTab","selectionStart","selectionEnd","_e","Delayed","onTimeout","Date","ms","scrollerGap","toString","sel_dontScroll","scroll","sel_mouse","origin","sel_move","findColumn","goal","skipped","spaceStrs","spaceStr","lst","nothing","createObj","inst","create","nonASCIISingleCaseWordChar","isWordCharBasic","helper","isEmpty","extendingChars","isExtendingChar","charCodeAt","skipExtendingChars","findFirst","pred","midF","mid","ceil","bidiOther","getBidiPartAt","order","sticky","bidiOrdering","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","BidiSpan","level","direction","outerType","i$1","i$2","type$1","i$3","prev$1","type$2","i$4","type$3","i$5","cur$1","type$4","i$6","end$1","replace$1","j$1","i$7","isRTL","j$2","nstart","getOrder","noHandlers","emitter","addEventListener","attachEvent","_handlers","getHandlers","removeEventListener","detachEvent","handlers","signalDOMEvent","preventDefault","defaultPrevented","e_defaultPrevented","codemirrorIgnore","signalCursorActivity","curOp","cursorActivityHandlers","hasHandler","eventMixin","ctor","e_preventDefault","returnValue","e_stopPropagation","stopPropagation","cancelBubble","e_stop","e_target","e_button","which","ctrlKey","zwspSupported","badBidiRects","dragAndDrop","zeroWidthElement","measure","hasBadBidiRects","txt","r0","r1","splitLinesAuto","nl","hasSelection","te","parentElement","compareEndPoints","hasCopyEvent","oncopy","badZoomedRects","modes","dependencies","mfactory","modeObj","modeExtensions","exts","modeProps","prop$1","extendMode","properties","nstate","a1","a2","lineOracle","lastColumnPos","lastColumnValue","lineStart","chunk","sz","chunkSize","getBetween","getLines","updateLineHeight","diff","no","lineAtHeight","h","lh","isLine","lineNumberFor","lineNumberFormatter","firstLineNumber","equalCursorPos","copyPos","maxPos","minPos","clipLine","clipPos","last","linelen","clipToLen","clipPosArray","skipTo","consume","caseInsensitive","cased","hideFirstChars","oracle","baseToken","SavedContext","maxLookAhead","baseTokens","baseTokenPos","highlightLine","forceToEnd","modeGen","lineClasses","runMode","overlay","overlays","i_end","opaque","styles","classes","bgClass","textClass","getLineStyles","updateFrontier","getContextBefore","resetState","maxHighlightLength","stateAfter","save","styleClasses","highlightFrontier","modeFrontier","precise","minindent","minline","lim","findStartLine","saved","fromSaved","processLine","viewFrom","viewTo","startAt","callBlankLine","readToken","blankLine","copy","Token","takeToken","asArray","tokens","extractLineClasses","lineClass","flattenSpans","curStart","curStyle","addModeClass","mName","sawReadOnlySpans","sawCollapsedSpans","MarkedSpan","getMarkedSpanFor","removeMarkedSpan","stretchSpansOverChange","full","oldFirst","markedSpans","oldLast","isInsert","nw","inclusiveLeft","insertLeft","endsAfter","inclusiveRight","markedSpansBefore","startsBefore","markedSpansAfter","sameLine","offset","span$1","clearEmptySpans","newMarkers","gapMarkers","gap","clearWhenEmpty","detachMarkedSpans","detachLine","attachMarkedSpans","attachLine","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","sp","collapsed","collapsedSpanAtStart","collapsedSpanAtEnd","collapsedSpanAround","conflictingCollapsedRange","visualLine","merged","visualLineNo","lineN","vis","visualLineEndNo","lineIsHidden","widgetNode","lineIsHiddenInner","heightAtLine","lineObj","lineLength","found$1","findMaxLine","d","maxLine","maxLineLength","maxLineChanged","Line","estimateHeight","cleanUpLine","styleToClassCache","styleToClassCacheWithMode","interpretTokenStyle","cache","buildLineContent","lineView","builder","trailingSpace","splitSpaces","rest","addToken","buildToken","buildTokenBadBidi","insertLineContent","externalMeasured","maps","caches","lastChild","querySelector","defaultSpecialCharPlaceholder","startStyle","endStyle","css","attributes","trailingBefore","spaceBefore","special","specialChars","mustWrap","txt$1","tabWidth","specialCharPlaceholder","fullStyle","part","buildCollapsedSpan","ignoreWidget","needsContentAttribute","setUneditable","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","foundBookmarks","endStyles","upto","tokenText","LineView","visualLineContinued","buildViewArray","nextPos","view","operationGroup","orphanDelayedCallbacks","signalLater","delayedCallbacks","fireOrphanDelayed","delayed","updateLineForChanges","dims","changes","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","zIndex","getLineContent","ext","built","background","insertBefore","updateLineBackground","gutter","gutterBackground","gutterClass","fixedGutter","gutterTotalWidth","markers","gutterMarkers","wrap$1","gutterWrap","lineNumber","gutterLeft","lineNumInnerWidth","k","gutterSpecs","gutterWidth","alignable","isWidget","insertLineWidgets","buildLineElement","insertLineWidgetsFor","allowAbove","widgets","ws","handleMouseEvents","positionLineWidget","above","noHScroll","wrapperWidth","coverGutter","paddingLeft","marginLeft","widgetHeight","parentStyle","clientWidth","eventInWidget","getAttribute","sizer","mover","paddingTop","lineSpace","paddingVert","paddingH","cachedPaddingH","currentStyle","scrollGap","displayWidth","scroller","barWidth","displayHeight","barHeight","mapFromLineView","measureChar","bias","measureCharPrepared","prepareMeasureForLine","findViewForLine","findViewIndex","getDimensions","forceUpdate","lineMeasure","updateExternalMeasurement","rect","hasHeights","prepared","varHeight","wrapping","curWidth","heights","rects","getClientRects","abs","ensureLineHeights","place","nodeAndOffsetInLineMap","coverStart","coverEnd","getUsefulRect","screen","logicalXDPI","deviceXDPI","normal","fromRange","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","maybeUpdateRectForZooming","rSpan","charWidth","nullRect","rtop","rbot","bot","bogus","singleCursorHeightPerLine","rbottom","measureCharInner","measureText","mStart","mEnd","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","clearCaches","cachedCharWidth","cachedTextHeight","lineNumChars","pageScrollX","pageXOffset","pageScrollY","marginTop","widgetTopHeight","intoCoordSystem","includeWidgets","yOff","viewOffset","lOff","xOff","fromCoordSystem","localBox","lineSpaceBox","charCoords","preparedMeasure","getBidi","partPos","invert","estimateCoords","PosWithInfo","outside","xRel","coordsCharInner","rangeEnd","wrappedLineExtent","begin","wrappedLineExtentChar","boxIsAfter","ltr","coordsBidiPartWrapped","coordsBidiPart","baseX","chAround","boxAround","atLeft","atStart","_lineNo","ref","closestDist","endX","dist","textHeight","clientLeft","compensateForHScroll","perLine","widgetsHeight","estimateLineHeights","est","estHeight","posFromMouse","liberal","forRect","space","e$1","colDiff","round","regChange","lendiff","updateLineNumbers","viewChanged","resetView","cut","viewCuttingPoint","cut$1","cutTop","cutBot","regLineChange","oldN","newN","countDirtyView","dirty","updateSelection","showSelection","prepareSelection","curFragment","cursors","selFragment","customCursor","$customCursor","primIndex","drawSelectionCursor","showCursorWhenSelecting","drawSelectionRange","cursor","cursorHeight","charPos","defaultCharWidth","otherCursor","cmpCoords","fragment","padding","leftSide","rightSide","sizerWidth","docLTR","drawForLine","fromArg","toArg","lineLen","wrapX","side","extent","iterateBidiSections","fromPos","toPos","openStart","openEnd","openRight","topLeft","topRight","botLeft","botRight","sFrom","sTo","fromLine","toLine","singleVLine","leftEnd","rightStart","restartBlink","blinker","cursorDiv","visibility","cursorBlinkRate","hasFocus","ensureFocus","delayBlurEvent","delayingBlurEvent","draggingText","selForContextMenu","receivedFocus","updateHeightsInViewport","prevBottom","lineDiv","viewTop","oldHeight","mustScroll","updateWidgetHeight","chWidth","w","visibleLines","viewport","ensure","ensureFrom","ensureTo","calculateScrollPos","snapMargin","screentop","docBottom","atTop","atBottom","gutterSpace","screenleft","screenw","tooWide","addToScrollTop","resolveScrollToPos","ensureCursorVisible","scrollToPos","cursorScrollMargin","scrollToCoords","scrollToCoordsRange","sPos","updateScrollTop","updateDisplaySimple","setScrollTop","startWorker","forceScroll","scrollbars","setScrollLeft","isScroller","scrollWidth","alignHorizontally","measureForScrollbars","gutterW","docH","viewHeight","viewWidth","barLeft","docHeight","NativeScrollbars","vert","horiz","tabIndex","checkedZeroWidth","minHeight","minWidth","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","bar","maybeDisable","elementFromPoint","NullScrollbars","updateScrollbars","startWidth","startHeight","updateScrollbarsInner","paddingBottom","heightForcer","borderBottom","scrollbarFiller","coverGutterNextToScrollbar","gutterFiller","scrollbarModel","native","initScrollbars","scrollbarStyle","axis","nextOpId","startOperation","op","updateInput","typing","changeObjs","cursorActivityCalled","selectionChanged","updateMaxLine","markArrays","ops","ownsGroup","endOperation","endCb","group","callbacks","fireCallbacksForOps","finishOperation","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","endOperation_finish","endOperations","scrollbarsClipped","marginBottom","borderRightWidth","maybeClipScrollbars","mustUpdate","DisplayUpdate","updatedDisplay","updateDisplayIfNeeded","barMeasure","adjustWidthTo","maxScrollLeft","preparedSelection","takeFocus","setDocumentHeight","postUpdateDisplay","wheelStartX","wheelStartY","limit","changed","endCoords","scrollPos","startTop","startLeft","scrollPosIntoView","doScroll","scrollNode","maybeScrollWindow","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","finish","runInOp","methodOp","docMethodOp","highlight","highlightWorker","workTime","changedLines","oldStyles","highlighted","oldCls","newCls","ischange","workDelay","force","visible","editorIsHidden","wrapperHeight","oldDisplayWidth","events","renderedView","maybeUpdateLineNumberWidth","viewportMargin","different","lastWrapHeight","lastWrapWidth","adjustView","toUpdate","selSnapshot","anchorNode","extend","anchorOffset","focusNode","focusOffset","selectionSnapshot","updateNumbersFrom","currentWheelTarget","updateNumber","patchDisplay","snapshot","removeAllRanges","addRange","restoreSelection","selectionDiv","reportedViewFrom","reportedViewTo","updateGutterSpace","alignWidgets","comp","innerW","lineGutter","lineNumWidth","getGutters","sawLineNumbers","renderGutters","specs","gElt","updateGutters","Display","clipPath","wheelDX","wheelDY","activeTouch","wheelSamples","wheelPixelsPerUnit","wheelEventDelta","dx","wheelDeltaX","dy","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","delta","onScrollWheel","chromeScrollHack","pointerEvents","pixelsPerUnit","deltaMode","deltaX","deltaY","canScrollX","canScrollY","pixels","movedX","movedY","sample","Selection","equals","there","deepCopy","Range","normalizeSelection","mayTouch","selectionsMayTouch","prim","inv","simpleSelection","changeEnd","adjustForChange","computeSelAfterChange","offsetPos","loadMode","modeOption","resetModeState","isWholeLineUpdate","wholeLineUpdateBefore","updateDoc","spansFor","updateLine","linesFor","lastText","lastSpans","nlines","insert","remove","added","added$1","added$2","linkedDocs","sharedHistOnly","propagate","skip","sharedHist","linked","shared","attachDoc","setDirectionClass","History","done","undone","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","historyChangeFromChange","histChange","attachLocalSpans","clearSelectionEvents","addChangeToHistory","selAfter","opId","hist","history","historyEventDelay","lastChangeEvent","pushSelectionToHistory","addSelectionToHistory","selectionEventCanBeMerged","clearRedo","existing","removeClearedSpans","explicitlyCleared","mergeOldSpans","getOldSpans","stretched","oldCur","stretchCur","copyHistoryArray","newGroup","instantiateSel","newChanges","extendRange","posBefore","setSelection","extendSelections","heads","replaceOneSelection","setSimpleSelection","setSelectionReplaceHistory","setSelectionNoUndo","filterSelectionChange","setSelectionInner","skipAtomicInSelection","reCheckSelection","mayClear","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","preventCursorLeft","selectLeft","preventCursorRight","selectRight","atomic","near","movePos","far","cantEdit","selectAll","filterChange","canceled","cancel","makeChange","ignoreReadOnly","suppressEdits","parts","mk","newParts","dfrom","dto","removeReadOnlyRanges","makeChangeInner","makeChangeSingleDoc","rebased","rebaseHist","makeChangeFromHistory","allowSelectionOnly","suppress","antiChanges","filter","returned","shiftDoc","distance","removed","recomputeMaxLength","checkWidthStart","retreatFrontier","changesHandler","changeHandler","makeChangeSingleDocInEditor","splitLines","rebaseHistSelSingle","rebaseHistArray","ok","copied","changeLine","changeType","LeafChunk","BranchChunk","removeInner","insertInner","iterN","remaining","leaf","maybeSpill","sibling","myIndex","used","LineWidget","adjustScrollWhenAboveVisible","this$1","oldH","nextMarkerId","TextMarker","isParent","SharedTextMarker","markTextShared","replacedWith","addToHistory","inThisOp","WeakSet","addMarkedSpan","clearOnEnter","clearHistory","withOp","visual","dHeight","findSharedMarkers","findMarks","detachSharedMarkers","subMarker","nextDocId","Doc","lineSep","cleanGeneration","setValue","getLineNumber","setCursor","extendSelectionsBy","addSelection","dup","newSel","oldPrev","newPrev","computeReplacedSel","undo","redo","undoSelection","redoSelection","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","gutterID","lineInfo","addLineWidget","insertAt","aboveVisible","removeLineWidget","setBookmark","realOpts","getAllMarks","posFromIndex","sepSize","indexFromPos","copyHistory","linkedDoc","mFrom","mTo","subMark","copySharedMarkers","unlinkDoc","splitIds","iterLinkedDocs","getEditor","setDirection","lastDrop","onDrop","clearDragCursor","files","dataTransfer","isReadOnly","FileReader","File","read","markAsReadAndPasteIfAllFilesAreRead","readTextFromFile","file","allowDropFileTypes","reader","onerror","onload","readAsText","text$1","getData","dragCursor","forEachCodeMirror","getElementsByClassName","byClass","editors","globalsRegistered","ensureGlobalHandlers","resizeTimer","onResize","setSize","keyNames","fromCharCode","normalizeKeyName","ctrl","cmd","normalizeKeyMap","keymap","keyname","lookupKey","getKeyMap","fallthrough","isModifierKey","keyCode","addModifierNames","noShift","altKey","metaKey","shiftKey","keyName","altGraphKey","deleteNearSelection","compute","kill","toKill","replaced","moveCharLogically","moveLogically","endOfLine","visually","prep","targetTop","basic","Left","Right","Delete","Insert","pcDefault","emacsy","macDefault","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","rightPos","goDocStart","goDocEnd","goLineStart","goLineStartSmart","lineStartSmart","goLineEnd","visualLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","moveV","goLineDown","goPageUp","goPageDown","goCharLeft","moveH","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","deleteH","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentSelection","indentMore","indentLess","insertTab","insertSoftTab","spaces","defaultTab","transposeChars","newlineAndIndent","openLine","toggleOverwrite","firstNonWS","inWS","doHandleBinding","dropShift","ensurePolled","prevShift","stopSeq","dispatchKey","seq","keySeq","dispatchKeyInner","keyMaps","lookupKeyForEditor","handleKeyBinding","motion","lastStoppedKey","onKeyDown","getField","handled","up","showCrossHair","onKeyUp","onKeyPress","charCode","handleCharBinding","lastClick","lastDoubleClick","PastClick","onMouseDown","supportsTouch","clickInGutter","repeat","now","compare","clickRepeat","selectingText","handleMappedButton","contained","behavior","unit","addNew","moveOnDrag","configureMouse","dragDrop","moved","dragEnd","mouseMove","dragStart","preventScroll","e2","leftButtonStartDrag","ourRange","ourIndex","startSel","rangeForUnit","lastPos","extendTo","posCol","leftPos","oldRange","ranges$1","anchorLine","boundary","headIndex","usePart","bidiSimplify","editorSize","counter","curCount","move","buttons","leftButtonSelect","leftButtonDown","onContextMenu","findWordAt","gutterEvent","prevent","mX","mY","touches","lineBox","g","contextMenuInGutter","themeChanged","optionHandlers","dragDropChanged","funcs","dragFunctions","toggle","enter","over","leave","drop","wrappingChanged","inputStyles","inputStyle","pasteIncoming","cutIncoming","touchFinished","prevTouch","finishTouch","isMouseLikeTouchEvent","touch","radiusX","radiusY","farAway","pageX","pageY","frag","onDragOver","setData","effectAllowed","setDragImage","_top","onDragStart","inp","registerEventHandlers","finishInit","initHooks","textRendering","how","aggressive","curSpace","curSpaceString","indentString","indentWithTabs","pos$1","defineInitHook","lastCopied","setLastCopied","newLastCopied","applyTextInput","inserted","deleted","recent","paste","textLines","multiPaste","pasteLinesPerSelection","lineWise","changeEvent","handlePaste","pasted","clipboardData","disableInput","smartIndent","copyableRanges","lineRange","disableBrowserMagic","field","hiddenTextarea","border","findPosH","origDir","lineDir","moveOnce","boundToLine","astral","bidi","mv","getWrappedLineExtent","moveInStorageOrder","searchInVisualLine","getRes","res","nextCh","moveVisually","sawType","hitSide","findPosV","pageSize","moveAmount","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","composing","gracePeriod","readDOMTimeout","posToDOM","badPos","bad","domToPos","lineNode","locateNodeInLineView","textNode","topNode","nodeValue","curNode","textContent","previousSibling","dist$1","belongsToInput","onCopyCut","lineWiseCopyCut","clearData","kludge","hadFocus","showPrimarySelection","contentEditable","updateFromDOM","readFromDOMSoon","forceCompositionEnd","screenReaderLabelChanged","showMultipleSelections","curAnchor","curFocus","rng","rangeCount","getRangeAt","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","blur","pollSelection","pollInterval","scan","isInGutter","triggerOnKeyDown","pollContent","fromIndex","fromNode","toNode","toIndex","newText","extraLinebreak","recognizeMarker","addText","walk","cmText","markerID","isBlock","domTextBetween","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","readOnlyChanged","resetPosition","TextareaInput","prevInput","pollingFast","resetting","createField","prepareCopyCut","fastPoll","dispatchEvent","Event","_display","opts","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","slowPoll","missed","same","resetSelectionOnContextMenu","oldScrollY","oldCSS","oldWrapperCSS","wrapperBox","scrollY","scrollTo","rehide","detectingSelectAll","prepareSelectAllHack","mouseup","extval","notOnInit","newBreaks","refresh","detach","attach","integer","defineOptions","setOption","getDoc","score","priority","insertSorted","getLineTokens","help","_global","defaultTextHeight","addWidget","vspace","hspace","triggerOnKeyPress","triggerOnKeyUp","triggerOnMouseDown","amount","rtlMoveVisually","goalColumn","goals","startChar","check","scrollToRange","interpret","swapDoc","phrase","phraseText","phrases","getScrollerElement","getGutterElement","registerGlobalHelper","predicate","addEditorMethods","dontDelegate","mime","func","defineDocExtension","realSubmit","leaveSubmitMethodAlone","submit","wrappedSubmit","getTextArea","toTextArea","addLegacyProps","version"],"mappings":"AAAA,SAASA,gBAAgBC,EAAUC,GAAe,KAAMD,aAAoBC,GAAgB,MAAM,IAAIC,UAAU,oCAAwC,CACxJ,SAASC,kBAAkBC,EAAQC,GAAS,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,IAAIE,EAAaH,EAAMC,GAAIE,EAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,UAAWF,IAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeT,EAAQU,eAAeN,EAAWO,KAAMP,EAAa,CAAE,CAC5U,SAASQ,aAAaf,EAAagB,EAAYC,GAAyN,OAAtMD,GAAYd,kBAAkBF,EAAYkB,UAAWF,GAAiBC,GAAaf,kBAAkBF,EAAaiB,GAAcN,OAAOC,eAAeZ,EAAa,YAAa,CAAEU,UAAU,IAAiBV,CAAa,CAC5R,SAASa,eAAeM,GAAK,IAAId,EAAIe,aAAaD,EAAG,UAAW,MAAO,UAAYE,QAAQhB,GAAKA,EAAIiB,OAAOjB,EAAI,CAC/G,SAASe,aAAaD,EAAGI,GAAK,GAAI,UAAYF,QAAQF,KAAOA,EAAG,OAAOA,EAAG,IAAIK,EAAIL,EAAEM,OAAOC,aAAc,QAAI,IAAWF,EAAG,CAAE,IAAInB,EAAImB,EAAEG,KAAKR,EAAGI,GAAK,WAAY,GAAI,UAAYF,QAAQhB,GAAI,OAAOA,EAAG,MAAM,IAAIJ,UAAU,+CAAiD,CAAE,OAAQ,WAAasB,EAAID,OAASM,QAAQT,EAAI,CAC3T,SAASE,QAAQQ,GAAgC,OAAOR,QAAU,mBAAqBI,QAAU,iBAAmBA,OAAOK,SAAW,SAAUD,GAAK,cAAcA,CAAG,EAAI,SAAUA,GAAK,OAAOA,GAAK,mBAAqBJ,QAAUI,EAAEE,cAAgBN,QAAUI,IAAMJ,OAAOP,UAAY,gBAAkBW,CAAG,EAAGR,QAAQQ,EAAI,CCL7TG,QAAA,SAAAR,EAAAL,EAAAc,EAAAV,GAAA,SAAAW,EAAAL,EAAAM,GAAA,IAAAF,EAAAJ,GAAA,CAAA,IAAAV,EAAAU,GAAA,CAAA,IAAAO,EAAA,mBAAAJ,SAAAA,QAAA,IAAAG,GAAAC,EAAA,OAAAA,EAAAP,GAAA,GAAA,GAAAxB,EAAA,OAAAA,EAAAwB,GAAA,GAAA,IAAAQ,EAAA,IAAAC,MAAA,uBAAAT,EAAA,KAAA,MAAAQ,EAAAE,KAAA,mBAAAF,CAAA,CAAA,IAAAG,EAAAP,EAAAJ,GAAA,CAAAY,QAAA,CAAA,GAAAtB,EAAAU,GAAA,GAAAF,KAAAa,EAAAC,SAAA,SAAAjB,GAAA,IAAAS,EAAAd,EAAAU,GAAA,GAAAL,GAAA,OAAAU,EAAAD,GAAAT,EAAA,GAAAgB,EAAAA,EAAAC,QAAAjB,EAAAL,EAAAc,EAAAV,EAAA,CAAA,OAAAU,EAAAJ,GAAAY,OAAA,CAAA,IAAA,IAAApC,EAAA,mBAAA2B,SAAAA,QAAAH,EAAA,EAAAA,EAAAN,EAAAjB,OAAAuB,IAAAK,EAAAX,EAAAM,IAAA,OAAAK,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,SAAAF,EAAAU,EAAAD,GCKA,IAAAE,EAAAX,EAAA,KACAY,EAAAZ,EAAA,IAGAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IAGAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IAGAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IAGAA,EAAA,IAGAA,EAAA,IACAA,EAAA,IACAA,EAAA,IAEA,IAAAa,EAAAb,EAAA,GAEAc,EAAAH,EAAA,gCACAI,EAAAJ,EAAA,sCACAK,EAAAJ,EAAAK,aAAAF,EAAAG,IAAA,GAAA,CACAC,MAAA,WACAC,KAAA,YACAC,aAAA,EACAC,cAAA,EACAC,YAAA,EACAC,aAAA,EACAC,mBAAA,EACAC,iBAAA,EACAC,kBAAA,EACAC,aAAA,EACAC,UAAA,IAAAC,OAAAC,gCACAC,MAAA,EACAC,QAAA,CAAA,6BAGA,SAAAC,IACA,IAAAC,EAAAnB,EAAAoB,WACAtB,EAAAuB,WAAAC,KAAA,QAAAC,KAAAJ,EAFA,CAKAD,IAEAlB,EAAAwB,GAAA,SAAA3B,EAAAqB,EAAA,KDjEA,EAAA,CD2EY,IAAO,IACP,EAAK,EACL,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,KCjGlB,GAAA,CDqGQ,SAAUlC,EAASU,EAAQD,GGlGnC,IAAAgC,IAOA,SAAA7B,GACA,aAEA,IAAA8B,EAAA,CACAC,OAAA,CACA,CAAA,OAAA,sBAAA,cACA,CAAA,OAAA,kEAAA,cACA,CAAA,OAAA,IAAA,cACA,CAAA,KAAA,KAAA,eAEAC,MAAA,CACA,CAAA,OAAA,SAAA,OACA,CAAA,OAAA,oCAAA,OACA,CAAA,OAAA,IAAA,cACA,CAAA,KAAA,KAAA,SAeAC,EAAA,CAAA,EAOA,SAAAC,EAAAC,EAAAC,GACA,IAAAC,EAAAF,EAAAE,MAPA,SAAAD,GACA,IAAAE,EAAAL,EAAAG,GACA,OAAAE,IACAL,EAAAG,GAAA,IAAAG,OAAA,OAAAH,EAAA,wCAHA,CAOAI,CAAAJ,IACA,OAAAC,EAAA,gBAAAI,KAAAJ,EAAA,IAAA,GAAA,EAFA,CAKA,SAAAK,EAAAC,EAAAC,GACA,OAAA,IAAAL,QAAAK,EAAA,IAAA,IAAA,SAAAD,EAAA,QAAA,IADA,CAIA,SAAAE,EAAAC,EAAAC,GACA,IAAA,IAAAC,KAAAF,EAGA,IAFA,IAAAG,EAAAF,EAAAC,KAAAD,EAAAC,GAAA,IACAE,EAAAJ,EAAAE,GACAvF,EAAAyF,EAAAxF,OAAA,EAAAD,GAAA,EAAAA,IACAwF,EAAAE,QAAAD,EAAAzF,GALA,CAgBAuC,EAAAoD,WAAA,aAAA,SAAAC,EAAAC,GACA,IAAAC,EAAAvD,EAAAwD,QAAAH,EAAA,CACAI,KAAA,MACAF,UAAA,EACAG,yBAAAJ,EAAAI,yBACAC,0BAAAL,EAAAK,0BACAC,oBAAAN,EAAAM,sBAGAC,EAAA,CAAA,EACAC,EAAAR,GAAAA,EAAAO,KAAAE,EAAAT,GAAAA,EAAAU,YAGA,GAFAnB,EAAAf,EAAA+B,GACAC,GAAAjB,EAAAiB,EAAAD,GACAE,EAAA,IAAA,IAAAtG,EAAAsG,EAAArG,OAAA,EAAAD,GAAA,EAAAA,IACAoG,EAAA9B,OAAAoB,QAAA,CAAA,OAAAY,EAAAtG,GAAAwG,QAAAF,EAAAtG,GAAA+C,OAEA,SAAAmB,EAAAuC,EAAAC,GACA,IAAAxB,EAAAX,EAAAuB,EAAAa,MAAAF,EAAAC,EAAAE,WAAArB,EAAA,UAAAsB,KAAAtC,GACA,GAAAgB,IAAA,WAAAsB,KAAAJ,EAAAK,aACA5B,EAAAwB,EAAAE,UAAA1B,SAAAwB,EAAAE,UAAA1B,QAAA6B,gBACAX,EAAAY,eAAA9B,GACAwB,EAAAO,MAAA/B,EAAA,SACA,GAAAwB,EAAAO,OAAA1B,GAAA,KAAAsB,KAAAJ,EAAAK,WAAA,CACA,IAAAG,EAAA,gBAAAjC,KAAA0B,EAAAO,OACAP,EAAAO,MAAA,KACA,IAAAC,EAAA,KAAAT,EAAAK,WAhCA,SAAAK,EAAAC,GACA,IAAA,IAAApH,EAAA,EAAAA,EAAAmH,EAAAlH,OAAAD,IAAA,CACA,IAAAqH,EAAAF,EAAAnH,GACA,IAAAqH,EAAA,IAAAA,EAAA,GAAAR,KAAApC,EAAA2C,EAAAC,EAAA,KAAA,OAAAA,EAAA,EAFA,CADA,CAgCAC,CAAAlB,EAAAa,EAAA,IAAAA,EAAA,IACAlE,EAAAR,EAAAwD,QAAAH,EAAAsB,GACAK,EAAAtC,EAAAgC,EAAA,IAAA,GAAAO,EAAAvC,EAAAgC,EAAA,IAAA,GACAP,EAAAC,MAAA,SAAAF,EAAAC,GACA,OAAAD,EAAA7B,MAAA2C,GAAA,IACAb,EAAAC,MAAAzC,EACAwC,EAAAe,WAAAf,EAAAgB,UAAA,KACA,MA3EA,SAAAjB,EAAAkB,EAAApD,GACA,IAAAqD,EAAAnB,EAAAK,UAAAe,EAAAD,EAAAE,OAAAH,GAOA,OANAE,GAAA,EACApB,EAAAsB,OAAAH,EAAA3H,OAAA4H,GACAD,EAAAhD,MAAA,WACA6B,EAAAsB,OAAAH,EAAA3H,QACAwG,EAAA7B,MAAA+C,GAAA,IAAAlB,EAAA7B,MAAAgD,IAEArD,CARA,CA6EAyD,CAAAvB,EAAAe,EAAAd,EAAAgB,UAAAf,MAAAF,EAAAC,EAAAe,YANA,EAQAf,EAAAgB,UAAA3E,EACA2D,EAAAe,WAAAlF,EAAA0F,WAAAlF,EAAA+C,EAAAoC,OAAAxB,EAAAE,UAAA,GAAA,IAfA,MAgBAF,EAAAO,QACAP,EAAAO,OAAAR,EAAAK,UACAL,EAAA0B,QAAAzB,EAAAO,OAAA,MAEA,OAAA1C,CA1BA,CA6BA,MAAA,CACA0D,WAAA,WAEA,MAAA,CAAAtB,MAAAzC,EAAA+C,MAAA,KAAAS,UAAA,KAAAD,WAAA,KAAAb,UADArE,EAAA0F,WAAAnC,GADA,EAKAsC,UAAA,SAAA1B,GACA,IAAA2B,EAIA,OAHA3B,EAAAe,aACAY,EAAA9F,EAAA6F,UAAA1B,EAAAgB,UAAAhB,EAAAe,aAEA,CAAAd,MAAAD,EAAAC,MAAAM,MAAAP,EAAAO,MACAS,UAAAhB,EAAAgB,UAAAD,WAAAY,EACAzB,UAAArE,EAAA6F,UAAAtC,EAAAY,EAAAE,WAPA,EAUAD,MAAA,SAAAF,EAAAC,GACA,OAAAA,EAAAC,MAAAF,EAAAC,EADA,EAIAwB,OAAA,SAAAxB,EAAA4B,EAAAC,GACA,OAAA7B,EAAAgB,WAAA,UAAAb,KAAAyB,GACAxC,EAAAoC,OAAAxB,EAAAE,UAAA0B,EAAAC,GACA7B,EAAAgB,UAAAQ,OACAxB,EAAAgB,UAAAQ,OAAAxB,EAAAe,WAAAa,EAAAC,GAEAhG,EAAAiG,IANA,EASAC,UAAA,SAAA/B,GACA,MAAA,CAAAA,MAAAA,EAAAe,YAAAf,EAAAE,UAAA7D,KAAA2D,EAAAgB,WAAA5B,EADA,EA1EA,GA8EA,MAAA,aAAA,OAEAvD,EAAAmG,WAAA,YAAA,YA7IA,EANA,UAAA1H,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,IAAAA,EAAA,IAAAA,EAAA,IAAAA,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,uBAAA,aAAA,2BAAA,cAAAvE,GAEAA,EAAA7B,WH8RQ,EACA,CACI,GAAM,GACN,GAAM,GACN,GAAM,GACN,GAAM,KC5SlB,GAAA,CDgTQ,SAAUZ,EAASU,EAAQD,GI7SnC,IAAAgC,IAOA,SAAA7B,GACA,aAEA,IAAAsG,EAAA,CACAC,gBAAA,CAAAC,MAAA,EAAAC,MAAA,EAAAC,IAAA,EAAAC,KAAA,EAAAC,SAAA,EACAC,OAAA,EAAAC,OAAA,EAAAC,IAAA,EAAAC,KAAA,EAAAC,OAAA,EACAC,QAAA,EAAAC,MAAA,EAAAC,MAAA,EAAAC,OAAA,EAAAnE,QAAA,EACAoE,OAAA,EAAAC,KAAA,EAAAC,UAAA,GACAC,iBAAA,CAAAC,IAAA,EAAAC,IAAA,EAAAC,UAAA,EAAAC,QAAA,EAAAC,GAAA,EACAC,IAAA,EAAAC,IAAA,EAAAC,OAAA,EAAAC,IAAA,EAAAC,OAAA,EACAC,IAAA,EAAAC,IAAA,GACAC,gBAAA,CACAZ,GAAA,CAAAA,IAAA,EAAAa,IAAA,GACAA,GAAA,CAAAb,IAAA,EAAAa,IAAA,GACAZ,GAAA,CAAAA,IAAA,GACAE,OAAA,CAAAA,QAAA,EAAAD,UAAA,GACAA,SAAA,CAAAA,UAAA,GACAE,EAAA,CAAAU,SAAA,EAAAC,SAAA,EAAAC,OAAA,EAAAC,YAAA,EAAAC,KAAA,EACAC,KAAA,EAAAC,IAAA,EAAAC,UAAA,EAAAC,QAAA,EAAAC,MAAA,EACAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EACAC,QAAA,EAAAC,QAAA,EAAA1C,IAAA,EAAA2C,MAAA,EAAAC,KAAA,EAAAC,IAAA,EACA9B,GAAA,EAAA+B,KAAA,EAAAC,SAAA,EAAAC,OAAA,EAAAC,IAAA,GACAjC,GAAA,CAAAA,IAAA,EAAAC,IAAA,GACAA,GAAA,CAAAD,IAAA,EAAAC,IAAA,GACAC,MAAA,CAAAA,OAAA,EAAAE,OAAA,GACAD,GAAA,CAAAA,IAAA,EAAAE,IAAA,GACAD,MAAA,CAAAF,OAAA,GACAG,GAAA,CAAAF,IAAA,EAAAE,IAAA,GACA6B,MAAA,CAAAhC,OAAA,EAAAE,OAAA,GACAE,GAAA,CAAAA,IAAA,IAEA6B,YAAA,CAAAL,KAAA,GACAM,eAAA,EACAC,cAAA,EACAC,UAAA,GAGAC,EAAA,CACA/D,gBAAA,CAAA,EACAkB,iBAAA,CAAA,EACAa,gBAAA,CAAA,EACA4B,YAAA,CAAA,EACAC,eAAA,EACAC,cAAA,EACAxG,qBAAA,EACAyG,UAAA,GAGArK,EAAAoD,WAAA,OAAA,SAAAmH,EAAAC,GACA,IAOAC,EAAAC,EAPAC,EAAAJ,EAAAI,WACAtH,EAAA,CAAA,EACAuH,EAAAJ,EAAAjH,SAAA+C,EAAAgE,EACA,IAAA,IAAAO,KAAAD,EAAAvH,EAAAwH,GAAAD,EAAAC,GACA,IAAA,IAAAA,KAAAL,EAAAnH,EAAAwH,GAAAL,EAAAK,GAKA,SAAAC,EAAA5G,EAAAC,GACA,SAAA4G,EAAAC,GAEA,OADA7G,EAAA8G,SAAAD,EACAA,EAAA9G,EAAAC,EAFA,CAKA,IAAA+G,EAAAhH,EAAAiH,OACA,MAAA,KAAAD,EACAhH,EAAAkH,IAAA,KACAlH,EAAAkH,IAAA,KACAlH,EAAA7B,MAAA,UAAA0I,EAAAM,EAAA,OAAA,QACA,KACAnH,EAAA7B,MAAA,MACA0I,EAAAM,EAAA,UAAA,WACAnH,EAAA7B,MAAA,WAAA,GAAA,IACA6B,EAAAoH,SAAA,aACAP,EAAAQ,EAAA,KAEA,KAEArH,EAAAkH,IAAA,MACAlH,EAAAoH,SAAA,aACAnH,EAAA8G,SAAAI,EAAA,OAAA,MACA,SAEAZ,EAAAvG,EAAAkH,IAAA,KAAA,WAAA,UACAjH,EAAA8G,SAAAvG,EACA,eAEA,KAAAwG,GAEAhH,EAAAkH,IAAA,KACAlH,EAAAkH,IAAA,KACAlH,EAAAoH,SAAA,eAAApH,EAAAkH,IAAA,KAEAlH,EAAAoH,SAAA,SAAApH,EAAAkH,IAAA,KAGAlH,EAAAoH,SAAA,cAAApH,EAAAkH,IAAA,MAEA,OAAA,SAEAlH,EAAAoH,SAAA,SACA,KA3CA,CAgDA,SAAA5G,EAAAR,EAAAC,GACA,IAwBAqH,EACAC,EAzBAP,EAAAhH,EAAAiH,OACA,GAAA,KAAAD,GAAA,KAAAA,GAAAhH,EAAAkH,IAAA,KAGA,OAFAjH,EAAA8G,SAAAH,EACAL,EAAA,KAAAS,EAAA,SAAA,eACA,cACA,GAAA,KAAAA,EAEA,OADAT,EAAA,SACA,KACA,GAAA,KAAAS,EAAA,CACA/G,EAAA8G,SAAAH,EACA3G,EAAAA,MAAAuH,EACAvH,EAAAxB,QAAAwB,EAAAwH,SAAA,KACA,IAAAR,EAAAhH,EAAA8G,SAAA/G,EAAAC,GACA,OAAAgH,EAAAA,EAAA,aAAA,WALA,CAMA,MAAA,SAAA7G,KAAA4G,IACA/G,EAAA8G,UASAO,EATAN,EAUAO,EAAA,SAAAvH,EAAAC,GACA,MAAAD,EAAA0B,OACA,GAAA1B,EAAAiH,QAAAK,EAAA,CACArH,EAAA8G,SAAAvG,EACA,KAFA,CAKA,MAAA,QAPA,EASA+G,EAAAG,eAAA,EACAH,GAnBAtH,EAAA0H,eAAA3H,EAAA4H,SACA3H,EAAA8G,SAAA/G,EAAAC,KAEAD,EAAA7B,MAAA,4CACA,OArBA,CAuCA,SAAAgJ,EAAArJ,EAAA+J,GACA,OAAA,SAAA7H,EAAAC,GACA,MAAAD,EAAA0B,OAAA,CACA,GAAA1B,EAAA7B,MAAA0J,GAAA,CACA5H,EAAA8G,SAAAH,EACA,KAFA,CAIA5G,EAAAiH,MALA,CAOA,OAAAnJ,CARA,CADA,CAaA,SAAAuJ,EAAAS,GACA,OAAA,SAAA9H,EAAAC,GAEA,IADA,IAAA+G,EACA,OAAAA,EAAAhH,EAAAiH,SAAA,CACA,GAAA,KAAAD,EAEA,OADA/G,EAAA8G,SAAAM,EAAAS,EAAA,GACA7H,EAAA8G,SAAA/G,EAAAC,GACA,GAAA,KAAA+G,EAAA,CACA,GAAA,GAAAc,EAAA,CACA7H,EAAA8G,SAAAH,EACA,KAFA,CAKA,OADA3G,EAAA8G,SAAAM,EAAAS,EAAA,GACA7H,EAAA8G,SAAA/G,EAAAC,EANA,CAJA,CAcA,MAAA,MAhBA,CADA,CAqBA,SAAA8H,EAAAtJ,GACA,OAAAA,GAAAA,EAAA6B,aADA,CAIA,SAAA0H,EAAA/H,EAAAxB,EAAAwJ,GACAC,KAAAC,KAAAlI,EAAAmI,QACAF,KAAAzJ,QAAAA,GAAA,GACAyJ,KAAAzG,OAAAxB,EAAAoI,SACAH,KAAAD,YAAAA,GACA9I,EAAA6G,YAAAzF,eAAA9B,IAAAwB,EAAAmI,SAAAnI,EAAAmI,QAAAE,YACAJ,KAAAI,UAAA,EANA,CAQA,SAAAC,EAAAtI,GACAA,EAAAmI,UAAAnI,EAAAmI,QAAAnI,EAAAmI,QAAAD,KADA,CAGA,SAAAK,EAAAvI,EAAAwI,GAEA,IADA,IAAAC,IACA,CACA,IAAAzI,EAAAmI,QACA,OAGA,GADAM,EAAAzI,EAAAmI,QAAA3J,SACAU,EAAAiF,gBAAA7D,eAAAwH,EAAAW,MACAvJ,EAAAiF,gBAAA2D,EAAAW,IAAAnI,eAAAwH,EAAAU,IACA,OAEAF,EAAAtI,EATA,CAFA,CAeA,SAAAuH,EAAAjB,EAAAvG,EAAAC,GACA,MAAA,WAAAsG,GACAtG,EAAAwH,SAAAzH,EAAA4H,SACAe,GACA,YAAApC,EACAqC,EAEApB,CAPA,CAUA,SAAAmB,EAAApC,EAAAvG,EAAAC,GACA,MAAA,QAAAsG,GACAtG,EAAAxB,QAAAuB,EAAAK,UACAmG,EAAA,MACAqC,GACA1J,EAAAO,qBAAA,UAAA6G,GACAC,EAAA,cACAqC,EAAAtC,EAAAvG,EAAAC,KAEAuG,EAAA,QACAmC,EAVA,CAaA,SAAAC,EAAArC,EAAAvG,EAAAC,GACA,GAAA,QAAAsG,EAAA,CACA,IAAA9H,EAAAuB,EAAAK,UAIA,OAHAJ,EAAAmI,SAAAnI,EAAAmI,QAAA3J,SAAAA,GACAU,EAAAoE,iBAAAhD,eAAAwH,EAAA9H,EAAAmI,QAAA3J,WACA8J,EAAAtI,GACAA,EAAAmI,SAAAnI,EAAAmI,QAAA3J,SAAAA,IAAA,IAAAU,EAAA2J,cACAtC,EAAA,MACAuC,IAEAvC,EAAA,YACAwC,EAVA,CAYA,OAAA7J,EAAAO,qBAAA,UAAA6G,GACAC,EAAA,cACAuC,EAAAxC,EAAAvG,EAAAC,KAEAuG,EAAA,QACAwC,EAlBA,CAsBA,SAAAD,EAAAxC,EAAA0C,EAAAhJ,GACA,MAAA,UAAAsG,GACAC,EAAA,QACAuC,IAEAR,EAAAtI,GACAuH,EANA,CAQA,SAAAwB,EAAAzC,EAAAvG,EAAAC,GAEA,OADAuG,EAAA,QACAuC,EAAAxC,EAAAvG,EAAAC,EAFA,CAKA,SAAA4I,EAAAtC,EAAA0C,EAAAhJ,GACA,GAAA,QAAAsG,EAEA,OADAC,EAAA,YACA0C,EACA,GAAA,UAAA3C,GAAA,gBAAAA,EAAA,CACA,IAAA9H,EAAAwB,EAAAxB,QAAAgJ,EAAAxH,EAAAwH,SASA,OARAxH,EAAAxB,QAAAwB,EAAAwH,SAAA,KACA,gBAAAlB,GACApH,EAAAkD,gBAAA9B,eAAAwH,EAAAtJ,IACA+J,EAAAvI,EAAAxB,IAEA+J,EAAAvI,EAAAxB,GACAwB,EAAAmI,QAAA,IAAAJ,EAAA/H,EAAAxB,EAAAgJ,GAAAxH,EAAAoI,WAEAb,CAVA,CAaA,OADAhB,EAAA,QACAqC,CAjBA,CAmBA,SAAAK,EAAA3C,EAAAvG,EAAAC,GACA,MAAA,UAAAsG,EAAA4C,GACAhK,EAAA+G,eAAAM,EAAA,SACAqC,EAAAtC,EAAAvG,EAAAC,GAHA,CAKA,SAAAkJ,EAAA5C,EAAAvG,EAAAC,GACA,MAAA,UAAAsG,EAAA6C,EACA,QAAA7C,GAAApH,EAAA8G,eAAAO,EAAA,SAAAqC,IACArC,EAAA,QACAqC,EAAAtC,EAAAvG,EAAAC,GAJA,CAMA,SAAAmJ,EAAA7C,EAAAvG,EAAAC,GACA,MAAA,UAAAsG,EAAA6C,EACAP,EAAAtC,EAAAvG,EAAAC,EAFA,CAKA,OAtMA2G,EAAAyC,UAAA,EAsMA,CACA7H,WAAA,SAAA8H,GACA,IAAArJ,EAAA,CAAA8G,SAAAH,EACA3G,MAAAuH,EACAa,SAAAiB,GAAA,EACA7K,QAAA,KAAAgJ,SAAA,KACAW,QAAA,MAEA,OADA,MAAAkB,IAAArJ,EAAAqJ,WAAAA,GACArJ,CAPA,EAUAC,MAAA,SAAAF,EAAAC,GAIA,IAHAA,EAAAxB,SAAAuB,EAAAuJ,QACAtJ,EAAAoI,SAAArI,EAAAwJ,eAEAxJ,EAAAyJ,WAAA,OAAA,KACAlD,EAAA,KACA,IAAAzI,EAAAmC,EAAA8G,SAAA/G,EAAAC,GAOA,OANAnC,GAAAyI,IAAA,WAAAzI,IACA0I,EAAA,KACAvG,EAAAA,MAAAA,EAAAA,MAAAsG,GAAAzI,EAAAkC,EAAAC,GACAuG,IACA1I,EAAA,SAAA0I,EAAA1I,EAAA,SAAA0I,IAEA1I,CAbA,EAgBA2D,OAAA,SAAAxB,EAAA4B,EAAA6H,GACA,IAAAtB,EAAAnI,EAAAmI,QAEA,GAAAnI,EAAA8G,SAAAW,cACA,OAAAzH,EAAAwH,UAAAxH,EAAAoI,SACApI,EAAA0H,eAAA,EAEA1H,EAAAoI,SAAA5B,EAEA,GAAA2B,GAAAA,EAAAE,SAAA,OAAAxM,EAAAiG,KACA,GAAA9B,EAAA8G,UAAAvG,GAAAP,EAAA8G,UAAAH,EACA,OAAA8C,EAAAA,EAAAvL,MAAA,UAAA,GAAA3E,OAAA,EAEA,GAAAyG,EAAAxB,QACA,OAAA,IAAAU,EAAAM,0BACAQ,EAAAwH,SAAAxH,EAAAxB,QAAAjF,OAAA,EAEAyG,EAAAwH,SAAAhB,GAAAtH,EAAAK,0BAAA,GAEA,GAAAL,EAAAwK,YAAA,cAAAvJ,KAAAyB,GAAA,OAAA,EACA,IAAA+H,EAAA/H,GAAA,sBAAAtD,KAAAsD,GACA,GAAA+H,GAAAA,EAAA,GACA,KAAAxB,GAAA,CACA,GAAAA,EAAA3J,SAAAmL,EAAA,GAAA,CACAxB,EAAAA,EAAAD,KACA,KAFA,CAGA,IAAAhJ,EAAAoE,iBAAAhD,eAAAwH,EAAAK,EAAA3J,UAGA,MAFA2J,EAAAA,EAAAD,IALA,MAUA,GAAAyB,EACA,KAAAxB,GAAA,CACA,IAAAyB,EAAA1K,EAAAiF,gBAAA2D,EAAAK,EAAA3J,UACA,IAAAoL,IAAAA,EAAAtJ,eAAAwH,EAAA6B,EAAA,KAGA,MAFAxB,EAAAA,EAAAD,IAHA,CAQA,KAAAC,GAAAA,EAAAD,OAAAC,EAAAH,aACAG,EAAAA,EAAAD,KACA,OAAAC,EAAAA,EAAA3G,OAAAgF,EACAxG,EAAAqJ,YAAA,CA5CA,EA+CAQ,cAAA,gBACAC,kBAAA,UACAC,gBAAA,SAEAC,cAAA9K,EAAAE,SAAA,OAAA,MACA6K,WAAA/K,EAAAE,SAAA,OAAA,MAEA8K,cAAA,SAAAlK,GACAA,EAAAA,OAAAkJ,IACAlJ,EAAAA,MAAA4I,EAFA,EAKAuB,cAAA,SAAAnK,GACA,OAAAA,EAAAxB,QAAA,CAAAc,KAAAU,EAAAxB,QAAA2C,MAAA,YAAAnB,EAAAsG,MAAA,IADA,EAIA8D,kBAAA,SAAApK,GAEA,IADA,IAAAmI,EAAA,GACAkC,EAAArK,EAAAmI,QAAAkC,EAAAA,EAAAA,EAAAnC,KACAC,EAAAmC,KAAAD,EAAA7L,SACA,OAAA2J,EAAAoC,SAJA,EAxVA,IAiWA1O,EAAAmG,WAAA,WAAA,OACAnG,EAAAmG,WAAA,kBAAA,OACAnG,EAAA2O,UAAAlK,eAAA,cACAzE,EAAAmG,WAAA,YAAA,CAAA1C,KAAA,MAAAF,UAAA,GApZA,EANA,UAAA9E,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WJ+wBQ,EACA,CAAE,GAAM,KCzxBhB,GAAA,CD4xBQ,SAAUZ,EAASU,EAAQD,GKzxBnC,IAAAgC,IAOA,SAAA7B,GACA,aAEAA,EAAAoD,WAAA,cAAA,SAAAC,EAAAC,GACA,IA8CAmH,EAAAmE,EA9CAjE,EAAAtH,EAAAsH,WACAkE,EAAAvL,EAAAuL,gBACAC,EAAAxL,EAAAyL,OACAC,EAAA1L,EAAA2L,MAAAH,EACAI,GAAA,IAAA5L,EAAA4L,WACAC,EAAA7L,EAAA8L,WACAC,EAAA/L,EAAAgM,gBAAA,mBAIAC,EAAA,WACA,SAAAC,EAAA/E,GAAA,MAAA,CAAAA,KAAAA,EAAAzI,MAAA,UAAA,CACA,IAAAyN,EAAAD,EAAA,aAAAE,EAAAF,EAAA,aAAAG,EAAAH,EAAA,aAAAI,EAAAJ,EAAA,aACAK,EAAAL,EAAA,YAAAM,EAAA,CAAArF,KAAA,OAAAzI,MAAA,QAEA,MAAA,CACA+N,GAAAP,EAAA,MAAAQ,MAAAP,EAAAQ,KAAAR,EAAAS,KAAAR,EAAAS,GAAAT,EAAAU,IAAAV,EAAAW,QAAAX,EACAY,OAAAV,EAAAW,MAAAX,EAAAY,SAAAZ,EAAAa,IAAAjB,EAAA,OAAAkB,OAAAf,EAAAgB,KAAAhB,EAAAiB,MAAAjB,EACAkB,SAAArB,EAAA,YAAAsB,IAAAtB,EAAA,OAAAuB,MAAAvB,EAAA,OAAAwB,IAAAxB,EAAA,OACAyB,SAAAzB,EAAA,YAAA0B,MAAA1B,EAAA,SACA2B,IAAA3B,EAAA,OAAA4B,OAAA5B,EAAA,UAAA6B,KAAA7B,EAAA,QAAA8B,QAAA9B,EAAA,WACA+B,GAAA1B,EAAA2B,OAAA3B,EAAA4B,WAAA5B,EACA6B,KAAA5B,EAAA6B,MAAA7B,EAAA8B,KAAA9B,EAAA+B,UAAA/B,EAAAgC,IAAAhC,EAAAiC,SAAAjC,EACA1D,KAAAoD,EAAA,QAAAwC,MAAAxC,EAAA,SAAAyC,MAAAzC,EAAA,QACA0C,MAAAvC,EAAAwC,OAAA3C,EAAA,UAAA4C,OAAA5C,EAAA,UAAA6C,QAAA1C,EACA2C,MAAA3C,EAfA,CAAA,GAmBA4C,EAAA,oBACAC,EAAA,wFAiBA,SAAAC,EAAAC,EAAA1Q,EAAA2Q,GAEA,OADAlI,EAAAiI,EAAA9D,EAAA+D,EACA3Q,CAFA,CAIA,SAAA4Q,EAAA1O,EAAAC,GACA,IAsEAqH,EAtEAN,EAAAhH,EAAAiH,OACA,GAAA,KAAAD,GAAA,KAAAA,EAEA,OADA/G,EAAA8G,UAoEAO,EApEAN,EAqEA,SAAAhH,EAAAC,GACA,IAAAgH,EAAA0H,GAAA,EACA,GAAA/D,GAAA,KAAA5K,EAAA4O,QAAA5O,EAAA7B,MAAAmQ,GAEA,OADArO,EAAA8G,SAAA2H,EACAH,EAAA,iBAAA,QAEA,KAAA,OAAAtH,EAAAjH,EAAAiH,UACAA,GAAAK,GAAAqH,IACAA,GAAAA,GAAA,MAAA1H,EAGA,OADA0H,IAAA1O,EAAA8G,SAAA2H,GACAH,EAAA,SAAA,SAXA,GApEAtO,EAAA8G,SAAA/G,EAAAC,GACA,GAAA,KAAA+G,GAAAhH,EAAA7B,MAAA,kCACA,OAAAoQ,EAAA,SAAA,UACA,GAAA,KAAAvH,GAAAhH,EAAA7B,MAAA,MACA,OAAAoQ,EAAA,SAAA,QACA,GAAA,qBAAAnO,KAAA4G,GACA,OAAAuH,EAAAvH,GACA,GAAA,KAAAA,GAAAhH,EAAAkH,IAAA,KACA,OAAAqH,EAAA,KAAA,YACA,GAAA,KAAAvH,GAAAhH,EAAA7B,MAAA,yCACA,OAAAoQ,EAAA,SAAA,UACA,GAAA,KAAAnO,KAAA4G,GAEA,OADAhH,EAAA7B,MAAA,oDACAoQ,EAAA,SAAA,UACA,GAAA,KAAAvH,EACA,OAAAhH,EAAAkH,IAAA,MACAjH,EAAA8G,SAAA8H,EACAA,EAAA7O,EAAAC,IACAD,EAAAkH,IAAA,MACAlH,EAAA8O,YACAP,EAAA,UAAA,YACAQ,GAAA/O,EAAAC,EAAA,IA5CA,SAAAD,GAEA,IADA,IAAAiH,EAAA0H,GAAA,EAAAK,GAAA,EACA,OAAA/H,EAAAjH,EAAAiH,SAAA,CACA,IAAA0H,EAAA,CACA,GAAA,KAAA1H,IAAA+H,EAAA,OACA,KAAA/H,EAAA+H,GAAA,EACAA,GAAA,KAAA/H,IAAA+H,GAAA,EAHA,CAKAL,GAAAA,GAAA,MAAA1H,CANA,CAFA,CA6CAgI,CAAAjP,GACAA,EAAA7B,MAAA,qCACAoQ,EAAA,SAAA,cAEAvO,EAAAkH,IAAA,KACAqH,EAAA,WAAA,WAAAvO,EAAAK,YAEA,GAAA,KAAA2G,EAEA,OADA/G,EAAA8G,SAAAmI,EACAA,EAAAlP,EAAAC,GACA,GAAA,KAAA+G,GAAA,KAAAhH,EAAA4O,OAEA,OADA5O,EAAA8O,YACAP,EAAA,OAAA,QACA,GAAA,KAAAvH,GAAAhH,EAAAoH,SAAA+D,GACA,OAAAoD,EAAA,WAAA,YACA,GAAA,KAAAvH,GAAAhH,EAAA7B,MAAA,QACA,KAAA6I,GAAAhH,EAAA7B,MAAA,QAAA,KAAAiC,KAAAJ,EAAAmP,OAAAC,MAAA,EAAApP,EAAAqP,QAEA,OADArP,EAAA8O,YACAP,EAAA,UAAA,WACA,GAAAF,EAAAjO,KAAA4G,GASA,MARA,KAAAA,GAAA/G,EAAAqP,SAAA,KAAArP,EAAAqP,QAAA/I,OACAvG,EAAAkH,IAAA,KACA,KAAAF,GAAA,KAAAA,GAAAhH,EAAAkH,IAAA,KACA,cAAA9G,KAAA4G,KACAhH,EAAAkH,IAAAF,GACA,KAAAA,GAAAhH,EAAAkH,IAAAF,KAGA,KAAAA,GAAAhH,EAAAkH,IAAA,KAAAqH,EAAA,KACAA,EAAA,WAAA,WAAAvO,EAAAK,WACA,GAAA8K,EAAA/K,KAAA4G,GAAA,CACAhH,EAAAoH,SAAA+D,GACA,IAAAoE,EAAAvP,EAAAK,UACA,GAAA,KAAAJ,EAAAuP,SAAA,CACA,GAAAnE,EAAAoE,qBAAAF,GAAA,CACA,IAAAjE,EAAAD,EAAAkE,GACA,OAAAhB,EAAAjD,EAAA/E,KAAA+E,EAAAxN,MAAAyR,EAFA,CAIA,GAAA,SAAAA,GAAAvP,EAAA7B,MAAA,4CAAA,GACA,OAAAoQ,EAAA,QAAA,UAAAgB,EANA,CAQA,OAAAhB,EAAA,WAAA,WAAAgB,EAXA,CAxDA,CAuFA,SAAAV,EAAA7O,EAAAC,GAEA,IADA,IAAA+G,EAAA0I,GAAA,EACA1I,EAAAhH,EAAAiH,QAAA,CACA,GAAA,KAAAD,GAAA0I,EAAA,CACAzP,EAAA8G,SAAA2H,EACA,KAFA,CAIAgB,EAAA,KAAA1I,CALA,CAOA,OAAAuH,EAAA,UAAA,UATA,CAYA,SAAAW,EAAAlP,EAAAC,GAEA,IADA,IAAAgH,EAAA0H,GAAA,EACA,OAAA1H,EAAAjH,EAAAiH,SAAA,CACA,IAAA0H,IAAA,KAAA1H,GAAA,KAAAA,GAAAjH,EAAAkH,IAAA,MAAA,CACAjH,EAAA8G,SAAA2H,EACA,KAFA,CAIAC,GAAAA,GAAA,MAAA1H,CALA,CAOA,OAAAsH,EAAA,QAAA,WAAAvO,EAAAK,UATA,CAYA,IAAAsP,EAAA,SAQA,SAAAC,EAAA5P,EAAAC,GACAA,EAAA4P,aAAA5P,EAAA4P,WAAA,MACA,IAAAC,EAAA9P,EAAAmP,OAAAY,QAAA,KAAA/P,EAAAqP,OACA,KAAAS,EAAA,GAAA,CAEA,GAAA7E,EAAA,CACA,IAAA+E,EAAA,6CAAAzR,KAAAyB,EAAAmP,OAAAC,MAAApP,EAAAqP,MAAAS,IACAE,IAAAF,EAAAE,EAAAC,MAFA,CAMA,IADA,IAAAnI,EAAA,EAAAoI,GAAA,EACAC,EAAAL,EAAA,EAAAK,GAAA,IAAAA,EAAA,CACA,IAAAnJ,EAAAhH,EAAAmP,OAAAiB,OAAAD,GACAE,EAAAV,EAAAI,QAAA/I,GACA,GAAAqJ,GAAA,GAAAA,EAAA,EAAA,CACA,IAAAvI,EAAA,GAAAqI,EAAA,KAAA,CACA,GAAA,KAAArI,EAAA,CAAA,KAAAd,IAAAkJ,GAAA,GAAA,KAAA,CAFA,MAGA,GAAAG,GAAA,GAAAA,EAAA,IACAvI,OACA,GAAAqD,EAAA/K,KAAA4G,GACAkJ,GAAA,OACA,GAAA,UAAA9P,KAAA4G,GACA,QAAAmJ,EAAA,CACA,GAAA,GAAAA,EAAA,OAEA,GADAnQ,EAAAmP,OAAAiB,OAAAD,EAAA,IACAnJ,GAAA,MAAAhH,EAAAmP,OAAAiB,OAAAD,EAAA,GAAA,CAAAA,IAAA,KAAA,CAHA,MAKA,GAAAD,IAAApI,EAAA,GACAqI,EACA,KAFA,CAhBA,CAqBAD,IAAApI,IAAA7H,EAAA4P,WAAAM,EA7BA,CAHA,CAqCA,IAAAG,EAAA,CAAA1E,MAAA,EAAA2E,QAAA,EAAAC,UAAA,EAAArB,QAAA,EACA/Q,QAAA,EAAA8J,MAAA,EAAAgG,QAAA,EAAA,kBAAA,GAEA,SAAAuC,EAAApI,EAAAT,EAAArB,EAAAmK,EAAAvI,EAAAwI,GACAzI,KAAAG,SAAAA,EACAH,KAAAN,OAAAA,EACAM,KAAA3B,KAAAA,EACA2B,KAAAC,KAAAA,EACAD,KAAAyI,KAAAA,EACA,MAAAD,IAAAxI,KAAAwI,MAAAA,EANA,CASA,SAAAE,EAAA3Q,EAAA4Q,GACA,IAAA7F,EAAA,OAAA,EACA,IAAA,IAAA8F,EAAA7Q,EAAA8Q,UAAAD,EAAAA,EAAAA,EAAA7J,KACA,GAAA6J,EAAAvR,MAAAsR,EAAA,OAAA,EACA,IAAA,IAAAvG,EAAArK,EAAAmI,QAAAkC,EAAAA,EAAAA,EAAAnC,KACA,IAAA2I,EAAAxG,EAAA0G,KAAAF,EAAAA,EAAAA,EAAA7J,KACA,GAAA6J,EAAAvR,MAAAsR,EAAA,OAAA,CANA,CAUA,SAAAI,EAAAhR,EAAAnC,EAAAyI,EAAAmE,EAAA1K,GACA,IAAAkR,EAAAjR,EAAAiR,GAQA,IALA5G,EAAArK,MAAAA,EAAAqK,EAAAtK,OAAAA,EAAAsK,EAAA6G,OAAA,KAAA7G,EAAA4G,GAAAA,EAAA5G,EAAAxM,MAAAA,EAEAmC,EAAAqP,QAAA/O,eAAA,WACAN,EAAAqP,QAAAoB,OAAA,KAIA,IADAQ,EAAA1X,OAAA0X,EAAAE,MAAAtG,EAAAuG,EAAAC,GACA/K,EAAAmE,GAAA,CACA,KAAAwG,EAAA1X,QAAA0X,EAAAA,EAAA1X,OAAA,GAAA+X,KACAL,EAAAE,KAAAF,GACA,OAAA5G,EAAA6G,OAAA7G,EAAA6G,OACA,YAAA5K,GAAAqK,EAAA3Q,EAAAyK,GAAA,aACA5M,CALA,CAXA,CAuBA,IAAAwM,EAAA,CAAArK,MAAA,KAAA2H,OAAA,KAAAuJ,OAAA,KAAAD,GAAA,MACA,SAAAM,IACA,IAAA,IAAAjY,EAAAkY,UAAAjY,OAAA,EAAAD,GAAA,EAAAA,IAAA+Q,EAAA4G,GAAA3G,KAAAkH,UAAAlY,GADA,CAGA,SAAAkV,IAEA,OADA+C,EAAAE,MAAA,KAAAD,YACA,CAFA,CAIA,SAAAE,EAAApS,EAAAqS,GACA,IAAA,IAAAd,EAAAc,EAAAd,EAAAA,EAAAA,EAAA7J,KAAA,GAAA6J,EAAAvR,MAAAA,EAAA,OAAA,EACA,OAAA,CAFA,CAIA,SAAAsS,EAAAhB,GACA,IAAA5Q,EAAAqK,EAAArK,MAEA,GADAqK,EAAA6G,OAAA,MACAnG,EAAA,CACA,GAAA/K,EAAAmI,QACA,GAAA,OAAAnI,EAAAqP,QAAAqB,MAAA1Q,EAAAmI,SAAAnI,EAAAmI,QAAA0J,MAAA,CAEA,IAAAC,EAAAC,EAAAnB,EAAA5Q,EAAAmI,SACA,GAAA,MAAA2J,EAEA,YADA9R,EAAAmI,QAAA2J,EAJA,MAOA,IAAAJ,EAAAd,EAAA5Q,EAAA8Q,WAEA,YADA9Q,EAAA8Q,UAAA,IAAAkB,EAAApB,EAAA5Q,EAAA8Q,YAKA3R,EAAA8S,aAAAP,EAAAd,EAAA5Q,EAAAiS,cACAjS,EAAAiS,WAAA,IAAAD,EAAApB,EAAA5Q,EAAAiS,YAhBA,CAHA,CAqBA,SAAAF,EAAAnB,EAAAzI,GACA,GAAAA,EAEA,IAAAA,EAAA0J,MAAA,CACA,IAAAK,EAAAH,EAAAnB,EAAAzI,EAAAD,MACA,OAAAgK,EACAA,GAAA/J,EAAAD,KAAAC,EACA,IAAAJ,EAAAmK,EAAA/J,EAAA4I,MAAA,GAFA,IAFA,CAKA,OAAAW,EAAAd,EAAAzI,EAAA4I,MACA5I,EAEA,IAAAJ,EAAAI,EAAAD,KAAA,IAAA8J,EAAApB,EAAAzI,EAAA4I,OAAA,EADA,CARA,OAAA,IAFA,CAeA,SAAAoB,EAAA7S,GACA,MAAA,UAAAA,GAAA,WAAAA,GAAA,aAAAA,GAAA,YAAAA,GAAA,YAAAA,CADA,CAMA,SAAAyI,EAAAG,EAAA6I,EAAAc,GAAA5J,KAAAC,KAAAA,EAAAD,KAAA8I,KAAAA,EAAA9I,KAAA4J,MAAAA,CAAA,CACA,SAAAG,EAAA1S,EAAA0H,GAAAiB,KAAA3I,KAAAA,EAAA2I,KAAAjB,KAAAA,CAAA,CAEA,IAAAoL,EAAA,IAAAJ,EAAA,OAAA,IAAAA,EAAA,YAAA,OACA,SAAAK,IACAhI,EAAArK,MAAAmI,QAAA,IAAAJ,EAAAsC,EAAArK,MAAAmI,QAAAkC,EAAArK,MAAA8Q,WAAA,GACAzG,EAAArK,MAAA8Q,UAAAsB,CAFA,CAIA,SAAAE,IACAjI,EAAArK,MAAAmI,QAAA,IAAAJ,EAAAsC,EAAArK,MAAAmI,QAAAkC,EAAArK,MAAA8Q,WAAA,GACAzG,EAAArK,MAAA8Q,UAAA,IAFA,CAKA,SAAAyB,IACAlI,EAAArK,MAAA8Q,UAAAzG,EAAArK,MAAAmI,QAAA4I,KACA1G,EAAArK,MAAAmI,QAAAkC,EAAArK,MAAAmI,QAAAD,IAFA,CAKA,SAAAsK,EAAAlM,EAAAoK,GACA,IAAA+B,EAAA,WACA,IAAAzS,EAAAqK,EAAArK,MAAAwB,EAAAxB,EAAAoI,SACA,GAAA,QAAApI,EAAAqP,QAAA/I,KAAA9E,EAAAxB,EAAAqP,QAAAjH,cACA,IAAA,IAAAsK,EAAA1S,EAAAqP,QAAAqD,GAAA,KAAAA,EAAApM,MAAAoM,EAAAjC,MAAAiC,EAAAA,EAAAxK,KACA1G,EAAAkR,EAAAtK,SACApI,EAAAqP,QAAA,IAAAmB,EAAAhP,EAAA6I,EAAAtK,OAAA4H,SAAArB,EAAA,KAAAtG,EAAAqP,QAAAqB,EALA,EAQA,OADA+B,EAAAnB,KAAA,EACAmB,CATA,CAWA,SAAAE,IACA,IAAA3S,EAAAqK,EAAArK,MACAA,EAAAqP,QAAAnH,OACA,KAAAlI,EAAAqP,QAAA/I,OACAtG,EAAAoI,SAAApI,EAAAqP,QAAAjH,UACApI,EAAAqP,QAAArP,EAAAqP,QAAAnH,KALA,CAUA,SAAA0K,EAAAC,GAMA,OALA,SAAAC,EAAAxM,GACA,OAAAA,GAAAuM,EAAArE,IACA,KAAAqE,GAAA,KAAAvM,GAAA,KAAAA,GAAA,KAAAA,EAAAiL,IACA/C,EAAAsE,EAHA,CADA,CASA,SAAAzB,EAAA/K,EAAAyM,GACA,MAAA,OAAAzM,EAAAkI,EAAAgE,EAAA,SAAAO,GAAAC,GAAAJ,EAAA,KAAAD,GACA,aAAArM,EAAAkI,EAAAgE,EAAA,QAAAS,EAAA5B,EAAAsB,GACA,aAAArM,EAAAkI,EAAAgE,EAAA,QAAAnB,EAAAsB,GACA,aAAArM,EAAA+D,EAAAtK,OAAA7B,MAAA,SAAA,GAAAsQ,IAAAA,EAAAgE,EAAA,QAAAU,EAAAN,EAAA,KAAAD,GACA,YAAArM,EAAAkI,EAAAoE,EAAA,MACA,KAAAtM,EAAAkI,EAAAgE,EAAA,KAAAF,EAAAT,GAAAc,EAAAJ,GACA,KAAAjM,EAAAkI,IACA,MAAAlI,GACA,QAAA+D,EAAArK,MAAAqP,QAAAqB,MAAArG,EAAArK,MAAAiR,GAAA5G,EAAArK,MAAAiR,GAAA1X,OAAA,IAAAoZ,GACAtI,EAAArK,MAAAiR,GAAAE,KAAA9G,GACAmE,EAAAgE,EAAA,QAAAS,EAAA5B,EAAAsB,EAAAQ,KAEA,YAAA7M,EAAAkI,EAAA4E,IACA,OAAA9M,EAAAkI,EAAAgE,EAAA,QAAAF,EAAAe,GAAAhC,EAAAkB,EAAAI,GACA,SAAArM,GAAA0E,GAAA,aAAA+H,GACA1I,EAAA6G,OAAA,UACA1C,EAAAgE,EAAA,OAAA,SAAAlM,EAAAA,EAAAyM,GAAAO,GAAAX,IAEA,YAAArM,EACA0E,GAAA,WAAA+H,GACA1I,EAAA6G,OAAA,UACA1C,EAAA6C,IACArG,IAAA,UAAA+H,GAAA,QAAAA,GAAA,QAAAA,IAAA1I,EAAAtK,OAAA7B,MAAA,UAAA,IACAmM,EAAA6G,OAAA,UACA,QAAA6B,EAAAvE,EAAA+E,IACA,QAAAR,EAAAvE,EAAAgF,GAAAZ,EAAA,YAAAa,GAAAb,EAAA,MACApE,EAAAgE,EAAA,QAAAkB,GAAAd,EAAA,KAAAJ,EAAA,KAAAX,GAAAc,EAAAA,IACA3H,GAAA,aAAA+H,GACA1I,EAAA6G,OAAA,UACA1C,EAAAgE,EAAA,QAAApB,EAAAC,EAAAsB,IACA3H,GAAA,YAAA+H,GACA1I,EAAA6G,OAAA,UACA1C,EAAA6C,IAEA7C,EAAAgE,EAAA,QAAAmB,IAGA,UAAArN,EAAAkI,EAAAgE,EAAA,QAAAS,EAAAL,EAAA,KAAAJ,EAAA,IAAA,UAAAF,EACAT,GAAAc,EAAAA,EAAAJ,GACA,QAAAjM,EAAAkI,EAAA4C,EAAAwB,EAAA,MACA,WAAAtM,EAAAkI,EAAAoE,EAAA,MACA,SAAAtM,EAAAkI,EAAAgE,EAAA,QAAAH,EAAAuB,EAAAvC,EAAAsB,EAAAJ,GACA,UAAAjM,EAAAkI,EAAAgE,EAAA,QAAAqB,GAAAlB,GACA,UAAArM,EAAAkI,EAAAgE,EAAA,QAAAsB,GAAAnB,GACA,SAAArM,EAAAkI,EAAA6C,GACA,KAAA0B,EAAAvE,EAAA4C,EAAAC,GACAE,EAAAiB,EAAA,QAAApB,EAAAwB,EAAA,KAAAD,EA/CA,CAiDA,SAAAiB,EAAAtN,GACA,GAAA,KAAAA,EAAA,OAAAkI,EAAAuF,GAAAnB,EAAA,KADA,CAGA,SAAAxB,EAAA9K,EAAAyM,GACA,OAAAiB,EAAA1N,EAAAyM,GAAA,EADA,CAGA,SAAAkB,EAAA3N,EAAAyM,GACA,OAAAiB,EAAA1N,EAAAyM,GAAA,EADA,CAGA,SAAAE,EAAA3M,GACA,MAAA,KAAAA,EAAAiL,IACA/C,EAAAgE,EAAA,KAAAU,EAAAN,EAAA,KAAAD,EAFA,CAIA,SAAAqB,EAAA1N,EAAAyM,EAAAmB,GACA,GAAA7J,EAAArK,MAAA4P,YAAAvF,EAAAtK,OAAAqP,MAAA,CACA,IAAA+E,EAAAD,EAAAE,EAAAC,EACA,GAAA,KAAA/N,EAAA,OAAAkI,EAAA6D,EAAAG,EAAA,KAAA8B,GAAAP,GAAA,KAAApB,EAAAC,EAAA,MAAAuB,EAAA5B,GACA,GAAA,YAAAjM,EAAA,OAAAiL,EAAAc,EAAAqB,GAAAd,EAAA,MAAAuB,EAAA5B,EAHA,CAMA,IAAAgC,EAAAL,EAAAM,EAAAC,EACA,OAAApE,EAAA/P,eAAAgG,GAAAkI,EAAA+F,GACA,YAAAjO,EAAAkI,EAAA4E,GAAAmB,GACA,SAAAjO,GAAA0E,GAAA,aAAA+H,GAAA1I,EAAA6G,OAAA,UAAA1C,EAAAgE,EAAA,QAAAkC,GAAA/B,IACA,aAAArM,GAAA,SAAAA,EAAAkI,EAAA0F,EAAAD,EAAA7C,GACA,KAAA9K,EAAAkI,EAAAgE,EAAA,KAAAU,EAAAN,EAAA,KAAAD,EAAA4B,GACA,YAAAjO,GAAA,UAAAA,EAAAkI,EAAA0F,EAAAD,EAAA7C,GACA,KAAA9K,EAAAkI,EAAAgE,EAAA,KAAAmC,GAAAhC,EAAA4B,GACA,KAAAjO,EAAAsO,GAAAC,GAAA,IAAA,KAAAN,GACA,SAAAjO,EAAAiL,EAAAuD,EAAAP,GACA,OAAAjO,EAAAkI,EAuDA,SAAA0F,GACA,OAAA,SAAA5N,GACA,MAAA,KAAAA,EAAAkI,EAAA0F,EAAAa,GAAA3b,IACA,YAAAkN,GAAA0E,EAAAwD,EAAAwG,GAAAd,EAAAM,EAAAC,GACAlD,EAAA2C,EAAAD,EAAA7C,EAHA,CADA,CAvDA6D,CAAAf,IACA1F,GAlBA,CAoBA,SAAA0E,EAAA5M,GACA,OAAAA,EAAApI,MAAA,cAAAqT,IACAA,EAAAH,EAFA,CAKA,SAAAqD,EAAAnO,EAAAyM,GACA,MAAA,KAAAzM,EAAAkI,EAAA0E,GACAsB,EAAAlO,EAAAyM,GAAA,EAFA,CAIA,SAAAyB,EAAAlO,EAAAyM,EAAAmB,GACA,IAAAgB,EAAA,GAAAhB,EAAAO,EAAAD,EACAW,EAAA,GAAAjB,EAAA9C,EAAA6C,EACA,MAAA,MAAA3N,EAAAkI,EAAA6D,EAAA6B,EAAAE,EAAAC,EAAA9B,GACA,YAAAjM,EACA,UAAAnG,KAAA4S,IAAA/H,GAAA,KAAA+H,EAAAvE,EAAA0G,GACAlK,GAAA,KAAA+H,GAAA1I,EAAAtK,OAAA7B,MAAA,4BAAA,GACAsQ,EAAAgE,EAAA,KAAA8B,GAAAb,GAAA,KAAAd,EAAAuC,GACA,KAAAnC,EAAAvE,EAAA4C,EAAAwB,EAAA,KAAAuC,GACA3G,EAAA2G,GAEA,SAAA7O,EAAAiL,EAAAuD,EAAAI,GACA,KAAA5O,EACA,KAAAA,EAAAsO,GAAAX,EAAA,IAAA,OAAAiB,GACA,KAAA5O,EAAAkI,EAAA4G,GAAAF,GACA,KAAA5O,EAAAkI,EAAAgE,EAAA,KAAAU,EAAAN,EAAA,KAAAD,EAAAuC,GACAlK,GAAA,MAAA+H,GAAA1I,EAAA6G,OAAA,UAAA1C,EAAAiF,GAAAyB,IACA,UAAA5O,GACA+D,EAAArK,MAAAuP,SAAAlF,EAAA6G,OAAA,WACA7G,EAAAtK,OAAAsB,OAAAgJ,EAAAtK,OAAAmQ,IAAA7F,EAAAtK,OAAAqP,MAAA,GACAZ,EAAA2G,SAHA,OALA,CAZA,CAuBA,SAAAL,EAAAxO,EAAAyM,GACA,MAAA,SAAAzM,EAAAiL,IACA,MAAAwB,EAAA5D,MAAA4D,EAAAxZ,OAAA,GAAAiV,EAAAsG,GACAtG,EAAA0E,EAAAmC,EAHA,CAKA,SAAAA,EAAA/O,GACA,GAAA,KAAAA,EAGA,OAFA+D,EAAA6G,OAAA,WACA7G,EAAArK,MAAA8G,SAAAmI,EACAT,EAAAsG,EAJA,CAOA,SAAAT,EAAA/N,GAEA,OADAqJ,EAAAtF,EAAAtK,OAAAsK,EAAArK,OACAuR,EAAA,KAAAjL,EAAA+K,EAAAD,EAFA,CAIA,SAAAgD,EAAA9N,GAEA,OADAqJ,EAAAtF,EAAAtK,OAAAsK,EAAArK,OACAuR,EAAA,KAAAjL,EAAA+K,EAAA4C,EAFA,CAWA,SAAA7a,GAAAkc,EAAAvC,GACA,GAAA,UAAAA,EAAA,OAAA1I,EAAA6G,OAAA,UAAA1C,EAAAiG,EADA,CAGA,SAAAM,GAAAO,EAAAvC,GACA,GAAA,UAAAA,EAAA,OAAA1I,EAAA6G,OAAA,UAAA1C,EAAAgG,EADA,CAGA,SAAAb,GAAArN,GACA,MAAA,KAAAA,EAAAkI,EAAAmE,EAAAtB,GACAE,EAAAkD,EAAA7B,EAAA,KAAAD,EAFA,CAIA,SAAAyC,GAAA9O,GACA,GAAA,YAAAA,EAAA,OAAA+D,EAAA6G,OAAA,WAAA1C,GADA,CAGA,SAAAqG,GAAAvO,EAAAyM,GACA,MAAA,SAAAzM,GACA+D,EAAA6G,OAAA,WACA1C,EAAAqG,KACA,YAAAvO,GAAA,WAAA+D,EAAAxM,OACAwM,EAAA6G,OAAA,WACA,OAAA6B,GAAA,OAAAA,EAAAvE,EAAA+G,KAEAvK,GAAAX,EAAArK,MAAA4P,YAAAvF,EAAAtK,OAAAqP,QAAAW,EAAA1F,EAAAtK,OAAA7B,MAAA,YAAA,MACAmM,EAAArK,MAAA4P,WAAAvF,EAAAtK,OAAAmQ,IAAAH,EAAA,GAAAxW,QACAiV,EAAAgH,MACA,UAAAlP,GAAA,UAAAA,GACA+D,EAAA6G,OAAAvG,EAAA,WAAAN,EAAAxM,MAAA,YACA2Q,EAAAgH,KACA,kBAAAlP,EACAkI,EAAAgH,IACAxK,GAAAmH,EAAAY,IACA1I,EAAA6G,OAAA,UACA1C,EAAAqG,KACA,KAAAvO,EACAkI,EAAA4C,EAAAqE,GAAA7C,EAAA,KAAA4C,IACA,UAAAlP,EACAkI,EAAAyF,EAAAuB,IACA,KAAAzC,GACA1I,EAAA6G,OAAA,UACA1C,EAAAqG,KACA,KAAAvO,EACAiL,EAAAiE,SADA,EAnBA,IAAAzF,CAPA,CA8BA,SAAAwF,GAAAjP,GACA,MAAA,YAAAA,EAAAiL,EAAAiE,KACAnL,EAAA6G,OAAA,WACA1C,EAAA4E,IAHA,CAKA,SAAAoC,GAAAlP,GACA,MAAA,KAAAA,EAAAkI,EAAAyF,GACA,KAAA3N,EAAAiL,EAAA6B,SAAA,CAFA,CAIA,SAAAkB,GAAAoB,EAAAC,EAAAC,GACA,SAAAC,EAAAvP,EAAAyM,GACA,GAAA6C,EAAAA,EAAA9F,QAAAxJ,IAAA,EAAA,KAAAA,EAAA,CACA,IAAAgL,EAAAjH,EAAArK,MAAAqP,QAEA,MADA,QAAAiC,EAAAZ,OAAAY,EAAApB,KAAAoB,EAAApB,KAAA,GAAA,GACA1B,GAAA,SAAAlI,EAAAyM,GACA,OAAAzM,GAAAqP,GAAA5C,GAAA4C,EAAApE,IACAA,EAAAmE,EAFA,GAGAG,EANA,CAQA,OAAAvP,GAAAqP,GAAA5C,GAAA4C,EAAAnH,IACAoH,GAAAA,EAAA9F,QAAA,MAAA,EAAAyB,EAAAmE,GACAlH,EAAAoE,EAAA+C,GAXA,CAaA,OAAA,SAAArP,EAAAyM,GACA,OAAAzM,GAAAqP,GAAA5C,GAAA4C,EAAAnH,IACA+C,EAAAmE,EAAAG,EAFA,CAdA,CAmBA,SAAAjB,GAAAc,EAAAC,EAAAjF,GACA,IAAA,IAAApX,EAAA,EAAAA,EAAAkY,UAAAjY,OAAAD,IACA+Q,EAAA4G,GAAA3G,KAAAkH,UAAAlY,IACA,OAAAkV,EAAAgE,EAAAmD,EAAAjF,GAAA4D,GAAAoB,EAAAC,GAAAhD,EAHA,CAKA,SAAAd,GAAAvL,GACA,MAAA,KAAAA,EAAAkI,IACA+C,EAAAF,EAAAQ,GAFA,CAIA,SAAA4D,GAAAnP,EAAAyM,GACA,GAAA/H,EAAA,CACA,GAAA,KAAA1E,EAAA,OAAAkI,EAAAiF,IACA,GAAA,KAAAV,EAAA,OAAAvE,EAAAiH,GAFA,CADA,CAMA,SAAAK,GAAAxP,EAAAyM,GACA,GAAA/H,IAAA,KAAA1E,GAAA,MAAAyM,GAAA,OAAAvE,EAAAiF,GADA,CAGA,SAAAsC,GAAAzP,GACA,GAAA0E,GAAA,KAAA1E,EACA,OAAA+D,EAAAtK,OAAA7B,MAAA,kBAAA,GAAAsQ,EAAA4C,EAAA4E,GAAAvC,IACAjF,EAAAiF,GAHA,CAMA,SAAAuC,GAAAV,EAAAvC,GACA,GAAA,MAAAA,EAEA,OADA1I,EAAA6G,OAAA,UACA1C,GAHA,CAMA,SAAAiF,GAAAnN,EAAAyM,GACA,MAAA,SAAAA,GAAA,UAAAA,GAAA,SAAAA,GAAA,YAAAA,GACA1I,EAAA6G,OAAA,UACA1C,EAAA,UAAAuE,EAAAkB,EAAAR,KAEA,YAAAnN,GAAA,QAAAyM,GACA1I,EAAA6G,OAAA,OACA1C,EAAAyH,KAEA,KAAAlD,GAAA,KAAAA,EAAAvE,EAAAiF,IACA,UAAAnN,GAAA,UAAAA,GAAA,QAAAA,EAAAkI,EAAAyH,IACA,KAAA3P,EAAAkI,EAAAgE,EAAA,KAAA8B,GAAAb,GAAA,IAAA,KAAAd,EAAAsD,IACA,KAAA3P,EAAAkI,EAAAgE,EAAA,KAAA0D,GAAAvD,EAAAsD,IACA,KAAA3P,EAAAkI,EAAA8F,GAAA6B,GAAA,KAAAC,GAAAH,IACA,KAAA3P,EAAAkI,EAAA8F,GAAAb,GAAA,KAAAA,IACA,SAAAnN,EAAAiL,EAAA8E,GAAAJ,SAAA,CAfA,CAiBA,SAAAG,GAAA9P,GACA,GAAA,MAAAA,EAAA,OAAAkI,EAAAiF,GADA,CAGA,SAAAyC,GAAA5P,GACA,OAAAA,EAAApI,MAAA,YAAAsQ,IACA,KAAAlI,GAAA,KAAAA,EAAAkI,EAAA0H,IACA3E,EAAA+E,GAAAJ,GAHA,CAKA,SAAAI,GAAAhQ,EAAAyM,GACA,MAAA,YAAAzM,GAAA,WAAA+D,EAAAxM,OACAwM,EAAA6G,OAAA,WACA1C,EAAA8H,KACA,KAAAvD,GAAA,UAAAzM,GAAA,UAAAA,EACAkI,EAAA8H,IACA,KAAAhQ,EACAkI,EAAAiF,IACA,KAAAnN,EACAkI,EAAAoE,EAAA,YAAAkD,GAAAlD,EAAA,KAAA0D,IACA,KAAAhQ,EACAiL,EAAAgF,GAAAD,IACAhQ,EAAApI,MAAA,mBAAA,EACAsQ,GAbA,CAgBA,SAAA6H,GAAA/P,EAAAyM,GACA,MAAA,SAAAzM,EAAAiL,IACA,MAAAwB,EAAA5D,MAAA4D,EAAAxZ,OAAA,GAAAiV,EAAA6H,IACA7H,EAAAiF,GAAA+C,GAHA,CAKA,SAAAA,GAAAlQ,GACA,GAAA,KAAAA,EAGA,OAFA+D,EAAA6G,OAAA,WACA7G,EAAArK,MAAA8G,SAAAmI,EACAT,EAAA6H,GAJA,CAOA,SAAAF,GAAA7P,EAAAyM,GACA,MAAA,YAAAzM,GAAA+D,EAAAtK,OAAA7B,MAAA,YAAA,IAAA,KAAA6U,EAAAvE,EAAA2H,IACA,KAAA7P,EAAAkI,EAAAiF,IACA,UAAAnN,EAAAkI,EAAA2H,IACA5E,EAAAkC,GAJA,CAMA,SAAAwC,GAAA3P,EAAAyM,GACA,MAAA,KAAAA,EAAAvE,EAAAgE,EAAA,KAAA8B,GAAAb,GAAA,KAAAd,EAAAsD,IACA,KAAAlD,GAAA,KAAAzM,GAAA,KAAAyM,EAAAvE,EAAAiF,IACA,KAAAnN,EAAAkI,EAAAiF,GAAAb,EAAA,KAAAqD,IACA,WAAAlD,GAAA,cAAAA,GAAA1I,EAAA6G,OAAA,UAAA1C,EAAAiF,KACA,KAAAV,EAAAvE,EAAAiF,GAAAb,EAAA,KAAAa,SAAA,CALA,CAOA,SAAAuB,GAAAM,EAAAvC,GACA,GAAA,KAAAA,EAAA,OAAAvE,EAAAgE,EAAA,KAAA8B,GAAAb,GAAA,KAAAd,EAAAsD,GADA,CAGA,SAAAQ,KACA,OAAAlF,EAAAkC,GAAAiD,GADA,CAGA,SAAAA,GAAApB,EAAAvC,GACA,GAAA,KAAAA,EAAA,OAAAvE,EAAAiF,GADA,CAGA,SAAAT,GAAAsC,EAAAvC,GACA,MAAA,QAAAA,GAAA1I,EAAA6G,OAAA,UAAA1C,EAAA+E,KACAhC,EAAAmC,GAAA+B,GAAAkB,GAAAC,GAFA,CAIA,SAAAlD,GAAApN,EAAAyM,GACA,OAAA/H,GAAAmH,EAAAY,IAAA1I,EAAA6G,OAAA,UAAA1C,EAAAkF,KACA,YAAApN,GAAAsL,EAAAmB,GAAAvE,KACA,UAAAlI,EAAAkI,EAAAkF,IACA,KAAApN,EAAAsO,GAAAiC,GAAA,KACA,KAAAvQ,EAAAsO,GAAAkC,GAAA,UAAA,CALA,CAOA,SAAAA,GAAAxQ,EAAAyM,GACA,MAAA,YAAAzM,GAAA+D,EAAAtK,OAAA7B,MAAA,SAAA,IAIA,YAAAoI,IAAA+D,EAAA6G,OAAA,YACA,UAAA5K,EAAAkI,EAAAkF,IACA,KAAApN,EAAAiL,IACA,KAAAjL,EAAAkI,EAAA4C,EAAAwB,EAAA,KAAAA,EAAA,KAAAkE,IACAtI,EAAAoE,EAAA,KAAAc,GAAAiD,MAPA/E,EAAAmB,GACAvE,EAAAmI,IAHA,CAWA,SAAAE,KACA,OAAAtF,EAAAmC,GAAAiD,GADA,CAGA,SAAAA,GAAAI,EAAAhE,GACA,GAAA,KAAAA,EAAA,OAAAvE,EAAAyF,EADA,CAGA,SAAA2C,GAAAtQ,GACA,GAAA,KAAAA,EAAA,OAAAkI,EAAAwE,GADA,CAGA,SAAAG,GAAA7M,EAAAyM,GACA,GAAA,aAAAzM,GAAA,QAAAyM,EAAA,OAAAvE,EAAAgE,EAAA,OAAA,QAAAnB,EAAAsB,EADA,CAGA,SAAAU,GAAA/M,EAAAyM,GACA,MAAA,SAAAA,EAAAvE,EAAA6E,IACA,KAAA/M,EAAAkI,EAAAgE,EAAA,KAAAwE,GAAArE,QAAA,CAFA,CAIA,SAAAqE,GAAA1Q,GACA,MAAA,OAAAA,EAAAkI,EAAAwE,GAAAiE,IACA,YAAA3Q,EAAAkI,EAAAyI,IACA1F,EAAA0F,GAHA,CAKA,SAAAA,GAAA3Q,EAAAyM,GACA,MAAA,KAAAzM,EAAAkI,IACA,KAAAlI,EAAAkI,EAAAyI,IACA,MAAAlE,GAAA,MAAAA,GAAA1I,EAAA6G,OAAA,UAAA1C,EAAA4C,EAAA6F,KACA1F,EAAAH,EAAA6F,GAJA,CAMA,SAAA7D,GAAA9M,EAAAyM,GACA,MAAA,KAAAA,GAAA1I,EAAA6G,OAAA,UAAA1C,EAAA4E,KACA,YAAA9M,GAAAsL,EAAAmB,GAAAvE,EAAA4E,KACA,KAAA9M,EAAAkI,EAAA6D,EAAAG,EAAA,KAAA8B,GAAAP,GAAA,KAAApB,EAAAoD,GAAA1E,EAAAkB,GACAvH,GAAA,KAAA+H,EAAAvE,EAAAgE,EAAA,KAAA8B,GAAAmC,GAAA,KAAA9D,EAAAS,SAAA,CAJA,CAMA,SAAAmD,GAAAjQ,EAAAyM,GACA,MAAA,KAAAA,GAAA1I,EAAA6G,OAAA,UAAA1C,EAAA+H,KACA,YAAAjQ,GAAAsL,EAAAmB,GAAAvE,EAAA+H,KACA,KAAAjQ,EAAAkI,EAAA6D,EAAAG,EAAA,KAAA8B,GAAAP,GAAA,KAAApB,EAAAoD,GAAAxD,GACAvH,GAAA,KAAA+H,EAAAvE,EAAAgE,EAAA,KAAA8B,GAAAmC,GAAA,KAAA9D,EAAA4D,SAAA,CAJA,CAMA,SAAA/C,GAAAlN,EAAAyM,GACA,MAAA,WAAAzM,GAAA,YAAAA,GACA+D,EAAA6G,OAAA,OACA1C,EAAAgF,KACA,KAAAT,EACAvE,EAAAgE,EAAA,KAAA8B,GAAAmC,GAAA,KAAA9D,QADA,CAJA,CAQA,SAAAoB,GAAAzN,EAAAyM,GAEA,MADA,KAAAA,GAAAvE,EAAA4C,EAAA2C,IACA,UAAAzN,EAAAkI,EAAAuF,IACA/I,GAAAmH,EAAAY,IAAA1I,EAAA6G,OAAA,UAAA1C,EAAAuF,KACA/I,GAAA,QAAA1E,EAAAkI,EAAAiH,GAAAkB,IACApF,EAAAmC,GAAA+B,GAAAkB,GALA,CAOA,SAAAjC,GAAApO,EAAAyM,GAEA,MAAA,YAAAzM,EAAAgN,GAAAhN,EAAAyM,GACAmE,GAAA5Q,EAAAyM,EAHA,CAKA,SAAAO,GAAAhN,EAAAyM,GACA,GAAA,YAAAzM,EAAA,OAAAsL,EAAAmB,GAAAvE,EAAA0I,GADA,CAGA,SAAAA,GAAA5Q,EAAAyM,GACA,MAAA,KAAAA,EAAAvE,EAAAgE,EAAA,KAAA8B,GAAAmC,GAAA,KAAA9D,EAAAuE,IACA,WAAAnE,GAAA,cAAAA,GAAA/H,GAAA,KAAA1E,GACA,cAAAyM,IAAA1I,EAAA6G,OAAA,WACA1C,EAAAxD,EAAAyI,GAAArC,EAAA8F,KAEA,KAAA5Q,EAAAkI,EAAAgE,EAAA,KAAA2E,GAAAxE,QAAA,CANA,CAQA,SAAAwE,GAAA7Q,EAAAyM,GACA,MAAA,SAAAzM,GACA,YAAAA,IACA,UAAAyM,GAAA,OAAAA,GAAA,OAAAA,GAAA/H,GAAAmH,EAAAY,KACA1I,EAAAtK,OAAA7B,MAAA,0BAAA,IACAmM,EAAA6G,OAAA,UACA1C,EAAA2I,KAEA,YAAA7Q,GAAA,WAAA+D,EAAAxM,OACAwM,EAAA6G,OAAA,WACA1C,EAAA4I,GAAAD,KAEA,UAAA7Q,GAAA,UAAAA,EAAAkI,EAAA4I,GAAAD,IACA,KAAA7Q,EACAkI,EAAA4C,EAAAqE,GAAA7C,EAAA,KAAAwE,GAAAD,IACA,KAAApE,GACA1I,EAAA6G,OAAA,UACA1C,EAAA2I,KAEAnM,GAAA,KAAA1E,EAAAiL,EAAAgF,GAAAY,IACA,KAAA7Q,GAAA,KAAAA,EAAAkI,EAAA2I,IACA,KAAA7Q,EAAAkI,IACA,KAAAuE,EAAAvE,EAAA4C,EAAA+F,SAAA,CAtBA,CAwBA,SAAAC,GAAA9Q,EAAAyM,GACA,GAAA,KAAAA,EAAA,OAAAvE,EAAA4I,IACA,GAAA,KAAArE,EAAA,OAAAvE,EAAA4I,IACA,GAAA,KAAA9Q,EAAA,OAAAkI,EAAAiF,GAAAkD,IACA,GAAA,KAAA5D,EAAA,OAAAvE,EAAAyF,GACA,IAAA9L,EAAAkC,EAAArK,MAAAqP,QAAAnH,KACA,OAAAqJ,EADApJ,GAAA,aAAAA,EAAAuI,KACA6F,GAAAnD,GANA,CAQA,SAAAS,GAAAvN,EAAAyM,GACA,MAAA,KAAAA,GAAA1I,EAAA6G,OAAA,UAAA1C,EAAA6I,GAAAzE,EAAA,OACA,WAAAG,GAAA1I,EAAA6G,OAAA,UAAA1C,EAAA4C,EAAAwB,EAAA,OACA,KAAAtM,EAAAkI,EAAA8F,GAAAgD,GAAA,KAAAD,GAAAzE,EAAA,MACArB,EAAAF,EAJA,CAMA,SAAAiG,GAAAhR,EAAAyM,GACA,MAAA,MAAAA,GAAA1I,EAAA6G,OAAA,UAAA1C,EAAAoE,EAAA,cACA,YAAAtM,EAAAiL,EAAA0C,EAAAqD,SAAA,CAFA,CAIA,SAAAxD,GAAAxN,GACA,MAAA,UAAAA,EAAAkI,IACA,KAAAlI,EAAAiL,EAAAH,GACA,KAAA9K,EAAAiL,EAAAkD,GACAlD,EAAAgG,GAAAC,GAAAH,GAJA,CAMA,SAAAE,GAAAjR,EAAAyM,GACA,MAAA,KAAAzM,EAAAsO,GAAA2C,GAAA,MACA,YAAAjR,GAAAsL,EAAAmB,GACA,KAAAA,IAAA1I,EAAA6G,OAAA,WACA1C,EAAAiJ,IAJA,CAMA,SAAAD,GAAAlR,GACA,GAAA,KAAAA,EAAA,OAAAkI,EAAA+I,GAAAC,GADA,CAGA,SAAAC,GAAAV,EAAAhE,GACA,GAAA,MAAAA,EAAA,OAAA1I,EAAA6G,OAAA,UAAA1C,EAAA+I,GADA,CAGA,SAAAF,GAAAN,EAAAhE,GACA,GAAA,QAAAA,EAAA,OAAA1I,EAAA6G,OAAA,UAAA1C,EAAA4C,EADA,CAGA,SAAAuD,GAAArO,GACA,MAAA,KAAAA,EAAAkI,IACA+C,EAAA+C,GAAAL,EAAA,KAFA,CAIA,SAAAV,KACA,OAAAhC,EAAAiB,EAAA,QAAAkB,GAAAd,EAAA,KAAAJ,EAAA,KAAA8B,GAAAoD,GAAA,KAAA/E,EAAAA,EADA,CAGA,SAAA+E,KACA,OAAAnG,EAAAmC,GAAAiD,GADA,CAUA,SAAA7H,GAAA/O,EAAAC,EAAAqB,GACA,OAAArB,EAAA8G,UAAA2H,GACA,iFAAAtO,KAAAH,EAAAuP,WACA,SAAAvP,EAAAuP,UAAA,SAAApP,KAAAJ,EAAAmP,OAAAC,MAAA,EAAApP,EAAAmQ,KAAA7O,GAAA,IAHA,CAQA,OArhBAgR,EAAAf,IAAAgB,EAAAhB,KAAA,EAKAiB,EAAAjB,KAAA,EAoBAqB,EAAArB,KAAA,EA4fA,CACA/P,WAAA,SAAAoW,GACA,IAAA3X,EAAA,CACA8G,SAAA2H,EACAc,SAAA,MACA0B,GAAA,GACA5B,QAAA,IAAAmB,GAAAmH,GAAA,GAAAnR,EAAA,EAAA,SAAA,GACAsK,UAAA3R,EAAA2R,UACA3I,QAAAhJ,EAAA2R,WAAA,IAAA/I,EAAA,KAAA,MAAA,GACAK,SAAAuP,GAAA,GAIA,OAFAxY,EAAA8S,YAAA,UAAA3X,QAAA6E,EAAA8S,cACAjS,EAAAiS,WAAA9S,EAAA8S,YACAjS,CAZA,EAeAC,MAAA,SAAAF,EAAAC,GAOA,GANAD,EAAAuJ,QACAtJ,EAAAqP,QAAA/O,eAAA,WACAN,EAAAqP,QAAAoB,OAAA,GACAzQ,EAAAoI,SAAArI,EAAAwJ,cACAoG,EAAA5P,EAAAC,IAEAA,EAAA8G,UAAA8H,GAAA7O,EAAAyJ,WAAA,OAAA,KACA,IAAA3L,EAAAmC,EAAA8G,SAAA/G,EAAAC,GACA,MAAA,WAAAsG,EAAAzI,GACAmC,EAAAuP,SAAA,YAAAjJ,GAAA,MAAAmE,GAAA,MAAAA,EAAAnE,EAAA,SACA0K,EAAAhR,EAAAnC,EAAAyI,EAAAmE,EAAA1K,GAXA,EAcAyB,OAAA,SAAAxB,EAAA4B,GACA,GAAA5B,EAAA8G,UAAA8H,GAAA5O,EAAA8G,UAAAmI,EAAA,OAAApT,EAAAiG,KACA,GAAA9B,EAAA8G,UAAA2H,EAAA,OAAA,EACA,IAAAmJ,EAAAC,EAAAjW,GAAAA,EAAAuO,OAAA,GAAAd,EAAArP,EAAAqP,QAEA,IAAA,aAAAlP,KAAAyB,GAAA,IAAA,IAAAtI,EAAA0G,EAAAiR,GAAA1X,OAAA,EAAAD,GAAA,IAAAA,EAAA,CACA,IAAAwe,EAAA9X,EAAAiR,GAAA3X,GACA,GAAAwe,GAAAnF,EAAAtD,EAAAA,EAAAnH,UACA,GAAA4P,GAAA3E,IAAA2E,GAAAvF,EAAA,KAHA,CAKA,MAAA,QAAAlD,EAAA/I,MAAA,QAAA+I,EAAA/I,QACA,KAAAuR,IAAAD,EAAA5X,EAAAiR,GAAAjR,EAAAiR,GAAA1X,OAAA,MACAqe,GAAAnD,GAAAmD,GAAApD,KACA,mBAAArU,KAAAyB,KACAyN,EAAAA,EAAAnH,KACAwC,GAAA,KAAA2E,EAAA/I,MAAA,QAAA+I,EAAAnH,KAAA5B,OACA+I,EAAAA,EAAAnH,MACA,IAAA5B,EAAA+I,EAAA/I,KAAAyR,EAAAF,GAAAvR,EAEA,MAAA,UAAAA,EAAA+I,EAAAjH,UAAA,YAAApI,EAAAuP,UAAA,KAAAvP,EAAAuP,SAAAF,EAAAqB,KAAAnX,OAAA,EAAA,GACA,QAAA+M,GAAA,KAAAuR,EAAAxI,EAAAjH,SACA,QAAA9B,EAAA+I,EAAAjH,SAAA5B,EACA,QAAAF,EACA+I,EAAAjH,UAnEA,SAAApI,EAAA4B,GACA,MAAA,YAAA5B,EAAAuP,UAAA,KAAAvP,EAAAuP,UACAnB,EAAAjO,KAAAyB,EAAAuO,OAAA,KACA,OAAAhQ,KAAAyB,EAAAuO,OAAA,GAHA,CAmEA6H,CAAAhY,EAAA4B,GAAA8I,GAAAlE,EAAA,GACA,UAAA6I,EAAAqB,MAAAqH,GAAA,GAAA5Y,EAAA8Y,mBAEA5I,EAAAoB,MAAApB,EAAA1H,QAAAoQ,EAAA,EAAA,GACA1I,EAAAjH,UAAA2P,EAAA,EAAAvR,GAFA6I,EAAAjH,UAAA,sBAAAjI,KAAAyB,GAAA4E,EAAA,EAAAA,EAzBA,EA8BAqD,cAAA,oCACAC,kBAAAe,EAAA,KAAA,KACAd,gBAAAc,EAAA,KAAA,KACAqN,qBAAArN,EAAA,KAAA,MACAsN,YAAAtN,EAAA,KAAA,KACAuN,KAAA,QACAC,cAAA,iBAEApO,WAAAY,EAAA,OAAA,aACAF,WAAAA,EACAE,SAAAA,EAEAiE,kBAAAA,GAEAwJ,eAAA,SAAAtY,GACAgR,EAAAhR,EAAA,OAAA,OAAA,OAAA,IAAAnE,EAAA0c,aAAA,GAAA,EAAA,MADA,EA95BA,IAo6BA1c,EAAA2c,eAAA,YAAA,aAAA,SAEA3c,EAAAmG,WAAA,kBAAA,cACAnG,EAAAmG,WAAA,kBAAA,cACAnG,EAAAmG,WAAA,yBAAA,cACAnG,EAAAmG,WAAA,2BAAA,cACAnG,EAAAmG,WAAA,yBAAA,cACAnG,EAAAmG,WAAA,mBAAA,CAAA1C,KAAA,aAAAwL,MAAA,IACAjP,EAAAmG,WAAA,qBAAA,CAAA1C,KAAA,aAAAwL,MAAA,IACAjP,EAAAmG,WAAA,4BAAA,CAAA1C,KAAA,aAAAwL,MAAA,IACAjP,EAAAmG,WAAA,sBAAA,CAAA1C,KAAA,aAAAsL,QAAA,IACA/O,EAAAmG,WAAA,kBAAA,CAAA1C,KAAA,aAAA2L,YAAA,IACApP,EAAAmG,WAAA,yBAAA,CAAA1C,KAAA,aAAA2L,YAAA,GAn7BA,EANA,UAAA3Q,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WL+8DQ,EACA,CAAE,GAAM,KCz9DhB,GAAA,CD49DQ,SAAUZ,EAASU,EAAQD,GMz9DnC,IAAAgC,IAOA,SAAA7B,GACA,aACA,IAAA4c,EAAA,wBACAC,EAAA,mCACAC,EAAA,+BAiBA,SAAAC,EAAA3c,GACA,IAAA,IAAA3C,EAAA,EAAAA,EAAA2C,EAAA+D,MAAA6Y,YAAAtf,OAAAD,IACA2C,EAAA6c,gBAAA7c,EAAA+D,MAAA6Y,YAAAvf,GAAA,OAAAmf,GACAxc,EAAA6c,gBAAA7c,EAAA+D,MAAA6Y,YAAAvf,GAAA,aAAAof,GACAzc,EAAA6c,gBAAA7c,EAAA+D,MAAA6Y,YAAAvf,GAAA,SAAAqf,EAJA,CAeA,SAAAI,EAAA9c,EAAA+c,GAEA,IADA,IAAAC,EAAA,GACA3f,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAA4f,EAAAF,EAAA1f,GACAoK,EAAAzH,EAAAkd,UAAA,mBACA,GAAA,UAAA7e,QAAAoJ,IAAAA,EAAA0V,SAAAF,EAAAG,OAAAxX,MAAAqX,EAAAI,KAAAzX,KAAAqX,EAAAK,QAAA,CAEA,IAAA1X,EAAA5F,EAAAud,yBAAAN,EAAAI,KAAAzX,MACAoX,EAAAA,EAAA1f,OAAA,IAAAsI,GAAAoX,EAAA3O,KAAAzI,EAFA,CAJA,EATA,SAAAxG,EAAAoe,GACA,GAAApe,EAAA9B,QAAAkgB,EAAAlgB,OAAA,OAAA,EACA,IAAA,IAAAD,EAAA,EAAAA,EAAA+B,EAAA9B,OAAAD,IACA,GAAA+B,EAAA/B,IAAAmgB,EAAAngB,GAAA,OAAA,EACA,OAAA,CAJA,EAiBAogB,CAAAzd,EAAA+D,MAAA6Y,YAAAI,IACAhd,EAAA0d,WAAA,WACAf,EAAA3c,GACA,IAAA,IAAA3C,EAAA,EAAAA,EAAA2f,EAAA1f,OAAAD,IACA2C,EAAA2d,aAAAX,EAAA3f,GAAA,OAAAmf,GACAxc,EAAA2d,aAAAX,EAAA3f,GAAA,aAAAof,GACAzc,EAAA2d,aAAAX,EAAA3f,GAAA,SAAAqf,GAEA1c,EAAA+D,MAAA6Y,YAAAI,CAPA,GAXA,CAsBA,SAAAY,EAAA5d,EAAA6d,GACAf,EAAA9c,EAAA6d,EAAAd,OADA,CApDAnd,EAAAke,aAAA,mBAAA,GAAA,SAAA9d,EAAAmB,EAAA4c,GACA,IAAA9R,EAAA8R,GAAAne,EAAAoe,MAAAD,EACA5c,GAAA8K,IACAA,IACAjM,EAAAie,IAAA,wBAAAL,GACAjB,EAAA3c,UACAA,EAAA+D,MAAA6Y,aAEAzb,IACAnB,EAAA+D,MAAA6Y,YAAA,GACAE,EAAA9c,EAAAA,EAAAke,kBACAle,EAAAwB,GAAA,wBAAAoc,IAXA,GANA,EANA,UAAAvf,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WNyhEQ,EACA,CAAE,GAAM,KCniEhB,GAAA,CDsiEQ,SAAUZ,EAASU,EAAQD,GOniEnC,IAAAgC,IAOA,SAAA7B,GACA,aACA,IAAAue,EAAA,0BACAC,EAAA,wBAuBA,SAAAC,EAAAC,GACAA,EAAAC,YAAAD,EAAAC,WAAAC,YAAAF,EADA,CAUA,SAAAG,EAAAze,EAAAxB,EAAAgQ,EAAAkQ,GACA,IAAAC,EAhCA,SAAA3e,EAAAxB,EAAAgQ,GACA,IAAAoQ,EAAAC,SAAAC,cAAA,OAQA,SAAAC,EAAAvgB,GACA,IAAAogB,EAAAL,WAAA,OAAA3e,EAAAqe,IAAAY,SAAA,YAAAE,GACA,IAAApD,EAAAqD,KAAAC,IAAA,EAAAzgB,EAAA0gB,QAAAN,EAAAO,aAAA,GACAC,EAAAJ,KAAAC,IAAA,EAAAD,KAAAK,IAAA7gB,EAAA8gB,QAAA,EAAAV,EAAAW,cAAAC,YAAAC,WAAAb,EAAAc,cACAd,EAAAhd,MAAA+Z,IAAAA,EAAA,KACAiD,EAAAhd,MAAAwd,KAAAA,EAAA,IALA,CAUA,OAjBAR,EAAAvH,UAAA,gCAAArX,EAAA2f,QAAAxf,MACAye,EAAAgB,YAAApR,EAAAqR,WAAA,IACA7f,EAAA+D,MAAA/C,KAAA2e,QAAAG,YACA9f,EAAA+f,oBAAAH,YAAAhB,GAEAC,SAAA3G,KAAA0H,YAAAhB,GASAhf,EAAA4B,GAAAqd,SAAA,YAAAE,GACAA,EAAAvgB,GACA,MAAAogB,EAAAhd,MAAAoe,UAAApB,EAAAhd,MAAAoe,QAAA,GACApB,CAnBA,CAgCAqB,CAAAjgB,EAAAxB,EAAAgQ,GACA,SAAA0R,IATA,IAAAtB,EAUAhf,EAAAqe,IAAAS,EAAA,WAAAwB,GACAvB,KAXAC,EAWAD,GAVAJ,aACA,MAAAK,EAAAhd,MAAAoe,SAAA3B,EAAAO,GACAA,EAAAhd,MAAAoe,QAAA,EACAG,YAAA,WAAA9B,EAAAO,EAAA,GAAA,MAOAD,EAAA,KAFA,CAIA,IAAAyB,EAAAC,aAAA,WACA,GAAA1B,EAAA,IAAA,IAAA1f,EAAAyf,GAAAzf,EAAAA,EAAAsf,WAAA,CAEA,GADAtf,GAAA,IAAAA,EAAAqhB,WAAArhB,EAAAA,EAAAshB,MACAthB,GAAA4f,SAAA3G,KAAA,OACA,IAAAjZ,EAAA,CAAAihB,IAAA,KAAA,CAHA,CAKA,IAAAvB,EAAA,OAAA6B,cAAAJ,EANA,GAOA,KACAxgB,EAAA4B,GAAAkd,EAAA,WAAAwB,EAdA,CAiBA,SAAAO,EAAAzgB,EAAA0gB,EAAAC,GAMA,IAAA,IAAAlW,KALAuB,KAAAiJ,OAAA,GACAyL,aAAAE,WAAAF,EAAA,CAAAG,eAAAH,IACAA,IAAA,IAAAA,IAAAA,EAAA,CAAA,GACA1U,KAAA2T,QAAA,CAAA,EACA3T,KAAA8U,cAAAJ,EAAAf,SAAA,CAAA,EACAnV,EAAAwB,KAAA2T,QAAAlV,GAAAD,EAAAC,GACA,IAAA,IAAAA,KAAAiW,EACAlW,EAAAnG,eAAAoG,GACA,MAAAiW,EAAAjW,KAAAuB,KAAA2T,QAAAlV,GAAAiW,EAAAjW,IACAiW,EAAAf,UACA3T,KAAA8U,cAAArW,GAAAiW,EAAAjW,IAGAuB,KAAA+U,QAAA,KACA/U,KAAA2U,UAAAA,EACA3U,KAAAgV,YAAA,SAAAxiB,IAwKA,SAAAwB,EAAAxB,GACA,IAAArB,EAAAqB,EAAArB,QAAAqB,EAAAyiB,WACA,GAAA,0BAAA/c,KAAA/G,EAAAka,WAAA,CAKA,IAJA,IAAA6J,EAAA/jB,EAAAgkB,wBAAAC,GAAAF,EAAA9B,KAAA8B,EAAAG,OAAA,EAAAC,GAAAJ,EAAAvF,IAAAuF,EAAAK,QAAA,EACAC,EAAAxhB,EAAAyhB,YAAAzhB,EAAA0hB,WAAA,CAAAtC,KAAAgC,EAAAzF,IAAA2F,GAAA,WAEAK,EAAA,GACAtkB,EAAA,EAAAA,EAAAmkB,EAAAlkB,SAAAD,EAAA,CACA,IAAAukB,EAAAJ,EAAAnkB,GAAAwkB,aACAD,GAAAD,EAAAtT,KAAAuT,EAFA,CAIAD,EAAArkB,QArBA,SAAA0C,EAAA2hB,EAAAnjB,GAGA,IAFA,IAAArB,EAAAqB,EAAArB,QAAAqB,EAAAyiB,WACAtC,EAAAE,SAAAiD,yBACAzkB,EAAA,EAAAA,EAAAskB,EAAArkB,OAAAD,IAAA,CACA,IAAAukB,EAAAD,EAAAtkB,GACAshB,EAAAiB,YAAAmC,EAAAH,GAFA,CAIAnD,EAAAze,EAAAxB,EAAAmgB,EAAAxhB,EAPA,CAqBA6kB,CAAAhiB,EAAA2hB,EAAAnjB,EATA,CAFA,CAxKAwiB,CAAAhhB,EAAAxB,EAAA,EACAwN,KAAAiW,WAAA,CAjBA,CAoBA,IAAAzX,EAAA,CACA0X,gBAAA,EACAC,UAAA,EACAC,MAAA,IACAC,cAAA,EACAxB,eAAA,KACAyB,OAAA,EACAxC,YAAA,KACAyC,iBAAA,KACAC,gBAAA,MAGA,SAAAC,EAAAziB,GACA,IAAA+D,EAAA/D,EAAA+D,MAAA/C,KACA+C,EAAA4c,WAAA3gB,EAAA0iB,YAAAvE,GACApa,EAAA4b,QAAAuC,gBAMA,SAAAliB,GACAA,EAAA2iB,UAAA,SAAA/c,GACA,IAAAgd,EAAAhd,EAAAid,WAAA,+BAAAxgB,KAAAuD,EAAAid,WACAD,GAAA5iB,EAAA6c,gBAAAjX,EAAA,OAAAgd,EAAA,GAFA,GADA,CANAE,CAAA9iB,GACA,IAAA,IAAA3C,EAAA,EAAAA,EAAA0G,EAAAkR,OAAA3X,SAAAD,EACA0G,EAAAkR,OAAA5X,GAAA0lB,QACAhf,EAAAkR,OAAA3X,OAAA,CANA,CAgBA,SAAA0lB,EAAAhjB,EAAAijB,EAAAC,EAAAC,EAAAhB,GACA,IAAAiB,EAAAvE,SAAAC,cAAA,OAAA7I,EAAAmN,EAWA,OAVAA,EAAA/L,UAAA,iDAAA6L,EACAC,KACAlN,EAAAmN,EAAAxD,YAAAf,SAAAC,cAAA,SACAzH,UAAA,0DAGA,GAAA8K,GAAAviB,EAAA4B,GAAAyU,EAAA,aAAA,SAAAzX,GACAigB,EAAAze,EAAAxB,EAAAykB,EAAAhN,EADA,IAIAmN,CAZA,CA6BA,SAAArB,EAAAH,GACA,IAAAsB,EAAAtB,EAAAsB,SACAA,IAAAA,EAAA,SACA,IAAAG,EAAAxE,SAAAC,cAAA,OAOA,OANAuE,EAAAhM,UAAA,mDAAA6L,OACA,IAAAtB,EAAA0B,YACAD,EAAAE,UAAA3B,EAAA0B,YAEAD,EAAAzD,YAAAf,SAAA2E,eAAA5B,EAAA6B,UAEAJ,CAVA,CA6BA,SAAAK,EAAA1jB,GACA,IAAA+D,EAAA/D,EAAA+D,MAAA/C,KACA,GAAA+C,EAAA,CACA,IAAA4b,EAAA5b,EAAA4b,QAKAkB,EAAAlB,EAAAkB,gBAAA7gB,EAAA2jB,UAAA/jB,EAAAgkB,IAAA,EAAA,GAAA,QACA,GAAA/C,EACA,GAAAlB,EAAA2C,OAAAzB,EAAAyB,OA1BA,SAAAtiB,EAAA6gB,GACA,IAAA9c,EAAA/D,EAAA+D,MAAA/C,KACA6iB,IAAA9f,EAAAke,WACA,SAAA6B,IACAD,GAAA,EACA7jB,EAAAie,IAAA,SAAA6F,EAFA,CAIA9jB,EAAAwB,GAAA,SAAAsiB,GACAjD,EAAA7gB,EAAAoB,YAAA,SAAAugB,EAAAoC,GACA/jB,EAAAie,IAAA,SAAA6F,GACA/f,EAAAke,YAAA4B,IACAE,GAAApC,aAAA/hB,IAAA+hB,EAAAoC,GACA/jB,EAAA0d,WAAA,WAAAsG,EAAAhkB,EAAA2hB,EAAA,IAJA,GAKA5d,EAAA+c,cAAA9gB,EAbA,CA2BAikB,CAAAjkB,EAAA6gB,OACA,CACA,IAAAc,EAAAd,EAAA7gB,EAAAoB,WAAA2C,EAAA+c,cAAA9gB,GACA,IAAA2hB,EAAA,OACAA,EAAAuC,KAAAvC,EAAAuC,MAAA,SAAAC,GACAnkB,EAAA0d,WAAA,WAAAsG,EAAAhkB,EAAAmkB,EAAA,GADA,IAGAnkB,EAAA0d,WAAA,WAAAsG,EAAAhkB,EAAA2hB,EAAA,GANA,CAVA,CAFA,CAsBA,SAAAqC,EAAAhkB,EAAAokB,GACA,IAAArgB,EAAA/D,EAAA+D,MAAA/C,KACA,GAAA+C,EAAA,CACA,IAAA4b,EAAA5b,EAAA4b,QACA8C,EAAAziB,GAIA,IAFA,IAvEAZ,EAAAoe,EAuEAmE,EAlEA,SAAAA,GAEA,IADA,IAAA0C,EAAA,GACAhnB,EAAA,EAAAA,EAAAskB,EAAArkB,SAAAD,EAAA,CACA,IAAAukB,EAAAD,EAAAtkB,GAAAuI,EAAAgc,EAAAlf,KAAAkD,MACAye,EAAAze,KAAAye,EAAAze,GAAA,KAAAyI,KAAAuT,EAFA,CAIA,OAAAyC,CANA,CAkEAC,CAAAF,GAEAxe,EAAA,EAAAA,EAAA+b,EAAArkB,SAAAsI,EAAA,CACA,IAAA2e,EAAA5C,EAAA/b,GACA,GAAA2e,EAAA,CAKA,IAHA,IAAAC,EAAA,KACAC,EAAA1gB,EAAA4c,WAAA9B,SAAAiD,yBAEAzkB,EAAA,EAAAA,EAAAknB,EAAAjnB,SAAAD,EAAA,CACA,IAAAukB,EAAA2C,EAAAlnB,GACA6lB,EAAAtB,EAAAsB,SACAA,IAAAA,EAAA,SAnFA1F,EAoFA0F,EAAAsB,EAnFA,UADAplB,EAoFAolB,GAnFAplB,EACAoe,EAoFAmC,EAAA4C,mBAAAX,EAAAjC,EAAA4C,iBAAAX,IACA7d,EAAA4c,WAAA8D,EAAA7E,YAAAmC,EAAAH,IAEAA,EAAAjf,IAAAoB,EAAAkR,OAAA5G,KAAArO,EAAA0kB,SAAA9C,EAAAlf,KAAAkf,EAAAjf,GAAA,CACA0U,UAAA,6CAAA6L,EACArB,aAAAD,IAXA,CAcA7d,EAAA4c,WACA3gB,EAAA2kB,gBAAA/e,EAAAuY,EAAA6E,EAAAhjB,EAAAykB,EAAAD,EAAAD,EAAAjnB,OAAA,EACAqiB,EAAAwC,WAEAxC,EAAAuC,gBACAliB,EAAA2d,aAAA/X,EAAA,OAAAwY,EAAAoG,EAxBA,CAFA,CA4BA7E,EAAA6C,iBAAA7C,EAAA6C,gBAAA4B,EAAAzC,EAAA3hB,EAlCA,CAFA,CAuCA,SAAA4kB,EAAA5kB,GACA,IAAA+D,EAAA/D,EAAA+D,MAAA/C,KACA+C,IACA8gB,aAAA9gB,EAAAgd,SACAhd,EAAAgd,QAAAZ,YAAA,WAAAuD,EAAA1jB,EAAA,GAAA+D,EAAA4b,QAAAyC,OAJA,CA+BAxiB,EAAAke,aAAA,QAAA,GAAA,SAAA9d,EAAAmB,EAAA4c,GAUA,GATAA,GAAAA,GAAAne,EAAAoe,OACAyE,EAAAziB,IACA,IAAAA,EAAA+D,MAAA/C,KAAA2e,QAAA0C,cACAriB,EAAAie,IAAA,SAAA2G,GACAhlB,EAAAqe,IAAAje,EAAA+f,oBAAA,YAAA/f,EAAA+D,MAAA/C,KAAAggB,aACA6D,aAAA7kB,EAAA+D,MAAA/C,KAAA+f,gBACA/gB,EAAA+D,MAAA/C,MAGAG,EAAA,CAEA,IADA,IAAAF,EAAAjB,EAAAkd,UAAA,WAAA4H,GAAA,EACAznB,EAAA,EAAAA,EAAA4D,EAAA3D,SAAAD,EAAA4D,EAAA5D,IAAA8gB,IAAA2G,GAAA,GACA,IAAA/gB,EAAA/D,EAAA+D,MAAA/C,KAAA,IAAAyf,EAAAzgB,EAAAmB,EAAA2jB,GACA/gB,EAAA4b,QAAA0C,cACAriB,EAAAwB,GAAA,SAAAojB,GACA,GAAA7gB,EAAA4b,QAAAwC,UAAA,UAAApe,EAAA4b,QAAAwC,UACAviB,EAAA4B,GAAAxB,EAAA+f,oBAAA,YAAAhc,EAAAid,aAEA0C,EAAA1jB,EATA,CAVA,IAuBAJ,EAAAmlB,gBAAA,eAAA,WACArB,EAAA1X,KADA,GAlRA,EANA,UAAA3N,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WPo1EQ,EACA,CAAE,GAAM,KC91EhB,GAAA,CDi2EQ,SAAUZ,EAASU,EAAQD,GQ11EnC,IAAAgC,IAOA,SAAA7B,GACA,aAEAA,EAAA2c,eAAA,OAAA,QAAA,SAAAxa,GACA,IAAAijB,EAAA,GACA,IAAAlkB,OAAAmkB,SAIA,OAHAnkB,OAAAokB,SACApkB,OAAAokB,QAAAC,MAAA,2EAEAH,EAIA,IAAAC,EAAAnkB,OAAAmkB,SAAAra,QAAA9J,OAAAmkB,SACAA,EAAAG,WAAA,SAAAC,EAAAC,GACA,IAAAC,EAAAD,EAAAC,IACAP,EAAA3W,KAAA,CAAA3L,KAAA9C,EAAAgkB,IAAA2B,EAAAC,WAAA,EAAAD,EAAAE,cACA9iB,GAAA/C,EAAAgkB,IAAA2B,EAAAG,UAAA,EAAAH,EAAAI,aACAlC,QAAA4B,GAJA,EAMA,IAAAJ,EAAAW,MAAA7jB,EAAA,CACA,MAAAvD,GAAA,CACA,OAAAwmB,CAnBA,GAHA,EANA,UAAA3mB,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WRs3EQ,EACA,CAAE,GAAM,KCp4EhB,GAAA,CDu4EQ,SAAUZ,EAASU,EAAQD,GSl4EnC,IAAAgC,IAOA,SAAA7B,GACA,aAkBAA,EAAA2c,eAAA,OAAA,cAfA,SAAAxa,EAAA4d,GACA,IAAA7e,OAAA+kB,OAIA,OAHA/kB,OAAAokB,SACApkB,OAAAokB,QAAAC,MAAA,+EAEA,GAEAxF,EAAApa,SACAoa,EAAApa,OAAA,GACAsgB,OAAA9jB,EAAA4d,EAAAA,EAAAmG,SACA,IAAAC,EAAAF,OAAAG,OAAAD,OAAAvP,EAAA,GAEA,OADAuP,GAMA,SAAAA,EAAAE,GACA,IAAA,IAAA5oB,EAAA,EAAAA,EAAA0oB,EAAAzoB,OAAAD,IAAA,CACA,IAAA8nB,EAAAY,EAAA1oB,GACA,GAAA8nB,EAAA,CACA,GAAAA,EAAAvf,MAAA,EAAA,CACA9E,OAAAokB,SACApkB,OAAAokB,QAAAgB,KAAA,6CAAAf,EAAAvf,KAAA,IAAAuf,GAEA,QAJA,CAOA,IAAAhS,EAAAgS,EAAAgB,UAAA,EAAAzM,EAAAvG,EAAA,EACA,GAAAgS,EAAAiB,SAAA,CACA,IAAArS,EAAAoR,EAAAiB,SAAAC,UAAAlT,GAAAhO,OAAA,OACA4O,GAAA,IACA2F,GAAA3F,EAHA,CAQA,IAAAuS,EAAA,CACA7C,QAAA0B,EAAAoB,OACArD,SAAAiC,EAAA5lB,MAAA4lB,EAAA5lB,KAAAinB,WAAA,KAAA,UAAA,QACA9jB,KAAA9C,EAAAgkB,IAAAuB,EAAAvf,KAAA,EAAAuN,GACAxQ,GAAA/C,EAAAgkB,IAAAuB,EAAAvf,KAAA,EAAA8T,IAGAuM,EAAA5X,KAAAiY,EAxBA,CAFA,CADA,CANAG,CAAAV,EAAAvP,GACAA,CAZA,GAJA,EANA,UAAAnY,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WTk7EQ,EACA,CAAE,GAAM,KC97EhB,GAAA,CDi8EQ,SAAUZ,EAASU,EAAQD,GU17EnC,IAAAgC,IAOA,SAAA7B,EAAA8mB,GACA,aAEA,IAAAC,EAAA,CACA,qBAAA,EACA,kBAAA,EACA,4BAAA,EACA,iBAAA,EACA,YAAA,EACA,oBAAA,EACA,aAAA,EACA,iBAAA,EACA,uBAAA,GAGA/mB,EAAA2c,eAAA,OAAA,QAAA,SAAAxa,EAAA4d,GACA,IAAAqF,EAAA,GASA,GARA0B,IAAAA,EAAAE,SAEAF,OADA,IAAAA,EAAA,QACAA,EAAA,QAEAA,EAAAA,UAGAA,IAAAA,EAAA5lB,OAAA4lB,WACAA,EAIA,OAHA5lB,OAAAokB,SACApkB,OAAAokB,QAAAC,MAAA,kIAEAH,EAGA,IADA,IAAA6B,EAAAH,EAAAE,OAAA7kB,EAAA4d,GAAAA,EAAAmH,OAAAH,GACAtpB,EAAA,EAAAA,EAAAwpB,EAAAvpB,OAAAD,IAAA,CACA,IAAAomB,EAAAoD,EAAAxpB,GACA0pB,EAAAtD,EAAA7d,KAAA,EAAAohB,EAAAvD,EAAA7d,KAAA,EAAAqhB,EAAAxD,EAAAld,IAAA,EAAA2gB,EAAAzD,EAAAld,IACAye,EAAA3W,KAAA,CACA3L,KAAA9C,EAAAgkB,IAAAmD,EAAAE,GACAtkB,GAAA/C,EAAAgkB,IAAAoD,EAAAE,GACAzD,QAAAA,EAAAA,QACAP,SAAAO,EAAApZ,MAPA,CAUA,OAAA2a,CA3BA,GAfA,EANA,UAAA3mB,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,IAAAA,EAAA,MACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,uBAAA,YAAAvE,GAEAA,EAAA7B,WAAAkB,OAAA4lB,SV2+EQ,EACA,CACI,IAAO,IACP,GAAM,KC3/ElB,IAAA,CD+/EQ,SAAU1nB,EAASU,EAAQD,GW//EnC,IAAA0nB,EAAAC,EAAAD,EAIAnb,KAJAob,EAIA,WAAA,aAMA,IAAAC,EAAA,CAAA,EAEAC,EAAA,CAAA,EAEA3pB,OAAAC,eAAA0pB,EAAA,aAAA,CAAAxQ,OAAA,IAVA,IAWAyQ,EAAA,WACA,SAAAA,IAAAzqB,gBAAAkP,KAAAub,GACAvb,KAAAwb,WAAA,CAAA,EACAxb,KAAAyb,cAAAzb,KAAA0b,QAAA,gBACA1b,KAAA2b,WAAA,GACA3b,KAAA4b,UAAA,IAJA,CADA,OAAA7pB,aAAAwpB,EAAA,CAAA,CAAAzpB,IAAA,UAAAgZ,MAOA,SAAAuO,GAGA,IAFA,IAAAwC,EAAA,CAAA,EACAC,EAAAzC,EAAA0C,MAAA,KACA1qB,EAAA,EAAAA,EAAAyqB,EAAAxqB,OAAAD,IACAwqB,EAAAC,EAAAzqB,KAAA,EAEA,OAAAwqB,CANA,GAPA,CAAA/pB,IAAA,QAAAgZ,MAeA,SAAAvV,GAAA,IAKAU,EACA+lB,EAEAzlB,EACA0lB,EAEAC,EAGAnmB,EAdAomB,EAAAnc,KACAoc,EAAApc,KAAAyb,cACAY,EAAA,2JACAC,EAAA,8FACAC,EAAA,SAGAC,EAAA,EAGAC,EAAA,KAEAC,EAAA,GACAC,EAAA,EAEAC,EAAA,EACAhjB,EAAA,EACAijB,EAAA7c,KAAA2b,WACA3b,KAAA8c,KAAA,QAAA,CACA7U,IAAA,EACArO,KAAA,EACAW,IAAA,IAyBA,IAvBA,IACAwiB,EAMAC,EAAA,SAAA3e,EAAA4e,EAAAhV,EAAA+R,GACA,IAAAzf,EAAA0N,EAAA2U,EAAA,EAUA,SATAnX,IAAAuU,IACAA,EAAA,CAAA,GAEAA,EAAAiD,IAAAA,EACAjD,EAAA/R,IAAAA,EACA+R,EAAApgB,KAAAA,EACAogB,EAAAzf,IAAAA,EACAsiB,EAAAxa,KAAA2X,GACAmC,EAAAW,KAAAze,EAAA2b,GACAuC,EAAAlmB,KAAA4mB,IACArjB,IACAgjB,EAAA3U,EAAAsU,EAAAC,SAbA,EAgBAvmB,EAAAomB,EAAAhmB,KAAAd,IAYA,IAXAymB,EAAA/lB,EAAA8R,OACAyU,IACAzmB,EAAAR,EAAA8kB,UAAAmC,EAAAR,GACAS,EACAC,EAAAra,KAAAtM,GAGAinB,EAAA,OAAAjnB,EAAAymB,IAGAA,EAAAH,EAAAG,YACAjmB,EAAAN,EAAA,MACAwmB,GAAAlmB,IAAAkmB,IAEAO,EAAA,QADAjnB,EAAA2mB,EAAAQ,KAAA,IACAP,EAAA,CACApmB,QAAAkmB,EACAU,MAAAjB,IAEAO,EAAA,KACAP,OAAAzW,EACAiX,EAAA,IAEAD,GAOA,GAAAA,EACAC,EAAAra,KAAApM,EAAA,SAGA,GAAAM,EAAAN,EAAA,GAAA,CACAgmB,EAAA,GAIA,IAHA,IAAAkB,EAAAlnB,EAAA,GACAmnB,OAAA,EACAC,EAAA,EACAD,EAAAd,EAAAjmB,KAAA8mB,IAAA,CACA,IAAA9lB,EAAA+lB,EAAA,GACAhe,EAAAge,EAAA,GACAA,EAAA,GACAA,EAAA,GACAA,EAAA,GACA,GACAtS,EAAAsS,EAAA,GACAA,EAAA,GACAA,EAAA,GACAA,EAAA,GACAA,EAAA,GACAA,EAAA,GACA,GACAnB,EAAA5Z,KAAA,CACAhL,KAAAA,EACAyT,MAAAA,EACA1L,MAAAA,EACA2I,MAAAqV,EAAArV,MACAkV,IAAAG,EAAA,KAEAC,GAAAD,EAAA,GAAA9rB,MArBA,CAuBA+rB,IAAAF,EAAA7rB,QACA0rB,EAAA,WAAA/mB,EAAA,GAAA+lB,EAAA,CACAzlB,QAAAA,EACA4mB,MAAAlB,EACA/iB,MAAAjD,EAAA,KAxFA8mB,WAAAd,EAAA3mB,MAAA,SAAAU,GAAA,MAAA,SAAAA,EAAAqB,IAAA,KAAA,CACAyT,MAAA,IAEAsR,EAAA7lB,KACA,IAAAwmB,EAAAjS,MAAAjD,QAAA,sBAuFA4U,EAAAlmB,EACA2lB,EAAAD,EAAAqB,SACAZ,EAAA,GACAC,EAAAH,IAIAQ,EAAA,OAAA/mB,EAAA,GAAA+lB,EA1CA,MA6CA/lB,EAAA,IAAAA,EAAA,KACA+mB,EAAA,UAAA/mB,EAAA,GAAA+lB,EAAA,CACAxZ,QAAAvM,EAAA,IAAAA,EAAA,GACAsnB,OAAAtnB,EAAA,UA1DA+mB,EAAA,SAAA/mB,EAAA,GAAA+lB,EAAA,CACAzlB,QAAAA,IA8DAhB,EAAAjE,OAAAkrB,GAEAQ,EAAA,OADAjnB,EAAAR,EAAA8kB,UAAAmC,EAAAjnB,EAAAjE,QACAkrB,GAEAxc,KAAA8c,KAAA,MAAA,CACA7U,IAAAuU,EACA5iB,KAAAA,EACAW,IAAAhF,EAAAjE,OAAAsrB,EAAA,GA5IA,GAfA,CAAA9qB,IAAA,cAAAgZ,MA8JA,SAAA0S,EAAAC,GAIA,IAHA,IAEApf,EAFAmd,EAAAxb,KAAAwb,WACAkC,EAAAF,EAAAzB,MAAA,SAEA1qB,EAAA,EAAAmC,EAAAkqB,EAAApsB,OAAAD,EAAAmC,EAAAnC,SAEAoU,IAAA+V,EADAnd,EAAAqf,EAAArsB,MAEAmqB,EAAAnd,GAAA,IAEAmd,EAAAnd,GAAAgE,KAAAob,EATA,GA9JA,CAAA3rB,IAAA,OAAAgZ,MA0KA,SAAAzM,EAAA2b,QACAvU,IAAAuU,IACAA,EAAA,CAAA,GAEAA,EAAA3b,KAAAA,EACA,IAAAsf,EAAA,GACAC,EAAA5d,KAAAwb,WAAAnd,GACAwf,EAAA7d,KAAAwb,WAAA,SACA/V,IAAAmY,IACAD,EAAAA,EAAAL,OAAAM,SAEAnY,IAAAoY,IACAF,EAAAA,EAAAL,OAAAO,IAEA,IAAAjC,EAAA5b,KAAA4b,UACA,OAAAA,WACAA,EAAA,UACA5B,EAAA4B,UAAAA,GAEA5b,KAAA4b,UAAA5B,EACA,IAAA,IAAA3oB,EAAA,EAAAmC,EAAAmqB,EAAArsB,OAAAD,EAAAmC,EAAAnC,IACAssB,EAAAtsB,GAAAsB,KAAAqN,KAAAga,EArBA,GA1KA,CAAAloB,IAAA,iBAAAgZ,MAkMA,SAAAzM,EAAAof,GACA,IAAAG,EAAA5d,KAAAwb,WAAAnd,GACA,QAAAoH,IAAAmY,EACA,IAAA,IAAAvsB,EAAA,EAAAmC,EAAAoqB,EAAAtsB,OAAAD,EAAAmC,EAAAnC,IACA,GAAAusB,EAAAvsB,KAAAosB,EAAA,CACAG,EAAAE,OAAAzsB,EAAA,GACA,KAFA,CAJA,GAlMA,CAAAS,IAAA,SAAAgZ,MA6MA,SAAAiT,EAAAhW,GACA,IAIAxN,EAHAyjB,EADAD,EAAAd,IAAAgB,OAAA,EAAAlW,GACAgU,MAAA,SACAmC,EAAAF,EAAA1sB,OAAA,EACAsI,EAAAmkB,EAAAnkB,KASA,OAPAskB,EAAA,GACAtkB,GAAAskB,EACA3jB,EAAAyjB,EAAAE,GAAA5sB,OAAA,GAGAiJ,EAAAwjB,EAAAxjB,IAAAwN,EAEA,CACAnO,KAAAA,EACAW,IAAAA,EAfA,GA7MA,CAAAzI,IAAA,cAAAgZ,MA+NA,SAAAmR,GAGA,IAFA,IACAjmB,EADAmoB,EAAA,CAAA,EAEA9sB,EAAA,EAAAmC,EAAAyoB,EAAA3qB,OAAAD,EAAAmC,EAAAnC,IAEA8sB,GADAnoB,EAAAimB,EAAA5qB,IACAgG,MAAArB,EAAA8U,MAEA,OAAAqT,CAPA,KA/NA5C,CAAA,CAAA,GAyOAD,EAAA,QAAAC,EAEA,IAAA6C,EAAA,CAAA,EAEAzsB,OAAAC,eAAAwsB,EAAA,aAAA,CAAAtT,OAAA,IAxPA,IAyPAuT,EAAA,WACA,SAAAA,EAAA9oB,EAAA+oB,GAAAxtB,gBAAAkP,KAAAqe,GACAre,KAAAzK,KAAAA,EACAyK,KAAAqY,MAAA9iB,EAAAwmB,MAAA,SACA,IAAA9lB,EAAA,QAAAI,KAAAd,GACAyK,KAAAue,MAAA,OAAAtoB,EAAAA,EAAA,GAAA3E,OAAA,EACA0O,KAAAse,QAAAA,EACAte,KAAA6a,SAAA,EANA,CADA,OAAA9oB,aAAAssB,EAAA,CAAA,CAAAvsB,IAAA,OAAAgZ,MASA,SAAA2M,EAAA7d,EAAAW,EAAAikB,EAAAvB,GACAjd,KAAAye,OAAA,OAAAhH,EAAA7d,EAAAW,EAAAikB,EAAAvB,EADA,GATA,CAAAnrB,IAAA,OAAAgZ,MAYA,SAAA2M,EAAA7d,EAAAW,EAAAikB,EAAAvB,GACAjd,KAAAye,OAAA,UAAAhH,EAAA7d,EAAAW,EAAAikB,EAAAvB,EADA,GAZA,CAAAnrB,IAAA,QAAAgZ,MAeA,SAAA2M,EAAA7d,EAAAW,EAAAikB,EAAAvB,GACAjd,KAAAye,OAAA,QAAAhH,EAAA7d,EAAAW,EAAAikB,EAAAvB,EADA,GAfA,CAAAnrB,IAAA,SAAAgZ,MAkBA,SAAAzM,EAAAoZ,EAAA7d,EAAAW,EAAAikB,EAAAvB,GAKA,IAJA,IAAA5E,EAAArY,KAAAqY,MACAkG,EAAAve,KAAAue,MACAnE,EAAA,GACAsE,EAAA,EACArtB,EAAAuI,EAAA,EAAAskB,EAAA7F,EAAA/mB,OAAAD,EAAA6sB,GAGA3jB,GADAmkB,GADAtE,EAAA/B,EAAAhnB,IACAC,SACAsI,EAAAskB,EAHA7sB,IAIAuI,IAEA,IADAW,GAAAmkB,KAEAnkB,GAAAgkB,GAOAve,KAAA6a,SAAAxY,KAAA,CACAhE,KAAAA,EACAoZ,QAAAA,EACAwF,IAAAA,EACA7C,SAAAA,EACAxgB,KAAAA,EACAW,IAAAA,EACAikB,KAAA,CACA3G,GAAA2G,EAAA3G,GACA8G,YAAAH,EAAAG,YACA5jB,KAAA,8CAAAuiB,OAAAkB,EAAA3G,MA7BA,KAlBAwG,CAAA,CAAA,GAoDAD,EAAA,QAAAC,EAEA,IAAAvD,EAAA,CAAA,EAEA8D,EAAA,CAAA,EAEAjtB,OAAAC,eAAAgtB,EAAA,aAAA,CAAA9T,OAAA,IACA8T,EAAA,QAAA,CACA/G,GAAA,cACA8G,YAAA,iIACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAU,EAAA9e,KACApB,EAAAmgB,YAAA,YAAA,SAAAhB,GACA,IAGAiB,EAHAzoB,EAAAwnB,EAAAxnB,QAAA6B,cACA+lB,EAAAvf,EAAAqgB,YAAAlB,EAAAZ,OACA5iB,EAAAwjB,EAAAxjB,IAAAhE,EAAAjF,OAAA,EAEA,QAAAiF,GAAA,QAAA4nB,GAGA,SAAA5nB,GAAA,SAAA4nB,GACA,UAAA5nB,GAAA,UAAA4nB,EAAA,QACA,QAAAA,GAAA,KAAAA,EAAA,MACAa,EAAA,SAAAzoB,EAAA,aAAA,oBACA6nB,EAAAlE,KAAA,wBAAAoD,OAAA0B,EAAA,uBAAAjB,EAAAnkB,KAAAW,EAAAukB,EAAAf,EAAAd,OANAmB,EAAAlE,KAAA,sDAAA6D,EAAAnkB,KAAAW,EAAAukB,EAAAf,EAAAd,IANA,GADA,GAoBA,IAAAiC,EAAA,CAAA,EAEAvtB,OAAAC,eAAAstB,EAAA,aAAA,CAAApU,OAAA,IACA,IAAAqU,EAAA,CACA,eACA,gBACA,gBACA,cACA,gBACA,cACA,WACA,WACA,gBACA,oBACA,mBACA,kBACA,WACA,4BACA,YACA,cACA,WACA,oBACA,gBACA,eACA,mBACA,YACA,aACA,WACA,eACA,oBACA,eACA,cACA,cACA,mBACA,YACA,aACA,SACA,WACA,UACA,UACA,UACA,SACA,aACA,sBACA,mBACA,eACA,YACA,YACA,YACA,gBACA,sBACA,iBACA,OACA,OACA,cACA,YACA,qBACA,mBACA,mBACA,mBACA,eACA,cACA,eACA,cACA,eACA,iBACA,cACA,UACA,UACA,aACA,UACA,aACA,mBACA,mBACA,cAuBAD,EAAA,QAAA,CACArH,GAAA,iBACA8G,YAAA,4CACAE,KAAA,SAAAjgB,EAAAwf,EAAAzK,GAAA,IAAAyL,EAAApf,KACAqf,GAAAC,MAAAC,QAAA5L,GAAAA,EAAA,IAAA2J,OAAA6B,GACAvgB,EAAAmgB,YAAA,YAAA,SAAAhB,GAIA,IAHA,IACA/nB,EADAmnB,EAAAY,EAAAZ,MAEA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EAHAkuB,EAAA,WAMA,IAAAC,GADAzpB,EAAAmnB,EAAA9rB,IACAgG,KACAgoB,EAAA/pB,MAAA,SAAAuV,GAAA,OAjCA,SAAAC,EAAA4U,GACA,GAAAA,aAAAvpB,OACA,QAAAupB,EAAAxnB,KAAA4S,IACA,CAAA7U,MAAA6U,EAAAW,QAAAiU,GAGA,IAAAC,EAAAD,EAAA,GACAE,EAAAF,EAAAA,EAAApuB,OAAA,GACAuuB,EAAAH,EAAAA,EAAApuB,OAAA,GACAwuB,EAAA,MAAAH,IACA,MAAAC,GACA,MAAAC,GAAA,MAAAD,GAEA,OAAAE,EADAA,GAAA,MAAAF,EAGA,IAAAzpB,OAAAupB,EAAAxY,MAAA,GAAA,GAAA,KAAAhP,KAAA4S,GACA,IAAA3U,OAAAupB,EAAAxY,MAAA,GAAA,IAAAhP,KAAA4S,GAGAA,IAAA4U,CAnBA,CAiCAK,CAAAN,EAAA5U,EAAA,KACA4U,IAAAA,EAAArnB,eACAgmB,EAAAjF,MAAA,2BAAAmE,OAAAmC,EAAA,4BAAA1B,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAAqX,EAAAppB,EAAAinB,IALA,EAAA5rB,EAAA,EAAAmC,EAAA2pB,EAAA7rB,OAAAD,EAAAmC,EAAAnC,IAAAmuB,GAJA,GAFA,GAkBA,IAAAQ,EAAA,CAAA,EAEAruB,OAAAC,eAAAouB,EAAA,aAAA,CAAAlV,OAAA,IACAkV,EAAA,QAAA,CACAnI,GAAA,cACA8G,YAAA,0CACAE,KAAA,SAAAjgB,EAAAwf,GAeA,IAfA,IAAA6B,EAAAjgB,KACAkgB,EAAA,CAAA,EACAC,EAAA,CACA,QACA,KACA,OACA,MACA,MACA,OACA,OACA,QACA,QACA,MACA,QAEA9uB,EAAA,EAAAA,EAAA8uB,EAAA7uB,OAAAD,IACA6uB,EAAAC,EAAA9uB,IAAAA,EAEAuN,EAAAmgB,YAAA,YAAA,SAAAhB,GAGA,IAFA,IAAAZ,EAAAY,EAAAZ,MACAiD,EAAA,GACA/uB,EAAA,EAAAA,EAAA8rB,EAAA7rB,OAAAD,IACA+uB,EAAA/d,KAAA8a,EAAA9rB,GAAAgG,MAEA,IAAAgpB,EAAAC,KAAAC,UAAAH,GACAA,EAAAI,MAAA,SAAAptB,EAAAoe,GACA,OAAA/L,MAAAya,EAAA9sB,IAAAqS,MAAAya,EAAA1O,GACA,EAEA/L,MAAAya,EAAA9sB,GACA,EAEAqS,MAAAya,EAAA1O,IACA,EAEA0O,EAAA9sB,GAAA8sB,EAAA1O,IAAApe,EAAAqtB,cAAAjP,EAVA,IAYA6O,IAAAC,KAAAC,UAAAH,IACAhC,EAAAjF,MAAA,oBAAAmE,OAAA+C,EAAA,4BAAA/C,OAAAgD,KAAAC,UAAAH,GAAA,KAAArC,EAAAnkB,KAAAmkB,EAAAxjB,IAAA0lB,EAAAlC,EAAAd,IApBA,GAlBA,GA4CA,IAAAyD,EAAA,CAAA,EAEA/uB,OAAAC,eAAA8uB,EAAA,aAAA,CAAA5V,OAAA,IACA4V,EAAA,QAAA,CACA7I,GAAA,sBACA8G,YAAA,6CACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAuC,EAAA3gB,KACApB,EAAAmgB,YAAA,YAAA,SAAAhB,GAMA,IALA,IACA/nB,EACAypB,EAFAtC,EAAAY,EAAAZ,MAGA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EACAsvB,EAAA,CAAA,EACAvvB,EAAA,EAAAmC,EAAA2pB,EAAA7rB,OAAAD,EAAAmC,EAAAnC,KAGA,IAAAuvB,EADAnB,GADAzpB,EAAAmnB,EAAA9rB,IACAgG,OAEA+mB,EAAAjF,MAAA,iCAAAmE,OAAAtnB,EAAAqB,KAAA,iBAAA0mB,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAA4Y,EAAA3qB,EAAAinB,KAEA2D,EAAAnB,IAAA,CAZA,GADA,GAmBA,IAAAoB,EAAA,CAAA,EAEAlvB,OAAAC,eAAAivB,EAAA,aAAA,CAAA/V,OAAA,IACA+V,EAAA,QAAA,CACAhJ,GAAA,oBACA8G,YAAA,gDACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAA0C,EAAA9gB,KACApB,EAAAmgB,YAAA,YAAA,SAAAhB,GAMA,IALA,IACA/nB,EAGAC,EAJAknB,EAAAY,EAAAZ,MAEA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EACAyvB,EAAA,uJAEA1vB,EAAA,EAAAmC,EAAA2pB,EAAA7rB,OAAAD,EAAAmC,EAAAnC,IAGA,GAFA2E,EAAAmnB,EAAA9rB,GAEA,QADA4E,EAAA8qB,EAAA1qB,KAAAL,EAAA8U,QACA,CACA,IAAAkW,EAAAC,OAAAhrB,EAAA,IACAirB,QAAA,KAAA,OACAA,QAAA,IAAA,OACA9C,EAAAlE,KAAA,4BAAAoD,OAAAtnB,EAAAqB,KAAA,uCAAAimB,OAAA0D,EAAA,OAAAjD,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAA+Y,EAAA9qB,EAAAinB,IAJA,CATA,GADA,GAqBA,IAAAkE,EAAA,CAAA,EAEAxvB,OAAAC,eAAAuvB,EAAA,aAAA,CAAArW,OAAA,IACAqW,EAAA,QAAA,CACAtJ,GAAA,2BACA8G,YAAA,6CACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAgD,EAAAphB,KACApB,EAAAmgB,YAAA,YAAA,SAAAhB,GAIA,IAHA,IACA/nB,EADAmnB,EAAAY,EAAAZ,MAEA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EACAD,EAAA,EAAAmC,EAAA2pB,EAAA7rB,OAAAD,EAAAmC,EAAAnC,KAEA,MADA2E,EAAAmnB,EAAA9rB,IACAyZ,OAAA,MAAA9U,EAAAoJ,OACA,KAAApJ,EAAA8U,OAAA,MAAA9U,EAAAoJ,QACAgf,EAAAjF,MAAA,4BAAAmE,OAAAtnB,EAAAqB,KAAA,gCAAA0mB,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAAqZ,EAAAprB,EAAAinB,IARA,GADA,GAgBA,IAAAoE,EAAA,CAAA,EAEA1vB,OAAAC,eAAAyvB,EAAA,aAAA,CAAAvW,OAAA,IACAuW,EAAA,QAAA,CACAxJ,GAAA,uBACA8G,YAAA,mCACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAkD,EAAAthB,KACApB,EAAAmgB,YAAA,YAAA,SAAAhB,GAIA,IAHA,IACA/nB,EADAmnB,EAAAY,EAAAZ,MAEA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EACAD,EAAA,EAAAmC,EAAA2pB,EAAA7rB,OAAAD,EAAAmC,EAAAnC,IAEA,MADA2E,EAAAmnB,EAAA9rB,IACA+N,OAAA,KAAApJ,EAAA8U,OACAsT,EAAAlE,KAAA,mBAAAoD,OAAAtnB,EAAAqB,KAAA,yBAAA0mB,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAAuZ,EAAAtrB,EAAAinB,IAPA,GADA,GAeA,IAAAsE,EAAA,CAAA,EAEA5vB,OAAAC,eAAA2vB,EAAA,aAAA,CAAAzW,OAAA,IACAyW,EAAA,QAAA,CACA1J,GAAA,2BACA8G,YAAA,6CACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAoD,EAAAxhB,KACApB,EAAAmgB,YAAA,YAAA,SAAAhB,GAIA,IAHA,IACA/nB,EADAmnB,EAAAY,EAAAZ,MAEA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EACAD,EAAA,EAAAmC,EAAA2pB,EAAA7rB,OAAAD,EAAAmC,EAAAnC,KAEA,MADA2E,EAAAmnB,EAAA9rB,IACAyZ,OAAA,MAAA9U,EAAAoJ,OACA,KAAApJ,EAAA8U,OAAA,MAAA9U,EAAAoJ,QACAgf,EAAAjF,MAAA,4BAAAmE,OAAAtnB,EAAAqB,KAAA,gCAAA0mB,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAAyZ,EAAAxrB,EAAAinB,IARA,GADA,GAgBA,IAAAwE,EAAA,CAAA,EAEA9vB,OAAAC,eAAA6vB,EAAA,aAAA,CAAA3W,OAAA,IACA2W,EAAA,QAAA,CACA5J,GAAA,kBACA8G,YAAA,iGACAE,KAAA,SAAAjgB,EAAAwf,EAAAzK,GAAA,IAAA+N,EAAA1hB,KACAqf,EAAAC,MAAAC,QAAA5L,GACAA,EACA,GACA/U,EAAAmgB,YAAA,YAAA,SAAAhB,GACA,IACA/nB,EADAmnB,EAAAY,EAAAZ,MAEA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EACA6rB,EAAAwE,SAAA,SAAAC,GACA5rB,EAAA4rB,EACA,IAAAnC,EAAAmC,EAAAvqB,MACA,IAAAgoB,EAAAxX,QAAA4X,KAGAmC,EAAA9W,MAAA+W,SAAAD,EAAA9W,OACAsT,EAAAjF,MAAA,uBAAAmE,OAAAmC,EAAA,oDAAA1B,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAA2Z,EAAA1rB,EAAAinB,KAEA2E,EAAA9W,MAAAoW,QAAA,WAAA,MAAAU,EAAA9W,OACAsT,EAAAjF,MAAA,uBAAAmE,OAAAmC,EAAA,2CAAA1B,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAA2Z,EAAA1rB,EAAAinB,KAVA,GAJA,GAJA,GAyBA,IAAA6E,EAAA,CAAA,EAEAnwB,OAAAC,eAAAkwB,EAAA,aAAA,CAAAhX,OAAA,IACAgX,EAAA,QAAA,CACAjK,GAAA,gBACA8G,YAAA,kCACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAA2D,EAAA/hB,KAYApB,EAAAmgB,YAAA,OAXA,SAAAiD,EAAAjE,GACA,UAAAA,EAAA1f,MACA,SAAA0f,EAAA1f,MAAA,QAAAnG,KAAA6lB,EAAAd,QAGA,YAAAc,EAAA1f,OAAA,IAAA0f,EAAA,OACA,IAAA,eAAA7lB,KAAA6lB,EAAAvb,WACA4b,EAAAjF,MAAA,kCAAA4E,EAAAnkB,KAAAmkB,EAAAxjB,IAAAwnB,EAAAhE,EAAAd,KAEAre,EAAAqjB,eAAA,MAAAD,GATA,GADA,GAgBA,IAAAE,EAAA,CAAA,EAEAvwB,OAAAC,eAAAswB,EAAA,aAAA,CAAApX,OAAA,IACAoX,EAAA,QAAA,CACArK,GAAA,gBACA8G,YAAA,0CACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAA+D,EAAAniB,KACAoiB,EAAA,SAAArE,IACA,IAAAA,EAAA,MACA,iBAAAA,EAAAvb,QAAApK,eACAgmB,EAAAlE,KAAA,0CAAA6D,EAAAnkB,KAAAmkB,EAAAxjB,IAAA4nB,EAAApE,EAAAd,IAHA,EAUAre,EAAAmgB,YAAA,MAAAqD,GACAxjB,EAAAmgB,YAAA,YALA,SAAAsD,IACAzjB,EAAAqjB,eAAA,UAAAG,GACAxjB,EAAAqjB,eAAA,WAAAI,EAFA,GAPA,GAgBA,IAAAC,EAAA,CAAA,EAEA3wB,OAAAC,eAAA0wB,EAAA,aAAA,CAAAxX,OAAA,IACAwX,EAAA,QAAA,CACAzK,GAAA,uBACA8G,YAAA,mDACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAmE,EAAAviB,KACAwiB,EAAA,gDACAC,GAAA,EACAJ,EAAA,SAAAtE,GACA,IACA1f,EADAO,EAAAqgB,YAAAlB,EAAAZ,OACA9e,KACA9H,EAAAwnB,EAAAxnB,QAAA6B,cACA,SAAA7B,IACAksB,GAAA,IAEA,IAAAA,GACA,WAAAlsB,GACA8H,IAAA,IAAAmkB,EAAAtqB,KAAAmG,IACA+f,EAAAlE,KAAA,mDAAA6D,EAAAnkB,KAAAmkB,EAAAxjB,IAAAgoB,EAAAxE,EAAAd,IAVA,EAmBAre,EAAAmgB,YAAA,WAAAsD,GACAzjB,EAAAmgB,YAAA,UAPA,SAAA2D,EAAA3E,GACA,SAAAA,EAAAxnB,QAAA6B,gBACAwG,EAAAqjB,eAAA,WAAAI,GACAzjB,EAAAqjB,eAAA,SAAAS,GAHA,GAhBA,GA2BA,IAAAC,EAAA,CAAA,EAEAhxB,OAAAC,eAAA+wB,EAAA,aAAA,CAAA7X,OAAA,IACA6X,EAAA,QAAA,CACA9K,GAAA,kBACA8G,YAAA,yDACAE,KAAA,SAAAjgB,EAAAwf,EAAAzK,GAAA,IAAAiP,EAAA5iB,KACA6iB,EAAA,QAAAlP,EAAA,WAAA,WACA/U,EAAAmgB,YAAA,YAAA,SAAAhB,GAIA,IAHA,IACA/nB,EADAmnB,EAAAY,EAAAZ,MAEA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EACAD,EAAA,EAAAmC,EAAA2pB,EAAA7rB,OAAAD,EAAAmC,EAAAnC,IAEA,GAAA,UADA2E,EAAAmnB,EAAA9rB,IACAgG,KAAA,EACA,aAAAwrB,IAAA,IAAA,SAAA3qB,KAAAlC,EAAA8U,QACA,aAAA+X,IACA,IAAA,eAAA3qB,KAAAlC,EAAA8U,SACAsT,EAAAlE,KAAA,qCAAAoD,OAAAtnB,EAAA8U,MAAA,eAAAwS,OAAAuF,EAAA,KAAA9E,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAA6a,EAAA5sB,EAAAinB,KAEA,KANA,CANA,GAFA,GAqBA,IAAA6F,EAAA,CAAA,EAEAnxB,OAAAC,eAAAkxB,EAAA,aAAA,CAAAhY,OAAA,IACA,IAEAiY,EAAA,oBAAAzF,OADA,4IACA,KAAAA,OAFA,sFAEA,KAIA0F,EAAA,gBAAA1F,OADA,oBACA,yBAKA2F,EAAA,+BAAA3F,OADA,6CACA,kCACA4F,EAAA,IAAA5F,OAAA2F,EAAA,MAAA3F,OAHA,yBAGA,MAAA,KAAAA,OAJA,kCAKA,MADA,KAAAA,OALA,mDAOA,MAFA,KAAAA,OAGA0F,EAAA,MAHA,KAAA1F,OATA,uCAaA,MACA,IACA6F,EAAA,IAAA7F,OAAAyF,EAAA,KAAAzF,OAAA4F,EAAA,KAAA5F,OAdA,wCAcA,KACAwF,EAAA,QAAA,CACAjL,GAAA,oBACA8G,YAAA,+EACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAgF,EAAApjB,KACApB,EAAAmgB,YAAA,YAAA,SAAAhB,GACA,IAAAxnB,EAAAwnB,EAAAxnB,QAAA6B,cACA+lB,EAAAvf,EAAAqgB,YAAAlB,EAAAZ,OACA5iB,EAAAwjB,EAAAxjB,IAAAhE,EAAAjF,OAAA,EACA+xB,EAAA,IAAAltB,OAAAgtB,EAAA,KACA,SAAA5sB,IACA,SAAA4nB,EACAA,EAAA,KAGAkF,EAAAnrB,KAAAimB,EAAA,OACAC,EAAAlE,KAAA,oEAAA6D,EAAAnkB,KAAAW,EAAA6oB,EAAArF,EAAAd,KAHAmB,EAAAlE,KAAA,0DAAA6D,EAAAnkB,KAAAW,EAAA6oB,EAAArF,EAAAd,KAOAmB,EAAAlE,KAAA,wDAAA6D,EAAAnkB,KAAAW,EAAA6oB,EAAArF,EAAAd,KAfA,GADA,GAuBA,IAAAqG,EAAA,CAAA,EAEA3xB,OAAAC,eAAA0xB,EAAA,aAAA,CAAAxY,OAAA,IACAwY,EAAA,QAAA,CACAzL,GAAA,uBACA8G,YAAA,iGACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAmF,EAAAvjB,KACApB,EAAAmgB,YAAA,YAAA,SAAAhB,GAKA,IAJA,IACA/nB,EACAypB,EAFAtC,EAAAY,EAAAZ,MAGA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EACAD,EAAA,EAAAmC,EAAA2pB,EAAA7rB,OAAAD,EAAAmC,EAAAnC,IAEAouB,GADAzpB,EAAAmnB,EAAA9rB,IACAgG,KACA,gBAAAa,KAAAunB,IACA,sBAAAvnB,KAAAlC,EAAA8U,QACAsT,EAAAlE,KAAA,0BAAAoD,OAAAmC,EAAA,+BAAA1B,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAAwb,EAAAvtB,EAAAinB,IAVA,GADA,GAmBA,IAAAuG,EAAA,CAAA,EAEA7xB,OAAAC,eAAA4xB,EAAA,aAAA,CAAA1Y,OAAA,IACA0Y,EAAA,QAAA,CACA3L,GAAA,iBACA8G,YAAA,mEACAE,KAAA,SAAAjgB,EAAAwf,EAAAzK,GAAA,IAeA6K,EAfAiF,EAAAzjB,KAsBA,GAAA,WAAA3N,QALAmsB,EADA,iBAAA7K,EAfA,CACA+P,UAAA,CACAC,MAAA,yBACAlM,QAAA,sFAEAmM,KAAA,CACAD,MAAA,yBACAlM,QAAA,+EAEAoM,KAAA,CACAF,MAAA,wCACAlM,QAAA,qEAKA9D,GAGAA,IAEA6K,EAAAmF,MAAA,CACA,IAAAA,EAAAnF,EAAAmF,MACAlM,EAAA+G,EAAA/G,QACAkM,aAAAxtB,SACAwtB,EAAA,IAAAxtB,OAAAwtB,IAEA/kB,EAAAmgB,YAAA,YAAA,SAAAhB,GAIA,IAHA,IACA/nB,EADAmnB,EAAAY,EAAAZ,MAEA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EACAD,EAAA,EAAAyyB,EAAA3G,EAAA7rB,OAAAD,EAAAyyB,EAAAzyB,IAOA,GALA,QADA2E,EAAAmnB,EAAA9rB,IACAgG,KAAAe,gBACA,IAAAurB,EAAAzrB,KAAAlC,EAAA8U,QACAsT,EAAAlE,KAAAzC,EAAAsG,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAA0b,EAAAztB,EAAAinB,KAGA,UAAAjnB,EAAAqB,KAAAe,cAGA,IAFA,IAAA2rB,EAAA/tB,EAAA8U,MAAAiR,MAAA,QACAiI,OAAA,EACAC,EAAA,EAAAC,EAAAH,EAAAzyB,OAAA2yB,EAAAC,EAAAD,KACAD,EAAAD,EAAAE,MACA,IAAAN,EAAAzrB,KAAA8rB,IACA5F,EAAAlE,KAAAzC,EAAAsG,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAA0b,EAAAO,EAjBA,GANA,CAtBA,GAuDA,IAAAG,EAAA,CAAA,EAEAxyB,OAAAC,eAAAuyB,EAAA,aAAA,CAAArZ,OAAA,IACAqZ,EAAA,QAAA,CACAtM,GAAA,YACA8G,YAAA,6CACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAgG,EAAApkB,KACAqkB,EAAA,CAAA,EACAzlB,EAAAmgB,YAAA,YAAA,SAAAhB,GAKA,IAJA,IACA/nB,EACA6hB,EAFAsF,EAAAY,EAAAZ,MAGA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EACAD,EAAA,EAAAmC,EAAA2pB,EAAA7rB,OAAAD,EAAAmC,EAAAnC,IAEA,GAAA,QADA2E,EAAAmnB,EAAA9rB,IACAgG,KAAAe,cAAA,EACAyf,EAAA7hB,EAAA8U,cAEArF,IAAA4e,EAAAxM,GACAwM,EAAAxM,GAAA,EAGAwM,EAAAxM,KAEAwM,EAAAxM,GAAA,GACAuG,EAAAjF,MAAA,kBAAAmE,OAAAzF,EAAA,sBAAAkG,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAAqc,EAAApuB,EAAAinB,MAGA,KAbA,CAPA,GAFA,GA6BA,IAAAqH,EAAA,CAAA,EAEA3yB,OAAAC,eAAA0yB,EAAA,aAAA,CAAAxZ,OAAA,IACAwZ,EAAA,QAAA,CACAzM,GAAA,yBACA8G,YAAA,gCACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAmG,EAAAvkB,KACApB,EAAAmgB,YAAA,YAAA,SAAAhB,GAMA,IALA,IACA/nB,EAEAypB,EAHAtC,EAAAY,EAAAZ,MAEA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EAEAkzB,EAAA,oLACAnzB,EAAA,EAAAmC,EAAA2pB,EAAA7rB,OAAAD,EAAAmC,EAAAnC,IAEAouB,GADAzpB,EAAAmnB,EAAA9rB,IACAgG,KAAAe,eACA,IAAAosB,EAAAtsB,KAAAunB,GACArB,EAAAlE,KAAA,mBAAAoD,OAAAtnB,EAAAinB,IAAA,sBAAAc,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAAwc,EAAAvuB,EAAAinB,KAEA,QAAAwC,GAAA,SAAAA,GACA,mBAAAvnB,KAAAlC,EAAA8U,QACAsT,EAAAlE,KAAA,mBAAAoD,OAAAtnB,EAAAinB,IAAA,sBAAAc,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAAwc,EAAAvuB,EAAAinB,IAdA,GADA,GAuBA,IAAAwH,EAAA,CAAA,EAEA9yB,OAAAC,eAAA6yB,EAAA,aAAA,CAAA3Z,OAAA,IACA2Z,EAAA,QAAA,CACA5M,GAAA,wBACA8G,YAAA,+BACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAsG,EAAA1kB,KACApB,EAAAmgB,YAAA,YAAA,SAAAhB,GAIA,IAHA,IACA/nB,EADAmnB,EAAAY,EAAAZ,MAEA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EACAD,EAAA,EAAAmC,EAAA2pB,EAAA7rB,OAAAD,EAAAmC,EAAAnC,IAEA,WADA2E,EAAAmnB,EAAA9rB,IACAgG,KAAAe,eACAgmB,EAAAlE,KAAA,kBAAAoD,OAAAtnB,EAAAinB,IAAA,sBAAAc,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAA2c,EAAA1uB,EAAAinB,IAPA,GADA,GAeA,IAAA0H,EAAA,CAAA,EAEAhzB,OAAAC,eAAA+yB,EAAA,aAAA,CAAA7Z,OAAA,IACA6Z,EAAA,QAAA,CACA9M,GAAA,uBACA8G,YAAA,+DACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAwG,EAAA5kB,KACA6kB,EAAA,GACAC,EAAA,GACAlmB,EAAAmgB,YAAA,YAAA,SAAAhB,GACA,IAAAxnB,EAAAwnB,EAAAxnB,QAAA6B,cACA+lB,EAAAvf,EAAAqgB,YAAAlB,EAAAZ,OACA5iB,EAAAwjB,EAAAxjB,IAAAhE,EAAAjF,OAAA,EACA,UAAAiF,GACA,WAAA4nB,EAAA,MACA2G,EAAAziB,KAAA,CAAA0b,MAAAA,EAAAxjB,IAAAA,EAAAsd,GAAAsG,EAAA,KAGA,UAAA5nB,GACA,QAAA4nB,GAAA,KAAAA,EAAA,KACA0G,EAAAxiB,KAAA,CAAA0b,MAAAA,EAAAxjB,IAAAA,EAAAwqB,SAAA5G,EAAA,KAXA,IAeAvf,EAAAmgB,YAAA,OAAA,WACA+F,EAAAnD,SAAA,SAAAqD,IAMA,SAAAA,GACA,IAAAhM,GAAA,EAMA,OALA6L,EAAAlD,SAAA,SAAAsD,GACAD,EAAAnN,IAAAmN,EAAAnN,KAAAoN,EAAAF,WACA/L,GAAA,EAFA,IAKAA,CAPA,EALAkM,CAAAF,IACA5G,EAAAlE,KAAA,mCAAA8K,EAAAjH,MAAAnkB,KAAAorB,EAAAzqB,IAAAqqB,EAAAI,EAAAjH,MAAAd,IAFA,GADA,GAlBA,GAqCA,IAAAkI,EAAA,CAAA,EAEAxzB,OAAAC,eAAAuzB,EAAA,aAAA,CAAAra,OAAA,IACAqa,EAAA,QAAA,CACAtN,GAAA,kBACA8G,YAAA,mCACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAgH,EAAAplB,KACApB,EAAAmgB,YAAA,YAAA,SAAAhB,GACA,WAAAA,EAAAxnB,QAAA6B,eACAgmB,EAAAjF,MAAA,mCAAA4E,EAAAnkB,KAAAmkB,EAAAxjB,IAAA6qB,EAAArH,EAAAd,IAFA,GADA,GASA,IAAAoI,EAAA,CAAA,EAEA1zB,OAAAC,eAAAyzB,EAAA,aAAA,CAAAva,OAAA,IACAua,EAAA,QAAA,CACAxN,GAAA,2BACA8G,YAAA,8CACAE,KAAA,SAAAjgB,EAAAwf,EAAAzK,GAAA,IAAA2R,EAAAtlB,KACAulB,EAAA,QACAC,EAAA,KACA,GAAA,iBAAA7R,EAAA,CACA,IAAA1d,EAAA,kBAAAI,KAAAsd,GACA1d,IACAsvB,EAAAtvB,EAAA,GACAuvB,EAAAvvB,EAAA,IAAAwvB,SAAAxvB,EAAA,GAAA,IAJA,CAOA2I,EAAAmgB,YAAA,QAAA,SAAAhB,GAIA,IAHA,IAEA9nB,EAFAgnB,EAAAc,EAAAd,IACAyI,EAAA,qBAEAzvB,EAAAyvB,EAAArvB,KAAA4mB,IAAA,CACA,IAAA0I,EAAA/mB,EAAAgnB,OAAA7H,EAAA9nB,EAAA8R,MAAA9R,EAAA,GAAA3E,QACA,GAAA,IAAAq0B,EAAAprB,IAAA,CAGA,IAAAsrB,EAAA5vB,EAAA,GACA,UAAAsvB,EACAC,GACA,IAAA,OAAAttB,KAAA2tB,IACAA,EAAAv0B,OAAAk0B,GAAA,GACApH,EAAAlE,KAAA,6CAAAoD,OAAAkI,EAAA,YAAAG,EAAA/rB,KAAA,EAAA0rB,EAAAvH,EAAAd,MAIA,IAAA,OAAA/kB,KAAA2tB,IACAzH,EAAAlE,KAAA,oCAAAyL,EAAA/rB,KAAA,EAAA0rB,EAAAvH,EAAAd,KAIA,QAAAsI,IAAA,IAAA,QAAArtB,KAAA2tB,GACAzH,EAAAlE,KAAA,kCAAAyL,EAAA/rB,KAAA,EAAA0rB,EAAAvH,EAAAd,MAEA,IAAA,YAAA/kB,KAAA2tB,IACAzH,EAAAlE,KAAA,8CAAAyL,EAAA/rB,KAAA,EAAA0rB,EAAAvH,EAAAd,IArBA,CAFA,CAJA,GAVA,GA4CA,IAAA6I,EAAA,CAAA,EAEAn0B,OAAAC,eAAAk0B,EAAA,aAAA,CAAAhb,OAAA,IACAgb,EAAA,QAAA,CACAjO,GAAA,mBACA8G,YAAA,sCACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAA2H,EAAA/lB,KACApB,EAAAmgB,YAAA,QAAA,SAAAhB,GAIA,IAHA,IAEA9nB,EAFAgnB,EAAAc,EAAAd,IACA+I,EAAA,iBAEA/vB,EAAA+vB,EAAA3vB,KAAA4mB,IAAA,CACA,IAAA0I,EAAA/mB,EAAAgnB,OAAA7H,EAAA9nB,EAAA8R,OACAqW,EAAAjF,MAAA,0CAAAmE,OAAArnB,EAAA,GAAA,OAAA0vB,EAAA/rB,KAAA+rB,EAAAprB,IAAAwrB,EAAAhI,EAAAd,IAFA,CAJA,GADA,GAaA,IAAAgJ,EAAA,CAAA,EAEAt0B,OAAAC,eAAAq0B,EAAA,aAAA,CAAAnb,OAAA,IACAmb,EAAA,QAAA,CACApO,GAAA,gBACA8G,YAAA,8DACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAA8H,EAAAlmB,KACApB,EAAAmgB,YAAA,YAAA,SAAAhB,GAKA,IAJA,IAEA/nB,EAFAO,EAAAwnB,EAAAxnB,QACA4mB,EAAAY,EAAAZ,MAEA5iB,EAAAwjB,EAAAxjB,IAAAhE,EAAAjF,OAAA,EACAD,EAAA,EAAAmC,EAAA2pB,EAAA7rB,OAAAD,EAAAmC,EAAAnC,IACA2E,EAAAmnB,EAAA9rB,KACA,IAAA,sCAAA6G,KAAA3B,IACA,QAAAP,EAAAqB,MACA,SAAAd,GAAA,SAAAP,EAAAqB,MACA,WAAAd,GAAA,SAAAP,EAAAqB,OACA,KAAArB,EAAA8U,OACAsT,EAAAjF,MAAA,mBAAAmE,OAAAtnB,EAAAqB,KAAA,oBAAAimB,OAAA/mB,EAAA,yBAAAwnB,EAAAnkB,KAAAW,EAAAvE,EAAA+R,MAAAme,EAAAlwB,EAAAinB,IAZA,GADA,GAoBA,IAAAkJ,EAAA,CAAA,EAEAx0B,OAAAC,eAAAu0B,EAAA,aAAA,CAAArb,OAAA,IACAqb,EAAA,QAAA,CACAtO,GAAA,iBACA8G,YAAA,+BACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAgI,EAAApmB,KACApB,EAAAmgB,YAAA,YAAA,SAAAhB,GACA,UAAAA,EAAAxnB,QAAA6B,eACAgmB,EAAAlE,KAAA,kCAAA6D,EAAAnkB,KAAAmkB,EAAAxjB,IAAA6rB,EAAArI,EAAAd,IAFA,GADA,GASA,IAAAoJ,EAAA,CAAA,EAEA10B,OAAAC,eAAAy0B,EAAA,aAAA,CAAAvb,OAAA,IACAub,EAAA,QAAA,CACAxO,GAAA,WACA8G,YAAA,sBACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAkI,EAAAtmB,KACAumB,EAAA,GACAC,EAAA5nB,EAAA8c,QAAA,8GACA9c,EAAAmgB,YAAA,YAAA,SAAAhB,GACA,IAAAxnB,EAAAwnB,EAAAxnB,QAAA6B,mBACAqN,IAAA+gB,EAAAjwB,IAAAwnB,EAAA7kB,OACAqtB,EAAAlkB,KAAA,CACA9L,QAAAA,EACAqD,KAAAmkB,EAAAnkB,KACAqjB,IAAAc,EAAAd,KANA,IAUAre,EAAAmgB,YAAA,UAAA,SAAAhB,GACA,IACA9V,EADA1R,EAAAwnB,EAAAxnB,QAAA6B,cAEA,IAAA6P,EAAAse,EAAAj1B,OAAA,EAAA2W,GAAA,GACAse,EAAAte,GAAA1R,UAAAA,EADA0R,KAKA,GAAAA,GAAA,EAAA,CAEA,IADA,IAAAwe,EAAA,GACAp1B,EAAAk1B,EAAAj1B,OAAA,EAAAD,EAAA4W,EAAA5W,IACAo1B,EAAApkB,KAAA,KAAAib,OAAAiJ,EAAAl1B,GAAAkF,QAAA,MAEA,GAAAkwB,EAAAn1B,OAAA,EAAA,CACA,IAAAsqB,EAAA2K,EAAAA,EAAAj1B,OAAA,GACA8sB,EAAAjF,MAAA,kCAAAmE,OAAAmJ,EAAAvJ,KAAA,IAAA,iCAAAI,OAAA1B,EAAAqB,IAAA,eAAAK,OAAA1B,EAAAhiB,KAAA,KAAAmkB,EAAAnkB,KAAAmkB,EAAAxjB,IAAA+rB,EAAAvI,EAAAd,IAFA,CAIAsJ,EAAAj1B,OAAA2W,CATA,MAYAmW,EAAAjF,MAAA,uCAAAmE,OAAAS,EAAAd,IAAA,MAAAc,EAAAnkB,KAAAmkB,EAAAxjB,IAAA+rB,EAAAvI,EAAAd,IApBA,IAuBAre,EAAAmgB,YAAA,OAAA,SAAAhB,GAEA,IADA,IAAA0I,EAAA,GACAp1B,EAAAk1B,EAAAj1B,OAAA,EAAAD,GAAA,EAAAA,IACAo1B,EAAApkB,KAAA,KAAAib,OAAAiJ,EAAAl1B,GAAAkF,QAAA,MAEA,GAAAkwB,EAAAn1B,OAAA,EAAA,CACA,IAAAsqB,EAAA2K,EAAAA,EAAAj1B,OAAA,GACA8sB,EAAAjF,MAAA,kCAAAmE,OAAAmJ,EAAAvJ,KAAA,IAAA,gCAAAI,OAAA1B,EAAAqB,IAAA,eAAAK,OAAA1B,EAAAhiB,KAAA,KAAAmkB,EAAAnkB,KAAAmkB,EAAAxjB,IAAA+rB,EAAA,GAFA,CALA,GApCA,GAiDA,IAAAI,EAAA,CAAA,EAEA/0B,OAAAC,eAAA80B,EAAA,aAAA,CAAA5b,OAAA,IACA4b,EAAA,QAAA,CACA7O,GAAA,iBACA8G,YAAA,kCACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAuI,EAAA3mB,KACAwmB,EAAA5nB,EAAA8c,QAAA,sHACA9c,EAAAmgB,YAAA,YAAA,SAAAhB,GACA,IAAAxnB,EAAAwnB,EAAAxnB,QAAA6B,mBACAqN,IAAA+gB,EAAAjwB,KACAwnB,EAAA7kB,OACAklB,EAAAlE,KAAA,qBAAAoD,OAAA/mB,EAAA,2BAAAwnB,EAAAnkB,KAAAmkB,EAAAxjB,IAAAosB,EAAA5I,EAAAd,KAJA,GAFA,GAaA,IAAA2J,EAAA,CAAA,EAEAj1B,OAAAC,eAAAg1B,EAAA,aAAA,CAAA9b,OAAA,IACA8b,EAAA,QAAA,CACA/O,GAAA,4BACA8G,YAAA,8CACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAyI,EAAA7mB,KACAwmB,EAAA5nB,EAAA8c,QAAA,sHACA9c,EAAAmgB,YAAA,YAAA,SAAAhB,GACA,IAAAxnB,EAAAwnB,EAAAxnB,QAAA6B,mBACAqN,IAAA+gB,EAAAjwB,IACAwnB,EAAA7kB,OACAklB,EAAAjF,MAAA,qBAAAmE,OAAA/mB,EAAA,uCAAAwnB,EAAAnkB,KAAAmkB,EAAAxjB,IAAAssB,EAAA9I,EAAAd,IAJA,GAFA,GAaA,IAAA6J,EAAA,CAAA,EAEAn1B,OAAAC,eAAAk1B,EAAA,aAAA,CAAAhc,OAAA,IACAgc,EAAA,QAAA,CACAjP,GAAA,oBACA8G,YAAA,+CACAE,KAAA,SAAAjgB,EAAAwf,EAAAzK,GAAA,IAAAoT,EAAA/mB,KACAqf,EAAAC,MAAAC,QAAA5L,GACAA,EACA,GACA/U,EAAAmgB,YAAA,mBAAA,SAAAhB,GACA,IAAAxnB,EAAAwnB,EAAAxnB,SACA,IAAA8oB,EAAAxX,QAAAtR,IACAA,IAAAA,EAAA6B,eACAgmB,EAAAjF,MAAA,8BAAAmE,OAAA/mB,EAAA,4BAAAwnB,EAAAnkB,KAAAmkB,EAAAxjB,IAAAwsB,EAAAhJ,EAAAd,IAJA,GAJA,GAcA,IAAA+J,EAAA,CAAA,EAEAr1B,OAAAC,eAAAo1B,EAAA,aAAA,CAAAlc,OAAA,IACAkc,EAAA,QAAA,CACAnP,GAAA,uBACA8G,YAAA,0CACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAA6I,EAAAjnB,KACAknB,EAAA,mBACAtoB,EAAAmgB,YAAA,mBAAA,SAAAhB,GACA,IAAAxnB,EAAAwnB,EAAAxnB,QACA2wB,EAAAhvB,KAAA3B,IACA6nB,EAAAjF,MAAA,8BAAAmE,OAAA/mB,EAAA,kCAAAwnB,EAAAnkB,KAAAmkB,EAAAxjB,IAAA0sB,EAAAlJ,EAAAd,IAHA,GAFA,GAWA,IAAAkK,EAAA,CAAA,EAEAx1B,OAAAC,eAAAu1B,EAAA,aAAA,CAAArc,OAAA,IACAqc,EAAA,QAAA,CACAtP,GAAA,gBACA8G,YAAA,yCACAE,KAAA,SAAAjgB,EAAAwf,GAAA,IAAAgJ,EAAApnB,KACAqnB,GAAA,EACAC,GAAA,EACAjF,EAAA,SAAAtE,GACA,IAAAxnB,EAAAwnB,EAAAxnB,QAAA6B,cACA,SAAA7B,EACA8wB,GAAA,EAEA,UAAA9wB,GAAA8wB,IACAC,GAAA,EANA,EA0BA1oB,EAAAmgB,YAAA,WAAAsD,GACAzjB,EAAAmgB,YAAA,UAlBA,SAAA2D,EAAA3E,GACA,IAAAxnB,EAAAwnB,EAAAxnB,QAAA6B,cACA,GAAAkvB,GAAA,UAAA/wB,EAAA,CACA,IAAAqlB,EAAAmC,EAAAnC,WACA,SAAAA,EAAAvd,MACA,SAAAud,EAAAvd,OAAA,IAAA,QAAAnG,KAAA0jB,EAAAqB,OACAmB,EAAAjF,MAAA,qCAAA4E,EAAAnkB,KAAAmkB,EAAAxjB,IAAA6sB,EAAArJ,EAAAd,IAJA,KAOA,SAAA1mB,KACA,IAAA+wB,GACAlJ,EAAAjF,MAAA,yCAAA4E,EAAAnkB,KAAAmkB,EAAAxjB,IAAA6sB,EAAArJ,EAAAd,KAEAre,EAAAqjB,eAAA,WAAAI,GACAzjB,EAAAqjB,eAAA,SAAAS,GAdA,GAZA,GAkCA,IAAA6E,EAAA,CAAA,EAEA51B,OAAAC,eAAA21B,EAAA,aAAA,CAAAzc,OAAA,IACA,IAAA0c,EAAA,CACAp0B,EAAA,CACAq0B,aAAA,EACAC,cAAA,CAAA,OAAA,SACAC,eAAA,CAAA,QAEAlrB,IAAA,CACAgrB,aAAA,GAEAG,KAAA,CACAH,aAAA,EACAE,eAAA,CAAA,SAEApqB,IAAA,CACAkqB,aAAA,EACAE,eAAA,CAAA,SAEAhyB,OAAA,CACAkyB,cAAA,CACA,CAAA,QAAA,SACA,CAAA,QAAA,WAGAjtB,IAAA,CACA6sB,aAAA,EACAC,cAAA,CAAA,MAAA,MAAA,WAGAH,EAAA,QAAA,CACA1P,GAAA,aACA8G,YAAA,oBACAE,KAAA,SAAAjgB,EAAAwf,EAAAzK,GAAA,IAAAmU,EAAA9nB,KACAwnB,EAAA71B,OAAAo2B,OAAAp2B,OAAAo2B,OAAA,CAAA,EAAAP,GAAA7T,GACA/U,EAAAmgB,YAAA,YAAA,SAAAhB,GACA,IAAAZ,EAAAY,EAAAZ,MACA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EACAiF,EAAAwnB,EAAAxnB,QAAA6B,cACA,GAAAovB,EAAAjxB,GAAA,CACA,IAAAyxB,EAAAR,EAAAjxB,IACA,IAAAyxB,EAAAP,aAAA1J,EAAA7kB,OAGA,IAAA8uB,EAAAP,aAAA1J,EAAA7kB,OACAklB,EAAAlE,KAAA,QAAAoD,OAAA/mB,EAAA,kCAAAwnB,EAAAnkB,KAAAmkB,EAAAxjB,IAAAutB,EAAA/J,EAAAd,KAHAmB,EAAAlE,KAAA,QAAAoD,OAAA/mB,EAAA,8BAAAwnB,EAAAnkB,KAAAmkB,EAAAxjB,IAAAutB,EAAA/J,EAAAd,KAKAqC,MAAAC,QAAAyI,EAAAN,gBACAM,EAAAN,cACA/F,SAAA,SAAA9J,GACA,GAAAyH,MAAAC,QAAA1H,GAAA,CACA,IAAAoQ,EAAApQ,EAAAqQ,KAAA,SAAA90B,GAAA,OAAAA,CAAA,IACA+0B,EAAAF,EAAAG,QACAC,EAAAJ,EACA9K,EAAAmL,MAAA,SAAAtyB,GAAA,OAAAA,EAAAqB,OAAA8wB,CAAA,IACAhL,EAAAwE,SAAA,SAAA3rB,GACAA,EAAAqB,OAAA8wB,IACA,IAAAE,EAAAxgB,QAAA7R,EAAA8U,QACAsT,EAAAjF,MAAA,QAAAmE,OAAA/mB,EAAA,0BAAA+mB,OAAA6K,EAAA,yBAAA7K,OAAA+K,EAAAnL,KAAA,UAAA,MAAAa,EAAAnkB,KAAAW,EAAAutB,EAAA/J,EAAAd,IAHA,IAQAmB,EAAAjF,MAAA,QAAAmE,OAAA/mB,EAAA,0BAAA+mB,OAAA6K,EAAA,MAAApK,EAAAnkB,KAAAW,EAAAutB,EAAA/J,EAAAd,IAbA,MAgBAE,EAAAmL,MAAA,SAAAtyB,GAAA,OAAA,IAAA6hB,EAAAkE,MAAA,KAAAlU,QAAA7R,EAAAqB,KAAA,KACA+mB,EAAAjF,MAAA,QAAAmE,OAAA/mB,EAAA,0BAAA+mB,OAAAzF,EAAA,MAAAkG,EAAAnkB,KAAAW,EAAAutB,EAAA/J,EAAAd,IAlBA,IAsBAqC,MAAAC,QAAAyI,EAAAH,gBACAG,EAAAH,cACAlG,SAAA,SAAA9J,GACA,GAAAyH,MAAAC,QAAA1H,GAAA,CACA,IAAAoQ,EAAApQ,EAAAqQ,KAAA,SAAA90B,GAAA,OAAAA,CAAA,IACA+0B,EAAAF,EAAAG,QACAC,EAAAJ,EACA9K,EAAAmL,MAAA,SAAAtyB,GAAA,OAAAA,EAAAqB,OAAA8wB,CAAA,KACAhL,EAAAwE,SAAA,SAAA3rB,GACAA,EAAAqB,OAAA8wB,IACA,IAAAE,EAAAxgB,QAAA7R,EAAA8U,QACAsT,EAAAjF,MAAA,QAAAmE,OAAA/mB,EAAA,mCAAA+mB,OAAA6K,EAAA,yBAAA7K,OAAA+K,EAAAnL,KAAA,UAAA,MAAAa,EAAAnkB,KAAAW,EAAAutB,EAAA/J,EAAAd,IAHA,GALA,CADA,IAgBAqC,MAAAC,QAAAyI,EAAAL,iBACAK,EAAAL,eACAhG,SAAA,SAAAlC,GACAtC,EAAAmL,MAAA,SAAAtyB,GAAA,OAAAA,EAAAqB,OAAAooB,CAAA,KACArB,EAAAjF,MAAA,aAAAmE,OAAAmC,EAAA,wBAAAnC,OAAA/mB,EAAA,4BAAAwnB,EAAAnkB,KAAAW,EAAAutB,EAAA/J,EAAAd,IAFA,GApDA,CAJA,GAFA,GAqEA,IAj4CA7H,EAi4CAmT,EAAA,CAAA,EAgNA,OA9MA52B,OAAAC,eAAA22B,EAAA,aAAA,CAAAzd,OAAA,IACAyd,EAAA,QAAA,CACA1Q,GAAA,iCACA8G,YAAA,gDACAE,KAAA,SAAAjgB,EAAAwf,EAAAzK,GAAA,IAAA6U,EAAAxoB,KACAqf,EAAAC,MAAAC,QAAA5L,GAAAA,EAAA,GACA/U,EAAAmgB,YAAA,YAAA,SAAAhB,GAGA,IAFA,IAAAZ,EAAAY,EAAAZ,MACA5iB,EAAAwjB,EAAAxjB,IAAAwjB,EAAAxnB,QAAAjF,OAAA,EACAD,EAAA,EAAAA,EAAA8rB,EAAA7rB,OAAAD,IACA,IAAA,IAAAguB,EAAAxX,QAAAsV,EAAA9rB,GAAAgG,MAAA,CACA,IAAApB,EAAA,cAAAI,KAAA8mB,EAAA9rB,GAAA4rB,IAAA4E,SACA5rB,GAAA,IAAAA,EAAA,GAAA3E,QAAA,IAAA2E,EAAA,GAAA3E,QACA8sB,EAAAjF,MAAA,kBAAAmE,OAAAH,EAAA9rB,GAAAgG,KAAA,sDAAA0mB,EAAAnkB,KAAAW,EAAA4iB,EAAA9rB,GAAA0W,MAAAygB,EAAArL,EAAA9rB,GAAA4rB,IAHA,CAJA,GAFA,GAiBA,SAAAxpB,GACA9B,OAAAC,eAAA6B,EAAA,aAAA,CAAAqX,OAAA,IACArX,EAAA80B,4BAAA90B,EAAA8zB,UAAA9zB,EAAA0zB,aAAA1zB,EAAAg1B,oBAAAh1B,EAAAqzB,iBAAArzB,EAAAmzB,sBAAAnzB,EAAAizB,aAAAjzB,EAAA4yB,QAAA5yB,EAAA0yB,cAAA1yB,EAAAwyB,YAAAxyB,EAAAqyB,eAAAryB,EAAA4xB,sBAAA5xB,EAAA0xB,eAAA1xB,EAAAkxB,mBAAAlxB,EAAAgxB,oBAAAhxB,EAAA6wB,qBAAA7wB,EAAA0wB,SAAA1wB,EAAA+vB,aAAA/vB,EAAAi1B,kBAAAj1B,EAAAqvB,gBAAArvB,EAAAkvB,aAAAlvB,EAAA6uB,mBAAA7uB,EAAAk1B,aAAAl1B,EAAAquB,aAAAruB,EAAAguB,eAAAhuB,EAAA8tB,sBAAA9tB,EAAA4tB,kBAAA5tB,EAAA0tB,sBAAA1tB,EAAAotB,gBAAAptB,EAAAitB,kBAAAjtB,EAAAm1B,SAAAn1B,EAAAyrB,cAAAzrB,EAAAmrB,gBAAA,EACA,IAAAiK,EAAAjK,EACAjtB,OAAAC,eAAA6B,EAAA,aAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAA20B,EAAA,OAAA,IACA,IAAAC,EAAA5J,EACAvtB,OAAAC,eAAA6B,EAAA,gBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAA40B,EAAA,OAAA,IACA,IAAAC,EAAA/I,EACAruB,OAAAC,eAAA6B,EAAA,WAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAA60B,EAAA,OAAA,IACA,IAAAC,EAAAtI,EACA/uB,OAAAC,eAAA6B,EAAA,oBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAA80B,EAAA,OAAA,IACA,IAAAC,EAAApI,EACAlvB,OAAAC,eAAA6B,EAAA,kBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAA+0B,EAAA,OAAA,IACA,IAAAC,EAAA/H,EACAxvB,OAAAC,eAAA6B,EAAA,wBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAg1B,EAAA,OAAA,IACA,IAAAC,EAAA9H,EACA1vB,OAAAC,eAAA6B,EAAA,oBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAi1B,EAAA,OAAA,IACA,IAAAC,EAAA7H,EACA5vB,OAAAC,eAAA6B,EAAA,wBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAk1B,EAAA,OAAA,IACA,IAAAC,EAAA5H,EACA9vB,OAAAC,eAAA6B,EAAA,iBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAm1B,EAAA,OAAA,IACA,IAAAC,EAAAxH,EACAnwB,OAAAC,eAAA6B,EAAA,eAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAo1B,EAAA,OAAA,IACA,IAAAC,EAAArH,EACAvwB,OAAAC,eAAA6B,EAAA,eAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAq1B,EAAA,OAAA,IACA,IAAAC,EAAAlH,EACA3wB,OAAAC,eAAA6B,EAAA,qBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAs1B,EAAA,OAAA,IACA,IAAAC,EAAA9G,EACAhxB,OAAAC,eAAA6B,EAAA,eAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAu1B,EAAA,OAAA,IACA,IAAAC,EAAA5G,EACAnxB,OAAAC,eAAA6B,EAAA,kBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAw1B,EAAA,OAAA,IACA,IAAAC,EAAArG,EACA3xB,OAAAC,eAAA6B,EAAA,oBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAy1B,EAAA,OAAA,IACA,IAAAC,EAAApG,EACA7xB,OAAAC,eAAA6B,EAAA,eAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAA01B,EAAA,OAAA,IACA,IAAAC,EAAA1F,EACAxyB,OAAAC,eAAA6B,EAAA,WAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAA21B,EAAA,OAAA,IACA,IAAAC,EAAAxF,EACA3yB,OAAAC,eAAA6B,EAAA,uBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAA41B,EAAA,OAAA,IACA,IAAAC,EAAAtF,EACA9yB,OAAAC,eAAA6B,EAAA,sBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAA61B,EAAA,OAAA,IACA,IAAAC,EAAArF,EACAhzB,OAAAC,eAAA6B,EAAA,qBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAA81B,EAAA,OAAA,IACA,IAAAC,GAAA9E,EACAxzB,OAAAC,eAAA6B,EAAA,iBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAA+1B,GAAA,OAAA,IACA,IAAAC,GAAA7E,EACA1zB,OAAAC,eAAA6B,EAAA,wBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAg2B,GAAA,OAAA,IACA,IAAAC,GAAArE,EACAn0B,OAAAC,eAAA6B,EAAA,iBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAi2B,GAAA,OAAA,IACA,IAAAC,GAAAnE,EACAt0B,OAAAC,eAAA6B,EAAA,cAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAk2B,GAAA,OAAA,IACA,IAAAC,GAAAlE,EACAx0B,OAAAC,eAAA6B,EAAA,gBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAm2B,GAAA,OAAA,IACA,IAAAC,GAAAjE,EACA10B,OAAAC,eAAA6B,EAAA,UAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAo2B,GAAA,OAAA,IACA,IAAAC,GAAA7D,EACA/0B,OAAAC,eAAA6B,EAAA,eAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAq2B,GAAA,OAAA,IACA,IAAAC,GAAA5D,EACAj1B,OAAAC,eAAA6B,EAAA,wBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAs2B,GAAA,OAAA,IACA,IAAAC,GAAA3D,EACAn1B,OAAAC,eAAA6B,EAAA,mBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAu2B,GAAA,OAAA,IACA,IAAAC,GAAA1D,EACAr1B,OAAAC,eAAA6B,EAAA,sBAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAw2B,GAAA,OAAA,IACA,IAAAC,GAAAxD,EACAx1B,OAAAC,eAAA6B,EAAA,eAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAAy2B,GAAA,OAAA,IACA,IAAAC,GAAArD,EACA51B,OAAAC,eAAA6B,EAAA,YAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAA02B,GAAA,OAAA,IACA,IAAAC,GAAAtC,EACA52B,OAAAC,eAAA6B,EAAA,8BAAA,CAAAjC,YAAA,EAAA0C,IAAA,WAAA,OAAA22B,GAAA,OAAA,GApEA,CAAA,CAsEA/P,GAEA,SAAArnB,GACA9B,OAAAC,eAAA6B,EAAA,aAAA,CAAAqX,OAAA,IACArX,EAAA8nB,WAAA9nB,EAAA4qB,SAAA5qB,EAAAq3B,UAAAr3B,EAAAinB,cAAA,EACA,IAAAqQ,EAAAzP,EACA7nB,EAAA8nB,WAAAwP,EAAA,QACA,IAAAC,EAAA5M,EACA3qB,EAAA4qB,SAAA2M,EAAA,QACA,IAAAF,EAAAhQ,EACArnB,EAAAq3B,UAAAA,EARA,IASAG,EAAA,WACA,SAAAA,IAAAn6B,gBAAAkP,KAAAirB,GACAjrB,KAAA8a,MAAA,CAAA,EACA9a,KAAAkrB,eAAA,CACA,qBAAA,EACA,kBAAA,EACA,4BAAA,EACA,iBAAA,EACA,YAAA,EACA,oBAAA,EACA,aAAA,EACA,iBAAA,EACA,uBAAA,EACA,iBAAA,EAZA,CADA,OAAAn5B,aAAAk5B,EAAA,CAAA,CAAAn5B,IAAA,UAAAgZ,MAgBA,SAAA0T,GACAxe,KAAA8a,MAAA0D,EAAA3G,IAAA2G,CADA,GAhBA,CAAA1sB,IAAA,SAAAgZ,MAmBA,SAAAvV,GAAA,IAAA+oB,EAAA/U,UAAAjY,OAAA,QAAAmU,IAAA8D,UAAA,GAAAA,UAAA,GAAAvJ,KAAAkrB,eACA,IAAAv5B,OAAAw5B,KAAA7M,GAAAhtB,SACAgtB,EAAAte,KAAAkrB,gBAEA31B,EAAAA,EAAA2rB,QAAA,4CAAA,SAAAkK,EAAAC,GAMA,OALAA,EAAAnK,QAAA,6CAAA,SAAAkK,EAAAE,EAAAxgB,GAGA,OAFAwT,EAAAgN,UACA7lB,IAAAqF,GAAAA,EAAAxZ,OAAA,IAAAgvB,KAAA1G,MAAA9O,GACA,EAHA,IAKA,EANA,IAQA,IAGA0T,EAHA5f,EAAA,IAAAmsB,EAAA,QACA3M,EAAA,IAAA4M,EAAA,QAAAz1B,EAAA+oB,GACAxD,EAAA9a,KAAA8a,MAEA,IAAA,IAAAjD,KAAAyG,OAEA7Y,KADA+Y,EAAA1D,EAAAjD,MACA,IAAAyG,EAAAzG,IACA2G,EAAAK,KAAAjgB,EAAAwf,EAAAE,EAAAzG,IAIA,OADAjZ,EAAAgb,MAAArkB,GACA6oB,EAAAvD,QAvBA,GAnBA,CAAA/oB,IAAA,SAAAgZ,MA4CA,SAAAygB,GAAA,IAAA5X,EAAApK,UAAAjY,OAAA,QAAAmU,IAAA8D,UAAA,GAAAA,UAAA,GAAA,CAAA,EACAiiB,EAAA,GACAC,EAAA,CACAC,MAAA,GACAC,KAAA,GACAC,IAAA,GACAC,MAAA,IAEAlY,EAAA8X,SACAA,EAAAC,MAAA,QACAD,EAAAE,KAAA,QACAF,EAAAG,IAAA,QACAH,EAAAI,MAAA,SAEA,IAAAtyB,EAAAoa,EAAApa,QAAA,EA+BA,OA9BAgyB,EAAA5J,SAAA,SAAArH,GACA,IAEAF,EAAAE,EAAAF,SACAxgB,EAAA0gB,EAAA1gB,KACAW,EAAA+f,EAAA/f,IACAuxB,EAAA1R,EAAA9oB,OACAy6B,EAAAxxB,EAAAyxB,GAAAzxB,EANA,GAMA,EACA0xB,EAAA7R,EAAA9oB,OAAAiJ,EANAyxB,GAMAzxB,EANAyxB,GAMAF,EACAvxB,EAAAyxB,KACAC,GATA,GASA1xB,EAAA,GAEA6f,EAAAA,EAAA8G,QAAA,MAAA,KAAA7G,UAAA0R,EAAA,EAAAE,GACAF,EAAA,IACA3R,EAAA,MAAAkD,OAAAlD,GACA2R,GAAA,GAEAE,EAAAH,IACA1R,GAAA,OAEAoR,EAAAnpB,KAAA,GAAAib,OAAAmO,EAAAC,MAAAQ,EAAA3yB,GAAA,KAAA+jB,OAAA1jB,EAAA,MAAA0jB,OAAAmO,EAAAE,MAAArO,OAAAlD,GAAAkD,OAAAmO,EAAAI,QACA,IAAAM,EAAA5xB,EAAAwxB,EACA91B,EAAAmkB,EAAAC,UAAA,EAAA8R,GAAAl2B,MAAA,qBACA,OAAAA,IACAk2B,GAAAl2B,EAAA3E,QAEAk6B,EAAAnpB,KAAA,GAAAib,OAAAmO,EAAAC,MACAQ,EAAA3yB,GACA2yB,EAAA55B,OAAAsH,GAAAtI,OAAA,EAAA66B,GAFA,MAAA7O,OAEAmO,EAAAG,KAFAtO,OAEAhD,EAAA7C,QAFA,MAAA6F,OAEAhD,EAAAkE,KAAA3G,GAFA,KAAAyF,OAEAmO,EAAAI,OA5BA,IA8BAL,CA7CA,KA5CAP,CAAA,CAAA,GA4FA,SAAAiB,EAAAj5B,EAAAomB,GACA,OAAA,IAAAiG,MAAArsB,EAAA,GAAAiqB,KAAA7D,GAAA,IADA,CAGA5lB,EAAAinB,SAAA,IAAAuQ,EACAt5B,OAAAw5B,KAAAL,GAAAnJ,SAAA,SAAA7vB,GACA2B,EAAAinB,SAAA0R,QAAAtB,EAAAh5B,GADA,GAzGA,CAAA,CA6GAupB,IA7kDAjG,EA+kDAiG,IA9kDAjG,EAAAiX,YAAA16B,OAAAO,UAAAmG,eAAA1F,KAAAyiB,EAAA,WAAAA,EAAA,QAAAA,CAHA,EAHA,WAAA/iB,QAAAoB,SAAA,IAAAC,EAAAA,EAAAD,QAAA2nB,IACA,mBAAAphB,QAAAA,OAAAC,IAAAD,OAAAohB,IACAD,EAAA,oBAAAmR,WAAAA,WAAAnR,GAAAoR,MAAA7R,SAAAU,GXonIQ,EACA,CAAC,GCxnIT,GAAA,CD2nIQ,SAAUpoB,EAASU,EAAQD,GYpnInC,IAAAgC,IAOA,SAAA7B,GACA,aAEAA,EAAA2c,eAAA,OAAA,OAAA,SAAAxa,EAAA4d,GACA,IAAAqF,EAAA,GACA,IAAAlkB,OAAA03B,QAIA,OAHA13B,OAAAokB,SACApkB,OAAAokB,QAAAC,MAAA,yEAEAH,EAGA,IADA,IAAA6B,EAAA2R,QAAA5R,OAAA7kB,EAAA4d,GAAAkH,SAAApD,EAAA,KACApmB,EAAA,EAAAA,EAAAwpB,EAAAvpB,OAAAD,IAAA,CAEA,IAAA0pB,GADAtD,EAAAoD,EAAAxpB,IACAuI,KAAA,EAAAohB,EAAAvD,EAAA7d,KAAA,EAAAqhB,EAAAxD,EAAAld,IAAA,EAAA2gB,EAAAzD,EAAAld,IACAye,EAAA3W,KAAA,CACA3L,KAAA9C,EAAAgkB,IAAAmD,EAAAE,GACAtkB,GAAA/C,EAAAgkB,IAAAoD,EAAAE,GACAzD,QAAAA,EAAAA,QACAP,SAAAO,EAAApZ,MAPA,CAUA,OAAA2a,CAnBA,GAHA,EANA,UAAA3mB,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WZ8oIQ,EACA,CAAE,GAAM,KC5pIhB,GAAA,CD+pIQ,SAAUZ,EAASU,EAAQD,Ga1pInC,IAAAgC,IAOA,SAAA7B,GACA,aAEA,IACA64B,EAAA,yBAsCA,SAAAC,EAAA14B,EAAA2f,GASA,GARA3T,KAAAhM,GAAAA,EACAgM,KAAA2T,QAAAA,EACA3T,KAAA2sB,OAAA,KACA3sB,KAAAnM,SAAA,EACAmM,KAAA4sB,KAAA,EACA5sB,KAAA6sB,SAAA7sB,KAAAhM,GAAA84B,UAAA,SACA9sB,KAAA+sB,SAAA/sB,KAAAhM,GAAAg5B,QAAAhtB,KAAA6sB,SAAAjzB,MAAAtI,OAAA0O,KAAAhM,GAAAi5B,eAAA37B,OAEA0O,KAAA2T,QAAAuZ,uBAAA,CACA,IAAAX,EAAAvsB,KACAhM,EAAAwB,GAAA,iBAAAwK,KAAAmtB,aAAA,WAAAZ,EAAAa,gBAAA,EAFA,CATA,CAlCAx5B,EAAAy5B,SAAA,SAAAr5B,EAAAs5B,EAAA3Z,GACA,IAAA2Z,EAAA,OAAAt5B,EAAAq5B,SAAA1Z,GACAA,GAAAA,EAAA2C,QAAAgX,EAAAhX,OAAA,GACA,IAAAiX,EAAA,CAAAjT,KAAAgT,GACA,GAAA3Z,EAAA,IAAA,IAAAlV,KAAAkV,EAAA4Z,EAAA9uB,GAAAkV,EAAAlV,GACA,OAAAzK,EAAAq5B,SAAAE,EALA,EAQA35B,EAAAmlB,gBAAA,YAAA,SAAApF,GACAA,EAiIA,SAAA3f,EAAAiU,EAAA0L,GACA,IAAA6Z,EAAAx5B,EAAA2f,QAAA8Z,YACAC,EAAA,CAAA,EACA,IAAA,IAAAjvB,KAAAkvB,EAAAD,EAAAjvB,GAAAkvB,EAAAlvB,GACA,GAAA+uB,EAAA,IAAA,IAAA/uB,KAAA+uB,OACA/nB,IAAA+nB,EAAA/uB,KAAAivB,EAAAjvB,GAAA+uB,EAAA/uB,IACA,GAAAkV,EAAA,IAAA,IAAAlV,KAAAkV,OACAlO,IAAAkO,EAAAlV,KAAAivB,EAAAjvB,GAAAkV,EAAAlV,IAEA,OADAivB,EAAApT,KAAAsT,UAAAF,EAAApT,KAAAoT,EAAApT,KAAAsT,QAAA55B,EAAAiU,IACAylB,CATA,CAjIAG,CAAA7tB,KAAAA,KAAA8sB,UAAA,SAAAnZ,GACA,IAAAma,EAAA9tB,KAAAkS,iBACA,KAAA4b,EAAAx8B,OAAA,GAAA,CAIA,GAAA0O,KAAA+tB,oBAAA,CACA,IAAApa,EAAA2G,KAAA0T,kBAAA,OAEA,IAAA,IAAA38B,EAAA,EAAAA,EAAAy8B,EAAAx8B,OAAAD,IACA,GAAAy8B,EAAAz8B,GAAAggB,KAAAzX,MAAAk0B,EAAAz8B,GAAA+f,OAAAxX,KAAA,MAJA,CAOAoG,KAAAjI,MAAAk2B,kBAAAjuB,KAAAjI,MAAAk2B,iBAAA/0B,QACA,IAAAg1B,EAAAluB,KAAAjI,MAAAk2B,iBAAA,IAAAvB,EAAA1sB,KAAA2T,GACAua,EAAAva,QAAA2G,OAEA1mB,EAAAu6B,OAAAnuB,KAAA,kBAAAA,MACAkuB,EAAAE,QAAA,GAhBA,CAHA,IAsBAx6B,EAAAmlB,gBAAA,aAAA,WACA/Y,KAAAjI,MAAAk2B,kBAAAjuB,KAAAjI,MAAAk2B,iBAAA/0B,OADA,IAmBA,IAAAm1B,EAAAv5B,OAAAu5B,uBAAA,SAAAC,GACA,OAAAna,WAAAma,EAAA,IAAA,GADA,EAGAC,EAAAz5B,OAAAy5B,sBAAA1V,aAkGA,SAAA2V,EAAAN,GACA,MAAA,iBAAAA,EAAAA,EACAA,EAAAn4B,IAFA,CAgDA,SAAA04B,EAAAC,EAAAC,GACA,KAAAA,GAAAA,GAAAD,GAAA,CACA,GAAA,OAAAC,EAAAC,SAAAC,eAAAF,EAAApc,YAAAmc,EAAA,OAAAC,EACAA,EAAAA,EAAApc,UAFA,CADA,CAOA,SAAAuc,EAAAZ,EAAAlU,GACAha,KAAA6X,GAAA,eAAA7E,KAAA+b,MAAA/b,KAAAgc,OAAA,MACAhvB,KAAAkuB,WAAAA,EACAluB,KAAAga,KAAAA,EACAha,KAAAivB,QAAA,EACA,IAAAtC,EAAA3sB,KAAAhM,EAAAk6B,EAAAl6B,GACAuf,EAAAvf,EAAAk7B,gBAAA3b,cACA4b,EAAA5b,EAAAC,aAAAD,EAAA4b,aAEAC,EAAApvB,KAAAovB,MAAA7b,EAAAT,cAAA,MACAsc,EAAAC,aAAA,OAAA,WACAD,EAAAC,aAAA,gBAAA,QACAD,EAAAvX,GAAA7X,KAAA6X,GACA,IAAA1jB,EAAA+5B,EAAAl6B,GAAA2f,QAAAxf,MACAi7B,EAAA/jB,UAAA,oBAAAlX,EACA6L,KAAAsvB,aAAAtV,EAAAsV,cAAA,EAGA,IADA,IAAAC,EAAAvV,EAAAtQ,KACArY,EAAA,EAAAA,EAAAk+B,EAAAj+B,SAAAD,EAAA,CACA,IAAAihB,EAAA8c,EAAAxb,YAAAL,EAAAT,cAAA,OAAA7Z,EAAAs2B,EAAAl+B,GACAga,EAtOA,mBAsOAha,GAAA2O,KAAAsvB,aAAA,GAAA,IAAA7C,GACA,MAAAxzB,EAAAoS,YAAAA,EAAApS,EAAAoS,UAAA,IAAAA,GACAiH,EAAAjH,UAAAA,EACAha,GAAA2O,KAAAsvB,cAAAhd,EAAA+c,aAAA,gBAAA,QACA/c,EAAAuF,GAAA7X,KAAA6X,GAAA,IAAAxmB,EACAihB,EAAA+c,aAAA,OAAA,UACAp2B,EAAAu2B,OAAAv2B,EAAAu2B,OAAAld,EAAA0H,EAAA/gB,GACAqZ,EAAAsB,YAAAL,EAAAiE,eAAAve,EAAAw2B,aAAAjB,EAAAv1B,KACAqZ,EAAAod,OAAAr+B,CAVA,CAaA,IAAAs+B,EAAAzB,EAAAva,QAAAgc,WAAApc,EAAArH,KACAjE,EAAAjU,EAAA47B,aAAA1B,EAAAva,QAAAkc,cAAA7V,EAAAtjB,KAAA,MACA0c,EAAAnL,EAAAmL,KAAAzD,EAAA1H,EAAAsN,OAAAua,GAAA,EACAC,EAAA,EAAAC,EAAA,EACA,GAAAL,IAAApc,EAAArH,KAAA,CAEA,IACA+jB,GADA,IAAA,CAAA,WAAA,WAAA,SAAApoB,QAAAsnB,EAAAe,iBAAAP,GAAA5c,UACA4c,EAAAA,EAAAM,aACAE,EAAAF,EAAA9a,wBACAib,EAAA7c,EAAArH,KAAAiJ,wBACA4a,EAAAI,EAAA/c,KAAAgd,EAAAhd,KAAA6c,EAAAI,WACAL,EAAAG,EAAAxgB,IAAAygB,EAAAzgB,IAAAsgB,EAAAK,SAPA,CASAlB,EAAAx5B,MAAAwd,KAAAA,EAAA2c,EAAA,KACAX,EAAAx5B,MAAA+Z,IAAAA,EAAAqgB,EAAA,KAGA,IAAAO,EAAApB,EAAA1b,YAAAT,KAAAC,IAAAM,EAAArH,KAAAwH,YAAAH,EAAAid,gBAAA9c,aACA+c,EAAAtB,EAAAuB,aAAA1d,KAAAC,IAAAM,EAAArH,KAAAiH,aAAAI,EAAAid,gBAAArd,cACAwc,EAAA/b,YAAAwb,GACAp7B,EAAAk7B,gBAAAG,aAAA,oBAAA,QACAr7B,EAAAk7B,gBAAAG,aAAA,YAAArvB,KAAA6X,IACA7jB,EAAAk7B,gBAAAG,aAAA,wBAAArvB,KAAA6X,GAAA,IAAA7X,KAAAsvB,cAEA,IAIAqB,EAJAzb,EAAAgZ,EAAAva,QAAAid,cAAAxB,EAAAja,wBAAA,IAAA0b,QACAC,IAAA5C,EAAAva,QAAAod,qBAAA3B,EAAA4B,aAAA5B,EAAA6B,aAAA,EAOA,GAHA9c,YAAA,WAAAwc,EAAA38B,EAAAk9B,eAAA,IAEAhc,EAAAK,OAAAkb,EACA,EAAA,CACA,IAAAU,EAAAjc,EAAAK,OAAAL,EAAAvF,IAAAyhB,EAAAlc,EAAAvF,KAAA1H,EAAAsN,OAAAtN,EAAA0H,KAAA,EACA8gB,EAAAvb,EAAAvF,IAAAyhB,GACAD,EAAAC,IAAAhC,EAAAx5B,MAAAu7B,QAAAA,EAAAC,GAAA,MACAhC,EAAAx5B,MAAA+Z,KAAAA,EAAA1H,EAAA0H,IAAAwhB,GAAAnB,EAAA,KACAF,GAAA,GAEAV,EAAAx5B,MAAAu7B,OAAAV,EAAAvb,EAAAvF,IAAA,EAAA,IAPA,CAUA,IAuBA0hB,EAvBAC,EAAApc,EAAAG,MAAAkb,EASA,GARAO,IAAAQ,GAAAt9B,EAAAu9B,QAAAC,gBACAF,EAAA,IACApc,EAAAG,MAAAH,EAAA9B,KAAAmd,IACAnB,EAAAx5B,MAAA67B,MAAAlB,EAAA,EAAA,KACAe,GAAApc,EAAAG,MAAAH,EAAA9B,KAAAmd,GAEAnB,EAAAx5B,MAAAwd,MAAAA,EAAAJ,KAAAC,IAAAhL,EAAAmL,KAAAke,EAAAvB,EAAA,IAAA,MAEAe,EAAA,IAAA,IAAApe,EAAA0c,EAAAsC,WAAAhf,EAAAA,EAAAA,EAAAif,YACAjf,EAAA9c,MAAAg8B,aAAA59B,EAAAu9B,QAAAC,eAAA,KAEAx9B,EAAA69B,UAAA7xB,KAAA8xB,OAvIA,SAAA5D,EAAA6D,GACA,IAAAC,EAAA,CACAC,GAAA,WAAAF,EAAAG,WAAA,EAAA,EACAC,KAAA,WAAAJ,EAAAG,UAAA,EAAA,EACAE,OAAA,WAAAL,EAAAG,UAAA,EAAAH,EAAAM,YAAA,EAAA,EACAC,SAAA,WAAAP,EAAAG,UAAAH,EAAAM,WAAA,GAAA,EAAA,EACAE,KAAA,WAAAR,EAAAS,SAAA,EAAA,EACAC,IAAA,WAAAV,EAAAS,SAAAT,EAAAzgC,OAAA,EAAA,EACAohC,MAAAX,EAAAY,KACAC,IAAAb,EAAAY,KACAE,IAAAd,EAAA74B,OAGA,MAAAhB,KAAA46B,UAAAC,YAGAf,EAAA,UAAA,WAAAD,EAAAG,WAAA,EAAA,EACAF,EAAA,UAAA,WAAAD,EAAAG,UAAA,EAAA,GAGA,IAAAc,EAAA9E,EAAAva,QAAAsf,WACAC,EAAAF,EAAA,CAAA,EAAAhB,EACA,SAAAmB,EAAArhC,EAAAqD,GACA,IAAAi+B,EAEAA,EADA,iBAAAj+B,EACA,SAAAnB,GAAA,OAAAmB,EAAAnB,EAAA+9B,EAAA,EAEAC,EAAA35B,eAAAlD,GACA68B,EAAA78B,GAEAA,EACA+9B,EAAAphC,GAAAshC,CATA,CAWA,GAAAJ,EACA,IAAA,IAAAlhC,KAAAkhC,EAAAA,EAAA36B,eAAAvG,IACAqhC,EAAArhC,EAAAkhC,EAAAlhC,IACA,IAAAuhC,EAAAnF,EAAAva,QAAA2f,UACA,GAAAD,EACA,IAAA,IAAAvhC,KAAAuhC,EAAAA,EAAAh7B,eAAAvG,IACAqhC,EAAArhC,EAAAuhC,EAAAvhC,IACA,OAAAohC,CAxCA,CAuIAK,CAAArF,EAAA,CACAgE,UAAA,SAAAj/B,EAAAugC,GAAA7G,EAAA8G,aAAA9G,EAAA2C,aAAAr8B,EAAAugC,EAAA,EACAhB,SAAA,SAAAv/B,GAAA05B,EAAA8G,aAAAxgC,EAAA,EACAo/B,SAAA,WAAA,OAAA1F,EAAA+G,cAAA,EACApiC,OAAAi+B,EAAAj+B,OACA4H,MAAA,WAAAg1B,EAAAh1B,OAAA,EACAy5B,KAAA,WAAAhG,EAAAgG,MAAA,EACA3Y,KAAAA,KAGAkU,EAAAva,QAAAggB,iBAEA3/B,EAAAwB,GAAA,OAAAwK,KAAA4zB,OAAA,WAAAvC,EAAAld,YAAA,WAAA+Z,EAAAh1B,OAAA,GAAA,IAAA,GACAlF,EAAAwB,GAAA,QAAAwK,KAAA6zB,QAAA,WAAAhb,aAAAwY,EAAA,IAGAr9B,EAAAwB,GAAA,SAAAwK,KAAA8zB,SAAA,WACA,IAAAC,EAAA//B,EAAAk9B,gBAAA1D,EAAAx5B,EAAA+f,oBAAAoB,wBACAwb,IAAAA,EAAA38B,EAAAk9B,iBACA,IAAA8C,EAAArkB,EAAAghB,EAAAhhB,IAAAokB,EAAApkB,IACAskB,EAAAD,GAAA7E,EAAA+E,cAAA3gB,EAAAid,iBAAAjd,EAAArH,MAAAokB,WAEA,GADAR,IAAAmE,GAAA7E,EAAAjc,cACA8gB,GAAAzG,EAAA7d,KAAAskB,GAAAzG,EAAAjY,OAAA,OAAA2Y,EAAAh1B,QACAk2B,EAAAx5B,MAAA+Z,IAAAqkB,EAAA,KACA5E,EAAAx5B,MAAAwd,KAAAA,EAAAud,EAAAvd,KAAA2gB,EAAA3gB,KAAA,IARA,GAWAxf,EAAA4B,GAAA45B,EAAA,YAAA,SAAA58B,GACA,IAAAL,EAAAs8B,EAAAW,EAAA58B,EAAArB,QAAAqB,EAAAyiB,YACA9iB,GAAA,MAAAA,EAAAu9B,SAAA/C,EAAA8G,aAAAthC,EAAAu9B,QAAA/C,EAAAgG,OAFA,IAKA/+B,EAAA4B,GAAA45B,EAAA,SAAA,SAAA58B,GACA,IAAAL,EAAAs8B,EAAAW,EAAA58B,EAAArB,QAAAqB,EAAAyiB,YACA9iB,GAAA,MAAAA,EAAAu9B,SACA/C,EAAA8G,aAAAthC,EAAAu9B,QACAxB,EAAAva,QAAAwgB,uBAAAxH,EAAAgG,OAJA,IAQA/+B,EAAA4B,GAAA45B,EAAA,aAAA,WACAjb,YAAA,WAAAngB,EAAAogC,OAAA,GAAA,GADA,IAKA,IAAAC,EAAAr0B,KAAAs0B,uBAMA,OALA,IAAAD,EAAA39B,MAAA,IAAA29B,EAAA19B,IACAqJ,KAAAu0B,iBAGA3gC,EAAAu6B,OAAAnU,EAAA,SAAAuV,EAAAvvB,KAAAsvB,cAAAF,EAAAoF,WAAAx0B,KAAAsvB,gBACA,CAxIA,CA2NA,SAAAmF,EAAAna,EAAAtmB,EAAA2f,EAAA+gB,GACA,GAAApa,EAAAhE,MACAgE,EAAAtmB,EAAA0gC,EAAA/gB,OACA,CACA,IAAAnJ,EAAA8P,EAAAtmB,EAAA2f,GACAnJ,GAAAA,EAAA0N,KAAA1N,EAAA0N,KAAAwc,GACAA,EAAAlqB,EAHA,CAHA,CAlXAkiB,EAAAx6B,UAAA,CACAgH,MAAA,WACA8G,KAAAgR,WACAhR,KAAAhM,GAAA+D,MAAAk2B,iBAAA,KACAjuB,KAAA4sB,KAAA,KACA5sB,KAAA2T,QAAAuZ,wBACAltB,KAAAhM,GAAAie,IAAA,iBAAAjS,KAAAmtB,cAGAntB,KAAA2sB,QAAA3sB,KAAAga,MAAApmB,EAAAu6B,OAAAnuB,KAAAga,KAAA,SACAha,KAAA2sB,QAAA3sB,KAAA2sB,OAAAzzB,QACAtF,EAAAu6B,OAAAnuB,KAAAhM,GAAA,gBAAAgM,KAAAhM,IAVA,EAaAgd,OAAA,WACA,OAAAhR,KAAAhM,GAAA+D,MAAAk2B,kBAAAjuB,IADA,EAIA2yB,KAAA,SAAA3Y,EAAA3oB,GACA,IAAA68B,EAAAlU,EAAAtQ,KAAArY,GAAAk7B,EAAAvsB,KACAA,KAAAhM,GAAA0d,WAAA,WACAwc,EAAA5T,KACA4T,EAAA5T,KAAAiS,EAAAv4B,GAAAgmB,EAAAkU,GAEA3B,EAAAv4B,GAAA2gC,aAAAnG,EAAAN,GAAAA,EAAAx3B,MAAAsjB,EAAAtjB,KACAw3B,EAAAv3B,IAAAqjB,EAAArjB,GAAA,YACA/C,EAAAu6B,OAAAnU,EAAA,OAAAkU,GACA3B,EAAAv4B,GAAA4gC,gBAPA,IASA50B,KAAA2T,QAAAkhB,aACA70B,KAAA9G,OAZA,EAgBAk0B,eAAA,WACAptB,KAAAnM,WACA06B,EAAAvuB,KAAAnM,UACAmM,KAAAnM,SAAA,GAGA,IAAAihC,EAAA90B,KAAA6sB,SACA7sB,KAAAga,OACA8a,EAAA90B,KAAAga,KAAAtjB,MAGA,IAAAuR,EAAAjI,KAAAhM,GAAA84B,YAAAlzB,EAAAoG,KAAAhM,GAAAg5B,QAAA/kB,EAAArO,MACA,GAAAqO,EAAArO,MAAAoG,KAAA6sB,SAAAjzB,MAAAA,EAAAtI,OAAA2W,EAAAnJ,IAAAkB,KAAA+sB,SAAA/sB,KAAA6sB,SAAA/tB,IACAmJ,EAAAnJ,GAAAg2B,EAAAh2B,IAAAkB,KAAAhM,GAAA+5B,sBACA9lB,EAAAnJ,IAAAkB,KAAA2T,QAAAohB,gBAAA78B,KAAA0B,EAAAsO,OAAAD,EAAAnJ,GAAA,IACAkB,KAAA9G,YACA,CACA,IAAAqzB,EAAAvsB,KACAA,KAAAnM,SAAAw6B,GAAA,WAAA9B,EAAA6B,QAAA,IACApuB,KAAA2sB,QAAA3sB,KAAA2sB,OAAAqI,SAHA,CAhBA,EAuBA5G,OAAA,SAAA6G,GACA,GAAA,MAAAj1B,KAAA4sB,KAAA,CACA,IAAAL,EAAAvsB,KAAAk1B,IAAAl1B,KAAA4sB,KACA6H,EAAAz0B,KAAA2T,QAAA2G,KAAAta,KAAAhM,GAAAgM,KAAA2T,SAAA,SAAAqG,GACAuS,EAAAK,MAAAsI,GAAA3I,EAAA4I,aAAAnb,EAAAib,EADA,GAFA,CADA,EAQAE,aAAA,SAAAnb,EAAAib,GACAj1B,KAAAga,MAAApmB,EAAAu6B,OAAAnuB,KAAAga,KAAA,UAEA,IAAAiV,EAAAjvB,KAAA2sB,QAAA3sB,KAAA2sB,OAAAsC,QAAAgG,GAAAj1B,KAAA2T,QAAAyhB,eACAp1B,KAAA2sB,QAAA3sB,KAAA2sB,OAAAzzB,QAEA8G,KAAAga,KAAAA,EAEAA,GAAAA,EAAAtQ,KAAApY,SACA29B,GAAA,GAAAjV,EAAAtQ,KAAApY,OACA0O,KAAA2yB,KAAA3Y,EAAA,IAEAha,KAAA2sB,OAAA,IAAAmC,EAAA9uB,KAAAga,GACApmB,EAAAu6B,OAAAnU,EAAA,UAbA,GAiOA8U,EAAA58B,UAAA,CACAgH,MAAA,WACA,GAAA8G,KAAAkuB,WAAAvB,QAAA3sB,KAAA,CACAA,KAAAkuB,WAAAvB,OAAA,KACA3sB,KAAAovB,MAAA7c,YAAAvS,KAAAovB,MAAA7c,WAAAC,YAAAxS,KAAAovB,OACApvB,KAAAkuB,WAAAl6B,GAAAqhC,aAAAr1B,KAAA8xB,QACA,IAAAj3B,EAAAmF,KAAAkuB,WAAAl6B,GAAAk7B,gBACAr0B,EAAAy6B,gBAAA,yBACAz6B,EAAAy6B,gBAAA,aAEA,IAAAthC,EAAAgM,KAAAkuB,WAAAl6B,GACAgM,KAAAkuB,WAAAva,QAAAggB,iBACA3/B,EAAAie,IAAA,OAAAjS,KAAA4zB,QACA5/B,EAAAie,IAAA,QAAAjS,KAAA6zB,UAEA7/B,EAAAie,IAAA,SAAAjS,KAAA8zB,SAbA,CADA,EAiBAkB,QAAA,WACAh1B,KAAAkuB,WAAAl6B,GAAAqhC,aAAAr1B,KAAA8xB,QACA,IAAAnF,EAAA3sB,KACAA,KAAA8xB,OAAA,CAAAY,MAAA,WAAA/F,EAAAsC,QAAA,CAAA,GACAjvB,KAAAkuB,WAAAl6B,GAAA69B,UAAA7xB,KAAA8xB,OAJA,EAOAa,KAAA,WACA3yB,KAAAkuB,WAAAyE,KAAA3yB,KAAAga,KAAAha,KAAAsvB,aADA,EAIAmE,aAAA,SAAApiC,EAAAmiC,GAKA,GAJAniC,GAAA2O,KAAAga,KAAAtQ,KAAApY,OACAD,EAAAmiC,EAAAxzB,KAAAga,KAAAtQ,KAAApY,OAAA,EAAA,EACAD,EAAA,IACAA,EAAAmiC,EAAA,EAAAxzB,KAAAga,KAAAtQ,KAAApY,OAAA,GACA0O,KAAAsvB,cAAAj+B,EAAA,CACA,IAAAqhB,EAAA1S,KAAAovB,MAAAoF,WAAAx0B,KAAAsvB,cACA5c,IACAA,EAAArH,UAAAqH,EAAArH,UAAA6V,QAAA,IAAAuL,EAAA,IACA/Z,EAAA4iB,gBAAA,mBAEA5iB,EAAA1S,KAAAovB,MAAAoF,WAAAx0B,KAAAsvB,aAAAj+B,IACAga,WAAA,IAAAohB,EACA/Z,EAAA2c,aAAA,gBAAA,QACArvB,KAAAkuB,WAAAl6B,GAAAk7B,gBAAAG,aAAA,wBAAA3c,EAAAmF,IACA7X,KAAAu0B,iBACA3gC,EAAAu6B,OAAAnuB,KAAAga,KAAA,SAAAha,KAAAga,KAAAtQ,KAAA1J,KAAAsvB,cAAA5c,EAXA,CALA,EAmBA6hB,eAAA,WACA,IAAAF,EAAAr0B,KAAAs0B,uBACAiB,EAAAv1B,KAAAovB,MAAAoF,WAAAH,EAAA39B,MACA8+B,EAAAx1B,KAAAovB,MAAAoF,WAAAH,EAAA19B,IACA8+B,EAAAz1B,KAAAovB,MAAAsC,WACA6D,EAAAvF,UAAAhwB,KAAAovB,MAAAkB,UACAtwB,KAAAovB,MAAAkB,UAAAiF,EAAAvF,UAAAyF,EAAAzF,UACAwF,EAAAxF,UAAAwF,EAAAriB,aAAAnT,KAAAovB,MAAAkB,UAAAtwB,KAAAovB,MAAA6B,eACAjxB,KAAAovB,MAAAkB,UAAAkF,EAAAxF,UAAAwF,EAAAriB,aAAAnT,KAAAovB,MAAA6B,aAAAwE,EAAAzF,UARA,EAWA0D,aAAA,WACA,OAAA1gB,KAAA+b,MAAA/uB,KAAAovB,MAAA6B,aAAAjxB,KAAAovB,MAAAsC,WAAAve,eAAA,CADA,EAIAmhB,qBAAA,WACA,IAAAoB,EAAA11B,KAAAkuB,WAAAva,QAAAgiB,cAAA,EACA,MAAA,CACAj/B,KAAAsc,KAAAC,IAAA,EAAAjT,KAAAsvB,aAAAoG,GACA/+B,GAAAqc,KAAAK,IAAArT,KAAAga,KAAAtQ,KAAApY,OAAA,EAAA0O,KAAAsvB,aAAAoG,GAJA,GAqDA9hC,EAAA2c,eAAA,OAAA,OAAA,CACAqd,QA3BA,SAAA55B,EAAAiU,GACA,IAAA2tB,EAAAC,EAAA7hC,EAAA8hC,WAAA7tB,EAAA,QACA,GAAA4tB,EAAAvkC,OAAA,CACA,IAAAykC,EAAA,SAAA/hC,EAAA0gC,EAAA/gB,GACA,IAAAqiB,EAtBA,SAAAhiC,EAAA6hC,GACA,IAAA7hC,EAAA+5B,oBAAA,OAAA8H,EAEA,IADA,IAAArrB,EAAA,GACAnZ,EAAA,EAAAA,EAAAwkC,EAAAvkC,OAAAD,IACAwkC,EAAAxkC,GAAA28B,mBAAAxjB,EAAAnI,KAAAwzB,EAAAxkC,IACA,OAAAmZ,CALA,CAsBAyrB,CAAAjiC,EAAA6hC,IACA,SAAAK,EAAA7kC,GACA,GAAAA,GAAA2kC,EAAA1kC,OAAA,OAAAojC,EAAA,MACAD,EAAAuB,EAAA3kC,GAAA2C,EAAA2f,GAAA,SAAAnJ,GACAA,GAAAA,EAAAd,KAAApY,OAAA,EAAAojC,EAAAlqB,GACA0rB,EAAA7kC,EAAA,EAFA,GAFA,CAOA6kC,CAAA,EATA,EAaA,OAFAH,EAAAzf,OAAA,EACAyf,EAAA/H,mBAAA,EACA+H,CAdA,CAeA,OAAAH,EAAA5hC,EAAA2jB,UAAA3jB,EAAA84B,YAAA,cACA,SAAA94B,GAAA,OAAAJ,EAAA0mB,KAAA6b,SAAAniC,EAAA,CAAA4hC,MAAAA,GAAA,EACAhiC,EAAA0mB,KAAA8b,QACA,SAAApiC,EAAA2f,GAAA,OAAA/f,EAAA0mB,KAAA8b,QAAApiC,EAAA2f,EAAA,EAEA,WAAA,CAtBA,IA8BA/f,EAAA2c,eAAA,OAAA,YAAA,SAAAvc,EAAA2f,GACA,IACA0iB,EADAp9B,EAAAjF,EAAA84B,YAAA90B,EAAAhE,EAAAsiC,WAAAr9B,GACAvC,EAAA9C,EAAAgkB,IAAA3e,EAAAW,KAAA5B,EAAAmP,OAAAxQ,EAAAsC,EACAjB,EAAAmP,MAAAlO,EAAA6F,IAAA,KAAA5G,KAAAF,EAAAiP,OAAAiB,OAAAjP,EAAA6F,GAAA9G,EAAAmP,MAAA,IACAkvB,EAAAr+B,EAAAiP,OAAAgX,OAAA,EAAAhlB,EAAA6F,GAAA9G,EAAAmP,QAEAkvB,EAAA,GACA3/B,EAAAuC,GAGA,IADA,IAAA+f,EAAA,GACA3nB,EAAA,EAAAA,EAAAsiB,EAAAiiB,MAAAtkC,OAAAD,IAAA,CACA,IAAAgW,EAAAsM,EAAAiiB,MAAAvkC,GACAgW,EAAAH,MAAA,EAAAmvB,EAAA/kC,SAAA+kC,GACArd,EAAA3W,KAAAgF,EAHA,CAMA,GAAA2R,EAAA1nB,OAAA,MAAA,CAAAoY,KAAAsP,EAAAtiB,KAAAA,EAAAC,GAAAA,EAhBA,IAmBA/C,EAAA2iC,SAAAC,aAAA5iC,EAAAy5B,SAEA,IAAAM,EAAA,CACArT,KAAA1mB,EAAA0mB,KAAAmc,KACArB,gBAAA,EACAvF,eAAA,EACAkF,gBAAA,mBACAF,aAAA,EACAlB,gBAAA,EACAzG,wBAAA,EACAiH,uBAAA,EACAxE,UAAA,KACAsD,WAAA,KACAK,UAAA,KACAvC,qBAAA,EACAH,eAAA,GAGAh9B,EAAAke,aAAA,cAAA,KA7fA,EANA,UAAAzf,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,Wb+rJQ,EACA,CAAE,GAAM,KC3sJhB,GAAA,CD8sJQ,SAAUZ,EAASU,EAAQD,Gc3sJnC,IAAAgC,IAOA,SAAA7B,GACA,IAAAgkB,EAAAhkB,EAAAgkB,IAEA,SAAA+J,EAAA+U,EAAArjC,GACA,IAAA,IAAAhC,EAAA,EAAAmB,EAAAkkC,EAAAplC,OAAAD,EAAAmB,IAAAnB,EAAAgC,EAAAqjC,EAAArlC,GADA,CAiBA,SAAAslC,EAAAnJ,EAAArqB,EAAAyzB,EAAAjjB,GAEA,IAAA1a,EAAAu0B,EAAAV,YAAA90B,EAAA4+B,EAAApJ,EAAAv0B,GACA,IAAA,yBAAAf,KAAAF,EAAAqG,MAAA,CACA,IAAAvE,EAAAlG,EAAAkG,UAAA0zB,EAAAp2B,UAAAY,EAAAD,OACA,GAAA,SAAA+B,EAAA1F,KAAA4N,WAAA,CACAhK,EAAAD,MAAA+B,EAAA/B,MAGA,YAAAG,KAAAF,EAAAiP,QAGAjP,EAAA0V,IAAAzU,EAAA6F,KACA9G,EAAA0V,IAAAzU,EAAA6F,GACA9G,EAAAiP,OAAAjP,EAAAiP,OAAAC,MAAA,EAAAjO,EAAA6F,GAAA9G,EAAAmP,QAJAnP,EAAA,CAAAmP,MAAAlO,EAAA6F,GAAA4O,IAAAzU,EAAA6F,GAAAmI,OAAA,GAAAlP,MAAAC,EAAAD,MACAsG,KAAA,KAAArG,EAAAiP,OAAA,WAAA,MAQA,IAFA,IAAA4vB,EAAA7+B,EAEA,YAAA6+B,EAAAx4B,MAAA,CAEA,GAAA,MADAw4B,EAAAD,EAAApJ,EAAA5V,EAAA3e,EAAAW,KAAAi9B,EAAA1vB,SACAF,OAAA,OAEA,GADA4vB,EAAAD,EAAApJ,EAAA5V,EAAA3e,EAAAW,KAAAi9B,EAAA1vB,SACAjH,EAAA,IAAAA,EAAA,GACAA,EAAAmC,KAAAw0B,EALA,CAOA,MAAA,CAAAntB,KAAAotB,EAAA9+B,EAAAkI,EAAAiD,EAAAwQ,GACAjd,KAAAkhB,EAAA3e,EAAAW,KAAA5B,EAAAmP,OACAxQ,GAAAihB,EAAA3e,EAAAW,KAAA5B,EAAA0V,KAvBA,CAFA,CAHA,CAsCA,SAAAqpB,EAAAvJ,EAAAv0B,GAIA,IAAAjB,EAAAw1B,EAAA8I,WAAAr9B,GAWA,OAVAA,EAAA6F,IAAA9G,EAAAmP,MAAA,GAAA,KAAAnP,EAAAiP,OAAAiB,OAAA,IACAlQ,EAAA0V,IAAA1V,EAAAmP,MACAnP,EAAAiP,OAAA,IACAjP,EAAAqG,KAAA,YAEA,cAAAnG,KAAAF,EAAAiP,UACAjP,EAAAqG,KAAA,WACArG,EAAAmP,QACAnP,EAAAiP,OAAAjP,EAAAiP,OAAAia,QAAA,KAAA,KAEAlpB,CAfA,CAFApE,EAAA2c,eAAA,OAAA,cALA,SAAAid,EAAA7Z,GACA,OAAAgjB,EAAAnJ,EAAAwJ,GACA,SAAAxkC,EAAAyG,GAAA,OAAAzG,EAAA8jC,WAAAr9B,EAAA,GACA0a,EAHA,IA4BA/f,EAAA2c,eAAA,OAAA,gBAHA,SAAAid,EAAA7Z,GACA,OAAAgjB,EAAAnJ,EAAAyJ,EAAAF,EAAApjB,EADA,IAKA,IAAAujB,EAAA,iJACAnb,MAAA,KACAob,EAAA,4IACApb,MAAA,KACAqb,EAAA,4BAAArb,MAAA,KACAib,EAAA,4NACAjb,MAAA,KACAkb,EAAA,gMACAlb,MAAA,KAWA,SAAA+a,EAAA9+B,EAAAkI,EAAAiD,EAAAwQ,GACA,IAAAqF,EAAA,GAAA7R,EAAAnP,EAAAiP,OAAAkU,EAAAxH,GAAAA,EAAA0jB,aAAAviC,OACA,SAAAwiC,EAAAje,GACA,GAAAA,EAAAke,YAAApwB,EAAA,IAhGA,SAAAuvB,EAAAc,GACA,IAAAlY,MAAAptB,UAAA2V,QAAA,CAEA,IADA,IAAAxW,EAAAqlC,EAAAplC,OACAD,KACA,GAAAqlC,EAAArlC,KAAAmmC,EACA,OAAA,EAGA,OAAA,CAPA,CASA,OAAA,GAAAd,EAAA7uB,QAAA2vB,EAVA,CAgGAC,CAAAze,EAAAK,IAAAL,EAAA3W,KAAAgX,EADA,CAGA,SAAAqe,EAAA7b,GACA,iBAAAA,EAAA8F,EAAAuV,EAAAI,GACAzb,aAAAyD,MAAAqC,EAAAwV,EAAAG,GACAzb,aAAAjH,UAAA+M,EAAAyV,EAAAE,GAjBA,SAAAzb,EAAA6Y,GACA,GAAA/iC,OAAAgmC,qBAAAhmC,OAAAimC,eAGA,IAAA,IAAA/kC,EAAAgpB,EAAAhpB,EAAAA,EAAAlB,OAAAimC,eAAA/kC,GACAlB,OAAAgmC,oBAAA9kC,GAAA8uB,QAAA+S,QAHA,IAAA,IAAAr9B,KAAAwkB,EAAA6Y,EAAAr9B,EAFA,CAkBAwgC,CAAAhc,EAAAyb,EAJA,CAOA,GAAAp3B,GAAAA,EAAA5O,OAAA,CAGA,IAAA+I,EAAAwhB,EAAA3b,EAAAgJ,MAiBA,IAhBA2S,EAAAxd,MAAA,IAAAwd,EAAAxd,KAAAwJ,QAAA,aACA8L,GAAAA,EAAAmkB,oBACAz9B,EAAAsZ,EAAAmkB,kBAAAjc,EAAA5U,SACA0M,IAAA,IAAAA,EAAAokB,iBACA19B,EAAAA,GAAA8gB,EAAAU,EAAA5U,UACA,UAAA4U,EAAAxd,KACAhE,EAAA,GACA,QAAAwhB,EAAAxd,KACAhE,EAAA,EACA,YAAAwhB,EAAAxd,OACA,MAAA8c,EAAA6c,QAAA,KAAAnc,EAAA5U,QAAA,UAAA4U,EAAA5U,QACA,mBAAAkU,EAAA6c,OAEA,MAAA7c,EAAA9N,GAAA,KAAAwO,EAAA5U,QAAA,mBAAAkU,EAAA9N,IACAhT,EAAA8gB,EAAA9N,KAFAhT,EAAA8gB,EAAA6c,UAIA,MAAA39B,GAAA6F,EAAA5O,QACA+I,EAAAA,EAAA6F,EAAAgJ,MAAAjC,QACA,MAAA5M,GAAAq9B,EAAAr9B,EAtBA,KAuBA,CAGA,IAAA,IAAAuO,EAAA5Q,EAAAD,MAAA8Q,UAAAD,EAAAA,EAAAA,EAAA7J,KAAAu4B,EAAA1uB,EAAAvR,MACA,IAAA,IAAAwY,EAAA7X,EAAAD,MAAAmI,QAAA2P,EAAAA,EAAAA,EAAA5P,KACA,IAAA2I,EAAAiH,EAAA/G,KAAAF,EAAAA,EAAAA,EAAA7J,KAAAu4B,EAAA1uB,EAAAvR,MACA,IAAAuR,EAAA5Q,EAAAD,MAAAiS,WAAApB,EAAAA,EAAAA,EAAA7J,KAAAu4B,EAAA1uB,EAAAvR,MACA,GAAAsc,GAAA,MAAAA,EAAAmkB,kBACA,IAAA,IAAAhmC,KAAA6hB,EAAAmkB,kBACAR,EAAAxlC,GACA6hB,IAAA,IAAAA,EAAAokB,gBACAL,EAAAvc,GACAwG,EAAAxe,EAAAm0B,EAZA,CAcA,OAAAte,CAjDA,CApGA,EANA,UAAA3mB,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,Wd+1JQ,EACA,CAAE,GAAM,KCz2JhB,GAAA,CD42JQ,SAAUZ,EAASU,EAAQD,Gez2JnC,IAAAgC,IAOA,SAAA7B,GACA,aAEA,IAAAqkC,EAAA,0iBAAAlc,MAAA,KACAmc,EAAA,CAAA,SAAA,QAAA,OAAA,WACAC,EAAA,CAAA,QAAA,QAAA,SAAA,SAAA,UACAC,EAAA,CAAA,MAAA,OAAA,MAAA,UACAC,EAAA,CAAA,oCAAA,sBAAA,cACAC,EAAA,CAAA,MAAA,SAAA,QAAA,WAAA,UAAA,WAAA,QAAA,aAAA,SAAA,MAAA,KAAA,SACA,aAAA,2BAAA,2BAAA,uBACA,wBAAA,qBAAA,qBACAplC,EAAA,CAAAiqB,MAAA,CAAA,GAEAnD,EAAA,CACA5mB,EAAA,CACA+pB,MAAA,CACAob,KAAA,KAAAC,KAAA,KAAAn6B,KAAA,KACAi6B,MAAAA,EACAnnC,OAAA+mC,EACAO,SAAAR,IAGAS,KAAAxlC,EACAylC,QAAAzlC,EACAkJ,QAAAlJ,EACA0lC,OAAA1lC,EACAkH,KAAA,CACA+iB,MAAA,CACA0b,IAAA,KAAAC,OAAA,KAAAP,KAAA,KAAApnC,OAAA,KAAAqnC,KAAA,KACAF,MAAAA,EAAAG,SAAAR,EAAA55B,KAAA,KACA06B,MAAA,CAAA,UAAA,OAAA,SAAA,UAGA18B,QAAAnJ,EACAoJ,MAAApJ,EACA8lC,MAAA,CACA7b,MAAA,CACA8b,IAAA,KAAAC,WAAA,KACAC,YAAA,CAAA,YAAA,mBACAC,QAAA,CAAA,OAAA,WAAA,QACAC,SAAA,CAAA,GAAA,YACAC,KAAA,CAAA,GAAA,QACAC,SAAA,CAAA,GAAA,cAGA/nB,EAAAte,EACAmH,KAAA,CAAA8iB,MAAA,CAAAob,KAAA,KAAApnC,OAAA+mC,IACAsB,SAAAtmC,EACAumC,IAAAvmC,EACAwmC,IAAAxmC,EACAymC,IAAAzmC,EACAqJ,WAAA,CAAA4gB,MAAA,CAAAyc,KAAA,OACA1tB,KAAAhZ,EACAoH,GAAApH,EACA2mC,OAAA,CACA1c,MAAA,CACAtgB,KAAA,KAAAi9B,WAAA,KAAAziC,KAAA,KAAAyT,MAAA,KACAivB,UAAA,CAAA,GAAA,aACAC,SAAA,CAAA,GAAA,aACAC,YAAA5B,EACA6B,WAAA9B,EACA+B,eAAA,CAAA,GAAA,cACAC,WAAAlC,EACA75B,KAAA,CAAA,SAAA,QAAA,YAGAg8B,OAAA,CAAAld,MAAA,CAAAsU,MAAA,KAAAN,OAAA,OACAmJ,QAAApnC,EACAqnC,OAAArnC,EACA0mC,KAAA1mC,EACAK,KAAAL,EACAqH,IAAA,CAAA4iB,MAAA,CAAAqd,KAAA,OACAC,SAAA,CAAAtd,MAAA,CAAAqd,KAAA,OACAhgC,QAAA,CACA2iB,MAAA,CACA9e,KAAA,CAAA,UAAA,WAAA,SACAq8B,MAAA,KAAAC,KAAA,KAAAC,WAAA,KAAApgC,QAAA,KAAAqgC,MAAA,KACAb,SAAA,CAAA,GAAA,YACAc,QAAA,CAAA,GAAA,aAGA9gB,KAAA,CAAAmD,MAAA,CAAArS,MAAA,OACAiwB,SAAA,CAAA5d,MAAA,CAAA6c,SAAA,CAAA,GAAA,YAAA7iB,SAAA,CAAA,GAAA,cACA6jB,SAAA,CAAA7d,MAAA,CAAAnD,KAAA,OACA1e,GAAApI,EACA+nC,IAAA,CAAA9d,MAAA,CAAAyc,KAAA,KAAAsB,SAAA,OACAC,QAAA,CAAAhe,MAAA,CAAAie,KAAA,CAAA,GAAA,UACAC,IAAAnoC,EACAsJ,IAAAtJ,EACAuJ,IAAAvJ,EACAooC,OAAA,CAAAne,MAAA,CAAAie,KAAA,OACA1+B,GAAAxJ,EACAiJ,GAAAjJ,EACAqoC,GAAAroC,EACAuH,MAAA,CAAA0iB,MAAA,CAAA8b,IAAA,KAAA56B,KAAA,KAAAozB,MAAA,KAAAN,OAAA,OACAqK,YAAA,CAAAre,MAAA,CAAA8b,IAAA,OACAt8B,SAAA,CAAAwgB,MAAA,CAAA6c,SAAA,CAAA,GAAA,YAAAn9B,KAAA,KAAAxF,KAAA,OACAokC,WAAAvoC,EACAwoC,OAAAxoC,EACAyoC,KAAAzoC,EACA0J,OAAA1J,EACA2J,KAAA,CACAsgB,MAAA,CACAye,OAAA,KAAAvkC,KAAA,KACA,iBAAA8gC,EACA3B,aAAA,CAAA,KAAA,OACAqF,QAAAxD,EACAyD,OAAA1D,EACA2D,WAAA,CAAA,GAAA,cACA5qC,OAAA+mC,IAGAx9B,MAAAxH,EACA8oC,SAAA9oC,EACA4J,GAAA5J,EAAA6J,GAAA7J,EAAA8J,GAAA9J,EAAA+J,GAAA/J,EAAAgK,GAAAhK,EAAAiK,GAAAjK,EACAme,KAAA,CACA8L,MAAA,CAAA,EACA8e,SAAA,CAAA,QAAA,OAAA,OAAA,QAAA,OAAA,SAAA,WAAA,YAEA7+B,OAAAlK,EACAmK,OAAAnK,EACAyH,GAAAzH,EACAqC,KAAA,CACA4nB,MAAA,CAAA+e,SAAA,MACAD,SAAA,CAAA,OAAA,SAEA5qC,EAAA6B,EACAipC,OAAA,CACAhf,MAAA,CACA8b,IAAA,KAAAmD,OAAA,KAAA/kC,KAAA,KAAAo6B,MAAA,KAAAN,OAAA,KACAkL,QAAA,CAAA,uBAAA,oBAAA,cAAA,iBACAC,SAAA,CAAA,GAAA,cAGA1hC,IAAA,CACAuiB,MAAA,CACA0b,IAAA,KAAAI,IAAA,KAAAsD,MAAA,KAAAC,OAAA,KAAA/K,MAAA,KAAAN,OAAA,KACAgI,YAAA,CAAA,YAAA,qBAGAt+B,MAAA,CACAsiB,MAAA,CACA0b,IAAA,KAAA4D,QAAA,KAAA5/B,KAAA,KAAAi9B,WAAA,KACA3I,OAAA,KAAAznB,KAAA,KAAAuJ,IAAA,KAAAypB,UAAA,KAAArpB,IAAA,KACAhc,KAAA,KAAAoU,QAAA,KAAAkxB,YAAA,KAAAC,KAAA,KAAA3D,IAAA,KACA4D,KAAA,KAAA/xB,MAAA,KAAA2mB,MAAA,KACAqL,OAAA,CAAA,UAAA,UAAA,WACAtG,aAAA,CAAA,KAAA,OACAuD,UAAA,CAAA,GAAA,aACAe,QAAA,CAAA,GAAA,WACAd,SAAA,CAAA,GAAA,YACAC,YAAA5B,EACA6B,WAAA9B,EACA+B,eAAA,CAAA,GAAA,cACAC,WAAAlC,EACA/gB,SAAA,CAAA,GAAA,YACA4lB,SAAA,CAAA,GAAA,YACAC,SAAA,CAAA,GAAA,YACA3+B,KAAA,CAAA,SAAA,OAAA,SAAA,MAAA,MAAA,QAAA,WAAA,WAAA,OAAA,QACA,OAAA,OAAA,iBAAA,SAAA,QAAA,QAAA,WAAA,QACA,OAAA,SAAA,QAAA,QAAA,YAGA4+B,IAAA,CAAA9f,MAAA,CAAAyc,KAAA,KAAAsB,SAAA,OACAgC,IAAAhqC,EACA4H,OAAA,CACAqiB,MAAA,CACAggB,UAAA,KAAAtgC,KAAA,KAAAxF,KAAA,KACA0iC,UAAA,CAAA,GAAA,aACAC,SAAA,CAAA,GAAA,YACAoD,QAAA,CAAA,SAGA1C,MAAA,CAAAvd,MAAA,CAAApY,IAAA,KAAAlI,KAAA,OACAwgC,OAAAnqC,EACAqI,GAAA,CAAA4hB,MAAA,CAAArS,MAAA,OACA/P,KAAA,CACAoiB,MAAA,CACAob,KAAA,KAAAl6B,KAAA,KACAo6B,SAAAR,EACAK,MAAAA,EACAgF,MAAA,CAAA,MAAA,QAAA,cAAA,uBAGApV,IAAA,CAAA/K,MAAA,CAAA9lB,KAAA,OACAkmC,KAAArqC,EACAoK,KAAA,CAAA6f,MAAA,CAAAud,MAAA,KAAAr8B,KAAA,CAAA,OAAA,UAAA,aACArD,KAAA,CACAmiB,MAAA,CACA3a,QAAA,KACAg7B,QAAArF,EACA9gC,KAAA,CAAA,WAAA,mBAAA,SAAA,cAAA,YAAA,YACA,aAAA,CAAA,mBAAA,eAAA,gBAAA,aAGAomC,MAAA,CAAAtgB,MAAA,CAAArS,MAAA,KAAAuI,IAAA,KAAAqqB,IAAA,KAAAC,KAAA,KAAA1qB,IAAA,KAAA2qB,QAAA,OACArgC,IAAArK,EACA2qC,SAAA3qC,EACA4qC,SAAA5qC,EACA6qC,OAAA,CACA5gB,MAAA,CACAnD,KAAA,KAAA3b,KAAA,KAAAhH,KAAA,KAAAmlC,OAAA,KAAA3/B,KAAA,KAAA40B,MAAA,KAAAN,OAAA,KACA6M,cAAA,CAAA,GAAA,mBAGAxgC,GAAA,CAAA2f,MAAA,CAAA8gB,SAAA,CAAA,GAAA,YAAA92B,MAAA,KAAA9I,KAAA,CAAA,IAAA,IAAA,IAAA,IAAA,OACA7C,SAAA,CAAA2hB,MAAA,CAAA6c,SAAA,CAAA,GAAA,YAAAU,MAAA,OACAj/B,OAAA,CAAA0hB,MAAA,CAAA6c,SAAA,CAAA,GAAA,YAAAU,MAAA,KAAAwD,SAAA,CAAA,GAAA,YAAApzB,MAAA,OACAmP,OAAA,CAAAkD,MAAA,CAAApY,IAAA,KAAAlI,KAAA,KAAAxF,KAAA,OACAqE,EAAAxI,EACA+H,MAAA,CAAAkiB,MAAA,CAAA9lB,KAAA,KAAAyT,MAAA,OACArN,IAAAvK,EACAirC,SAAA,CAAAhhB,MAAA,CAAArS,MAAA,KAAAmI,IAAA,OACAmrB,EAAA,CAAAjhB,MAAA,CAAAyc,KAAA,OACAj+B,GAAAzI,EACA0I,GAAA1I,EACAmrC,KAAAnrC,EACAA,EAAAA,EACAorC,KAAAprC,EACAyC,OAAA,CACAwnB,MAAA,CACA9e,KAAA,CAAA,mBACA46B,IAAA,KACA3iB,MAAA,CAAA,GAAA,SACAioB,MAAA,CAAA,GAAA,SACAf,QAAArF,IAGAz6B,QAAAxK,EACAsrC,OAAA,CACArhB,MAAA,CACAtgB,KAAA,KAAAxF,KAAA,KAAAulC,KAAA,KACA7C,UAAA,CAAA,GAAA,aACAC,SAAA,CAAA,GAAA,YACA7iB,SAAA,CAAA,GAAA,cAGAsnB,MAAAvrC,EACA4D,OAAA,CAAAqmB,MAAA,CAAA8b,IAAA,KAAA56B,KAAA,KAAAi6B,MAAA,OACAkC,KAAAtnC,EACAwrC,OAAAxrC,EACAyrC,OAAAzrC,EACA0C,MAAA,CACAunB,MAAA,CACA9e,KAAA,CAAA,YACAi6B,MAAAA,EACAsG,OAAA,OAGAC,IAAA3rC,EACA4rC,QAAA5rC,EACA6rC,IAAA7rC,EACAyK,MAAAzK,EACA2I,MAAA3I,EACA4I,GAAA,CAAAqhB,MAAA,CAAA6hB,QAAA,KAAAC,QAAA,KAAAC,QAAA,OACAC,SAAA,CACAhiB,MAAA,CACAsf,QAAA,KAAA5/B,KAAA,KAAA6/B,UAAA,KAAArlC,KAAA,KAAAslC,YAAA,KACAyC,KAAA,KAAAC,KAAA,KACAtF,UAAA,CAAA,GAAA,aACAC,SAAA,CAAA,GAAA,YACA+C,SAAA,CAAA,GAAA,YACAC,SAAA,CAAA,GAAA,YACAsC,KAAA,CAAA,OAAA,UAGAvjC,MAAA7I,EACA8I,GAAA,CAAAmhB,MAAA,CAAA6hB,QAAA,KAAAC,QAAA,KAAAC,QAAA,KAAAK,MAAA,CAAA,MAAA,MAAA,WAAA,cACA1hC,MAAA3K,EACAssC,KAAA,CAAAriB,MAAA,CAAA+d,SAAA,OACAL,MAAA3nC,EACA+I,GAAA/I,EACAgI,MAAA,CACAiiB,MAAA,CACA8b,IAAA,KAAAyB,MAAA,KAAAx1B,QAAA,KACAu6B,KAAA,CAAA,YAAA,WAAA,eAAA,WAAA,YACAC,QAAAzH,IAGArlB,GAAA1f,EACAC,EAAAD,EACA0K,GAAA1K,EACAwR,IAAAxR,EACAysC,MAAA,CACAxiB,MAAA,CACA8b,IAAA,KAAA2G,OAAA,KAAAnO,MAAA,KAAAN,OAAA,KACAgI,YAAA,CAAA,YAAA,mBACAC,QAAA,CAAA,OAAA,WAAA,QACAC,SAAA,CAAA,GAAA,YACAH,WAAA,CAAA,SACA2G,MAAA,CAAA,GAAA,SACAtG,SAAA,CAAA,GAAA,cAGAp+B,IAAAjI,GAGA4sC,EAAA,CACAC,UAAA,CAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KACAn6B,MAAA,KACAo6B,gBAAA,CAAA,OAAA,SACAC,YAAA,KACAzjC,IAAA,CAAA,MAAA,MAAA,QACA0jC,UAAA,CAAA,OAAA,QAAA,QACAC,SAAA,CAAA,OAAA,OAAA,OAAA,UAAA,SACAC,OAAA,CAAA,UACAvoB,GAAA,KACAwoB,MAAA,CAAA,SACAC,OAAA,KACAC,SAAA,KACAC,QAAA,KACAC,UAAA,CAAA,aACAC,SAAA,KACAC,KAAA,CAAA,KAAA,MACApsC,WAAA,CAAA,OAAA,SACAC,YAAA,CAAA,OAAA,SACAosC,eAAA,CAAA,OAAA,SACAhrC,MAAA,KACAirC,SAAA,CAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KACAhG,MAAA,KACAiG,UAAA,CAAA,MAAA,MACAC,QAAA,KACAC,IAAA,CAAA,aAAA,YAAA,SAAA,WAAA,OAAA,UAAA,OAAA,WAAA,aAAA,WAAA,OAAA,SAAA,QAEA,SAAAC,EAAAplB,GACA,IAAA,IAAA7lB,KAAA8pC,EAAAA,EAAAznC,eAAArC,KACA6lB,EAAAsB,MAAAnnB,GAAA8pC,EAAA9pC,GAFA,CAMA,IAAA,IAAAY,KADAqqC,EAAA/tC,GACA8mB,EAAAA,EAAA3hB,eAAAzB,IAAAojB,EAAApjB,IAAA1D,GACA+tC,EAAAjnB,EAAApjB,IAEAhD,EAAAstC,WAAAlnB,EAMApmB,EAAA2c,eAAA,OAAA,QALA,SAAAvc,EAAA2f,GACA,IAAAja,EAAA,CAAAynC,WAAAnnB,GACA,GAAArG,EAAA,IAAA,IAAAytB,KAAAztB,EAAAja,EAAA0nC,GAAAztB,EAAAytB,GACA,OAAAxtC,EAAA0mB,KAAA+mB,IAAArtC,EAAA0F,EAHA,GA9UA,EANA,UAAArH,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,IAAAA,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,uBAAA,cAAAvE,GAEAA,EAAA7B,WfwuLQ,EACA,CACI,GAAM,GACN,GAAM,KCpvLlB,GAAA,CDwvLQ,SAAUZ,EAASU,EAAQD,GgBrvLnC,IAAAgC,IAOA,SAAA7B,GACA,aAEA,IAAAgkB,EAAAhkB,EAAAgkB,IAEA,SAAA/f,EAAAyiB,EAAAgnB,EAAAC,GACA,OAAAA,EAAAjnB,EAAAzS,QAAAy5B,IAAA,EACA,GAAAhnB,EAAAid,YAAA+J,EAAA,EAFA,CAmHA1tC,EAAA2c,eAAA,OAAA,OA9GA,SAAAvc,EAAA2f,GACA,IAAAlc,EAAAkc,GAAAA,EAAAwtB,WACA/hC,EAAAuU,GAAAA,EAAA6tB,WAAA,IACAD,EAAA5tB,GAAAA,EAAA4tB,cACA,GAAA9pC,EAAA,CACA,IAAAwB,EAAAjF,EAAA84B,YAAA90B,EAAAhE,EAAAsiC,WAAAr9B,GAMA,GALAjB,EAAA0V,IAAAzU,EAAA6F,KACA9G,EAAA0V,IAAAzU,EAAA6F,GACA9G,EAAAiP,OAAAjP,EAAAiP,OAAAC,MAAA,EAAAjO,EAAA6F,GAAA9G,EAAAmP,SAEA8C,EAAArW,EAAAkG,UAAA9F,EAAAoD,UAAAY,EAAAD,QACA3D,KAAA8N,cAAA,CACA,IAAAu/B,EAEAliC,EAFAiL,EAAA,GAAAk3B,GAAA,EACA9qC,EAAA,UAAAsB,KAAAF,EAAAqG,QAAA,KAAAnG,KAAAF,EAAAiP,QACA1Q,EAAAK,GAAA,MAAAsB,KAAAF,EAAAiP,QAEA,GAAA1Q,EAAA,CACA,IAAAorC,EAAA3tC,EAAAg5B,QAAA/zB,EAAAW,MAAAsN,MAAA8L,KAAAC,IAAA,EAAAjb,EAAAmP,MAAA,GAAAnP,EAAAmP,OACAy6B,EAAA,OAAA1pC,KAAAypC,GAAA,QAAA,KAAAzpC,KAAAypC,GAAA,OAAA,KACAC,IAAAriC,EAAAvH,EAAAmP,OAAA,SAAAy6B,EAAA,EAAA,GAHA,MAIAhrC,GAAA,KAAAoB,EAAAiP,OACA26B,EAAA,OACAhrC,GAAA,MAAAoB,EAAAiP,SACA26B,EAAA,SAGA,IAAAppC,EAAAyR,EAAA7V,KAAA8N,cAAA+H,EAAAlS,OACA,IAAAnB,IAAA4B,GAAAopC,EAAA,CACArrC,IACAkrC,EAAAzpC,EAAAiP,QACAy6B,EAAAE,EACA,IACA33B,EADA/J,EAAA+J,EAAA7V,KAAA+N,kBAAA8H,EAAA7V,KAAA+N,kBAAA8H,EAAAlS,OAAA,GAEA8pC,GADA53B,EAAA/J,EAAA5O,QAAA4O,EAAAA,EAAA5O,OAAA,KACAmG,EAAAwS,GACA63B,EAAA73B,EAAA43B,GAAAA,EAAA5F,SAAAxkC,EAAA,QACA,GAAAqqC,GAAA,SAAAF,EACA,IAAA,IAAAvwC,EAAA,EAAAA,EAAAywC,EAAAxwC,SAAAD,EAAAowC,IAAA5pC,EAAAiqC,EAAAzwC,GAAAowC,EAAAF,IACA/2B,EAAAnI,KAAA,IAAAy/B,EAAAzwC,SACA,GAAA,SAAAuwC,EACA,IAAA,IAAAvqC,KAAAI,GACAA,EAAAY,eAAAhB,IAAA,QAAAA,GAAA,UAAAA,GAAAoqC,IAAA5pC,EAAAR,EAAAoqC,EAAAF,IACA/2B,EAAAnI,KAAA,IAAAhL,GAEA4S,KAAAw3B,GAAA,SAAAG,GAAA/pC,EAAAoS,EAAAw3B,EAAAF,KACA/2B,EAAAnI,KAAA,KAAA4H,EAAA,IAjBA,KAkBA,CAEA,IAAAkT,GAAA0kB,EAAArpC,GAAAf,EAAAe,EAAAnB,QAAAwqC,EAAA1kB,MACA2iB,EAAAroC,EAAA,UACA,IAAA0lB,IAAA2iB,EAAA,OACA,GAAA3iB,GAEA,GAAA2iB,EAAA,CACA,IAAAiC,EAAA,CAAA,EACA,IAAA,IAAAC,KAAAlC,EAAAA,EAAAznC,eAAA2pC,KAAAD,EAAAC,GAAAlC,EAAAkC,IACA,IAAA,IAAAA,KAAA7kB,EAAAA,EAAA9kB,eAAA2pC,KAAAD,EAAAC,GAAA7kB,EAAA6kB,IACA7kB,EAAA4kB,CAJA,OADA5kB,EAAA2iB,EAOA,GAAA,UAAA9nC,EAAAqG,MAAA,KAAArG,EAAAiP,OAAA,CACA,IAEAg7B,EAAAC,GAFAP,EAAA3tC,EAAAmuC,SAAAvqB,EAAA3e,EAAAW,KAAAoZ,KAAAC,IAAA,EAAAha,EAAA6F,GAAA,KACA8Y,EAAA3e,EAAAW,KAAA,UAAA5B,EAAAqG,KAAArG,EAAAmP,MAAAnP,EAAA0V,OACAzX,MAAA,2BACA,IAAAisC,IAAA/kB,EAAA9kB,eAAA6pC,EAAA,OAAAD,EAAA9kB,EAAA+kB,EAAA,KAAA,OAEA,GADA,mBAAAD,IAAAA,EAAAA,EAAAtvC,KAAAqN,KAAAhM,IACA,UAAAgE,EAAAqG,KAAA,CACAojC,EAAAzpC,EAAAiP,OACA,IAAAhU,EAAA,EACA,OAAAiF,KAAAF,EAAAiP,OAAAiB,OAAA,MACA9I,EAAApH,EAAAiP,OAAAiB,OAAA,GACAu5B,EAAAzpC,EAAAiP,OAAAC,MAAA,GACAjU,KAEA,IAAAmvC,EAAApqC,EAAAiP,OAAA3V,OAKA,GAJA,OAAA4G,KAAAF,EAAAiP,OAAAiB,OAAAk6B,EAAA,MACAhjC,EAAApH,EAAAiP,OAAAiB,OAAAk6B,EAAA,GACAX,EAAAzpC,EAAAiP,OAAAgX,OAAAhrB,EAAAmvC,EAAA,IAEAnvC,EAAA,CACA,IAAA2G,EAAA5F,EAAAg5B,QAAA/zB,EAAAW,MACAA,EAAAtI,OAAA0G,EAAA0V,KAAA9T,EAAAsO,OAAAlQ,EAAA0V,MAAAtO,GAAApH,EAAA0V,KAFA,CAIAg0B,GAAA,CAjBA,CAmBA,IAAAW,EAAA,SAAAJ,GACA,GAAAA,EACA,IAAA,IAAA5wC,EAAA,EAAAA,EAAA4wC,EAAA3wC,SAAAD,EAAAowC,IAAA5pC,EAAAoqC,EAAA5wC,GAAAowC,EAAAF,IACA/2B,EAAAnI,KAAAjD,EAAA6iC,EAAA5wC,GAAA+N,GACA,OAAAkjC,GAJA,EAMA,OAAAL,GAAAA,EAAA/pB,KAAA+pB,EAAA/pB,KAAAmqB,GACAA,EAAAJ,EAhCA,CAsCA,IAAA,IAAAjsC,IAJA,aAAAgC,EAAAqG,OACAojC,EAAAzpC,EAAAiP,OACAy6B,GAAA,GAEAvkB,GAAAA,EAAA9kB,eAAArC,IAAAyrC,IAAA5pC,EAAA7B,EAAAyrC,EAAAF,IACA/2B,EAAAnI,KAAArM,EApDA,CA8DA,OAAAssC,GAhGA,CAPA,CAgGA,SAAAA,IACA,MAAA,CACA54B,KAAAc,EACA9T,KAAAgrC,EAAA9pB,EAAA3e,EAAAW,KAAA,MAAA2F,EAAAvH,EAAAmP,MAAA5H,GAAAtG,EACAtC,GAAA+qC,EAAA9pB,EAAA3e,EAAAW,KAAA5B,EAAA0V,KAAAzU,EAJA,CApGA,GAVA,EANA,UAAA5G,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WhB03LQ,EACA,CAAE,GAAM,KCp4LhB,GAAA,CDu4LQ,SAAUZ,EAASU,EAAQD,GiBp4LnC,IAAAgC,IAOA,SAAA7B,GACA,aAEA,IAAA2uC,EAAA,CAAAvxB,OAAA,EAAAwxB,MAAA,EAAAb,OAAA,EAAA7G,QAAA,EAAA51B,QAAA,EACA80B,SAAA,EAAA1oB,MAAA,EAAAmxB,QAAA,EAAA,cAAA,EAAA,eAAA,EACA,aAAA,EAAA,gBAAA,EAAArO,MAAA,EAAAsO,MAAA,EAAA,WAAA,EACAC,cAAA,EAAAC,QAAA,EAAAjC,KAAA,EAAA,aAAA,EAAA,eAAA,EACA5lC,KAAA,EAAA8nC,IAAA,EAAA,YAAA,EAAA,iBAAA,EAAA,mBAAA,EACA,cAAA,EAAA,eAAA,EAAA,aAAA,EAAAC,SAAA,EAAA,eAAA,EACAnG,YAAA,EAAA,YAAA,EAAA,aAAA,EAAAK,SAAA,EAAA+F,KAAA,EACAC,UAAA,EAAA7xC,OAAA,EAAA8xC,MAAA,EAAAC,QAAA,GAGAtvC,EAAA2c,eAAA,OAAA,OAAA,SAAAvc,GACA,IAAAiF,EAAAjF,EAAA84B,YAAA90B,EAAAhE,EAAAsiC,WAAAr9B,GACAgR,EAAArW,EAAAkG,UAAA9F,EAAAoD,UAAAY,EAAAD,OACA,GAAA,OAAAkS,EAAA7V,KAAAiD,KAAA,CAEA,GAAA,WAAAW,EAAAqG,MAAA,GAAA,aAAAwJ,QAAA7P,EAAAiP,QACA,MAAA,CAAAyC,KAAA,CAAA,cAAAhT,KAAA9C,EAAAgkB,IAAA3e,EAAAW,KAAA5B,EAAAmP,OACAxQ,GAAA/C,EAAAgkB,IAAA3e,EAAAW,KAAA5B,EAAA0V,MAEA,IAAAvG,EAAAnP,EAAAmP,MAAAuG,EAAAzU,EAAA6F,GAAAuI,EAAArP,EAAAiP,OAAAC,MAAA,EAAAwG,EAAAvG,GACA,WAAAjP,KAAAmP,KACAA,EAAA,GAAAF,EAAAuG,EAAAzU,EAAA6F,IAGA,IAAApG,EAAA9E,EAAAuvC,YAAA,YAEA34B,EAAA,GAOA44B,EAAAn5B,EAAAlS,MAAAA,MAaA,MAZA,UAAAqrC,GAAA,cAAAprC,EAAAqG,KACAglC,EAAAd,GACA,SAAAa,GAAA,aAAAA,EACAC,EAAA3qC,EAAA4qC,kBACA,QAAAF,GAAA,UAAAA,GAAA,MAAAA,GAAA,UAAAA,GACAC,EAAA3qC,EAAA6qC,eACAF,EAAA3qC,EAAA8qC,gBACA,SAAAJ,GAAA,gBAAAA,IACAC,EAAA3qC,EAAA+qC,YACAJ,EAAA3qC,EAAAgrC,gBAGAl5B,EAAAlZ,OAAA,CACAoY,KAAAc,EACA9T,KAAA9C,EAAAgkB,IAAA3e,EAAAW,KAAAuN,GACAxQ,GAAA/C,EAAAgkB,IAAA3e,EAAAW,KAAA8T,SAHA,CAjCA,CAcA,SAAA21B,EAAAlgC,GACA,IAAA,IAAA9L,KAAA8L,EACAkE,GAAA,GAAAhQ,EAAAkgC,YAAAlwB,EAAA,IACAmD,EAAAnI,KAAAhL,EAHA,CAjBA,GAbA,EANA,UAAAhF,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,IAAAA,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,uBAAA,sBAAAvE,GAEAA,EAAA7B,WjB+9LQ,EACA,CACI,GAAM,GACN,GAAM,KC3+LlB,GAAA,CD++LQ,SAAUZ,EAASU,EAAQD,GkB5+LnC,IAAAgC,IAOA,SAAA7B,GACA,aAuZA,SAAA+vC,EAAAC,GAEA,IADA,IAAAzY,EAAA,CAAA,EACA95B,EAAA,EAAAA,EAAAuyC,EAAAtyC,SAAAD,EACA85B,EAAAyY,EAAAvyC,GAAA+G,gBAAA,EAEA,OAAA+yB,CALA,CArZAv3B,EAAAoD,WAAA,OAAA,SAAAC,EAAAC,GACA,IAAA2sC,EAAA3sC,EAAA2sC,OACA3sC,EAAAosC,mBAAApsC,EAAAtD,EAAAuvC,YAAA,aAEA,IAiBA9kC,EAAAylC,EAjBAvlC,EAAAtH,EAAAsH,WACAwlC,EAAA7sC,EAAA6sC,WACAC,EAAA9sC,EAAA8sC,eAAA,CAAA,EACAP,EAAAvsC,EAAAusC,YAAA,CAAA,EACAC,EAAAxsC,EAAAwsC,eAAA,CAAA,EACAO,EAAA/sC,EAAA+sC,oBAAA,CAAA,EACAX,EAAApsC,EAAAosC,kBAAA,CAAA,EACAY,EAAAhtC,EAAAgtC,6BAAA,CAAA,EACAC,EAAAjtC,EAAAitC,gBAAA,CAAA,EACAC,EAAAltC,EAAAktC,oBAAA,CAAA,EACAZ,EAAAtsC,EAAAssC,eAAA,CAAA,EACAD,EAAArsC,EAAAqsC,eAAA,CAAA,EACAc,EAAAntC,EAAAmtC,YACAn0B,EAAAhZ,EAAAgZ,YACAo0B,GAAA,IAAAptC,EAAAotC,oBACAC,GAAA,IAAAttC,EAAAstC,qCAGA,SAAAl+B,EAAAzQ,EAAA0Q,GAAA,OAAAjI,EAAAiI,EAAA1Q,CAAA,CAIA,SAAA4Q,EAAA1O,EAAAC,GACA,IAAA+G,EAAAhH,EAAAiH,OACA,GAAAglC,EAAAjlC,GAAA,CACA,IAAA0L,EAAAu5B,EAAAjlC,GAAAhH,EAAAC,GACA,IAAA,IAAAyS,EAAA,OAAAA,CAFA,CAIA,MAAA,KAAA1L,GACAhH,EAAAoH,SAAA,YACAmH,EAAA,MAAAvO,EAAAK,YACA,KAAA2G,IAAA,KAAAA,GAAA,KAAAA,IAAAhH,EAAAkH,IAAA,KACAqH,EAAA,KAAA,WACA,KAAAvH,GAAA,KAAAA,GACA/G,EAAA8G,SAAA2lC,EAAA1lC,GACA/G,EAAA8G,SAAA/G,EAAAC,IACA,KAAA+G,GACAhH,EAAAoH,SAAA,YACAmH,EAAA,OAAA,SACA,KAAAvH,GACAhH,EAAA7B,MAAA,WACAoQ,EAAA,UAAA,cACA,KAAAnO,KAAA4G,IAAA,KAAAA,GAAAhH,EAAAkH,IAAA,OACAlH,EAAAoH,SAAA,UACAmH,EAAA,SAAA,SACA,MAAAvH,EAYA,WAAA5G,KAAA4G,GACAuH,EAAA,KAAA,aACA,KAAAvH,GAAAhH,EAAA7B,MAAA,yBACAoQ,EAAA,YAAA,aACA,iBAAAnO,KAAA4G,GACAuH,EAAA,KAAAvH,GACAhH,EAAA7B,MAAA,mBACA,mCAAAiC,KAAAJ,EAAAK,aACAJ,EAAA8G,SAAA4lC,GAEAp+B,EAAA,kBAAA,aACA,WAAAnO,KAAA4G,IACAhH,EAAAoH,SAAA,YACAmH,EAAA,WAAA,SAEAA,EAAA,KAAA,MA1BA,QAAAnO,KAAAJ,EAAA4O,SACA5O,EAAAoH,SAAA,UACAmH,EAAA,SAAA,SACAvO,EAAA7B,MAAA,gBACA6B,EAAAoH,SAAA,YACApH,EAAA7B,MAAA,SAAA,GACAoQ,EAAA,aAAA,uBACAA,EAAA,aAAA,aACAvO,EAAA7B,MAAA,SACAoQ,EAAA,OAAA,aADA,CAhCA,CAsDA,SAAAm+B,EAAAplC,GACA,OAAA,SAAAtH,EAAAC,GAEA,IADA,IAAA+G,EAAA2H,GAAA,EACA,OAAA3H,EAAAhH,EAAAiH,SAAA,CACA,GAAAD,GAAAM,IAAAqH,EAAA,CACA,KAAArH,GAAAtH,EAAAsB,OAAA,GACA,KAFA,CAIAqN,GAAAA,GAAA,MAAA3H,CALA,CAQA,OADAA,GAAAM,IAAAqH,GAAA,KAAArH,KAAArH,EAAA8G,SAAA,MACAwH,EAAA,SAAA,SAVA,CADA,CAeA,SAAAo+B,EAAA3sC,EAAAC,GAMA,OALAD,EAAAiH,OACAjH,EAAA7B,MAAA,eAAA,GAGA8B,EAAA8G,SAAA,KAFA9G,EAAA8G,SAAA2lC,EAAA,KAGAn+B,EAAA,KAAA,IANA,CAWA,SAAAvG,EAAAzB,EAAA9E,EAAA0G,GACAD,KAAA3B,KAAAA,EACA2B,KAAAzG,OAAAA,EACAyG,KAAAC,KAAAA,CAHA,CAMA,SAAAykC,EAAA3sC,EAAAD,EAAAuG,EAAA9E,GAEA,OADAxB,EAAAmI,QAAA,IAAAJ,EAAAzB,EAAAvG,EAAAwJ,gBAAA,IAAA/H,EAAA,EAAAgF,GAAAxG,EAAAmI,SACA7B,CAFA,CAKA,SAAAgC,EAAAtI,GAGA,OAFAA,EAAAmI,QAAAD,OACAlI,EAAAmI,QAAAnI,EAAAmI,QAAAD,MACAlI,EAAAmI,QAAA7B,IAHA,CAMA,SAAAiL,EAAAjL,EAAAvG,EAAAC,GACA,OAAA4sC,EAAA5sC,EAAAmI,QAAA7B,MAAAA,EAAAvG,EAAAC,EADA,CAGA,SAAA6sC,EAAAvmC,EAAAvG,EAAAC,EAAA9E,GACA,IAAA,IAAA5B,EAAA4B,GAAA,EAAA5B,EAAA,EAAAA,IACA0G,EAAAmI,QAAAnI,EAAAmI,QAAAD,KACA,OAAAqJ,EAAAjL,EAAAvG,EAAAC,EAHA,CAQA,SAAA8sC,EAAA/sC,GACA,IAAAuP,EAAAvP,EAAAK,UAAAC,cAEA0rC,EADAP,EAAAlrC,eAAAgP,GACA,OACAm8B,EAAAnrC,eAAAgP,GACA,UAEA,UAPA,CAUA,IAAAs9B,EAAA,CAEAA,IAAA,SAAAtmC,EAAAvG,EAAAC,GACA,GAAA,KAAAsG,EACA,OAAAqmC,EAAA3sC,EAAAD,EAAA,SACA,GAAA,KAAAuG,GAAAtG,EAAAmI,QAAAD,KACA,OAAAI,EAAAtI,GACA,GAAAusC,GAAA,cAAApsC,KAAAmG,GACA,OAAAqmC,EAAA3sC,EAAAD,EAAA,oBACA,GAAA,uBAAAI,KAAAmG,GACA,OAAAqmC,EAAA3sC,EAAAD,EAAA,iBACA,GAAA,+CAAAI,KAAAmG,GACA,OAAAqmC,EAAA3sC,EAAAD,EAAA,WACA,GAAA,+BAAAI,KAAAmG,GAEA,OADAtG,EAAA+sC,SAAAzmC,EACA,4BACA,GAAA,sCAAAnG,KAAAmG,GACA,MAAA,YACA,GAAAA,GAAA,KAAAA,EAAA6J,OAAA,GACA,OAAAw8B,EAAA3sC,EAAAD,EAAA,MACA,GAAA,QAAAuG,EACAylC,EAAA,eACA,GAAA,QAAAzlC,EACAylC,EAAA,UACA,IAAA,uBAAAzlC,EACA,MAAA,YACA,GAAA,iBAAAA,EACA,OAAAqmC,EAAA3sC,EAAAD,EAAA,iBACA,GAAA,KAAAuG,EACA,MAAA,SACA,GAAAgmC,GAAA,KAAAhmC,EACA,OAAAqmC,EAAA3sC,EAAAD,EAAA,SADA,CAGA,OAAAC,EAAAmI,QAAA7B,IA/BA,EAkCAsmC,MAAA,SAAAtmC,EAAAvG,EAAAC,GACA,GAAA,QAAAsG,EAAA,CACA,IAAAgJ,EAAAvP,EAAAK,UAAAC,cACA,OAAAkrC,EAAAjrC,eAAAgP,IACAy8B,EAAA,WACA,aACAI,EAAA7rC,eAAAgP,IACAy8B,EAAAS,EAAA,WAAA,WACA,aACAF,GACAP,EAAAhsC,EAAA7B,MAAA,iBAAA,GAAA,WAAA,MACA,UAEA6tC,GAAA,SACA,YAbA,CAeA,MAAA,QAAAzlC,EACA,QACAgmC,GAAA,QAAAhmC,GAAA,aAAAA,EAIAsmC,EAAAh1B,IAAAtR,EAAAvG,EAAAC,IAHA+rC,EAAA,QACA,QApBA,EA0BAa,UAAA,SAAAtmC,EAAAvG,EAAAC,GACA,MAAA,KAAAsG,EAAAqmC,EAAA3sC,EAAAD,EAAA,QACAwR,EAAAjL,EAAAvG,EAAAC,EAFA,EAKA4sC,KAAA,SAAAtmC,EAAAvG,EAAAC,GACA,GAAA,KAAAsG,EAAA,OAAAgC,EAAAtI,GACA,GAAA,KAAAsG,GAAAgmC,EAAA,OAAAK,EAAA3sC,EAAAD,EAAA,aACA,GAAA,KAAAuG,GAAA,KAAAA,EAAA,OAAAumC,EAAAvmC,EAAAvG,EAAAC,GACA,GAAA,KAAAsG,EAAA,OAAAqmC,EAAA3sC,EAAAD,EAAA,UAEA,GAAA,QAAAuG,GAAA,sDAAAnG,KAAAJ,EAAAK,YAEA,GAAA,QAAAkG,EACAwmC,EAAA/sC,QACA,GAAA,iBAAAuG,EACA,OAAAqmC,EAAA3sC,EAAAD,EAAA,sBAJAgsC,GAAA,SAMA,MAAA,MAbA,EAgBAa,UAAA,SAAAtmC,EAAA0C,EAAAhJ,GACA,MAAA,KAAAsG,EAAAgC,EAAAtI,GACA,QAAAsG,GAAAylC,EAAA,WAAA,aACA/rC,EAAAmI,QAAA7B,IAHA,EAMAsmC,OAAA,SAAAtmC,EAAAvG,EAAAC,GACA,MAAA,KAAAsG,GAAA,KAAAA,EAAAumC,EAAAvmC,EAAAvG,EAAAC,GACA,KAAAsG,EAAAgC,EAAAtI,GACA,KAAAsG,EAAAqmC,EAAA3sC,EAAAD,EAAA,UACA,iBAAAuG,EAAAqmC,EAAA3sC,EAAAD,EAAA,kBACA,QAAAuG,GAAAwmC,EAAA/sC,GACA,SANA,EASA6sC,OAAA,SAAAtmC,EAAAvG,EAAAC,GACA,MAAA,QAAAsG,EAAA,SAEA,QAAAA,GACAylC,EAAA,aACA/rC,EAAAmI,QAAA7B,MAEAiL,EAAAjL,EAAAvG,EAAAC,EAPA,EAUA4sC,cAAA,SAAAtmC,EAAAvG,EAAAC,GACA,MAAA,QAAAsG,GAAA2lC,EAAA3rC,eAAAP,EAAAK,YACA2rC,EAAA,MACA/rC,EAAAmI,QAAA7B,MAEAsmC,EAAAI,QAAA1mC,EAAAvG,EAAAC,EALA,EASA4sC,QAAA,SAAAtmC,EAAAvG,EAAAC,GACA,GAAA,KAAAsG,EAAA,OAAAqmC,EAAA3sC,EAAAD,EAAA,kBACA,GAAA,KAAAuG,GAAA,KAAAA,EAAA,OAAAumC,EAAAvmC,EAAAvG,EAAAC,GACA,GAAA,KAAAsG,EAAA,OAAAgC,EAAAtI,IAAA2sC,EAAA3sC,EAAAD,EAAAusC,EAAA,QAAA,OAEA,GAAA,iBAAAhmC,EAAA,OAAAqmC,EAAA3sC,EAAAD,EAAA,iBAEA,GAAA,QAAAuG,EAAA,CACA,IAAAgJ,EAAAvP,EAAAK,UAAAC,cAEA0rC,EADA,QAAAz8B,GAAA,OAAAA,GAAA,OAAAA,GAAA,MAAAA,EACA,UACAo8B,EAAAprC,eAAAgP,GACA,YACAq8B,EAAArrC,eAAAgP,GACA,WACA48B,EAAA5rC,eAAAgP,GACA,UACAi8B,EAAAjrC,eAAAgP,GACA,WACA68B,EAAA7rC,eAAAgP,GACAk9B,EAAA,WAAA,WACAhB,EAAAlrC,eAAAgP,GACA,OACAm8B,EAAAnrC,eAAAgP,GACA,UAEA,OAnBA,CAqBA,OAAAtP,EAAAmI,QAAA7B,IA5BA,EA+BAsmC,iBAAA,SAAAtmC,EAAAvG,EAAAC,GACA,MAAA,KAAAsG,EACAumC,EAAAvmC,EAAAvG,EAAAC,GACA,KAAAsG,EACAgC,EAAAtI,IAAA2sC,EAAA3sC,EAAAD,EAAAusC,EAAA,QAAA,OAAA,IACA,QAAAhmC,IACAylC,EAAA,SACA/rC,EAAAmI,QAAA7B,KAPA,EAUAsmC,eAAA,SAAAtmC,EAAAvG,EAAAC,GACA,MAAA,KAAAsG,EAAAgC,EAAAtI,GACA,KAAAsG,GAAA,KAAAA,EAAAumC,EAAAvmC,EAAAvG,EAAAC,EAAA,GACA4sC,EAAAI,QAAA1mC,EAAAvG,EAAAC,EAHA,EAMA4sC,0BAAA,SAAAtmC,EAAAvG,EAAAC,GACA,MAAA,KAAAsG,EACAqmC,EAAA3sC,EAAAD,EAAA,sBACA,QAAAuG,GAAA,kBAAAtG,EAAA+sC,UACAhB,EAAA,WACA,6BAEAx6B,EAAAjL,EAAAvG,EAAAC,EAPA,EAUA4sC,mBAAA,SAAAtmC,EAAAvG,EAAAC,GACA,MAAA,KAAAsG,GACAtG,EAAA+sC,SAAA,KACAzkC,EAAAtI,IAEA,QAAAsG,GAGAylC,EAFA,cAAA/rC,EAAA+sC,WAAAX,EAAA9rC,eAAAP,EAAAK,UAAAC,gBACA,kBAAAL,EAAA+sC,WAAAV,EAAA/rC,eAAAP,EAAAK,UAAAC,eACA,QAEA,WACA,aAEA,oBAbA,EAgBAusC,UAAA,SAAAtmC,EAAAvG,EAAAC,GACA,MAAA,QAAAsG,GAAAylC,EAAA,WAAA,aACA,KAAAzlC,EAAAqmC,EAAA3sC,EAAAD,EAAA,OACAwR,EAAAjL,EAAAvG,EAAAC,EAHA,EAMA4sC,GAAA,SAAAtmC,EAAAvG,EAAAC,GACA,MAAA,KAAAsG,EAAAgC,EAAAtI,GACA,KAAAsG,GAAA,KAAAA,EAAAumC,EAAAvmC,EAAAvG,EAAAC,IACA,QAAAsG,EAAAylC,EAAA,MACA,QAAAzlC,IAAAylC,EAAA,WACA,KALA,EAQAa,cAAA,SAAAtmC,EAAAvG,EAAAC,GACA,MAAA,KAAAsG,EAAAgC,EAAAtI,GACA,KAAAsG,GAAA,KAAAA,EAAAumC,EAAAvmC,EAAAvG,EAAAC,IACA,QAAAsG,EAAAylC,EAAA,WACA,YAAAzlC,GAAA,KAAAA,GAAA,KAAAA,IAAAylC,EAAA,SACA,gBALA,GAQA,MAAA,CACAxqC,WAAA,SAAAe,GACA,MAAA,CAAAwE,SAAA,KACA9G,MAAA8rC,EAAA,QAAA,MACAiB,SAAA,KACA5kC,QAAA,IAAAJ,EAAA+jC,EAAA,QAAA,MAAAxpC,GAAA,EAAA,MAJA,EAOArC,MAAA,SAAAF,EAAAC,GACA,IAAAA,EAAA8G,UAAA/G,EAAAyJ,WAAA,OAAA,KACA,IAAA3L,GAAAmC,EAAA8G,UAAA2H,GAAA1O,EAAAC,GAQA,OAPAnC,GAAA,UAAAvD,QAAAuD,KACAyI,EAAAzI,EAAA,GACAA,EAAAA,EAAA,IAEAkuC,EAAAluC,EACA,WAAAyI,IACAtG,EAAAA,MAAA4sC,EAAA5sC,EAAAA,OAAAsG,EAAAvG,EAAAC,IACA+rC,CAVA,EAaAvqC,OAAA,SAAAxB,EAAA4B,GACA,IAAAyI,EAAArK,EAAAmI,QAAApB,EAAAnF,GAAAA,EAAAuO,OAAA,GACA3O,EAAA6I,EAAA7I,OAcA,MAbA,QAAA6I,EAAA/D,MAAA,KAAAS,GAAA,KAAAA,IAAAsD,EAAAA,EAAAnC,MACAmC,EAAAnC,OACA,KAAAnB,GAAA,SAAAsD,EAAA/D,MAAA,OAAA+D,EAAA/D,MACA,iBAAA+D,EAAA/D,MAAA,sBAAA+D,EAAA/D,MAIA,KAAAS,GAAA,UAAAsD,EAAA/D,MAAA,kBAAA+D,EAAA/D,QACA,KAAAS,GAAA,MAAAsD,EAAA/D,MAAA,WAAA+D,EAAA/D,QAEA9E,EAAAyZ,KAAAC,IAAA,EAAA7Q,EAAA7I,OAAAgF,IAJAhF,GADA6I,EAAAA,EAAAnC,MACA1G,QAOAA,CAhBA,EAmBAyrC,cAAA,IACAnjC,kBAAA,KACAC,gBAAA,KACAmO,qBAAA,MACAC,YAAAA,EACAC,KAAA,QAjZA,IA6ZA,IAAA80B,EAAA,CACA,SAAA,SAAA,MAAA,cACAjB,EAAAL,EAAAsB,GAEAC,EAAA,CACA,MAAA,QAAA,UAAA,WAAA,QAAA,aAAA,SACA,MAAA,KAAA,YACAzB,EAAAE,EAAAuB,GAEAC,EAAA,CACA,QAAA,YAAA,YAAA,SAAA,aAAA,aACA,eAAA,mBAAA,mBAAA,gBACA,oBAAA,oBAAA,eACA,mBAAA,mBAAA,sBACA,0BAAA,0BAAA,QAAA,YACA,YAAA,cAAA,kBAAA,kBACA,aAAA,iBAAA,iBAAA,aACA,iBAAA,iBAAA,OAAA,OAAA,cACA,qBAAA,yBAAA,yBACA,UAAA,cAAA,QAAA,YAAA,uBACA,gBAAA,uBACAzB,EAAAC,EAAAwB,GAEAC,EAAA,CACA,YAAA,WAAA,OAAA,SAAA,OAAA,YAAA,QACA,YAAA,cACA,OAAA,QACA,WAAA,QACAnB,EAAAN,EAAAyB,GAEAC,EAAA,CACA,gBAAA,cAAA,aAAA,mBACA,qBAAA,MAAA,eAAA,YAAA,kBACA,sBAAA,qBAAA,sBACA,4BAAA,iBAAA,uBACA,4BAAA,aAAA,UAAA,kBACA,sBAAA,aAAA,wBACA,wBAAA,kBAAA,mBACA,mBAAA,oBAAA,sBACA,wBAAA,wBAAA,oBACA,kBAAA,iBAAA,UAAA,QAAA,aACA,iBAAA,iBAAA,iBAAA,kBACA,SAAA,gBAAA,sBAAA,4BACA,6BAAA,sBAAA,sBACA,kBAAA,eAAA,eAAA,sBACA,sBAAA,qBAAA,sBACA,qBAAA,cAAA,oBAAA,oBACA,oBAAA,gBAAA,eAAA,qBACA,qBAAA,qBAAA,iBAAA,eACA,aAAA,mBAAA,yBACA,0BAAA,mBAAA,mBACA,eAAA,SAAA,uBAAA,aAAA,aACA,cAAA,eAAA,eAAA,eAAA,cACA,QAAA,OAAA,QAAA,gBAAA,eAAA,cACA,aAAA,cAAA,oBAAA,oBACA,oBAAA,cAAA,eAAA,UAAA,UACA,UAAA,oBAAA,gBAAA,OAAA,MAAA,YACA,aAAA,SAAA,YAAA,UAAA,oBACA,4BAAA,2BACA,6BAAA,4BAAA,oBACA,qBAAA,YAAA,cAAA,MAAA,cAAA,eACA,OAAA,aAAA,iBAAA,YAAA,YACA,cAAA,YAAA,QAAA,eAAA,YAAA,YACA,OAAA,cAAA,wBAAA,eACA,yBAAA,sBAAA,YACA,mBAAA,eAAA,aAAA,iBACA,eAAA,0BAAA,oBACA,0BAAA,yBAAA,uBACA,wBAAA,0BAAA,cAAA,MACA,OAAA,YAAA,oBAAA,iBAAA,iBACA,cAAA,kBAAA,kBAAA,oBACA,WAAA,WAAA,eAAA,eAAA,iBACA,gBAAA,sBAAA,wBACA,qBAAA,sBAAA,SAAA,UAAA,OACA,oBAAA,kBAAA,mBAAA,mBACA,QAAA,cAAA,kBAAA,oBAAA,eACA,mBAAA,qBAAA,YAAA,kBACA,gBAAA,eAAA,OAAA,iBAAA,aACA,cAAA,mBAAA,gBAAA,qBACA,sBAAA,yBAAA,aACA,mBAAA,sBAAA,kBAAA,SACA,gBAAA,cAAA,eAAA,aAAA,QACA,oBAAA,eAAA,qBAAA,gBACA,gBAAA,YAAA,iBAAA,aAAA,YACA,cAAA,gBAAA,cAAA,YAAA,YACA,iBAAA,aAAA,kBACA,YAAA,iBAAA,aAAA,kBAAA,YACA,iBAAA,UAAA,WAAA,YAAA,WAAA,YACA,SAAA,aAAA,kBAAA,SAAA,gBACA,kBAAA,cAAA,kBAAA,gBACA,UAAA,QAAA,UAAA,UAAA,gBAAA,iBACA,gBAAA,gBAAA,WAAA,iBACA,gBAAA,aAAA,aAAA,UAAA,iBACA,eAAA,gBAAA,cAAA,OAAA,mBACA,oBAAA,oBAAA,cAAA,QACA,cAAA,eAAA,cAAA,qBAAA,QACA,cAAA,gBAAA,cAAA,aAAA,cACA,WAAA,qBAAA,mBAAA,SACA,qBAAA,sBAAA,sBACA,kBAAA,mBAAA,SAAA,OAAA,aACA,cAAA,WAAA,QAAA,SAAA,WAAA,iBACA,UAAA,aAAA,gBAAA,gBAAA,YACA,QAAA,kBAAA,gBAAA,sBACA,0BAAA,4BAAA,uBACA,uBAAA,2BACA,6BAAA,qBAAA,sBACA,oBAAA,iBAAA,uBACA,2BAAA,6BACA,wBAAA,wBAAA,4BACA,8BAAA,sBAAA,uBACA,qBAAA,oBAAA,mBACA,wBAAA,eAAA,eAAA,gBACA,OAAA,QAAA,WAAA,eAAA,gBACA,oBAAA,cAAA,SAAA,aAAA,WACA,eAAA,SAAA,cAAA,aAAA,kBACA,aAAA,kBAAA,uBAAA,kBACA,wBAAA,uBAAA,uBACA,2BAAA,wBAAA,gBACA,sBAAA,yBAAA,sBACA,cAAA,cAAA,eAAA,mBACA,eAAA,gBAAA,iBAAA,cACA,mBAAA,sBAAA,iBACA,0BAAA,YAAA,MAAA,eAAA,YAAA,mBACA,kBAAA,aAAA,mBAAA,sBACA,sBAAA,6BAAA,YACA,eAAA,cAAA,iBAAA,aAAA,gBACA,iBAAA,eAAA,cAAA,cAAA,aACA,eAAA,eAAA,SAAA,cAAA,SAAA,QACA,cAAA,aAAA,eAAA,YAAA,eAAA,UAEA,YAAA,YAAA,OAAA,oBAAA,SAAA,cACA,gBAAA,iBAAA,aAAA,eAAA,iBACA,sBAAA,8BACA,kBAAA,OAAA,eAAA,YAAA,kBACA,SAAA,aAAA,aAAA,eAAA,cAAA,kBAAA,SACA,mBAAA,oBAAA,iBAAA,kBACA,oBAAA,iBAAA,eAAA,iBACA,iBAAA,oBAAA,+BACA,6BAAA,cAAA,gBACA/B,EAAAK,EAAA0B,GAEAC,EAAA,CACA,eAAA,eAAA,eAAA,qBAAA,mBACA,yBAAA,yBAAA,yBACA,qBAAA,2BAAA,2BACA,2BAAA,qBAAA,qBACA,gBAAA,sBAAA,oBACA,0BAAA,0BACA,0BAAA,sBAAA,4BACA,4BAAA,4BACA,sBAAA,sBAAA,qBAAA,eACA,mBAAA,qBAAA,gBAAA,oBACA,sBAAA,kBAAA,sBAAA,gBAAA,oBACA,sBAAA,iBAAA,qBACA,uBAAA,mBAAA,2BACA,wBAAA,uBAAA,8BACA,uBAAA,4BAAA,yBACA,wBAAA,4BAAA,yBACA,6BAAA,iCAAA,eAAA,QACApB,EAAAP,EAAA2B,GAKAnB,EAAAR,EAHA,CACA,eAAA,cAAA,MAAA,gBAAA,eACA,wBAAA,eAAA,cAAA,eAMAS,EAAAT,EAHA,CACA,mBAAA,WAAA,WAAA,MAAA,SAAA,QACA,WAAA,SAAA,UAAA,WAGA4B,EAAA,CACA,YAAA,eAAA,OAAA,aAAA,QAAA,QACA,SAAA,QAAA,iBAAA,OAAA,aAAA,QACA,YAAA,YAAA,aAAA,YAAA,QAAA,iBACA,WAAA,UAAA,OAAA,WAAA,WAAA,gBACA,WAAA,YAAA,WAAA,YAAA,cAAA,iBACA,aAAA,aAAA,UAAA,aAAA,eACA,gBAAA,gBAAA,gBAAA,gBAAA,aACA,WAAA,cAAA,UAAA,UAAA,aAAA,YACA,cAAA,cAAA,UAAA,YAAA,aACA,OAAA,YAAA,OAAA,OAAA,QAAA,cAAA,WACA,UAAA,YAAA,SAAA,QAAA,QAAA,WACA,gBAAA,YAAA,eAAA,YAAA,aACA,YAAA,uBAAA,YAAA,aAAA,YAAA,YACA,cAAA,gBAAA,eAAA,iBAAA,iBACA,iBAAA,cAAA,OAAA,YAAA,QAAA,UACA,SAAA,mBAAA,aAAA,eAAA,eACA,iBAAA,kBAAA,oBAAA,kBACA,kBAAA,eAAA,YAAA,YAAA,WACA,cAAA,OAAA,UAAA,QAAA,YAAA,SAAA,YACA,SAAA,gBAAA,YAAA,gBAAA,gBACA,aAAA,YAAA,OAAA,OAAA,OAAA,aACA,SAAA,gBAAA,MAAA,YAAA,YAAA,cACA,SAAA,aAAA,WAAA,WAAA,SAAA,SAAA,UACA,YAAA,YAAA,YAAA,OAAA,cAAA,YAAA,MACA,OAAA,UAAA,SAAA,YAAA,SAAA,QAAA,QACA,aAAA,SAAA,eACA/B,EAAAG,EAAA4B,GAEAC,EAAA,CACA,QAAA,WAAA,eAAA,WAAA,gBAAA,OACA,oBAAA,QAAA,QAAA,MAAA,aAAA,aAAA,YACA,SAAA,UAAA,kBAAA,cAAA,eACA,eAAA,WAAA,YAAA,OAAA,OAAA,YAAA,QAAA,eAAA,aACA,eAAA,WAAA,aAAA,YAAA,WAAA,QAAA,gBAAA,SACA,UAAA,QAAA,QAAA,aAAA,OAAA,OAAA,SAAA,SAAA,aACA,OAAA,SAAA,QAAA,YAAA,aAAA,aAAA,UAAA,SACA,aAAA,kBAAA,eAAA,aAAA,OAAA,YACA,aAAA,sBAAA,UAAA,cAAA,QACA,OAAA,SAAA,WAAA,SAAA,cAAA,qBACA,oBAAA,kBAAA,QAAA,OAAA,cACA,aAAA,WAAA,QAAA,aAAA,cAAA,SAAA,iBACA,UAAA,YAAA,iBAAA,UAAA,UAAA,WACA,cAAA,eAAA,aAAA,WAAA,OAAA,UAAA,WAAA,QAAA,OACA,QAAA,YAAA,eAAA,eAAA,UAAA,SAAA,SAAA,SAAA,UACA,uBAAA,UAAA,iBAAA,QAAA,mBACA,iBAAA,kBAAA,mBAAA,aAAA,aACA,OAAA,UAAA,oBAAA,kBAAA,WACA,WAAA,eACA,SAAA,SAAA,OAAA,cAAA,WAAA,OAAA,UAAA,cAAA,WACA,UAAA,UAAA,WAAA,QAAA,MAAA,WAAA,mBACA,yBAAA,uBAAA,yBACA,yBAAA,0BACA,0BAAA,0BACA,wBAAA,0BACA,2BAAA,0BACA,0BAAA,0BAAA,wBACA,mBAAA,YAAA,YAAA,WAAA,UAAA,kBACA,iBAAA,UAAA,OAAA,OAAA,WAAA,QAAA,OAAA,OAAA,WAAA,aAAA,YACA,WAAA,OAAA,qBAAA,WAAA,YAAA,WAAA,OAAA,SACA,WAAA,WAAA,OAAA,SAAA,mBAAA,aAAA,SACA,OAAA,SAAA,OAAA,SAAA,YAAA,gBACA,WAAA,iBAAA,aAAA,MAAA,OAAA,MAAA,aAAA,OAAA,SACA,iBAAA,kBAAA,sBAAA,WACA,iBAAA,WAAA,UAAA,UAAA,SAAA,cACA,eAAA,cAAA,cAAA,eAAA,QAAA,SAAA,YAAA,SACA,SAAA,kBAAA,oBAAA,UAAA,UACA,WAAA,iBAAA,WAAA,QACA,uBAAA,sBAAA,wBACA,YAAA,MAAA,QAAA,SAAA,OAAA,QAAA,UAAA,UACA,eAAA,SAAA,kBAAA,QAAA,YAAA,UAAA,WACA,QAAA,UAAA,OAAA,QAAA,cAAA,iBACA,cAAA,oBAAA,cAAA,kBACA,cAAA,YAAA,MAAA,aAAA,YAAA,eAAA,QAAA,SAAA,WACA,oBAAA,eAAA,oBACA,sBAAA,2BAAA,SACA,OAAA,WAAA,kBACA,WAAA,cAAA,SAAA,gBACA,MAAA,YAAA,YAAA,OAAA,WAAA,uBAAA,WAAA,UAAA,WACA,WAAA,YAAA,cAAA,iBAAA,UACA,gBAAA,YAAA,OAAA,SAAA,cAAA,SACA,YAAA,UAAA,UAAA,YAAA,cAAA,UAAA,QAAA,UAAA,aACA,qBAAA,gBAAA,QAAA,QAAA,SACA,UAAA,gBAAA,UAAA,WAAA,UAAA,cACA,UAAA,OAAA,SAAA,UAAA,cAAA,aAAA,cAAA,eACA,UAAA,UAAA,WAAA,MAAA,WAAA,WAAA,cACA,WAAA,cAAA,kBAAA,QAAA,YACA,aAAA,4BAAA,YAAA,SACA,WAAA,SAAA,4BAAA,4BACA,2BAAA,WAAA,WAAA,QAAA,UACA,MAAA,OAAA,QAAA,QAAA,SAAA,WAAA,UAAA,UACA,UAAA,QAAA,MAAA,aAAA,cAAA,MAAA,SAAA,UACA,WAAA,aAAA,WAAA,aAAA,QAAA,UAAA,SAAA,SAAA,SAAA,SACA,SAAA,YAAA,kBAAA,YAAA,cACA,4BAAA,yBACA,6BAAA,iCAAA,aAAA,WACA,iBAAA,gBAAA,WAAA,QAAA,QAAA,OAAA,SACA,sBAAA,wBAAA,SACA,OAAA,QAAA,QAAA,mBAAA,QAAA,oBACA,kBAAA,yBAAA,uBAAA,OACA,QAAA,aAAA,gBAAA,UAAA,aAAA,QAAA,SACA,cAAA,YAAA,aAAA,cAAA,QAAA,eAAA,gBAAA,eAAA,YAAA,SACA,gBAAA,QAAA,SAAA,aAAA,UAAA,SAAA,aAAA,MACA,uBAAA,YAAA,QAAA,YAAA,WAAA,UAAA,YAAA,QACA,gBAAA,aAAA,eAAA,qBACA,qBAAA,qBAAA,YAAA,kBACA,QACA,SAAA,OAAA,cAAA,WAAA,WAAA,YAAA,OACA,QAAA,OAAA,mBAAA,aAAA,kBACA,oBAAA,eAAA,UAAA,QAAA,cACA,sBAAA,cAAA,sBAAA,KAAA,MACA,sBAAA,wBAAA,YACA,YAAA,cAAA,aAAA,aAAA,aACA,cAAA,kBAAA,iBAAA,YAAA,qBAAA,QAAA,KACA,cAAA,iBAAA,cAAA,oBACA,cAAA,kBAAA,cAAA,YAAA,OAAA,MACA,MAAA,WAAA,gBAAA,WAAA,UAAA,cAAA,iBACA,gBAAA,SAAA,WAAA,OAAA,OAAA,QACA,SAAA,cAAA,aAAA,QAAA,OAAA,eAAA,UAAA,UAAA,MACA,WAAA,YACAjC,EAAAI,EAAA6B,GAEAC,EAAAR,EAAA3nB,OAAA4nB,GAAA5nB,OAAA6nB,GAAA7nB,OAAA8nB,GACA9nB,OAAA+nB,GAAA/nB,OAAAgoB,GAAAhoB,OAAAioB,GACAjoB,OAAAkoB,GAGA,SAAAE,EAAA5tC,EAAAC,GAEA,IADA,IAAA+G,EAAA0I,GAAA,EACA,OAAA1I,EAAAhH,EAAAiH,SAAA,CACA,GAAAyI,GAAA,KAAA1I,EAAA,CACA/G,EAAA8G,SAAA,KACA,KAFA,CAIA2I,EAAA,KAAA1I,CALA,CAOA,MAAA,CAAA,UAAA,UATA,CAFAlL,EAAA2c,eAAA,YAAA,MAAAk1B,GAcA7xC,EAAAmG,WAAA,WAAA,CACAiqC,cAAAA,EACAP,WAAAA,EACAC,cAAAA,EACAO,mBAAAA,EACAX,iBAAAA,EACAY,4BAAAA,EACAC,eAAAA,EACAC,mBAAAA,EACAZ,cAAAA,EACAD,cAAAA,EACAQ,WAAA,CACA,IAAA,SAAAjsC,EAAAC,GACA,QAAAD,EAAAkH,IAAA,OACAjH,EAAA8G,SAAA6mC,EACAA,EAAA5tC,EAAAC,GAHA,GAMAV,KAAA,QAGAzD,EAAAmG,WAAA,cAAA,CACA0pC,WAAAA,EACAC,cAAAA,EACAO,mBAAAA,EACAX,iBAAAA,EACAY,4BAAAA,EACAV,cAAAA,EACAD,cAAAA,EACAY,eAAAA,EACAE,aAAA,EACAn0B,YAAA,KACA6zB,WAAA,CACA,IAAA,SAAAjsC,EAAAC,GACA,OAAAD,EAAAkH,IAAA,MACAlH,EAAA8O,YACA,CAAA,UAAA,YACA9O,EAAAkH,IAAA,MACAjH,EAAA8G,SAAA6mC,EACAA,EAAA5tC,EAAAC,IAEA,CAAA,WAAA,WARA,EAWA,IAAA,SAAAD,GACA,QAAAA,EAAA7B,MAAA,UAAA,IACA,CAAA,KAAA,KAFA,EAKAtC,EAAA,SAAAmE,GAEA,OADAA,EAAA7B,MAAA,WACA6B,EAAA7B,MAAA,SAAA,GACA,CAAA,aAAA,uBACA,CAAA,aAAA,WAJA,EAMA,IAAA,SAAA6B,GACA,QAAAA,EAAAkH,IAAA,MACA,CAAA,KAAA,gBAFA,GAKA3H,KAAA,MACA2K,WAAA,SAGApO,EAAAmG,WAAA,cAAA,CACA0pC,WAAAA,EACAC,cAAAA,EACAO,mBAAAA,EACAX,iBAAAA,EACAY,4BAAAA,EACAV,cAAAA,EACAD,cAAAA,EACAY,eAAAA,EACAE,aAAA,EACAn0B,YAAA,KACA6zB,WAAA,CACA,IAAA,SAAAjsC,EAAAC,GACA,OAAAD,EAAAkH,IAAA,MACAlH,EAAA8O,YACA,CAAA,UAAA,YACA9O,EAAAkH,IAAA,MACAjH,EAAA8G,SAAA6mC,EACAA,EAAA5tC,EAAAC,IAEA,CAAA,WAAA,WARA,EAWA,IAAA,SAAAD,GACA,OAAAA,EAAAkH,IAAA,KAAA,CAAA,KAAA,kBACAlH,EAAA7B,MAAA,yGAAA,KACA6B,EAAAoH,SAAA,YACApH,EAAA7B,MAAA,SAAA,GACA,CAAA,aAAA,uBACA,CAAA,aAAA,YANA,EAQA,IAAA,WACA,MAAA,CAAA,OAAA,OADA,GAIAoB,KAAA,MACA2K,WAAA,SAGApO,EAAAmG,WAAA,aAAA,CACAiqC,cAAAA,EACAP,WAAAA,EACAC,cAAAA,EACAJ,iBAAAA,EACAY,4BAAAA,EACAC,eAAAA,EACAC,mBAAAA,EACAZ,cAAAA,EACAD,cAAAA,EACAe,qBAAA,EACAP,WAAA,CACA,IAAA,SAAAjsC,EAAAC,GACA,QAAAD,EAAAkH,IAAA,OACAjH,EAAA8G,SAAA6mC,EACAA,EAAA5tC,EAAAC,GAHA,GAMAV,KAAA,MACA2K,WAAA,OAh1BA,EANA,UAAA3P,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WlByyPQ,EACA,CAAE,GAAM,KCnzPhB,GAAA,CDszPQ,SAAUZ,EAASU,EAAQD,GmBnzPnC,IAAAgC,IAOA,SAAA7B,GACA,aAEA,IAAA+xC,EAAA,SAEA/xC,EAAA2c,eAAA,OAAA,WAAA,SAAAid,EAAA7Z,GAKA,IAJA,IAAAtM,EAAAsM,GAAAA,EAAAtM,MAAAs+B,EACA10B,EAAA0C,GAAAA,EAAA1C,OAJA,IAKAhY,EAAAu0B,EAAAV,YAAA8Y,EAAApY,EAAAR,QAAA/zB,EAAAW,MACA8T,EAAAzU,EAAA6F,GAAAqI,EAAAuG,EACAvG,GAAAE,EAAAnP,KAAA0tC,EAAA19B,OAAAf,EAAA,OAAAA,EAKA,IAJA,IAAA0+B,EAAA1+B,GAAAuG,GAAAk4B,EAAA1+B,MAAAC,EAAAuG,GAEAhE,EAAAiK,GAAAA,EAAAjK,MAAA,GAAAo8B,EAAA,CAAA,EACAC,EAAA,IAAA5vC,OAAAkR,EAAAvQ,OAAA,KACA0F,GAAA,EAAAA,GAAA,EAAAA,GAAA,EAEA,IADA,IAAA5C,EAAAX,EAAAW,KAAAohB,EAAAhI,KAAAK,IAAAL,KAAAC,IAAArZ,EAAA4C,EAAAyU,EAAAuc,EAAAwY,aAAAxY,EAAAyY,YAAAzpC,EACA5C,GAAAohB,EAAAphB,GAAA4C,EAEA,IADA,IAAAsL,EAAA/R,EAAAy3B,EAAAR,QAAApzB,GACAkO,EAAAi+B,EAAA1vC,KAAAN,IACA6D,GAAAX,EAAAW,MAAAkO,EAAA,KAAA+9B,GACAA,GAAA,GAAA/9B,EAAA,GAAAyvB,YAAAsO,EAAA,IAAAl0C,OAAAO,UAAAmG,eAAA1F,KAAAmzC,EAAAh+B,EAAA,MACAg+B,EAAAh+B,EAAA,KAAA,EACA4B,EAAArH,KAAAyF,EAAA,KAKA,MAAA,CAAA4B,KAAAA,EAAAhT,KAAA9C,EAAAgkB,IAAA3e,EAAAW,KAAAuN,GAAAxQ,GAAA/C,EAAAgkB,IAAA3e,EAAAW,KAAA8T,GAvBA,GALA,EANA,UAAArb,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WnBu1PQ,EACA,CAAE,GAAM,KCj2PhB,GAAA,CDo2PQ,SAAUZ,EAASU,EAAQD,GoBj2PnC,IAAAgC,IAOA,SAAA7B,GACAA,EAAAke,aAAA,qBAAA,GAAA,SAAA9d,EAAAmB,EAAA8K,GACAA,GAAArM,EAAAoe,OAAA/R,GAAA,GACAA,IAAA9K,EACAnB,EAAAkyC,cAAA,kBACAjmC,GAAA9K,GACAnB,EAAAmyC,WAAA,CACAnuC,MAAA,SAAAF,GACA,IAAA,IAAAtE,EAAAsE,EAAAmP,OAAA3V,OAAAD,EAAAmC,EAAAnC,GAAA,KAAA6G,KAAAJ,EAAAmP,OAAAiB,OAAA7W,EAAA,MAAAA,GACA,OAAAA,EAAAyG,EAAAmQ,KAAAnQ,EAAAmQ,IAAA5W,EAAA,OACAyG,EAAAmQ,IAAAzU,EACA,gBAJA,EAMA6D,KAAA,iBAZA,GADA,EANA,UAAAhF,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WpBy3PQ,EACA,CAAE,GAAM,KCn4PhB,GAAA,CDs4PQ,SAAUZ,EAASU,EAAQD,GqBn4PnC,IAAAgC,IAOA,SAAA7B,GACA,aAgBA,SAAAmjB,EAAA/iB,GACAA,EAAA+D,MAAAquC,QAAApyC,EAAA+D,MAAAquC,OAAArvB,QACA/iB,EAAA+D,MAAAsuC,UAAAryC,EAAA+D,MAAAsuC,SAAAtvB,QACA/iB,EAAA+D,MAAAquC,OAAApyC,EAAA+D,MAAAsuC,SAAA,IAHA,CAMA,SAAAC,EAAAtyC,GACAA,EAAA+D,MAAAwuC,gBAAA,EACAvyC,EAAA0d,WAAA,WAEA,GADAqF,EAAA/iB,IACAA,EAAA+5B,oBAAA,CACA,IAAA90B,EAAAjF,EAAA84B,YAAA7b,EAAAjd,EAAAwyC,cACAv1B,EAAAva,KAAAsc,KAAAK,IAAApC,EAAAva,KAAAuC,EAAAW,MAAAqX,EAAAta,GAAAqc,KAAAC,IAAAha,EAAAW,KAAA,EAAAqX,EAAAta,IACA,IAAAV,EAAArC,EAAA6yC,gBAAAzyC,EAAAiF,EAAAgY,GACA,GAAAhb,EAAA,CACA,GAAAjC,EAAA+D,MAAA2uC,cAAA,CACA,IAAAC,EAAA,QAAA1wC,EAAA2wC,GAAA3wC,EAAAmlC,KAAAnlC,EAAAiD,MACAytC,IAAA3yC,EAAA+D,MAAAquC,OAAApyC,EAAA0kB,SAAAiuB,EAAAjwC,KAAAiwC,EAAAhwC,GAAA,CAAA0U,UAAA,2BAFA,CAIA,IAAAw7B,EAAA,SAAA5wC,EAAA2wC,GAAA3wC,EAAAmlC,KAAAnlC,EAAAiD,MACA2tC,EACA7yC,EAAA+D,MAAAsuC,SAAAryC,EAAA0kB,SAAAmuB,EAAAnwC,KAAAmwC,EAAAlwC,GAAA,CAAA0U,UAAA,2BAEArX,EAAA+D,MAAAwuC,gBAAA,CATA,CAJA,CAFA,GAFA,CAqBA,SAAAO,EAAA9yC,GACAA,EAAA+D,MAAAwuC,gBAAAD,EAAAtyC,EADA,CAzCAJ,EAAAke,aAAA,aAAA,GAAA,SAAA9d,EAAAmB,EAAA4c,GACAA,GAAAA,GAAAne,EAAAoe,OACAhe,EAAAie,IAAA,iBAAAq0B,GACAtyC,EAAAie,IAAA,iBAAA60B,GACA/vB,EAAA/iB,IAEAmB,IACAnB,EAAA+D,MAAA2uC,cAAA,UAAAr0C,QAAA8C,IAAAA,EAAA4xC,SACA/yC,EAAAwB,GAAA,iBAAA8wC,GACAtyC,EAAAwB,GAAA,iBAAAsxC,GACAR,EAAAtyC,GAVA,IA6CAJ,EAAA2iC,SAAAyQ,cAAA,SAAAhzC,GACA,IAAAglB,EAAAplB,EAAA6yC,gBAAAzyC,EAAAA,EAAA84B,aACA,GAAA9T,EAAA,CACA,IAAA6tB,EAAA,SAAA7tB,EAAA4tB,GAAA5tB,EAAAoiB,KAAApiB,EAAA9f,MACA2tC,GAAA7yC,EAAAizC,gBAAAJ,EAAAlwC,GAAAkwC,EAAAnwC,KAFA,CAFA,CAhDA,EANA,UAAArE,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,IAAAA,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,uBAAA,oBAAAvE,GAEAA,EAAA7B,WrBm8PQ,EACA,CACI,GAAM,GACN,GAAM,KC/8PlB,GAAA,CDm9PQ,SAAUZ,EAASU,EAAQD,GsBh9PnC,IAAAgC,IAOA,SAAA7B,GACA,IAAAszC,EAAA,UAAAhvC,KAAA46B,UAAAqU,aACA,MAAAt0B,SAAAu0B,cAAAv0B,SAAAu0B,aAAA,GAEAxvB,EAAAhkB,EAAAgkB,IAEAyvB,EAAA,CAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,KAAA,IAAA,MAEA,SAAAC,EAAArwC,GACA,OAAAA,GAAAA,EAAAqwC,cAAA,WADA,CAIA,SAAAC,EAAAvzC,EAAAwzC,EAAAvwC,GACA,IAAA2C,EAAA5F,EAAAyzC,cAAAD,EAAA5tC,MAAAqO,EAAAu/B,EAAA1oC,GAAA,EACA4oC,EAAAzwC,GAAAA,EAAAywC,YACA,MAAAA,IACAA,EAAA,0BAAAxvC,KAAAlE,EAAA+f,oBAAA1I,YACA,IAAA06B,EAAAuB,EAAArwC,GAMAhB,GAAAyxC,GAAAz/B,GAAA,GAAA89B,EAAA7tC,KAAA0B,EAAA7D,KAAAmS,OAAAD,KAAAo/B,EAAAztC,EAAA7D,KAAAmS,OAAAD,KACA89B,EAAA7tC,KAAA0B,EAAA7D,KAAAmS,OAAAD,EAAA,KAAAo/B,EAAAztC,EAAA7D,KAAAmS,SAAAD,IACA,IAAAhS,EAAA,OAAA,KACA,IAAAuG,EAAA,KAAAvG,EAAAiS,OAAA,GAAA,GAAA,EACA,GAAAjR,GAAAA,EAAA0wC,QAAAnrC,EAAA,IAAAyL,GAAAu/B,EAAA1oC,IAAA,OAAA,KACA,IAAAlJ,EAAA5B,EAAA4zC,eAAAhwB,EAAA4vB,EAAA5tC,KAAAqO,EAAA,IAEA+Q,EAAA6uB,EAAA7zC,EAAA4jB,EAAA4vB,EAAA5tC,KAAAqO,GAAAzL,EAAA,EAAA,EAAA,IAAAA,EAAA5G,EAAAqB,GACA,OAAA,MAAA+hB,EAAA,KACA,CAAAtiB,KAAAkhB,EAAA4vB,EAAA5tC,KAAAqO,GAAAtR,GAAAqiB,GAAAA,EAAA/Q,IACAhS,MAAA+iB,GAAAA,EAAAla,IAAA7I,EAAAiS,OAAA,GAAA4/B,QAAAtrC,EAAA,EArBA,CA+BA,SAAAqrC,EAAA7zC,EAAAwzC,EAAAhrC,EAAA5G,EAAAqB,GAQA,IAPA,IAAA8wC,EAAA9wC,GAAAA,EAAA+wC,mBAAA,IACAC,EAAAhxC,GAAAA,EAAAgxC,cAAA,IAEA1hB,EAAA,GACAwf,EAAAuB,EAAArwC,GACAixC,EAAA1rC,EAAA,EAAAwW,KAAAK,IAAAm0B,EAAA5tC,KAAAquC,EAAAj0C,EAAAiyC,WAAA,GACAjzB,KAAAC,IAAAjf,EAAAgyC,YAAA,EAAAwB,EAAA5tC,KAAAquC,GACAE,EAAAX,EAAA5tC,KAAAuuC,GAAAD,EAAAC,GAAA3rC,EAAA,CACA,IAAA5C,EAAA5F,EAAAg5B,QAAAmb,GACA,GAAAvuC,EAAA,CACA,IAAAqO,EAAAzL,EAAA,EAAA,EAAA5C,EAAAtI,OAAA,EAAAoc,EAAAlR,EAAA,EAAA5C,EAAAtI,QAAA,EACA,KAAAsI,EAAAtI,OAAAy2C,GAEA,IADAI,GAAAX,EAAA5tC,OAAAqO,EAAAu/B,EAAA1oC,IAAAtC,EAAA,EAAA,EAAA,IACAyL,GAAAyF,EAAAzF,GAAAzL,EAAA,CACA,IAAAsC,EAAAlF,EAAAsO,OAAAD,GACA,GAAA89B,EAAA7tC,KAAA4G,UAAA2G,IAAA7P,IACA5B,EAAA4zC,eAAAhwB,EAAAuwB,EAAAlgC,EAAA,KAAA,MAAArS,GAAA,KAAA,CACA,IAAAK,EAAAoxC,EAAAvoC,GACA,GAAA7I,GAAA,KAAAA,EAAAiS,OAAA,IAAA1L,EAAA,EAAA+pB,EAAAlkB,KAAAvD,OACA,KAAAynB,EAAAj1B,OAAA,MAAA,CAAA2W,IAAA2P,EAAAuwB,EAAAlgC,GAAAnJ,GAAAA,GACAynB,EAAArd,KAAA,CAJA,CAHA,CAJA,CAFA,CAiBA,OAAAi/B,EAAA3rC,IAAAA,EAAA,EAAAxI,EAAAiyC,WAAAjyC,EAAAgyC,cAAA,IAzBA,CA4BA,SAAAoC,EAAAp0C,EAAAq0C,EAAApxC,GAKA,IAHA,IAAAqxC,EAAAt0C,EAAA+D,MAAAqwC,cAAAG,wBAAA,IACAC,EAAAvxC,GAAAA,EAAAuxC,qBACAC,EAAA,GAAA13B,EAAA/c,EAAAke,iBACA7gB,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAA4E,EAAA8a,EAAA1f,GAAAigB,SAAAi2B,EAAAvzC,EAAA+c,EAAA1f,GAAAggB,KAAApa,GACA,GAAAhB,IAAAA,EAAAA,QAAA,IAAAuyC,IAAAx0C,EAAAg5B,QAAA/2B,EAAAS,KAAAkD,MAAAtI,QAAAg3C,EAAA,CACA,IAAA1yC,EAAAK,EAAAA,MAAA,6BAAA,gCACAwyC,EAAApmC,KAAArO,EAAA0kB,SAAAziB,EAAAS,KAAAkhB,EAAA3hB,EAAAS,KAAAkD,KAAA3D,EAAAS,KAAAoI,GAAA,GAAA,CAAAuM,UAAAzV,KACAK,EAAAU,IAAA3C,EAAAg5B,QAAA/2B,EAAAU,GAAAiD,MAAAtI,QAAAg3C,GACAG,EAAApmC,KAAArO,EAAA0kB,SAAAziB,EAAAU,GAAAihB,EAAA3hB,EAAAU,GAAAiD,KAAA3D,EAAAU,GAAAmI,GAAA,GAAA,CAAAuM,UAAAzV,IAJA,CAFA,CAUA,GAAA6yC,EAAAn3C,OAAA,CAGA41C,GAAAlzC,EAAA+D,MAAA2wC,SAAA10C,EAAAogC,QAEA,IAAArd,EAAA,WACA/iB,EAAA0d,WAAA,WACA,IAAA,IAAArgB,EAAA,EAAAA,EAAAo3C,EAAAn3C,OAAAD,IAAAo3C,EAAAp3C,GAAA0lB,OADA,GADA,EAKA,IAAAsxB,EACA,OAAAtxB,EADA5C,WAAA4C,EAAA,IAVA,CAfA,CA8BA,SAAA4xB,EAAA30C,GACAA,EAAA0d,WAAA,WACA1d,EAAA+D,MAAAqwC,cAAAQ,uBACA50C,EAAA+D,MAAAqwC,cAAAQ,uBACA50C,EAAA+D,MAAAqwC,cAAAQ,qBAAA,MAEA50C,EAAA+D,MAAAqwC,cAAAQ,qBAAAR,EAAAp0C,GAAA,EAAAA,EAAA+D,MAAAqwC,cALA,GADA,CAUA,SAAAS,EAAA70C,GACAA,EAAA+D,MAAAqwC,eAAAp0C,EAAA+D,MAAAqwC,cAAAQ,uBACA50C,EAAA+D,MAAAqwC,cAAAQ,uBACA50C,EAAA+D,MAAAqwC,cAAAQ,qBAAA,KAHA,CAOAh1C,EAAAke,aAAA,iBAAA,GAAA,SAAA9d,EAAAmB,EAAA4c,GACAA,GAAAA,GAAAne,EAAAoe,OACAhe,EAAAie,IAAA,iBAAA02B,GACA30C,EAAAie,IAAA,QAAA02B,GACA30C,EAAAie,IAAA,OAAA42B,GACAA,EAAA70C,IAEAmB,IACAnB,EAAA+D,MAAAqwC,cAAA,UAAA/1C,QAAA8C,GAAAA,EAAA,CAAA,EACAnB,EAAAwB,GAAA,iBAAAmzC,GACA30C,EAAAwB,GAAA,QAAAmzC,GACA30C,EAAAwB,GAAA,OAAAqzC,GAXA,IAeAj1C,EAAAmlB,gBAAA,iBAAA,WAAAqvB,EAAApoC,MAAA,EAAA,IACApM,EAAAmlB,gBAAA,uBAAA,SAAA9Q,EAAAhR,EAAA6xC,GAUA,OARAA,GAAA,kBAAA7xC,KACA6xC,GAGAA,EAAAnB,OAAA1wC,EACAA,EAAA6xC,GAHA7xC,EAAAA,EAAA,CAAA0wC,QAAA,GAAA,MAMAJ,EAAAvnC,KAAAiI,EAAAhR,EAVA,IAYArD,EAAAmlB,gBAAA,kBAAA,SAAA9Q,EAAAzL,EAAA5G,EAAAqB,GACA,OAAA4wC,EAAA7nC,KAAAiI,EAAAzL,EAAA5G,EAAAqB,EADA,GAlJA,EANA,UAAA5E,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WtBomQQ,EACA,CAAE,GAAM,KC9mQhB,GAAA,CDinQQ,SAAUZ,EAASU,EAAQD,GuB9mQnC,IAAAgC,IAOA,SAAA7B,GACA,aAEA,IAAAm1C,EAAA,2DACAC,EAAA,sDACAC,EAAA,UAmDA,SAAAC,EAAAl1C,EAAAiU,GACA,IAAA8S,EAAA9S,EAAArO,KAAAuvC,EAAA,EAAAC,EAAA,EACAC,EAAAN,EAAA1yC,KAAArC,EAAAg5B,QAAAjS,IAAAuuB,EAAAD,EAAA,GAEA,EAAA,CAEA,IAAAE,EAAAxuB,GADAouB,GAAA,GAEAK,EAAAx1C,EAAAg5B,QAAAuc,GAAAE,EAAAV,EAAA1yC,KAAAmzC,GAEA,GAAAC,EAAA,CACA,IAAAC,EAAAD,EAAA,GACAE,EAAAlkB,SAAA4jB,EAAA,GAAA,IAAAF,EAAAC,EACAQ,EAAAnkB,SAAAgkB,EAAA,GAAA,IAAAI,EAAAD,EAEA,GAAAN,IAAAI,GAAAI,MAAAF,GAUA,CACA,GAAAN,EAAAh4C,OAAAo4C,EAAAp4C,OAAA,OAGA,GAAAg4C,EAAAh4C,OAAAo4C,EAAAp4C,QAAA,IAAA63C,EAAA,OACAC,GAAA,CALA,MATAO,IAAAC,IAAAC,EAAAD,EAAA,GACAD,EAAAC,IAAAC,EAAAF,EAAA,GACA31C,EAAA2gC,aACA6U,EAAAtoB,QAAA6nB,EAAAW,EAAAG,EAAAJ,EAAA,GAAAA,EAAA,IACA,CACA7vC,KAAA2vC,EAAAzqC,GAAA,GACA,CACAlF,KAAA2vC,EAAAzqC,GAAA0qC,EAAAl4C,QAbA,CALA,OA4BAm4C,EAhCA,CAjDA71C,EAAA2iC,SAAAwT,qCAAA,SAAA/1C,GACA,GAAAA,EAAAkd,UAAA,gBAAA,OAAAtd,EAAAiG,KAEA,IADA,IAAAkX,EAAA/c,EAAAke,iBAAA83B,EAAA,GACA34C,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAA4W,EAAA8I,EAAA1f,GAAAggB,KAGA44B,EAAAj2C,EAAAk2C,cAAAjiC,EAAArO,MACAqQ,EAAArW,EAAAkG,UAAA9F,EAAAoD,UAAA6yC,GACA,GAAA,aAAAhgC,EAAA7V,KAAAiD,MAAA,aAAA4S,EAAA7V,KAAA4N,WAEA,YADAhO,EAAAm2C,YAAA,oBAMA,IAAA1gC,GAAA,KAHAwgC,EAAAhgC,EAAAlS,OAGA2R,KACA0gC,EAAA,IAAAH,EAAA7qC,MAEAxF,EAAA5F,EAAAg5B,QAAA/kB,EAAArO,MAAA3D,EAAA8yC,EAAA1yC,KAAAuD,GACAywC,EAAA,QAAAnyC,KAAA0B,EAAAsN,MAAA,EAAAe,EAAAnJ,KACA,IAAAiS,EAAA1f,GAAAigB,UAAA7H,IAAA2gC,IAAAn0C,GAAAo0C,EAEA,YADAr2C,EAAAm2C,YAAA,oBAGA,GAAAnB,EAAA9wC,KAAA0B,GAAA,CACA,IAAA0wC,EAAAF,GAAA,QAAAlyC,KAAA0B,GACA2wC,GAAA,QAAAryC,KAAA0B,IACA0wC,GAAAC,IAAAv2C,EAAA2gC,aAAA,GAAA,CACA/6B,KAAAqO,EAAArO,KAAAkF,GAAA,GACA,CACAlF,KAAAqO,EAAArO,KAAAkF,GAAAmJ,EAAAnJ,GAAA,IAEAkrC,EAAA34C,GAAA,IARA,KASA,CACA,IAAAkI,EAAAtD,EAAA,GAAAusC,EAAAvsC,EAAA,GACAu0C,IAAAvB,EAAA/wC,KAAAjC,EAAA,KAAAA,EAAA,GAAA4R,QAAA,MAAA,GACA4iC,EAAAD,EAAA/kB,SAAAxvB,EAAA,GAAA,IAAA,EAAAA,EAAA,GAAAA,EAAA,GAAAirB,QAAA,IAAA,KACA8oB,EAAA34C,GAAA,KAAAkI,EAAAkxC,EAAAjI,EAEAgI,GAAAtB,EAAAl1C,EAAAiU,EANA,CA/BA,CAyCAjU,EAAA02C,kBAAAV,EA5CA,CAPA,EANA,UAAA33C,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WvBksQQ,EACA,CAAE,GAAM,KC5sQhB,GAAA,CD+sQQ,SAAUZ,EAASU,EAAQD,GwBlrQnC,IAAAgC,IAOA,SAAA7B,GACAA,EAAAke,aAAA,iBAAA,GAAA,SAAA9d,EAAAmB,EAAA4c,GAGA,GAFAA,GAAAne,EAAAoe,MAAAD,GACA/d,EAAAqhC,aAAA,iBACAlgC,EAAA,CACA,IAAA+yB,EAAA,CAAA7wB,KAAA,iBACA,UAAAhF,QAAA8C,KAAA,IAAAA,EAAAw1C,cACAziB,EAAA,OAAA,SAAAl0B,GAAA,OAwGA,SAAAA,GACA,OAAAA,EAAAkd,UAAA,gBAAAtd,EAAAiG,KACA+wC,EAAA52C,GAAA,EAFA,CAxGA62C,CAAA72C,EAAA,GACA,UAAA3B,QAAA8C,KAAA,IAAAA,EAAA21C,cACA5iB,EAAA,OAAA,SAAAl0B,GAAA,OASA,SAAAA,GACA,GAAAA,EAAAkd,UAAA,gBAAA,OAAAtd,EAAAiG,KAGA,IAFA,IAAAkX,EAAA/c,EAAAke,iBAAA83B,EAAA,GACA5I,EAAAptC,EAAAkd,UAAA,iBACA7f,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAA0f,EAAA1f,GAAAigB,QAAA,OAAA1d,EAAAiG,KACA,IAAAoO,EAAA8I,EAAA1f,GAAAggB,KAAA05B,EAAA/2C,EAAAsiC,WAAAruB,GACAgC,EAAArW,EAAAkG,UAAA9F,EAAAoD,UAAA2zC,EAAAhzC,OAAAA,EAAAkS,EAAAlS,MACAS,EAAAyR,EAAA7V,KAAA8N,eAAA+H,EAAA7V,KAAA8N,cAAAnK,GACAxB,EAAAiC,GAAAA,EAAAnB,KACA,IAAAd,EAAA,OAAA3C,EAAAiG,KAEA,IAAAtE,EAAA,QAAA0U,EAAA7V,KAAA2N,cACAipC,EAAA,UAAA34C,QAAA+uC,IAAAA,EAAA4J,eAAAz1C,GAAA01C,EACAC,EAAA,UAAA74C,QAAA+uC,IAAAA,EAAA8J,YAAA31C,GAAA41C,EAEAJ,EAAAr9B,IAAAzF,EAAAnJ,KAAAvI,EAAAA,EAAA2Q,MAAA,EAAA3Q,EAAAjF,OAAAy5C,EAAAr9B,IAAAzF,EAAAnJ,KACA,IAAAssC,EAAA70C,EAAA6B,cAEA,IAAA7B,GACA,UAAAw0C,EAAA1sC,OAAA0sC,EAAAr9B,KAAAzF,EAAAnJ,KAAA,SAAA5G,KAAA6yC,EAAA9jC,OAAAiB,OAAA6iC,EAAA9jC,OAAA3V,OAAA,KAAA,GAAAy5C,EAAA9jC,OAAA3V,SACA,OAAAy5C,EAAA1sC,MAAA7F,EAAAU,OACA6xC,EAAA9jC,OAAAY,QAAA,MAAAI,EAAAnJ,GAAAisC,EAAA5jC,MAAA,GACA6jC,GAAAnjC,EAAAmjC,EAAAI,IAAA,GACAC,EAAAr3C,EAAAiW,EAAA7V,KAAA+N,mBAAA8H,EAAA7V,KAAA+N,kBAAApK,IAAA,GAAAxB,EAAA0R,GAAA,GACA,OAAArU,EAAAiG,KAEA,IAAAyxC,EAAA,UAAAj5C,QAAA+uC,IAAAA,EAAAkK,UACA,GAAAA,GAAAzjC,EAAAyjC,EAAA/0C,IAAA,EACAyzC,EAAA34C,GAAA,CAAA0E,KAAA,KAAAw1C,OAAA33C,EAAAgkB,IAAA3P,EAAArO,KAAAqO,EAAAnJ,GAAA,QADA,CAKA,IAAAvF,EAAA2xC,GAAArjC,EAAAqjC,EAAAE,IAAA,EACApB,EAAA34C,GAAA,CAAAkI,OAAAA,EACAxD,KAAA,KAAAwD,EAAA,OAAA,IAAA,KAAAhD,EAAA,IACAg1C,OAAAhyC,EAAA3F,EAAAgkB,IAAA3P,EAAArO,KAAA,EAAA,GAAAhG,EAAAgkB,IAAA3P,EAAArO,KAAAqO,EAAAnJ,GAAA,GARA,CAxBA,CAmCA,IAAA0sC,EAAA,UAAAn5C,QAAA+uC,IAAAA,EAAAoK,sBACA,IAAAn6C,EAAA0f,EAAAzf,OAAA,EAAAD,GAAA,EAAAA,IAAA,CACA,IAAAoX,EAAAuhC,EAAA34C,GACA2C,EAAA2gC,aAAAlsB,EAAA1S,KAAAgb,EAAA1f,GAAAggB,KAAAN,EAAA1f,GAAA+f,OAAA,WACA,IAAAS,EAAA7d,EAAAke,iBAAAhL,MAAA,GACA2K,EAAAxgB,GAAA,CAAAggB,KAAA5I,EAAA8iC,OAAAn6B,OAAA3I,EAAA8iC,QACAv3C,EAAAy3C,cAAA55B,IACA25B,GAAA/iC,EAAAlP,SACAvF,EAAA03C,WAAAjjC,EAAA8iC,OAAA3xC,KAAA,MAAA,GACA5F,EAAA03C,WAAAjjC,EAAA8iC,OAAA3xC,KAAA,EAAA,MAAA,GARA,CAxCA,CATA+xC,CAAA33C,EAAA,GACAA,EAAA69B,UAAA3J,EANA,CAHA,IAYA,IAAA+iB,EAAA,CAAA,OAAA,OAAA,KAAA,MAAA,UAAA,QAAA,KAAA,MAAA,QAAA,SAAA,OAAA,OAAA,QACA,SAAA,QAAA,OACAE,EAAA,CAAA,SAAA,aAAA,OAAA,SAAA,MAAA,KAAA,WAAA,OAAA,WAAA,KAAA,KAAA,KAAA,KACA,KAAA,KAAA,OAAA,OAAA,SAAA,QAAA,SAAA,SAAA,KAAA,IAAA,SAAA,QAAA,MAuDA,SAAAP,EAAA52C,EAAA43C,GAKA,IAJA,IAAA76B,EAAA/c,EAAAke,iBAAA83B,EAAA,GACA34B,EAAAu6B,EAAA,IAAA,KACAxK,EAAAptC,EAAAkd,UAAA,iBACAs6B,EAAA,UAAAn5C,QAAA+uC,IAAAA,EAAAyK,kBACAx6C,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAA0f,EAAA1f,GAAAigB,QAAA,OAAA1d,EAAAiG,KACA,IAAAoO,EAAA8I,EAAA1f,GAAAggB,KAAA05B,EAAA/2C,EAAAsiC,WAAAruB,GACAgC,EAAArW,EAAAkG,UAAA9F,EAAAoD,UAAA2zC,EAAAhzC,OAAAA,EAAAkS,EAAAlS,MACA,GAAA6zC,IAAA,UAAAb,EAAA1sC,MAAA,KAAA0sC,EAAA9jC,OAAAiB,OAAA,IACA6iC,EAAA5jC,OAAAc,EAAAnJ,GAAA,GACA,OAAAlL,EAAAiG,KAKA,IAAAiyC,EAAAC,EAAA,OAAA9hC,EAAA7V,KAAAiD,MAAA,aAAArD,EAAAoD,UAAAC,KACA,GAAA00C,GAAA,cAAA9hC,EAAA7V,KAAAiD,KACAy0C,EAAAz6B,EAAA,cACA,GAAA06B,GAAA,OAAA9hC,EAAA7V,KAAAiD,KACAy0C,EAAAz6B,EAAA,YACA,CACA,IAAAnR,EAAA+J,EAAA7V,KAAA+N,mBAAA8H,EAAA7V,KAAA+N,kBAAApK,GACA4X,EAAAzP,EAAA5O,OAAA4O,EAAAA,EAAA5O,OAAA,GAAA,GACA,IAAA4O,GAAAA,EAAA5O,QAAA+5C,EAAAr3C,EAAAkM,EAAAyP,EAAA1H,GACA,OAAArU,EAAAiG,KACAiyC,EAAAz6B,EAAA1B,CALA,CAOA,KAAA3b,EAAAg5B,QAAA/kB,EAAArO,MAAAsO,OAAA6iC,EAAAr9B,OAAAo+B,GAAA,KACA9B,EAAA34C,GAAAy6C,CAxBA,CA4BA,GAFA93C,EAAA02C,kBAAAV,GACAj5B,EAAA/c,EAAAke,kBACAs5B,EACA,IAAAn6C,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,KACAA,GAAA0f,EAAAzf,OAAA,GAAAyf,EAAA1f,GAAAggB,KAAAzX,KAAAmX,EAAA1f,EAAA,GAAAggB,KAAAzX,OACA5F,EAAA03C,WAAA36B,EAAA1f,GAAAggB,KAAAzX,KApCA,CA+CA,SAAAiO,EAAAmkC,EAAA15B,GACA,GAAA05B,EAAAnkC,QAAA,OAAAmkC,EAAAnkC,QAAAyK,GACA,IAAA,IAAAjhB,EAAA,EAAAmB,EAAAw5C,EAAA16C,OAAAD,EAAAmB,IAAAnB,EACA,GAAA26C,EAAA36C,IAAAihB,EAAA,OAAAjhB,EACA,OAAA,CAJA,CASA,SAAAg6C,EAAAr3C,EAAAkM,EAAA3J,EAAA0R,EAAAgkC,GACA,IAAAr4C,EAAAs4C,kBAAA,OAAA,EACA,IAAAx+B,EAAAsF,KAAAK,IAAArf,EAAAiyC,WAAA,EAAAh+B,EAAArO,KAAA,KACAuyC,EAAAv4C,EAAAs4C,kBAAAl4C,EAAAiU,EAAA,KAAAyF,GACA,IAAAy+B,GAAAA,EAAAv1C,KAAAL,EAAA,OAAA,EAKA,IADA,IAAA61C,EAAAH,EAAA,EAAA,EACA56C,EAAA6O,EAAA5O,OAAA,EAAAD,GAAA,GACA6O,EAAA7O,IAAAkF,EADAlF,MACA+6C,EAIA,IADAnkC,EAAAkkC,EAAAx1C,GACAtF,EAAA,EAAAA,EAAA+6C,EAAA/6C,IAAA,CACA,IAAA0N,EAAAnL,EAAAs4C,kBAAAl4C,EAAAiU,EAAA,KAAAyF,GACA,IAAA3O,GAAAA,EAAAnI,KAAAL,EAAA,OAAA,EACA0R,EAAAlJ,EAAApI,EAHA,CAKA,OAAA,CAnBA,CAXA/C,EAAA2iC,SAAA8V,SAAA,SAAAr4C,GAAA,OAAA42C,EAAA52C,EAAA,CApHA,EANA,UAAA3B,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,IAAAA,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,uBAAA,oBAAAvE,GAEAA,EAAA7B,WxBu3QQ,EACA,CACI,GAAM,GACN,GAAM,KC75QlB,GAAA,CDi6QQ,SAAUZ,EAASU,EAAQD,GyB95QnC,IAAAgC,IAOA,SAAA7B,GACA,aAEA,IAAAgkB,EAAAhkB,EAAAgkB,IACA,SAAA00B,EAAAl5C,EAAAoe,GAAA,OAAApe,EAAAwG,KAAA4X,EAAA5X,MAAAxG,EAAA0L,GAAA0S,EAAA1S,EAAA,CAEA,IAAAytC,EAAA,+KAEAC,EAAA,IAAAr2C,OAAA,UAAAo2C,EAAA,KADAA,EACA,iDAAA,KAEA,SAAAE,EAAAz4C,EAAA4F,EAAAkF,EAAAmS,GACAjR,KAAApG,KAAAA,EAAAoG,KAAAlB,GAAAA,EACAkB,KAAAhM,GAAAA,EAAAgM,KAAAjK,KAAA/B,EAAAg5B,QAAApzB,GACAoG,KAAAqT,IAAApC,EAAA+B,KAAAC,IAAAhC,EAAAva,KAAA1C,EAAAgyC,aAAAhyC,EAAAgyC,YACAhmC,KAAAiT,IAAAhC,EAAA+B,KAAAK,IAAApC,EAAAta,GAAA,EAAA3C,EAAAiyC,YAAAjyC,EAAAiyC,UAJA,CAOA,SAAAyG,EAAAC,EAAA7tC,GACA,IAAAT,EAAAsuC,EAAA34C,GAAA4zC,eAAAhwB,EAAA+0B,EAAA/yC,KAAAkF,IACA,OAAAT,GAAA,UAAAnG,KAAAmG,EAFA,CAKA,SAAAmrC,EAAAmD,GACA,KAAAA,EAAA/yC,MAAA+yC,EAAA15B,KAGA,OAFA05B,EAAA7tC,GAAA,EACA6tC,EAAA52C,KAAA42C,EAAA34C,GAAAg5B,UAAA2f,EAAA/yC,OACA,CAJA,CAMA,SAAAgzC,EAAAD,GACA,KAAAA,EAAA/yC,MAAA+yC,EAAAt5B,KAGA,OAFAs5B,EAAA52C,KAAA42C,EAAA34C,GAAAg5B,UAAA2f,EAAA/yC,MACA+yC,EAAA7tC,GAAA6tC,EAAA52C,KAAAzE,QACA,CAJA,CAOA,SAAAu7C,EAAAF,GACA,OAAA,CACA,IAAAG,EAAAH,EAAA52C,KAAA8R,QAAA,IAAA8kC,EAAA7tC,IACA,IAAA,GAAAguC,EAAA,CAAA,GAAAtD,EAAAmD,GAAA,SAAA,MAAA,CACA,GAAAD,EAAAC,EAAAG,EAAA,GAAA,CACA,IAAAC,EAAAJ,EAAA52C,KAAAwhC,YAAA,IAAAuV,GACAE,EAAAD,GAAA,IAAA,KAAA70C,KAAAy0C,EAAA52C,KAAAmR,MAAA6lC,EAAA,EAAAD,IAEA,OADAH,EAAA7tC,GAAAguC,EAAA,EACAE,EAAA,YAAA,SAJA,CAAAL,EAAA7tC,GAAAguC,EAAA,CAHA,CADA,CAWA,SAAAG,EAAAN,GACA,OAAA,CACA,IAAAO,EAAAP,EAAA7tC,GAAA6tC,EAAA52C,KAAAwhC,YAAA,IAAAoV,EAAA7tC,GAAA,IAAA,EACA,IAAA,GAAAouC,EAAA,CAAA,GAAAN,EAAAD,GAAA,SAAA,MAAA,CACA,GAAAD,EAAAC,EAAAO,EAAA,GAAA,CACAV,EAAAhwB,UAAA0wB,EACAP,EAAA7tC,GAAAouC,EACA,IAAAj3C,EAAAu2C,EAAAn2C,KAAAs2C,EAAA52C,MACA,GAAAE,GAAAA,EAAA8R,OAAAmlC,EAAA,OAAAj3C,CAJA,MAAA02C,EAAA7tC,GAAAouC,CAHA,CADA,CAYA,SAAAC,EAAAR,GACA,OAAA,CACAH,EAAAhwB,UAAAmwB,EAAA7tC,GACA,IAAAka,EAAAwzB,EAAAn2C,KAAAs2C,EAAA52C,MACA,IAAAijB,EAAA,CAAA,GAAAwwB,EAAAmD,GAAA,SAAA,MAAA,CACA,GAAAD,EAAAC,EAAA3zB,EAAAjR,MAAA,GAEA,OADA4kC,EAAA7tC,GAAAka,EAAAjR,MAAAiR,EAAA,GAAA1nB,OACA0nB,EAFA2zB,EAAA7tC,GAAAka,EAAAjR,MAAA,CAJA,CADA,CAUA,SAAAqlC,EAAAT,GACA,OAAA,CACA,IAAAG,EAAAH,EAAA7tC,GAAA6tC,EAAA52C,KAAAwhC,YAAA,IAAAoV,EAAA7tC,GAAA,IAAA,EACA,IAAA,GAAAguC,EAAA,CAAA,GAAAF,EAAAD,GAAA,SAAA,MAAA,CACA,GAAAD,EAAAC,EAAAG,EAAA,GAAA,CACA,IAAAC,EAAAJ,EAAA52C,KAAAwhC,YAAA,IAAAuV,GACAE,EAAAD,GAAA,IAAA,KAAA70C,KAAAy0C,EAAA52C,KAAAmR,MAAA6lC,EAAA,EAAAD,IAEA,OADAH,EAAA7tC,GAAAguC,EAAA,EACAE,EAAA,YAAA,SAJA,CAAAL,EAAA7tC,GAAAguC,CAHA,CADA,CAYA,SAAAO,EAAAV,EAAA/1C,GAEA,IADA,IAAA2vB,EAAA,KACA,CACA,IAAA7Y,EAAA3O,EAAAouC,EAAAR,GAAA5xB,EAAA4xB,EAAA/yC,KAAA0zC,EAAAX,EAAA7tC,IAAAC,EAAAA,EAAA,GAAAzN,OAAA,GACA,IAAAyN,KAAA2O,EAAAm/B,EAAAF,IAAA,OACA,GAAA,aAAAj/B,EACA,GAAA3O,EAAA,GAAA,CACA,IAAA,IAAA1N,EAAAk1B,EAAAj1B,OAAA,EAAAD,GAAA,IAAAA,EAAA,GAAAk1B,EAAAl1B,IAAA0N,EAAA,GAAA,CACAwnB,EAAAj1B,OAAAD,EACA,KAFA,CAIA,GAAAA,EAAA,KAAAuF,GAAAA,GAAAmI,EAAA,IAAA,MAAA,CACAnI,IAAAmI,EAAA,GACArI,KAAAkhB,EAAAmD,EAAAuyB,GACA32C,GAAAihB,EAAA+0B,EAAA/yC,KAAA+yC,EAAA7tC,IARA,MAWAynB,EAAAlkB,KAAAtD,EAAA,GAfA,CAFA,CAqBA,SAAAwuC,EAAAZ,EAAA/1C,GAEA,IADA,IAAA2vB,EAAA,KACA,CACA,IAAAtmB,EAAAmtC,EAAAT,GACA,IAAA1sC,EAAA,OACA,GAAA,aAAAA,EAAA,CACA,IAAA+a,EAAA2xB,EAAA/yC,KAAA4zC,EAAAb,EAAA7tC,GACAqI,EAAA8lC,EAAAN,GACA,IAAAxlC,EAAA,OACA,GAAAA,EAAA,GACAof,EAAAlkB,KAAA8E,EAAA,QACA,CACA,IAAA,IAAA9V,EAAAk1B,EAAAj1B,OAAA,EAAAD,GAAA,IAAAA,EAAA,GAAAk1B,EAAAl1B,IAAA8V,EAAA,GAAA,CACAof,EAAAj1B,OAAAD,EACA,KAFA,CAIA,GAAAA,EAAA,KAAAuF,GAAAA,GAAAuQ,EAAA,IAAA,MAAA,CACAvQ,IAAAuQ,EAAA,GACAzQ,KAAAkhB,EAAA+0B,EAAA/yC,KAAA+yC,EAAA7tC,IACAnI,GAAAihB,EAAAoD,EAAAwyB,GARA,CANA,MAAAP,EAAAN,EAHA,CAFA,CAyBA/4C,EAAA2c,eAAA,OAAA,OAAA,SAAAvc,EAAAmT,GAEA,IADA,IAAAwlC,EAAA,IAAAF,EAAAz4C,EAAAmT,EAAAvN,KAAA,KACA,CACA,IAAA6zC,EAAAN,EAAAR,GACA,IAAAc,GAAAd,EAAA/yC,MAAAuN,EAAAvN,KAAA,OACA,IAAA8T,EAAAm/B,EAAAF,GACA,IAAAj/B,EAAA,OACA,IAAA+/B,EAAA,IAAA,aAAA//B,EAAA,CACA,IAAAmf,EAAAjV,EAAA+0B,EAAA/yC,KAAA+yC,EAAA7tC,IACA4uC,EAAAL,EAAAV,EAAAc,EAAA,IACA,OAAAC,GAAApB,EAAAoB,EAAAh3C,KAAAm2B,GAAA,EAAA,CAAAn2B,KAAAm2B,EAAAl2B,GAAA+2C,EAAAh3C,MAAA,IAHA,CALA,CAFA,IAcA9C,EAAA6yC,gBAAA,SAAAzyC,EAAAiU,EAAAgJ,GACA,IAAA07B,EAAA,IAAAF,EAAAz4C,EAAAiU,EAAArO,KAAAqO,EAAAnJ,GAAAmS,GACA,IAAA,GAAA07B,EAAA52C,KAAA8R,QAAA,OAAA,GAAA8kC,EAAA52C,KAAA8R,QAAA,KAAA,CACA,IAAA6F,EAAAm/B,EAAAF,GAAAh2C,EAAA+W,GAAAkK,EAAA+0B,EAAA/yC,KAAA+yC,EAAA7tC,IACAqI,EAAAuG,GAAAu/B,EAAAN,GACA,GAAAj/B,GAAAvG,KAAAmlC,EAAAK,EAAA1kC,GAAA,GAAA,CACA,IAAA0lC,EAAA,CAAAj3C,KAAAkhB,EAAA+0B,EAAA/yC,KAAA+yC,EAAA7tC,IAAAnI,GAAAA,EAAAC,IAAAuQ,EAAA,IACA,MAAA,aAAAuG,EAAA,CAAA0tB,KAAAuS,EAAAz0C,MAAA,KAAA0tC,GAAA,QAEAz/B,EAAA,GACA,CAAAi0B,KAAAmS,EAAAZ,EAAAxlC,EAAA,IAAAjO,MAAAy0C,EAAA/G,GAAA,SAGA,CAAAxL,KAAAuS,EAAAz0C,MAAAm0C,EADAV,EAAA,IAAAF,EAAAz4C,EAAA2C,EAAAiD,KAAAjD,EAAAmI,GAAAmS,GACA9J,EAAA,IAAAy/B,GAAA,OARA,CAHA,CAFA,EAiBAhzC,EAAAg6C,iBAAA,SAAA55C,EAAAiU,EAAAgJ,EAAAra,GAEA,IADA,IAAA+1C,EAAA,IAAAF,EAAAz4C,EAAAiU,EAAArO,KAAAqO,EAAAnJ,GAAAmS,KACA,CACA,IAAAmqB,EAAAmS,EAAAZ,EAAA/1C,GACA,IAAAwkC,EAAA,MACA,IACAliC,EAAAm0C,EADA,IAAAZ,EAAAz4C,EAAAiU,EAAArO,KAAAqO,EAAAnJ,GAAAmS,GACAmqB,EAAAxkC,KACA,GAAAsC,EAAA,MAAA,CAAAkiC,KAAAA,EAAAliC,MAAAA,EALA,CAFA,EAYAtF,EAAAs4C,kBAAA,SAAAl4C,EAAAiU,EAAA5Q,EAAAqW,GAEA,OAAA2/B,EADA,IAAAZ,EAAAz4C,EAAAiU,EAAArO,KAAAqO,EAAAnJ,GAAA4O,EAAA,CAAAhX,KAAA,EAAAC,GAAA+W,GAAA,MACArW,EAFA,CAzKA,EANA,UAAAhF,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,WzBmpRQ,EACA,CAAE,GAAM,KC7pRhB,GAAA,CDgqRQ,SAAUZ,EAASU,EAAQD,G0B7pRnC,IAAAgC,IAOA,SAAA7B,GACA,IAAA4K,EAAA,CACAqvC,MAAA,eACAC,YAAA,YACAC,QAAA,GACAC,QAAA,QAGAp2B,EAAAhkB,EAAAgkB,IAcA,SAAA1G,EAAAwD,EAAArd,GACA,MAAA,SAAAA,GAAA,iBAAAqd,EAAAA,EACA,UAAAriB,QAAAqiB,IAAA,MAAAA,EAAArd,GAAAqd,EAAArd,GACAmH,EAAAnH,EAHA,CAZAzD,EAAAke,aAAA,qBAAA,GAAA,SAAA9d,EAAAmB,EAAA4c,GACAA,GAAAA,GAAAne,EAAAoe,OACAhe,EAAAqhC,aAAAvD,GACA99B,EAAA+D,MAAAqY,cAAA,MAEAjb,IACA84C,EAAA/8B,EAAA/b,EAAA,UACAnB,EAAA+D,MAAAqY,cAAAjb,EACAnB,EAAA69B,UAAAC,GARA,IAkBA,IAAAA,EAAA,CAAAoc,UAoBA,SAAAl6C,GACA,IAAA0gB,EAAAy5B,EAAAn6C,GACA,IAAA0gB,GAAA1gB,EAAAkd,UAAA,gBAAA,OAAAtd,EAAAiG,KAIA,IAFA,IAAAg0C,EAAA38B,EAAAwD,EAAA,SACA3D,EAAA/c,EAAAke,iBACA7gB,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAA0f,EAAA1f,GAAAigB,QAAA,OAAA1d,EAAAiG,KACA,IAAAu0C,EAAAC,EAAAr6C,EAAA+c,EAAA1f,GAAAggB,MACA,IAAA+8B,GAAAP,EAAAhmC,QAAAumC,GAAA,GAAA,EAAA,OAAAx6C,EAAAiG,IAHA,CAKA,IAAAxI,EAAA0f,EAAAzf,OAAA,EAAAD,GAAA,EAAAA,IAAA,CACA,IAAA4H,EAAA8X,EAAA1f,GAAAggB,KACArd,EAAA2gC,aAAA,GAAA/c,EAAA3e,EAAAW,KAAAX,EAAA6F,GAAA,GAAA8Y,EAAA3e,EAAAW,KAAAX,EAAA6F,GAAA,GAAA,UAFA,CAXA,EApBA4zB,MAqCA,SAAA1+B,GACA,IAAA0gB,EAAAy5B,EAAAn6C,GACAg6C,EAAAt5B,GAAAxD,EAAAwD,EAAA,WACA,IAAAs5B,GAAAh6C,EAAAkd,UAAA,gBAAA,OAAAtd,EAAAiG,KAGA,IADA,IAAAkX,EAAA/c,EAAAke,iBACA7gB,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAA0f,EAAA1f,GAAAigB,QAAA,OAAA1d,EAAAiG,KACA,IAAAu0C,EAAAC,EAAAr6C,EAAA+c,EAAA1f,GAAAggB,MACA,IAAA+8B,GAAAJ,EAAAnmC,QAAAumC,GAAA,GAAA,EAAA,OAAAx6C,EAAAiG,IAHA,CAKA7F,EAAA0d,WAAA,WACA,IAAA48B,EAAAt6C,EAAAu6C,iBAAA,KACAv6C,EAAAw6C,iBAAAF,EAAAA,EAAA,MACAG,EAAAz6C,GAAA,GACA+c,EAAA/c,EAAAke,iBACA,IAAA,IAAA7gB,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAAuI,EAAAmX,EAAA1f,GAAAggB,KAAAzX,KACA5F,EAAA03C,WAAA9xC,EAAA,MAAA,GACA5F,EAAA03C,WAAA9xC,EAAA,EAAA,MAAA,EAHA,CALA,GAXA,GApCA,SAAAq0C,EAAAS,GACA,IAAA,IAAAr9C,EAAA,EAAAA,EAAAq9C,EAAAp9C,OAAAD,IAAA,CACA,IAAAyN,EAAA4vC,EAAAxmC,OAAA7W,GAAAS,EAAA,IAAAgN,EAAA,IACAgzB,EAAAhgC,KAAAggC,EAAAhgC,GAAA68C,EAAA7vC,GAFA,CADA,CAQA,SAAA6vC,EAAA7vC,GACA,OAAA,SAAA9K,GAAA,OAoEA,SAAAA,EAAA8K,GACA,IAAA4V,EAAAy5B,EAAAn6C,GACA,IAAA0gB,GAAA1gB,EAAAkd,UAAA,gBAAA,OAAAtd,EAAAiG,KAEA,IAAAg0C,EAAA38B,EAAAwD,EAAA,SACAzM,EAAA4lC,EAAAhmC,QAAA/I,GACA,IAAA,GAAAmJ,EAAA,OAAArU,EAAAiG,KAWA,IATA,IAQAwE,EARAyvC,EAAA58B,EAAAwD,EAAA,eAEAq5B,EAAA78B,EAAAwD,EAAA,WAEAk6B,EAAAf,EAAA3lC,OAAAD,EAAA,IAAAnJ,EACAiS,EAAA/c,EAAAke,iBACA28B,EAAA5mC,EAAA,GAAA,EAGA5W,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAAy9C,EAAA79B,EAAAF,EAAA1f,GAAA4H,EAAAgY,EAAAI,KACAtS,EAAA/K,EAAAmuC,SAAAlpC,EAAA2e,EAAA3e,EAAAW,KAAAX,EAAA6F,GAAA,IACA,GAAA+vC,IAAA59B,EAAAK,QACAw9B,EAAA,gBACA,IAAAF,GAAAC,GAAA9vC,GAAAD,EAOA,GAAA8vC,GAAA31C,EAAA6F,GAAA,GAAAivC,EAAAlmC,QAAA/I,IAAA,GACA9K,EAAAmuC,SAAAvqB,EAAA3e,EAAAW,KAAAX,EAAA6F,GAAA,GAAA7F,IAAA6F,EAAAA,EAAA,CACA,GAAA7F,EAAA6F,GAAA,GAAA,WAAA5G,KAAAlE,EAAA4zC,eAAAhwB,EAAA3e,EAAAW,KAAAX,EAAA6F,GAAA,KAAA,OAAAlL,EAAAiG,KACAi1C,EAAA,SAFA,MAGA,GAAAF,EAAA,CACA,IAAA3uC,EAAA,GAAAhH,EAAA6F,GAAA,IAAA9K,EAAAmuC,SAAAvqB,EAAA3e,EAAAW,KAAAX,EAAA6F,GAAA,GAAA7F,GACA,GAAArF,EAAAm7C,WAAAhwC,IAAAkB,GAAAnB,GAAAlL,EAAAm7C,WAAA9uC,GACA,OAAArM,EAAAiG,KADAi1C,EAAA,MAFA,KAIA,KAAAD,KAAA,IAAA9vC,EAAAzN,QAAA,KAAA4G,KAAA6G,IAAA+uC,EAAAjmC,QAAA9I,IAAA,GAGA,OAAAnL,EAAAiG,KAFAi1C,EAAA,MACA,MAfAA,EADAF,GAAAI,EAAAh7C,EAAAiF,GACA,OACA80C,EAAAlmC,QAAA/I,IAAA,GAAA9K,EAAAmuC,SAAAlpC,EAAA2e,EAAA3e,EAAAW,KAAAX,EAAA6F,GAAA,KAAAA,EAAAA,EAAAA,EACA,YAEA,OAcA,GAAAT,GACA,GAAAA,GAAAywC,EAAA,OAAAl7C,EAAAiG,UADAwE,EAAAywC,CAzBA,CA6BA,IAAA17B,EAAAnL,EAAA,EAAA4lC,EAAA3lC,OAAAD,EAAA,GAAAnJ,EACAuW,EAAApN,EAAA,EAAAnJ,EAAA+uC,EAAA3lC,OAAAD,EAAA,GACAjU,EAAA0d,WAAA,WACA,GAAA,QAAArT,EACAowC,EAAAz6C,EAAA,QACA,GAAA,aAAAqK,EACAowC,EAAAz6C,EAAA,QACA,GAAA,YAAAqK,EAAA,CAEA,IADA,IAAA4wC,EAAAj7C,EAAAk7C,gBACA79C,EAAA,EAAAA,EAAA49C,EAAA39C,OAAAD,IACA49C,EAAA59C,GAAA+hB,EAAA67B,EAAA59C,GAAAgkB,EAGA,IAFArhB,EAAA02C,kBAAAuE,EAAA,UACAA,EAAAj7C,EAAAke,iBAAAhL,QACA7V,EAAA,EAAAA,EAAA49C,EAAA39C,OAAAD,IACA49C,EAAA59C,GAAA89C,EAAAF,EAAA59C,IACA2C,EAAAy3C,cAAAwD,EARA,KASA,QAAA5wC,GACArK,EAAAw6C,iBAAAp7B,EAAAiC,EAAA,MACArhB,EAAAo7C,gBAAAh8B,EAAAiC,GACAo5B,EAAAz6C,GAAA,IACA,WAAAqK,IACArK,EAAAw6C,iBAAAp7B,EAAAA,EAAAA,EAAAA,EAAA,UACAq7B,EAAAz6C,EAAA,GApBA,GAhDA,CApEAq7C,CAAAr7C,EAAA8K,EAAA,CADA,CAIA,SAAAqvC,EAAAn6C,GACA,IAAAs7C,EAAAt7C,EAAA+D,MAAAqY,cACA,OAAAk/B,GAAAA,EAAAxL,SAAAwL,EACAt7C,EAAAu7C,UAAAv7C,EAAA84B,aACA1c,eAAAk/B,CAJA,CAgDA,SAAAb,EAAAz6C,EAAAwI,GAEA,IADA,IAAAgzC,EAAA,GAAAz+B,EAAA/c,EAAAke,iBAAAu9B,EAAA,EACAp+C,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAA4f,EAAAF,EAAA1f,GACA4f,EAAAI,MAAArd,EAAA84B,cAAA2iB,EAAAp+C,GACA,IAAA4W,EAAAgJ,EAAAI,KAAAvS,IAAAtC,EAAA,EAAA,CAAA5C,KAAAqX,EAAAI,KAAAzX,KAAAkF,GAAAmS,EAAAI,KAAAvS,GAAAtC,GAAA,CAAA5C,KAAAqX,EAAAI,KAAAzX,KAAA,GACA41C,EAAAntC,KAAA,CAAA+O,OAAAnJ,EAAAoJ,KAAApJ,GAJA,CAMAjU,EAAAy3C,cAAA+D,EAAAC,EARA,CAWA,SAAAN,EAAAt9B,GACA,IAAA69B,EAAA97C,EAAA+7C,OAAA99B,EAAAT,OAAAS,EAAAR,MAAA,EACA,MAAA,CAAAD,OAAA,IAAAwG,EAAA/F,EAAAT,OAAAxX,KAAAiY,EAAAT,OAAAtS,IAAA4wC,GAAA,EAAA,IACAr+B,KAAA,IAAAuG,EAAA/F,EAAAR,KAAAzX,KAAAiY,EAAAR,KAAAvS,IAAA4wC,EAAA,GAAA,IAHA,CA+EA,SAAArB,EAAAr6C,EAAAiU,GACA,IAAAoR,EAAArlB,EAAAmuC,SAAAvqB,EAAA3P,EAAArO,KAAAqO,EAAAnJ,GAAA,GACA8Y,EAAA3P,EAAArO,KAAAqO,EAAAnJ,GAAA,IACA,OAAA,GAAAua,EAAA/nB,OAAA+nB,EAAA,IAHA,CAMA,SAAA21B,EAAAh7C,EAAAiU,GACA,IAAAjQ,EAAAhE,EAAAsiC,WAAA1e,EAAA3P,EAAArO,KAAAqO,EAAAnJ,GAAA,IACA,MAAA,WAAA5G,KAAAF,EAAAqG,OAAArG,EAAAmP,OAAAc,EAAAnJ,KACA,GAAAmJ,EAAAnJ,KAAA,WAAA5G,KAAAlE,EAAA4zC,eAAA3/B,IAHA,CAtJAgmC,EAAAzvC,EAAAqvC,MAAA,IAnCA,EANA,UAAAx7C,QAAAoB,IAAA,UAAApB,QAAAqB,GACA+B,EAAAzC,EAAA,KACA,mBAAAgH,QAAAA,OAAAC,IACAD,OAAA,CAAA,wBAAAvE,GAEAA,EAAA7B,W1Bq2RQ,EACA,CAAE,GAAM,KC/2RhB,GAAA,CDk3RQ,SAAUZ,EAASU,EAAQD,G2Bz2RnC,IAAA0nB,EAAAC,EAAAD,EAIAnb,KAJAob,EAIA,WAAA,aAIA,IAAA+rB,EAAArU,UAAAqU,UACApU,EAAAD,UAAAC,SAEA6c,EAAA,aAAA13C,KAAAivC,GACA0I,EAAA,UAAA33C,KAAAivC,GACA2I,EAAA,wCAAAz5C,KAAA8wC,GACA4I,EAAA,cAAA15C,KAAA8wC,GACA6I,EAAAH,GAAAC,GAAAC,EACAE,EAAAD,IAAAH,EAAAh9B,SAAAu0B,cAAA,IAAA2I,GAAAD,GAAA,IACAI,GAAAH,GAAA,WAAA73C,KAAAivC,GACAgJ,EAAAD,GAAA,eAAAh4C,KAAAivC,GACAiJ,GAAAL,GAAA,gBAAA15C,KAAA8wC,GACAkJ,EAAAD,IAAAA,EAAA,GACAE,EAAA,UAAAp4C,KAAAivC,GACAoJ,EAAA,iBAAAr4C,KAAA46B,UAAA0d,QACAC,EAAA,+BAAAv4C,KAAAivC,GACAuJ,EAAA,YAAAx4C,KAAAivC,GAEAwJ,EAAAJ,IAAA,cAAAr4C,KAAAivC,IAAArU,UAAA8d,eAAA,GACAC,EAAA,UAAA34C,KAAAivC,GAEA2J,EAAAH,GAAAE,GAAA,mDAAA34C,KAAAivC,GACA4J,EAAAJ,GAAA,MAAAz4C,KAAA66B,GACAie,EAAA,WAAA94C,KAAAivC,GACA8J,EAAA,OAAA/4C,KAAA66B,GAEAme,EAAAZ,GAAAnJ,EAAAlxC,MAAA,uBACAi7C,IAAAA,EAAAt+C,OAAAs+C,EAAA,KACAA,GAAAA,GAAA,KAAAZ,GAAA,EAAAJ,GAAA,GAEA,IAAAiB,EAAAJ,IAAAZ,GAAAG,IAAA,MAAAY,GAAAA,EAAA,QACAE,EAAAxB,GAAAI,GAAAC,GAAA,EAEA,SAAAoB,EAAAC,GAAA,OAAA,IAAAn7C,OAAA,UAAAm7C,EAAA,gBAAA,CAEA,IAkCArgC,EAlCAsgC,EAAA,SAAA7+B,EAAA4+B,GACA,IAAAn5C,EAAAua,EAAArH,UACApV,EAAAo7C,EAAAC,GAAAj7C,KAAA8B,GACA,GAAAlC,EAAA,CACA,IAAAusC,EAAArqC,EAAA+O,MAAAjR,EAAA8R,MAAA9R,EAAA,GAAA3E,QACAohB,EAAArH,UAAAlT,EAAA+O,MAAA,EAAAjR,EAAA8R,QAAAy6B,EAAAvsC,EAAA,GAAAusC,EAAA,GAFA,CAHA,EASA,SAAAgP,EAAAh/C,GACA,IAAA,IAAAi/C,EAAAj/C,EAAAgiC,WAAAljC,OAAAmgD,EAAA,IAAAA,EACAj/C,EAAAggB,YAAAhgB,EAAAk/B,YACA,OAAAl/B,CAHA,CAMA,SAAAk/C,EAAAC,EAAAn/C,GACA,OAAAg/C,EAAAG,GAAA/9B,YAAAphB,EADA,CAIA,SAAA8f,EAAA1b,EAAA4L,EAAA6I,EAAAzV,GACA,IAAApD,EAAAqgB,SAAAC,cAAAlc,GAGA,GAFAyU,IAAA7Y,EAAA6Y,UAAAA,GACAzV,IAAApD,EAAAoD,MAAAg8C,QAAAh8C,GACA,iBAAA4M,EAAAhQ,EAAAohB,YAAAf,SAAA2E,eAAAhV,SACA,GAAAA,EAAA,IAAA,IAAAnR,EAAA,EAAAA,EAAAmR,EAAAlR,SAAAD,EAAAmB,EAAAohB,YAAApR,EAAAnR,IACA,OAAAmB,CANA,CASA,SAAAq/C,EAAAj7C,EAAA4L,EAAA6I,EAAAzV,GACA,IAAApD,EAAA8f,EAAA1b,EAAA4L,EAAA6I,EAAAzV,GAEA,OADApD,EAAA68B,aAAA,OAAA,gBACA78B,CAHA,CAuBA,SAAAs/C,EAAAH,EAAAI,GAGA,GAFA,GAAAA,EAAAz9B,WACAy9B,EAAAA,EAAAx/B,YACAo/B,EAAAG,SACA,OAAAH,EAAAG,SAAAC,GACA,GAEA,GADA,IAAAA,EAAAz9B,WAAAy9B,EAAAA,EAAAx9B,MACAw9B,GAAAJ,EAAA,OAAA,QACAI,EAAAA,EAAAx/B,WARA,CAWA,SAAAy/B,EAAAC,GAIA,IACAC,EADAC,EAAAF,EAAA1+B,eAAA0+B,EAEA,IACAC,EAAAD,EAAAC,aADA,CAEA,MAAA1/C,GACA0/C,EAAAC,EAAAjmC,MAAA,IADA,CAGA,KAAAgmC,GAAAA,EAAAE,YAAAF,EAAAE,WAAAF,eACAA,EAAAA,EAAAE,WAAAF,cACA,OAAAA,CAbA,CAgBA,SAAAG,EAAA3/B,EAAA4+B,GACA,IAAAn5C,EAAAua,EAAArH,UACAgmC,EAAAC,GAAAp5C,KAAAC,KAAAua,EAAArH,YAAAlT,EAAA,IAAA,IAAAm5C,EAFA,CAIA,SAAAgB,EAAAl/C,EAAAoe,GAEA,IADA,IAAA+gC,EAAAn/C,EAAA2oB,MAAA,KACA1qB,EAAA,EAAAA,EAAAkhD,EAAAjhD,OAAAD,IACAkhD,EAAAlhD,KAAAggD,EAAAkB,EAAAlhD,IAAA6G,KAAAsZ,KAAAA,GAAA,IAAA+gC,EAAAlhD,IACA,OAAAmgB,CAJA,CA/CAP,EAAA4B,SAAA2/B,YAAA,SAAA9/B,EAAAvL,EAAAuG,EAAA+kC,GACA,IAAAlgD,EAAAsgB,SAAA2/B,cAGA,OAFAjgD,EAAAmgD,OAAAD,GAAA//B,EAAAhF,GACAnb,EAAAogD,SAAAjgC,EAAAvL,GACA5U,CAJA,EAMA,SAAAmgB,EAAAvL,EAAAuG,GACA,IAAAnb,EAAAsgB,SAAA3G,KAAA0mC,kBACA,IAAArgD,EAAAsgD,kBAAAngC,EAAAH,WAAA,CACA,MAAA/f,GAAA,OAAAD,CAAA,CAIA,OAHAA,EAAAugD,UAAA,GACAvgD,EAAAwgD,QAAA,YAAArlC,GACAnb,EAAAygD,UAAA,YAAA7rC,GACA5U,CAPA,EAgDA,IAAA0gD,EAAA,SAAAvgC,GAAAA,EAAA8rB,QAAA,EAMA,SAAA2T,EAAAn+C,GAAA,OAAAA,EAAAu9B,QAAA2hB,QAAA3/B,aAAA,CAEA,SAAAwvB,EAAA/uC,GACA,OAAAi+C,EAAAj+C,EAAAu9B,QAAA2hB,QADA,CAIA,SAAAjB,EAAAkB,GAEA,OAAAA,EAAAC,YAAAD,EAAAC,cAAAD,EAAA5/B,aAFA,CAKA,SAAA8/B,EAAAr/C,GAAA,OAAAm+C,EAAAn+C,GAAAwf,WAAA,CAEA,SAAA8/B,EAAAjgD,GACA,IAAAkgD,EAAAj0B,MAAAptB,UAAAgV,MAAAvU,KAAA4W,UAAA,GACA,OAAA,WAAA,OAAAlW,EAAAmW,MAAA,KAAA+pC,EAAA,CAFA,CAKA,SAAAC,EAAA33B,EAAA1qB,EAAAsiD,GAEA,IAAA,IAAAh1C,KADAtN,IAAAA,EAAA,CAAA,GACA0qB,GACAA,EAAAxjB,eAAAoG,KAAA,IAAAg1C,GAAAtiD,EAAAkH,eAAAoG,KACAtN,EAAAsN,GAAAod,EAAApd,IACA,OAAAtN,CALA,CAUA,SAAAuiD,EAAAzsC,EAAAyG,EAAAimC,EAAAC,EAAAC,GACA,MAAAnmC,IAEA,IADAA,EAAAzG,EAAA9N,OAAA,kBACAuU,EAAAzG,EAAA3V,QAEA,IAAA,IAAAD,EAAAuiD,GAAA,EAAA3gD,EAAA4gD,GAAA,IAAA,CACA,IAAAC,EAAA7sC,EAAAY,QAAA,KAAAxW,GACA,GAAAyiD,EAAA,GAAAA,GAAApmC,EACA,OAAAza,GAAAya,EAAArc,GACA4B,GAAA6gD,EAAAziD,EACA4B,GAAA0gD,EAAA1gD,EAAA0gD,EACAtiD,EAAAyiD,EAAA,CANA,CALA,CAjCAnD,EACAsC,EAAA,SAAAvgC,GAAAA,EAAAqhC,eAAA,EAAArhC,EAAAshC,aAAAthC,EAAA5H,MAAAxZ,MAAA,EACA0+C,IACAiD,EAAA,SAAAvgC,GAAA,IAAAA,EAAA8rB,QAAA,CAAA,MAAAyV,GAAA,CAAA,GA6CA,IAAAC,EAAA,WACAl0C,KAAA6X,GAAA,KACA7X,KAAA3M,EAAA,KACA2M,KAAAw/B,KAAA,EACAx/B,KAAA2uC,QAAA2E,EAAAtzC,KAAAm0C,UAAAn0C,KAJA,EAwBA,SAAA6H,EAAA+7B,EAAAtxB,GACA,IAAA,IAAAjhB,EAAA,EAAAA,EAAAuyC,EAAAtyC,SAAAD,EACA,GAAAuyC,EAAAvyC,IAAAihB,EAAA,OAAAjhB,EACA,OAAA,CAHA,CAlBA6iD,EAAAhiD,UAAAiiD,UAAA,SAAA5nB,GACAA,EAAA1U,GAAA,EACA0U,EAAAiT,OAAA,IAAA4U,KACA7nB,EAAAl5B,IAEA8gB,WAAAoY,EAAAoiB,QAAApiB,EAAAiT,MAAA,IAAA4U,KALA,EAQAF,EAAAhiD,UAAA6vC,IAAA,SAAAsS,EAAAhhD,GACA2M,KAAA3M,EAAAA,EACA,IAAAmsC,GAAA,IAAA4U,KAAAC,IACAr0C,KAAA6X,IAAA2nB,EAAAx/B,KAAAw/B,QACA3mB,aAAA7Y,KAAA6X,IACA7X,KAAA6X,GAAA1D,WAAAnU,KAAA2uC,QAAA0F,GACAr0C,KAAAw/B,KAAAA,EANA,EAiBA,IAAA8U,EAAA,GAIAz6C,EAAA,CAAA06C,SAAA,WAAA,MAAA,iBAAA,GAGAC,EAAA,CAAAC,QAAA,GAAAC,EAAA,CAAAC,OAAA,UAAAC,EAAA,CAAAD,OAAA,SAIA,SAAAE,EAAA5tC,EAAA6tC,EAAAnB,GACA,IAAA,IAAA1rC,EAAA,EAAA1N,EAAA,IAAA,CACA,IAAAu5C,EAAA7sC,EAAAY,QAAA,KAAAI,IACA,GAAA6rC,IAAAA,EAAA7sC,EAAA3V,QACA,IAAAyjD,EAAAjB,EAAA7rC,EACA,GAAA6rC,GAAA7sC,EAAA3V,QAAAiJ,EAAAw6C,GAAAD,EACA,OAAA7sC,EAAA+K,KAAAK,IAAA0hC,EAAAD,EAAAv6C,GAIA,GAHAA,GAAAu5C,EAAA7rC,EAEAA,EAAA6rC,EAAA,GADAv5C,GAAAo5C,EAAAp5C,EAAAo5C,IAEAmB,EAAA,OAAA7sC,CATA,CADA,CAcA,IAAA+sC,EAAA,CAAA,IACA,SAAAC,EAAAhiD,GACA,KAAA+hD,EAAA1jD,QAAA2B,GACA+hD,EAAA3yC,KAAA6yC,GAAAF,GAAA,KACA,OAAAA,EAAA/hD,EAHA,CAMA,SAAAiiD,GAAAxe,GAAA,OAAAA,EAAAA,EAAAplC,OAAA,EAAA,CAEA,SAAA42B,GAAA0b,EAAAvwC,GAEA,IADA,IAAAq6B,EAAA,GACAr8B,EAAA,EAAAA,EAAAuyC,EAAAtyC,OAAAD,IAAAq8B,EAAAr8B,GAAAgC,EAAAuwC,EAAAvyC,GAAAA,GACA,OAAAq8B,CAHA,CAYA,SAAAynB,KAAA,CAEA,SAAAC,GAAA/6C,EAAAjJ,GACA,IAAAikD,EAQA,OAPA1jD,OAAA2jD,OACAD,EAAA1jD,OAAA2jD,OAAAj7C,IAEA86C,GAAAjjD,UAAAmI,EACAg7C,EAAA,IAAAF,IAEA/jD,GAAAoiD,EAAApiD,EAAAikD,GACAA,CATA,CAYA,IAAAE,GAAA,4GACA,SAAAC,GAAA12C,GACA,MAAA,KAAA5G,KAAA4G,IAAAA,EAAA,MACAA,EAAA+vB,eAAA/vB,EAAA1G,eAAAm9C,GAAAr9C,KAAA4G,GAFA,CAIA,SAAAiwC,GAAAjwC,EAAA22C,GACA,OAAAA,KACAA,EAAA3+C,OAAA+Q,QAAA,QAAA,GAAA2tC,GAAA12C,KACA22C,EAAAv9C,KAAA4G,GAFA02C,GAAA12C,EADA,CAMA,SAAA42C,GAAA75B,GACA,IAAA,IAAA5oB,KAAA4oB,EAAA,GAAAA,EAAAxjB,eAAApF,IAAA4oB,EAAA5oB,GAAA,OAAA,EACA,OAAA,CAFA,CAUA,IAAA0iD,GAAA,64DACA,SAAAC,GAAA92C,GAAA,OAAAA,EAAA+2C,WAAA,IAAA,KAAAF,GAAAz9C,KAAA4G,EAAA,CAGA,SAAAg3C,GAAAz8B,EAAApR,EAAAzL,GACA,MAAAA,EAAA,EAAAyL,EAAA,EAAAA,EAAAoR,EAAA/nB,SAAAskD,GAAAv8B,EAAAnR,OAAAD,KAAAA,GAAAzL,EACA,OAAAyL,CAFA,CAQA,SAAA8tC,GAAAC,EAAAt/C,EAAAC,GAIA,IADA,IAAA6F,EAAA9F,EAAAC,GAAA,EAAA,IACA,CACA,GAAAD,GAAAC,EAAA,OAAAD,EACA,IAAAu/C,GAAAv/C,EAAAC,GAAA,EAAAu/C,EAAA15C,EAAA,EAAAwW,KAAAmjC,KAAAF,GAAAjjC,KAAA+b,MAAAknB,GACA,GAAAC,GAAAx/C,EAAA,OAAAs/C,EAAAE,GAAAx/C,EAAAC,EACAq/C,EAAAE,GAAAv/C,EAAAu/C,EACAx/C,EAAAw/C,EAAA15C,CALA,CAJA,CA4BA,IAAA45C,GAAA,KACA,SAAAC,GAAAC,EAAAx3C,EAAAy3C,GACA,IAAAv9B,EACAo9B,GAAA,KACA,IAAA,IAAA/kD,EAAA,EAAAA,EAAAilD,EAAAhlD,SAAAD,EAAA,CACA,IAAA4H,EAAAq9C,EAAAjlD,GACA,GAAA4H,EAAAvC,KAAAoI,GAAA7F,EAAAtC,GAAAmI,EAAA,OAAAzN,EACA4H,EAAAtC,IAAAmI,IACA7F,EAAAvC,MAAAuC,EAAAtC,IAAA,UAAA4/C,EAAAv9B,EAAA3nB,EACA+kD,GAAA/kD,GAEA4H,EAAAvC,MAAAoI,IACA7F,EAAAvC,MAAAuC,EAAAtC,IAAA,UAAA4/C,EAAAv9B,EAAA3nB,EACA+kD,GAAA/kD,EATA,CAYA,OAAA,MAAA2nB,EAAAA,EAAAo9B,EAfA,CAyCA,IAAAI,GAAA,WAeA,IAAAC,EAAA,4CACAC,EAAA,SAAAC,EAAA,QAAAC,EAAA,SAAAC,EAAA,OAEA,SAAAC,EAAAC,EAAArgD,EAAAC,GACAqJ,KAAA+2C,MAAAA,EACA/2C,KAAAtJ,KAAAA,EAAAsJ,KAAArJ,GAAAA,CAFA,CAKA,OAAA,SAAA0iB,EAAA29B,GACA,IAAAC,EAAA,OAAAD,EAAA,IAAA,IAEA,GAAA,GAAA39B,EAAA/nB,QAAA,OAAA0lD,IAAAP,EAAAv+C,KAAAmhB,GAAA,OAAA,EAEA,IADA,IAtBA9lB,EAsBA6uC,EAAA/oB,EAAA/nB,OAAAksB,EAAA,GACAnsB,EAAA,EAAAA,EAAA+wC,IAAA/wC,EACAmsB,EAAAnb,MAxBA9O,EAwBA8lB,EAAAw8B,WAAAxkD,KAvBA,IAJA,2PAIA6W,OAAA3U,GACA,MAAAA,GAAAA,GAAA,KAAA,IACA,MAAAA,GAAAA,GAAA,KAJA,6PAIA2U,OAAA3U,EAAA,MACA,MAAAA,GAAAA,GAAA,KAAA,IACA,MAAAA,GAAAA,GAAA,KAAA,IACA,MAAAA,EAAA,IACA,KAuBA,IAAA,IAAA2jD,EAAA,EAAAj3C,EAAAg3C,EAAAC,EAAA9U,IAAA8U,EAAA,CACA,IAAA74C,EAAAmf,EAAA05B,GACA,KAAA74C,EAAAmf,EAAA05B,GAAAj3C,EACAA,EAAA5B,CAHA,CAWA,IAAA,IAAA84C,EAAA,EAAAl+C,EAAAg+C,EAAAE,EAAA/U,IAAA+U,EAAA,CACA,IAAAC,EAAA55B,EAAA25B,GACA,KAAAC,GAAA,KAAAn+C,EAAAukB,EAAA25B,GAAA,IACAR,EAAAz+C,KAAAk/C,KAAAn+C,EAAAm+C,EAAA,KAAAA,IAAA55B,EAAA25B,GAAA,KAHA,CASA,IAAA,IAAAE,EAAA,EAAAC,EAAA95B,EAAA,GAAA65B,EAAAjV,EAAA,IAAAiV,EAAA,CACA,IAAAE,EAAA/5B,EAAA65B,GACA,KAAAE,GAAA,KAAAD,GAAA,KAAA95B,EAAA65B,EAAA,GAAA75B,EAAA65B,GAAA,IACA,KAAAE,GAAAD,GAAA95B,EAAA65B,EAAA,IACA,KAAAC,GAAA,KAAAA,IAAA95B,EAAA65B,GAAAC,GACAA,EAAAC,CALA,CAYA,IAAA,IAAAC,EAAA,EAAAA,EAAApV,IAAAoV,EAAA,CACA,IAAAC,EAAAj6B,EAAAg6B,GACA,GAAA,KAAAC,EAAAj6B,EAAAg6B,GAAA,SACA,GAAA,KAAAC,EAAA,CACA,IAAA/pC,OAAA,EACA,IAAAA,EAAA8pC,EAAA,EAAA9pC,EAAA00B,GAAA,KAAA5kB,EAAA9P,KAAAA,GAEA,IADA,IAAAwT,EAAAs2B,GAAA,KAAAh6B,EAAAg6B,EAAA,IAAA9pC,EAAA00B,GAAA,KAAA5kB,EAAA9P,GAAA,IAAA,IACAuW,EAAAuzB,EAAAvzB,EAAAvW,IAAAuW,EAAAzG,EAAAyG,GAAA/C,EACAs2B,EAAA9pC,EAAA,CALA,CAHA,CAeA,IAAA,IAAAgqC,EAAA,EAAAC,EAAAV,EAAAS,EAAAtV,IAAAsV,EAAA,CACA,IAAAE,EAAAp6B,EAAAk6B,GACA,KAAAC,GAAA,KAAAC,EAAAp6B,EAAAk6B,GAAA,IACAf,EAAAz+C,KAAA0/C,KAAAD,EAAAC,EAHA,CAYA,IAAA,IAAAC,EAAA,EAAAA,EAAAzV,IAAAyV,EACA,GAAAnB,EAAAx+C,KAAAslB,EAAAq6B,IAAA,CACA,IAAAC,OAAA,EACA,IAAAA,EAAAD,EAAA,EAAAC,EAAA1V,GAAAsU,EAAAx+C,KAAAslB,EAAAs6B,MAAAA,GAIA,IAHA,IAAAnW,EAAA,MAAAkW,EAAAr6B,EAAAq6B,EAAA,GAAAZ,GAEAc,EAAApW,IADA,MAAAmW,EAAA1V,EAAA5kB,EAAAs6B,GAAAb,IACAtV,EAAA,IAAA,IAAAsV,EACAe,EAAAH,EAAAG,EAAAF,IAAAE,EAAAx6B,EAAAw6B,GAAAD,EACAF,EAAAC,EAAA,CAPA,CAiBA,IADA,IAAAhwC,EAAAwuC,EAAA,GACA2B,EAAA,EAAAA,EAAA7V,GACA,GAAAwU,EAAA1+C,KAAAslB,EAAAy6B,IAAA,CACA,IAAA9wC,EAAA8wC,EACA,MAAAA,EAAAA,EAAA7V,GAAAwU,EAAA1+C,KAAAslB,EAAAy6B,MAAAA,GACA3B,EAAAj0C,KAAA,IAAAy0C,EAAA,EAAA3vC,EAAA8wC,GAHA,KAIA,CACA,IAAAhwC,EAAAgwC,EAAArR,EAAA0P,EAAAhlD,OAAA4mD,EAAA,OAAAlB,EAAA,EAAA,EACA,MAAAiB,EAAAA,EAAA7V,GAAA,KAAA5kB,EAAAy6B,KAAAA,GACA,IAAA,IAAAE,EAAAlwC,EAAAkwC,EAAAF,GACA,GAAApB,EAAA3+C,KAAAslB,EAAA26B,IAAA,CACAlwC,EAAAkwC,IAAA7B,EAAAx4B,OAAA8oB,EAAA,EAAA,IAAAkQ,EAAA,EAAA7uC,EAAAkwC,IAAAvR,GAAAsR,GACA,IAAAE,EAAAD,EACA,MAAAA,EAAAA,EAAAF,GAAApB,EAAA3+C,KAAAslB,EAAA26B,MAAAA,GACA7B,EAAAx4B,OAAA8oB,EAAA,EAAA,IAAAkQ,EAAA,EAAAsB,EAAAD,IACAvR,GAAAsR,EACAjwC,EAAAkwC,CANA,OAOAA,EAEAlwC,EAAAgwC,GAAA3B,EAAAx4B,OAAA8oB,EAAA,EAAA,IAAAkQ,EAAA,EAAA7uC,EAAAgwC,GAbA,CA2BA,MAXA,OAAAjB,IACA,GAAAV,EAAA,GAAAS,QAAAjvC,EAAAuR,EAAApjB,MAAA,WACAqgD,EAAA,GAAA5/C,KAAAoR,EAAA,GAAAxW,OACAglD,EAAAv/C,QAAA,IAAA+/C,EAAA,EAAA,EAAAhvC,EAAA,GAAAxW,UAEA,GAAA4jD,GAAAoB,GAAAS,QAAAjvC,EAAAuR,EAAApjB,MAAA,WACAi/C,GAAAoB,GAAA3/C,IAAAmR,EAAA,GAAAxW,OACAglD,EAAAj0C,KAAA,IAAAy0C,EAAA,EAAA1U,EAAAt6B,EAAA,GAAAxW,OAAA8wC,MAIA,OAAA4U,EAAAV,EAAAh0C,UAAAg0C,CAzHA,CAvBA,CAAA,GAuJA,SAAA+B,GAAAz+C,EAAAo9C,GACA,IAAAV,EAAA18C,EAAA08C,MAEA,OADA,MAAAA,IAAAA,EAAA18C,EAAA08C,MAAAE,GAAA58C,EAAA7D,KAAAihD,IACAV,CAHA,CAWA,IAAAgC,GAAA,GAEA9iD,GAAA,SAAA+iD,EAAAl6C,EAAAhL,GACA,GAAAklD,EAAAC,iBACAD,EAAAC,iBAAAn6C,EAAAhL,GAAA,QACA,GAAAklD,EAAAE,YACAF,EAAAE,YAAA,KAAAp6C,EAAAhL,OACA,CACA,IAAA60B,EAAAqwB,EAAAG,YAAAH,EAAAG,UAAA,CAAA,GACAxwB,EAAA7pB,IAAA6pB,EAAA7pB,IAAAi6C,IAAAh7B,OAAAjqB,EAFA,CALA,EAWA,SAAAslD,GAAAJ,EAAAl6C,GACA,OAAAk6C,EAAAG,WAAAH,EAAAG,UAAAr6C,IAAAi6C,EADA,CAIA,SAAArmC,GAAAsmC,EAAAl6C,EAAAhL,GACA,GAAAklD,EAAAK,oBACAL,EAAAK,oBAAAv6C,EAAAhL,GAAA,QACA,GAAAklD,EAAAM,YACAN,EAAAM,YAAA,KAAAx6C,EAAAhL,OACA,CACA,IAAA60B,EAAAqwB,EAAAG,UAAAhiB,EAAAxO,GAAAA,EAAA7pB,GACA,GAAAq4B,EAAA,CACA,IAAA3uB,EAAAF,EAAA6uB,EAAArjC,GACA0U,GAAA,IACAmgB,EAAA7pB,GAAAq4B,EAAAxvB,MAAA,EAAAa,GAAAuV,OAAAoZ,EAAAxvB,MAAAa,EAAA,IAHA,CAFA,CALA,CAeA,SAAAomB,GAAAoqB,EAAAl6C,GACA,IAAAy6C,EAAAH,GAAAJ,EAAAl6C,GACA,GAAAy6C,EAAAxnD,OAEA,IADA,IAAAiiD,EAAAj0B,MAAAptB,UAAAgV,MAAAvU,KAAA4W,UAAA,GACAlY,EAAA,EAAAA,EAAAynD,EAAAxnD,SAAAD,EAAAynD,EAAAznD,GAAAmY,MAAA,KAAA+pC,EAJA,CAUA,SAAAwF,GAAA/kD,EAAAxB,EAAAsxC,GAIA,MAHA,iBAAAtxC,IACAA,EAAA,CAAA6L,KAAA7L,EAAAwmD,eAAA,WAAAh5C,KAAAi5C,kBAAA,CAAA,IACA9qB,GAAAn6B,EAAA8vC,GAAAtxC,EAAA6L,KAAArK,EAAAxB,GACA0mD,GAAA1mD,IAAAA,EAAA2mD,gBAJA,CAOA,SAAAC,GAAAplD,GACA,IAAA0iC,EAAA1iC,EAAA0kD,WAAA1kD,EAAA0kD,UAAAtrB,eACA,GAAAsJ,EAEA,IADA,IAAAqL,EAAA/tC,EAAAqlD,MAAAC,yBAAAtlD,EAAAqlD,MAAAC,uBAAA,IACAjoD,EAAA,EAAAA,EAAAqlC,EAAAplC,SAAAD,GAAA,GAAAwW,EAAAk6B,EAAArL,EAAArlC,KACA0wC,EAAA1/B,KAAAq0B,EAAArlC,GALA,CAQA,SAAAkoD,GAAAhB,EAAAl6C,GACA,OAAAs6C,GAAAJ,EAAAl6C,GAAA/M,OAAA,CADA,CAMA,SAAAkoD,GAAAC,GACAA,EAAAvnD,UAAAsD,GAAA,SAAA6I,EAAAhL,GAAAmC,GAAAwK,KAAA3B,EAAAhL,EAAA,EACAomD,EAAAvnD,UAAA+f,IAAA,SAAA5T,EAAAhL,GAAA4e,GAAAjS,KAAA3B,EAAAhL,EAAA,CAFA,CAQA,SAAAqmD,GAAAlnD,GACAA,EAAAwmD,eAAAxmD,EAAAwmD,iBACAxmD,EAAAmnD,aAAA,CAFA,CAIA,SAAAC,GAAApnD,GACAA,EAAAqnD,gBAAArnD,EAAAqnD,kBACArnD,EAAAsnD,cAAA,CAFA,CAIA,SAAAZ,GAAA1mD,GACA,OAAA,MAAAA,EAAAymD,iBAAAzmD,EAAAymD,iBAAA,GAAAzmD,EAAAmnD,WADA,CAGA,SAAAI,GAAAvnD,GAAAknD,GAAAlnD,GAAAonD,GAAApnD,EAAA,CAEA,SAAAwnD,GAAAxnD,GAAA,OAAAA,EAAArB,QAAAqB,EAAAyiB,UAAA,CACA,SAAAglC,GAAAznD,GACA,IAAAgf,EAAAhf,EAAA0nD,MAOA,OANA,MAAA1oC,IACA,EAAAhf,EAAAqnC,OAAAroB,EAAA,EACA,EAAAhf,EAAAqnC,OAAAroB,EAAA,EACA,EAAAhf,EAAAqnC,SAAAroB,EAAA,IAEAu/B,GAAAv+C,EAAA2nD,SAAA,GAAA3oC,IAAAA,EAAA,GACAA,CARA,CAYA,IAQA4oC,GAeAC,GAvBAC,GAAA,WAGA,GAAAtK,GAAAC,EAAA,EAAA,OAAA,EACA,IAAAxzC,EAAA6V,EAAA,OACA,MAAA,cAAA7V,GAAA,aAAAA,CALA,CAAA,GASA,SAAA89C,GAAAC,GACA,GAAA,MAAAJ,GAAA,CACA,IAAAliD,EAAAoa,EAAA,OAAA,KACAo/B,EAAA8I,EAAAloC,EAAA,OAAA,CAAApa,EAAA2a,SAAA2E,eAAA,QACA,GAAAgjC,EAAA9oB,WAAAve,eACAinC,GAAAliD,EAAAwb,aAAA,GAAAxb,EAAAib,aAAA,KAAA68B,GAAAC,EAAA,GAJA,CAMA,IAAAv9B,EAAA0nC,GAAA9nC,EAAA,OAAA,KACAA,EAAA,OAAA,IAAA,KAAA,yDAEA,OADAI,EAAA2c,aAAA,UAAA,IACA3c,CAVA,CAeA,SAAA+nC,GAAAD,GACA,GAAA,MAAAH,GAAA,OAAAA,GACA,IAAAK,EAAAhJ,EAAA8I,EAAA3nC,SAAA2E,eAAA,QACAmjC,EAAA1pC,EAAAypC,EAAA,EAAA,GAAAvlC,wBACAylC,EAAA3pC,EAAAypC,EAAA,EAAA,GAAAvlC,wBAEA,OADAq8B,EAAAgJ,MACAG,GAAAA,EAAAvnC,MAAAunC,EAAAtlC,SACAglC,GAAAO,EAAAvlC,MAAAslC,EAAAtlC,MAAA,EAPA,CAYA,IA8BA7iB,GA9BAqoD,GAAA,GAAA,QAAA9+B,MAAA,MAAAzqB,OAAA,SAAA2V,GAEA,IADA,IAAAgB,EAAA,EAAAuC,EAAA,GAAAhX,EAAAyT,EAAA3V,OACA2W,GAAAzU,GAAA,CACA,IAAAsnD,EAAA7zC,EAAAY,QAAA,KAAAI,IACA,GAAA6yC,IAAAA,EAAA7zC,EAAA3V,QACA,IAAAsI,EAAAqN,EAAAC,MAAAe,EAAA,MAAAhB,EAAAiB,OAAA4yC,EAAA,GAAAA,EAAA,EAAAA,GACAl/C,EAAAhC,EAAAiO,QAAA,OACA,GAAAjM,GACA4O,EAAAnI,KAAAzI,EAAAsN,MAAA,EAAAtL,IACAqM,GAAArM,EAAA,IAEA4O,EAAAnI,KAAAzI,GACAqO,EAAA6yC,EAAA,EAVA,CAaA,OAAAtwC,CAfA,EAgBA,SAAAvD,GAAA,OAAAA,EAAA8U,MAAA,WAAA,EAEAg/B,GAAAjmD,OAAAm4B,aAAA,SAAA+tB,GACA,IAAA,OAAAA,EAAAjH,gBAAAiH,EAAAhH,YAAA,CACA,MAAAxhD,GAAA,OAAA,CAAA,CAFA,EAGA,SAAAwoD,GACA,IAAA/pC,EACA,IAAAA,EAAA+pC,EAAAznC,cAAAyvB,UAAAwP,aAAA,CACA,MAAAhgD,GAAA,CACA,SAAAye,GAAAA,EAAAgqC,iBAAAD,IACA,GAAA/pC,EAAAiqC,iBAAA,aAAAjqC,EALA,EAQAkqC,GAEA,WADA3oD,GAAA8f,EAAA,UAEA9f,GAAA68B,aAAA,SAAA,WACA,mBAAA78B,GAAA4oD,QAGAC,GAAA,KAUAC,GAAA,CAAA,EAAA/4C,GAAA,CAAA,EAKA,SAAAvL,GAAAK,EAAAjD,GACAmV,UAAAjY,OAAA,IACA8C,EAAAmnD,aAAAj8B,MAAAptB,UAAAgV,MAAAvU,KAAA4W,UAAA,IACA+xC,GAAAjkD,GAAAjD,CAHA,CAYA,SAAA+uC,GAAAzqC,GACA,GAAA,iBAAAA,GAAA6J,GAAAlK,eAAAK,GACAA,EAAA6J,GAAA7J,QACA,GAAAA,GAAA,iBAAAA,EAAArB,MAAAkL,GAAAlK,eAAAK,EAAArB,MAAA,CACA,IAAA2hB,EAAAzW,GAAA7J,EAAArB,MACA,iBAAA2hB,IAAAA,EAAA,CAAA3hB,KAAA2hB,KACAtgB,EAAA08C,GAAAp8B,EAAAtgB,IACArB,KAAA2hB,EAAA3hB,IAJA,KAKA,IAAA,iBAAAqB,GAAA,0BAAAR,KAAAQ,GACA,OAAAyqC,GAAA,mBACA,GAAA,iBAAAzqC,GAAA,2BAAAR,KAAAQ,GACA,OAAAyqC,GAAA,mBADA,CAGA,MAAA,iBAAAzqC,EAAA,CAAArB,KAAAqB,GACAA,GAAA,CAAArB,KAAA,OAdA,CAmBA,SAAAD,GAAAuc,EAAAjb,GACAA,EAAAyqC,GAAAzqC,GACA,IAAA8iD,EAAAF,GAAA5iD,EAAArB,MACA,IAAAmkD,EAAA,OAAApkD,GAAAuc,EAAA,cACA,IAAA8nC,EAAAD,EAAA7nC,EAAAjb,GACA,GAAAgjD,GAAArjD,eAAAK,EAAArB,MAAA,CACA,IAAAskD,EAAAD,GAAAhjD,EAAArB,MACA,IAAA,IAAAoH,KAAAk9C,EACAA,EAAAtjD,eAAAoG,KACAg9C,EAAApjD,eAAAoG,KAAAg9C,EAAA,IAAAh9C,GAAAg9C,EAAAh9C,IACAg9C,EAAAh9C,GAAAk9C,EAAAl9C,GALA,CAUA,GAFAg9C,EAAApkD,KAAAqB,EAAArB,KACAqB,EAAAsJ,aAAAy5C,EAAAz5C,WAAAtJ,EAAAsJ,YACAtJ,EAAAkjD,UAAA,IAAA,IAAAC,KAAAnjD,EAAAkjD,UACAH,EAAAI,GAAAnjD,EAAAkjD,UAAAC,GAEA,OAAAJ,CAlBA,CAuBA,IAAAC,GAAA,CAAA,EACA,SAAAI,GAAA1nD,EAAA2nD,GAEAvI,EAAAuI,EADAL,GAAArjD,eAAAjE,GAAAsnD,GAAAtnD,GAAAsnD,GAAAtnD,GAAA,CAAA,EADA,CAKA,SAAAqF,GAAArF,EAAA2D,GACA,IAAA,IAAAA,EAAA,OAAAA,EACA,GAAA3D,EAAAqF,UAAA,OAAArF,EAAAqF,UAAA1B,GACA,IAAAikD,EAAA,CAAA,EACA,IAAA,IAAA/oD,KAAA8E,EAAA,CACA,IAAA5C,EAAA4C,EAAA9E,GACAkC,aAAAmqB,QAAAnqB,EAAAA,EAAAmoB,OAAA,KACA0+B,EAAA/oD,GAAAkC,CAHA,CAKA,OAAA6mD,CATA,CAcA,SAAAliD,GAAA1F,EAAA2D,GAEA,IADA,IAAA0Q,EACArU,EAAA0F,YACA2O,EAAArU,EAAA0F,UAAA/B,KACA0Q,EAAArU,MAAAA,GACA2D,EAAA0Q,EAAA1Q,MACA3D,EAAAqU,EAAArU,KAEA,OAAAqU,GAAA,CAAArU,KAAAA,EAAA2D,MAAAA,EARA,CAWA,SAAAuB,GAAAlF,EAAA6nD,EAAAC,GACA,OAAA9nD,EAAAkF,YAAAlF,EAAAkF,WAAA2iD,EAAAC,EADA,CASA,IAAA5rC,GAAA,SAAArJ,EAAA0sC,EAAAwI,GACAn8C,KAAAiI,IAAAjI,KAAAmH,MAAA,EACAnH,KAAAiH,OAAAA,EACAjH,KAAA2zC,QAAAA,GAAA,EACA3zC,KAAAo8C,cAAAp8C,KAAAq8C,gBAAA,EACAr8C,KAAAs8C,UAAA,EACAt8C,KAAAm8C,WAAAA,CANA,EAiFA,SAAAnvB,GAAAmlB,EAAAl/C,GAEA,IADAA,GAAAk/C,EAAAld,OACA,GAAAhiC,GAAAk/C,EAAAvV,KAAA,MAAA,IAAAtpC,MAAA,qBAAAL,EAAAk/C,EAAAld,OAAA,qBAEA,IADA,IAAAsnB,EAAApK,GACAoK,EAAAlkC,OACA,IAAA,IAAAhnB,EAAA,KAAAA,EAAA,CACA,IAAA0gD,EAAAwK,EAAAtgB,SAAA5qC,GAAAmrD,EAAAzK,EAAA0K,YACA,GAAAxpD,EAAAupD,EAAA,CAAAD,EAAAxK,EAAA,KAAA,CACA9+C,GAAAupD,CAHA,CAMA,OAAAD,EAAAlkC,MAAAplB,EAXA,CAgBA,SAAAypD,GAAAvK,EAAAhrC,EAAAuG,GACA,IAAAggB,EAAA,GAAAz6B,EAAAkU,EAAAvN,KAQA,OAPAu4C,EAAAxF,KAAAxlC,EAAAvN,KAAA8T,EAAA9T,KAAA,GAAA,SAAAA,GACA,IAAA7D,EAAA6D,EAAA7D,KACA9C,GAAAya,EAAA9T,OAAA7D,EAAAA,EAAAmR,MAAA,EAAAwG,EAAA5O,KACA7L,GAAAkU,EAAAvN,OAAA7D,EAAAA,EAAAmR,MAAAC,EAAArI,KACA4uB,EAAArrB,KAAAtM,KACA9C,CALA,IAOAy6B,CATA,CAYA,SAAAivB,GAAAxK,EAAAz7C,EAAAC,GACA,IAAA+2B,EAAA,GAEA,OADAykB,EAAAxF,KAAAj2C,EAAAC,GAAA,SAAAiD,GAAA8zB,EAAArrB,KAAAzI,EAAA7D,KAAA,IACA23B,CAHA,CAQA,SAAAkvB,GAAAhjD,EAAAu3B,GACA,IAAA0rB,EAAA1rB,EAAAv3B,EAAAu3B,OACA,GAAA0rB,EAAA,IAAA,IAAA5pD,EAAA2G,EAAA3G,EAAAA,EAAAA,EAAA0+C,OAAA1+C,EAAAk+B,QAAA0rB,CAFA,CAOA,SAAA1U,GAAAvuC,GACA,GAAA,MAAAA,EAAA+3C,OAAA,OAAA,KAEA,IADA,IAAA14C,EAAAW,EAAA+3C,OAAAmL,EAAAj1C,EAAA5O,EAAAof,MAAAze,GACA2iD,EAAAtjD,EAAA04C,OAAA4K,EAAAtjD,EAAAsjD,EAAAA,EAAAA,EAAA5K,OACA,IAAA,IAAAtgD,EAAA,EACAkrD,EAAAtgB,SAAA5qC,IAAA4H,IADA5H,EAEAyrD,GAAAP,EAAAtgB,SAAA5qC,GAAAorD,YAGA,OAAAK,EAAA7jD,EAAAg8B,KATA,CAcA,SAAA8nB,GAAAR,EAAAS,GACA,IAAA/pD,EAAAspD,EAAAtnB,MACAxqB,EAAA,EAAA,CACA,IAAA,IAAAysC,EAAA,EAAAA,EAAAqF,EAAAtgB,SAAA3qC,SAAA4lD,EAAA,CACA,IAAAnF,EAAAwK,EAAAtgB,SAAAib,GAAAp4C,EAAAizC,EAAA5gB,OACA,GAAA6rB,EAAAl+C,EAAA,CAAAy9C,EAAAxK,EAAA,SAAAtnC,CAAA,CACAuyC,GAAAl+C,EACA7L,GAAA8+C,EAAA0K,WAJA,CAMA,OAAAxpD,CAPA,QAQAspD,EAAAlkC,OAEA,IADA,IAAAhnB,EAAA,EACAA,EAAAkrD,EAAAlkC,MAAA/mB,SAAAD,EAAA,CACA,IAAA4rD,EAAAV,EAAAlkC,MAAAhnB,GAAA8/B,OACA,GAAA6rB,EAAAC,EAAA,MACAD,GAAAC,CAHA,CAKA,OAAAhqD,EAAA5B,CAjBA,CAoBA,SAAA6rD,GAAA/K,EAAA3+C,GAAA,OAAAA,GAAA2+C,EAAAld,OAAAzhC,EAAA2+C,EAAAld,MAAAkd,EAAAvV,IAAA,CAEA,SAAAugB,GAAAxpC,EAAAtiB,GACA,OAAAiB,OAAAqhB,EAAAypC,oBAAA/rD,EAAAsiB,EAAA0pC,iBADA,CAKA,SAAAzlC,GAAAhe,EAAAkF,EAAAy3C,GAGA,QAFA,IAAAA,IAAAA,EAAA,QAEAv2C,gBAAA4X,IAAA,OAAA,IAAAA,GAAAhe,EAAAkF,EAAAy3C,GACAv2C,KAAApG,KAAAA,EACAoG,KAAAlB,GAAAA,EACAkB,KAAAu2C,OAAAA,CANA,CAWA,SAAAjK,GAAAl5C,EAAAoe,GAAA,OAAApe,EAAAwG,KAAA4X,EAAA5X,MAAAxG,EAAA0L,GAAA0S,EAAA1S,EAAA,CAEA,SAAAw+C,GAAAlqD,EAAAoe,GAAA,OAAApe,EAAAmjD,QAAA/kC,EAAA+kC,QAAA,GAAAjK,GAAAl5C,EAAAoe,EAAA,CAEA,SAAA+rC,GAAAnoC,GAAA,OAAAwC,GAAAxC,EAAAxb,KAAAwb,EAAAtW,GAAA,CACA,SAAA0+C,GAAApqD,EAAAoe,GAAA,OAAA86B,GAAAl5C,EAAAoe,GAAA,EAAAA,EAAApe,CAAA,CACA,SAAAqqD,GAAArqD,EAAAoe,GAAA,OAAA86B,GAAAl5C,EAAAoe,GAAA,EAAApe,EAAAoe,CAAA,CAIA,SAAAksC,GAAAvL,EAAAl/C,GAAA,OAAA+f,KAAAC,IAAAk/B,EAAAld,MAAAjiB,KAAAK,IAAApgB,EAAAk/C,EAAAld,MAAAkd,EAAAvV,KAAA,GAAA,CACA,SAAA+gB,GAAAxL,EAAAlqC,GACA,GAAAA,EAAArO,KAAAu4C,EAAAld,MAAA,OAAArd,GAAAu6B,EAAAld,MAAA,GACA,IAAA2oB,EAAAzL,EAAAld,MAAAkd,EAAAvV,KAAA,EACA,OAAA30B,EAAArO,KAAAgkD,EAAAhmC,GAAAgmC,EAAA5wB,GAAAmlB,EAAAyL,GAAA7nD,KAAAzE,QAGA,SAAA2W,EAAA41C,GACA,IAAA/+C,EAAAmJ,EAAAnJ,GACA,OAAA,MAAAA,GAAAA,EAAA++C,EAAAjmC,GAAA3P,EAAArO,KAAAikD,GACA/+C,EAAA,EAAA8Y,GAAA3P,EAAArO,KAAA,GACAqO,CAJA,CAFA61C,CAAA71C,EAAA+kB,GAAAmlB,EAAAlqC,EAAArO,MAAA7D,KAAAzE,OAJA,CAYA,SAAAysD,GAAA5L,EAAAvO,GAEA,IADA,IAAAlW,EAAA,GACAr8B,EAAA,EAAAA,EAAAuyC,EAAAtyC,OAAAD,IAAAq8B,EAAAr8B,GAAAssD,GAAAxL,EAAAvO,EAAAvyC,IACA,OAAAq8B,CAHA,CA9LApd,GAAApe,UAAAsH,IAAA,WAAA,OAAAwG,KAAAiI,KAAAjI,KAAAiH,OAAA3V,MAAA,EACAgf,GAAApe,UAAAmP,IAAA,WAAA,OAAArB,KAAAiI,KAAAjI,KAAAs8C,SAAA,EACAhsC,GAAApe,UAAAwU,KAAA,WAAA,OAAA1G,KAAAiH,OAAAiB,OAAAlI,KAAAiI,WAAAxC,CAAA,EACA6K,GAAApe,UAAA6M,KAAA,WACA,GAAAiB,KAAAiI,IAAAjI,KAAAiH,OAAA3V,OACA,OAAA0O,KAAAiH,OAAAiB,OAAAlI,KAAAiI,MAFA,EAIAqI,GAAApe,UAAA8M,IAAA,SAAA/I,GACA,IAAA6I,EAAAkB,KAAAiH,OAAAiB,OAAAlI,KAAAiI,KAIA,GAFA,iBAAAhS,EAAA6I,GAAA7I,EACA6I,IAAA7I,EAAAiC,KAAAjC,EAAAiC,KAAA4G,GAAA7I,EAAA6I,IACA,QAAAkB,KAAAiI,IAAAnJ,CALA,EAOAwR,GAAApe,UAAAgN,SAAA,SAAAjJ,GAEA,IADA,IAAAkR,EAAAnH,KAAAiI,IACAjI,KAAAhB,IAAA/I,KACA,OAAA+J,KAAAiI,IAAAd,CAHA,EAKAmJ,GAAApe,UAAAqP,SAAA,WAEA,IADA,IAAA4F,EAAAnH,KAAAiI,IACA,aAAA/P,KAAA8H,KAAAiH,OAAAiB,OAAAlI,KAAAiI,SAAAjI,KAAAiI,IACA,OAAAjI,KAAAiI,IAAAd,CAHA,EAKAmJ,GAAApe,UAAA0U,UAAA,WAAA5G,KAAAiI,IAAAjI,KAAAiH,OAAA3V,MAAA,EACAgf,GAAApe,UAAA8rD,OAAA,SAAAl/C,GACA,IAAAka,EAAAhZ,KAAAiH,OAAAY,QAAA/I,EAAAkB,KAAAiI,KACA,GAAA+Q,GAAA,EAAA,OAAAhZ,KAAAiI,IAAA+Q,GAAA,CAFA,EAIA1I,GAAApe,UAAAkH,OAAA,SAAAnG,GAAA+M,KAAAiI,KAAAhV,CAAA,EACAqd,GAAApe,UAAAwN,OAAA,WAKA,OAJAM,KAAAo8C,cAAAp8C,KAAAmH,QACAnH,KAAAq8C,gBAAA3I,EAAA1zC,KAAAiH,OAAAjH,KAAAmH,MAAAnH,KAAA2zC,QAAA3zC,KAAAo8C,cAAAp8C,KAAAq8C,iBACAr8C,KAAAo8C,cAAAp8C,KAAAmH,OAEAnH,KAAAq8C,iBAAAr8C,KAAAs8C,UAAA5I,EAAA1zC,KAAAiH,OAAAjH,KAAAs8C,UAAAt8C,KAAA2zC,SAAA,EALA,EAOArjC,GAAApe,UAAAoP,YAAA,WACA,OAAAoyC,EAAA1zC,KAAAiH,OAAA,KAAAjH,KAAA2zC,UACA3zC,KAAAs8C,UAAA5I,EAAA1zC,KAAAiH,OAAAjH,KAAAs8C,UAAAt8C,KAAA2zC,SAAA,EAFA,EAIArjC,GAAApe,UAAA+D,MAAA,SAAAwV,EAAAwyC,EAAAC,GACA,GAAA,iBAAAzyC,EAOA,CACA,IAAAxV,EAAA+J,KAAAiH,OAAAC,MAAAlH,KAAAiI,KAAAhS,MAAAwV,GACA,OAAAxV,GAAAA,EAAA8R,MAAA,EAAA,MACA9R,IAAA,IAAAgoD,IAAAj+C,KAAAiI,KAAAhS,EAAA,GAAA3E,QACA2E,EAJA,CANA,IAAAkoD,EAAA,SAAA9kC,GAAA,OAAA6kC,EAAA7kC,EAAAjhB,cAAAihB,CAAA,EAEA,GAAA8kC,EADAn+C,KAAAiH,OAAAgX,OAAAje,KAAAiI,IAAAwD,EAAAna,UACA6sD,EAAA1yC,GAEA,OADA,IAAAwyC,IAAAj+C,KAAAiI,KAAAwD,EAAAna,SACA,CANA,EAeAgf,GAAApe,UAAAiG,QAAA,WAAA,OAAA6H,KAAAiH,OAAAC,MAAAlH,KAAAmH,MAAAnH,KAAAiI,IAAA,EACAqI,GAAApe,UAAAksD,eAAA,SAAAnrD,EAAAgX,GACAjK,KAAAs8C,WAAArpD,EACA,IAAA,OAAAgX,GAAA,CAAA,QACAjK,KAAAs8C,WAAArpD,CAAA,CAHA,EAKAqd,GAAApe,UAAAi3C,UAAA,SAAAl2C,GACA,IAAAorD,EAAAr+C,KAAAm8C,WACA,OAAAkC,GAAAA,EAAAlV,UAAAl2C,EAFA,EAIAqd,GAAApe,UAAAosD,UAAA,WACA,IAAAD,EAAAr+C,KAAAm8C,WACA,OAAAkC,GAAAA,EAAAC,UAAAt+C,KAAAiI,IAFA,EAkIA,IAAAs2C,GAAA,SAAAxmD,EAAAoxC,GACAnpC,KAAAjI,MAAAA,EACAiI,KAAAmpC,UAAAA,CAFA,EAKArpC,GAAA,SAAAqyC,EAAAp6C,EAAA6B,EAAAuvC,GACAnpC,KAAAjI,MAAAA,EACAiI,KAAAmyC,IAAAA,EACAnyC,KAAApG,KAAAA,EACAoG,KAAAw+C,aAAArV,GAAA,EACAnpC,KAAAy+C,WAAA,KACAz+C,KAAA0+C,aAAA,CANA,EA8CA,SAAAC,GAAA3qD,EAAA4F,EAAAsG,EAAA0+C,GAGA,IAAAxb,EAAA,CAAApvC,EAAA+D,MAAA8mD,SAAAC,EAAA,CAAA,EAEAC,GAAA/qD,EAAA4F,EAAA7D,KAAA/B,EAAAm+C,IAAA/9C,KAAA8L,GAAA,SAAAwN,EAAA9X,GAAA,OAAAwtC,EAAA/gC,KAAAqL,EAAA9X,EAAA,GACAkpD,EAAAF,GAkCA,IAjCA,IAAA7mD,EAAAmI,EAAAnI,MAGAuhC,EAAA,SAAAzmC,GACAqN,EAAAu+C,WAAArb,EACA,IAAA4b,EAAAhrD,EAAA+D,MAAAknD,SAAApsD,GAAAxB,EAAA,EAAAu1C,EAAA,EACA1mC,EAAAnI,OAAA,EACAgnD,GAAA/qD,EAAA4F,EAAA7D,KAAAipD,EAAA5qD,KAAA8L,GAAA,SAAAwN,EAAA9X,GAGA,IAFA,IAAAuR,EAAA9V,EAEAu1C,EAAAl5B,GAAA,CACA,IAAAwxC,EAAA9b,EAAA/xC,GACA6tD,EAAAxxC,GACA01B,EAAAtlB,OAAAzsB,EAAA,EAAAqc,EAAA01B,EAAA/xC,EAAA,GAAA6tD,GACA7tD,GAAA,EACAu1C,EAAA5zB,KAAAK,IAAA3F,EAAAwxC,EALA,CAOA,GAAAtpD,EACA,GAAAopD,EAAAG,OACA/b,EAAAtlB,OAAA3W,EAAA9V,EAAA8V,EAAAuG,EAAA,WAAA9X,GACAvE,EAAA8V,EAAA,OAEA,KAAAA,EAAA9V,EAAA8V,GAAA,EAAA,CACA,IAAAlO,EAAAmqC,EAAAj8B,EAAA,GACAi8B,EAAAj8B,EAAA,IAAAlO,EAAAA,EAAA,IAAA,IAAA,WAAArD,CAFA,CAfA,GAoBAkpD,GACA5+C,EAAAnI,MAAAA,EACAmI,EAAAu+C,WAAA,KACAv+C,EAAAw+C,aAAA,CA3BA,EA8BA7rD,EAAA,EAAAA,EAAAmB,EAAA+D,MAAAknD,SAAA3tD,SAAAuB,EAAAymC,EAAAzmC,GAEA,MAAA,CAAAusD,OAAAhc,EAAAic,QAAAP,EAAAQ,SAAAR,EAAAS,UAAAT,EAAA,KA1CA,CA6CA,SAAAU,GAAAxrD,EAAA4F,EAAA6lD,GACA,IAAA7lD,EAAAwlD,QAAAxlD,EAAAwlD,OAAA,IAAAprD,EAAA+D,MAAA8mD,QAAA,CACA,IAAA3+C,EAAAw/C,GAAA1rD,EAAAm0C,GAAAvuC,IACA+lD,EAAA/lD,EAAA7D,KAAAzE,OAAA0C,EAAA2f,QAAAisC,oBAAAnmD,GAAAzF,EAAAm+C,IAAA/9C,KAAA8L,EAAAnI,OACAyS,EAAAm0C,GAAA3qD,EAAA4F,EAAAsG,GACAy/C,IAAAz/C,EAAAnI,MAAA4nD,GACA/lD,EAAAimD,WAAA3/C,EAAA4/C,MAAAH,GACA/lD,EAAAwlD,OAAA50C,EAAA40C,OACA50C,EAAA60C,QAAAzlD,EAAAmmD,aAAAv1C,EAAA60C,QACAzlD,EAAAmmD,eAAAnmD,EAAAmmD,aAAA,MACAN,IAAAzrD,EAAAm+C,IAAA6N,oBACAhsD,EAAAm+C,IAAA8N,aAAAjtC,KAAAC,IAAAjf,EAAAm+C,IAAA8N,eAAAjsD,EAAAm+C,IAAA6N,mBAVA,CAYA,OAAApmD,EAAAwlD,MAbA,CAgBA,SAAAM,GAAA1rD,EAAAf,EAAAitD,GACA,IAAA/N,EAAAn+C,EAAAm+C,IAAA5gB,EAAAv9B,EAAAu9B,QACA,IAAA4gB,EAAA/9C,KAAAkF,WAAA,OAAA,IAAAwG,GAAAqyC,GAAA,EAAAl/C,GACA,IAAAkU,EA6HA,SAAAnT,EAAAf,EAAAitD,GAGA,IAFA,IAAAC,EAAAC,EAAAjO,EAAAn+C,EAAAm+C,IACAkO,EAAAH,GAAA,EAAAjtD,GAAAe,EAAAm+C,IAAA/9C,KAAA0F,UAAA,IAAA,KACAX,EAAAlG,EAAAkG,EAAAknD,IAAAlnD,EAAA,CACA,GAAAA,GAAAg5C,EAAAld,MAAA,OAAAkd,EAAAld,MACA,IAAAr7B,EAAAozB,GAAAmlB,EAAAh5C,EAAA,GAAAqpC,EAAA5oC,EAAAimD,WACA,GAAArd,KAAA0d,GAAA/mD,GAAAqpC,aAAA+b,GAAA/b,EAAA2G,UAAA,IAAAgJ,EAAA8N,cACA,OAAA9mD,EACA,IAAAgH,EAAAuzC,EAAA95C,EAAA7D,KAAA,KAAA/B,EAAA2f,QAAAggC,UACA,MAAAyM,GAAAD,EAAAhgD,KACAigD,EAAAjnD,EAAA,EACAgnD,EAAAhgD,EARA,CAWA,OAAAigD,CAdA,CA7HAE,CAAAtsD,EAAAf,EAAAitD,GACAK,EAAAp5C,EAAAgrC,EAAAld,OAAAjI,GAAAmlB,EAAAhrC,EAAA,GAAA04C,WACA3/C,EAAAqgD,EAAAzgD,GAAA0gD,UAAArO,EAAAoO,EAAAp5C,GAAA,IAAArH,GAAAqyC,EAAA74C,GAAA64C,EAAA/9C,MAAA+S,GASA,OAPAgrC,EAAAxF,KAAAxlC,EAAAlU,GAAA,SAAA2G,GACA6mD,GAAAzsD,EAAA4F,EAAA7D,KAAAmK,GACA,IAAA+H,EAAA/H,EAAAtG,KACAA,EAAAimD,WAAA53C,GAAAhV,EAAA,GAAAgV,EAAA,GAAA,GAAAA,GAAAspB,EAAAmvB,UAAAz4C,EAAAspB,EAAAovB,OAAAzgD,EAAA4/C,OAAA,KACA5/C,EAAAspC,UAJA,IAMA0W,IAAA/N,EAAA8N,aAAA//C,EAAAtG,MACAsG,CAdA,CAoBA,SAAAugD,GAAAzsD,EAAA+B,EAAAmK,EAAA0gD,GACA,IAAAxsD,EAAAJ,EAAAm+C,IAAA/9C,KACA0D,EAAA,IAAAwY,GAAAva,EAAA/B,EAAA2f,QAAAggC,QAAAzzC,GAGA,IAFApI,EAAAqP,MAAArP,EAAAmQ,IAAA24C,GAAA,EACA,IAAA7qD,GAAA8qD,GAAAzsD,EAAA8L,EAAAnI,QACAD,EAAA0B,OACAsnD,GAAA1sD,EAAA0D,EAAAoI,EAAAnI,OACAD,EAAAqP,MAAArP,EAAAmQ,GAPA,CAWA,SAAA44C,GAAAzsD,EAAA2D,GACA,GAAA3D,EAAA2sD,UAAA,OAAA3sD,EAAA2sD,UAAAhpD,GACA,GAAA3D,EAAA0F,UAAA,CACA,IAAAmQ,EAAAnQ,GAAA1F,EAAA2D,GACA,OAAAkS,EAAA7V,KAAA2sD,UAAA92C,EAAA7V,KAAA2sD,UAAA92C,EAAAlS,YAAA,CAFA,CAFA,CAOA,SAAA+oD,GAAA1sD,EAAA0D,EAAAC,EAAAkS,GACA,IAAA,IAAA5Y,EAAA,EAAAA,EAAA,GAAAA,IAAA,CACA4Y,IAAAA,EAAA,GAAAnQ,GAAA1F,EAAA2D,GAAA3D,MACA,IAAAwB,EAAAxB,EAAA4D,MAAAF,EAAAC,GACA,GAAAD,EAAAmQ,IAAAnQ,EAAAqP,MAAA,OAAAvR,CAHA,CAKA,MAAA,IAAAtC,MAAA,QAAAc,EAAAiD,KAAA,6BANA,CAxIAyI,GAAA5N,UAAAi3C,UAAA,SAAAl2C,GACA,IAAA2G,EAAAoG,KAAAmyC,IAAAnlB,QAAAhtB,KAAApG,KAAA3G,GAEA,OADA,MAAA2G,GAAA3G,EAAA+M,KAAAw+C,eAAAx+C,KAAAw+C,aAAAvrD,GACA2G,CAHA,EAMAkG,GAAA5N,UAAAosD,UAAA,SAAArrD,GACA,IAAA+M,KAAAy+C,WAAA,OAAA,KACA,KAAAz+C,KAAAy+C,WAAAz+C,KAAA0+C,eAAAzrD,GACA+M,KAAA0+C,cAAA,EACA,IAAArgD,EAAA2B,KAAAy+C,WAAAz+C,KAAA0+C,aAAA,GACA,MAAA,CAAArgD,KAAAA,GAAAA,EAAA6iB,QAAA,kBAAA,IACA0b,KAAA58B,KAAAy+C,WAAAz+C,KAAA0+C,cAAAzrD,EANA,EASA6M,GAAA5N,UAAAs3C,SAAA,WACAxpC,KAAApG,OACAoG,KAAAw+C,aAAA,GAAAx+C,KAAAw+C,cAFA,EAKA1+C,GAAA0gD,UAAA,SAAArO,EAAAoO,EAAA3mD,GACA,OAAA2mD,aAAAhC,GACA,IAAAz+C,GAAAqyC,EAAA14C,GAAA04C,EAAA/9C,KAAAmsD,EAAAxoD,OAAA6B,EAAA2mD,EAAApX,WAEA,IAAArpC,GAAAqyC,EAAA14C,GAAA04C,EAAA/9C,KAAAmsD,GAAA3mD,EAJA,EAOAkG,GAAA5N,UAAA4tD,KAAA,SAAAkB,GACA,IAAAjpD,GAAA,IAAAipD,EAAAvnD,GAAAuG,KAAAmyC,IAAA/9C,KAAA4L,KAAAjI,OAAAiI,KAAAjI,MACA,OAAAiI,KAAAw+C,aAAA,EAAA,IAAAD,GAAAxmD,EAAAiI,KAAAw+C,cAAAzmD,CAFA,EAsHA,IAAAkpD,GAAA,SAAAnpD,EAAAuG,EAAAtG,GACAiI,KAAAmH,MAAArP,EAAAqP,MAAAnH,KAAA0N,IAAA5V,EAAAmQ,IACAjI,KAAAiH,OAAAnP,EAAAK,UACA6H,KAAA3B,KAAAA,GAAA,KACA2B,KAAAjI,MAAAA,CAJA,EAQA,SAAAmpD,GAAAltD,EAAAiU,EAAAi4C,EAAAiB,GACA,IAAAvrD,EAGAwrD,EAHAjP,EAAAn+C,EAAAm+C,IAAA/9C,EAAA+9C,EAAA/9C,KAEAwF,EAAAozB,GAAAmlB,GADAlqC,EAAA01C,GAAAxL,EAAAlqC,IACArO,MAAAsG,EAAAw/C,GAAA1rD,EAAAiU,EAAArO,KAAAsmD,GACApoD,EAAA,IAAAwY,GAAA1W,EAAA7D,KAAA/B,EAAA2f,QAAAggC,QAAAzzC,GAEA,IADAihD,IAAAC,EAAA,KACAD,GAAArpD,EAAAmQ,IAAAA,EAAAnJ,MAAAhH,EAAA0B,OACA1B,EAAAqP,MAAArP,EAAAmQ,IACArS,EAAAkrD,GAAA1sD,EAAA0D,EAAAoI,EAAAnI,OACAopD,GAAAC,EAAA/+C,KAAA,IAAA4+C,GAAAnpD,EAAAlC,EAAA6D,GAAA04C,EAAA/9C,KAAA8L,EAAAnI,SAEA,OAAAopD,EAAAC,EAAA,IAAAH,GAAAnpD,EAAAlC,EAAAsK,EAAAnI,MAXA,CAcA,SAAAspD,GAAAhjD,EAAA4b,GACA,GAAA5b,EAAA,OAAA,CACA,IAAAijD,EAAAjjD,EAAApI,MAAA,qCACA,IAAAqrD,EAAA,MACAjjD,EAAAA,EAAA6I,MAAA,EAAAo6C,EAAAv5C,OAAA1J,EAAA6I,MAAAo6C,EAAAv5C,MAAAu5C,EAAA,GAAAhwD,QACA,IAAAmN,EAAA6iD,EAAA,GAAA,UAAA,YACA,MAAArnC,EAAAxb,GACAwb,EAAAxb,GAAA6iD,EAAA,GACA,IAAAnrD,OAAA,YAAAmrD,EAAA,GAAA,aAAAppD,KAAA+hB,EAAAxb,MACAwb,EAAAxb,IAAA,IAAA6iD,EAAA,GARA,CAUA,OAAAjjD,CAXA,CAeA,SAAA0gD,GAAA/qD,EAAA+B,EAAA3B,EAAA8L,EAAA7M,EAAAyrD,EAAAF,GACA,IAAA2C,EAAAntD,EAAAmtD,aACA,MAAAA,IAAAA,EAAAvtD,EAAA2f,QAAA4tC,cACA,IACA3rD,EADA4rD,EAAA,EAAAC,EAAA,KACA3pD,EAAA,IAAAwY,GAAAva,EAAA/B,EAAA2f,QAAAggC,QAAAzzC,GACA+J,EAAAjW,EAAA2f,QAAA+tC,cAAA,CAAA,MAEA,IADA,IAAA3rD,GAAAsrD,GAAAR,GAAAzsD,EAAA8L,EAAAnI,OAAA+mD,IACAhnD,EAAA0B,OAAA,CASA,GARA1B,EAAAmQ,IAAAjU,EAAA2f,QAAAisC,oBACA2B,GAAA,EACA3C,GAAA6B,GAAAzsD,EAAA+B,EAAAmK,EAAApI,EAAAmQ,KACAnQ,EAAAmQ,IAAAlS,EAAAzE,OACAsE,EAAA,MAEAA,EAAAyrD,GAAAP,GAAA1sD,EAAA0D,EAAAoI,EAAAnI,MAAAkS,GAAA60C,GAEA70C,EAAA,CACA,IAAA03C,EAAA13C,EAAA,GAAA5S,KACAsqD,IAAA/rD,EAAA,MAAAA,EAAA+rD,EAAA,IAAA/rD,EAAA+rD,GAFA,CAIA,IAAAJ,GAAAE,GAAA7rD,EAAA,CACA,KAAA4rD,EAAA1pD,EAAAqP,OAEA9T,EADAmuD,EAAAxuC,KAAAK,IAAAvb,EAAAqP,MAAAq6C,EAAA,KACAC,GAEAA,EAAA7rD,CALA,CAOAkC,EAAAqP,MAAArP,EAAAmQ,GApBA,CAsBA,KAAAu5C,EAAA1pD,EAAAmQ,KAAA,CAIA,IAAAA,EAAA+K,KAAAK,IAAAvb,EAAAmQ,IAAAu5C,EAAA,KACAnuD,EAAA4U,EAAAw5C,GACAD,EAAAv5C,CANA,CA7BA,CA+EA,IAAA25C,IAAA,EAAAC,IAAA,EAYA,SAAAC,GAAA1qC,EAAA1gB,EAAAC,GACAqJ,KAAAoX,OAAAA,EACApX,KAAAtJ,KAAAA,EAAAsJ,KAAArJ,GAAAA,CAFA,CAMA,SAAAorD,GAAAvsC,EAAA4B,GACA,GAAA5B,EAAA,IAAA,IAAAnkB,EAAA,EAAAA,EAAAmkB,EAAAlkB,SAAAD,EAAA,CACA,IAAAmpC,EAAAhlB,EAAAnkB,GACA,GAAAmpC,EAAApjB,QAAAA,EAAA,OAAAojB,CAFA,CADA,CASA,SAAAwnB,GAAAxsC,EAAAglB,GAEA,IADA,IAAAjoC,EACAlB,EAAA,EAAAA,EAAAmkB,EAAAlkB,SAAAD,EACAmkB,EAAAnkB,IAAAmpC,IAAAjoC,IAAAA,EAAA,KAAA8P,KAAAmT,EAAAnkB,IACA,OAAAkB,CAJA,CAuDA,SAAA0vD,GAAA9P,EAAAj9C,GACA,GAAAA,EAAAgtD,KAAA,OAAA,KACA,IAAAC,EAAAjF,GAAA/K,EAAAj9C,EAAAwB,KAAAkD,OAAAozB,GAAAmlB,EAAAj9C,EAAAwB,KAAAkD,MAAAwoD,YACAC,EAAAnF,GAAA/K,EAAAj9C,EAAAyB,GAAAiD,OAAAozB,GAAAmlB,EAAAj9C,EAAAyB,GAAAiD,MAAAwoD,YACA,IAAAD,IAAAE,EAAA,OAAA,KAEA,IAAA/U,EAAAp4C,EAAAwB,KAAAoI,GAAA0uC,EAAAt4C,EAAAyB,GAAAmI,GAAAwjD,EAAA,GAAAhW,GAAAp3C,EAAAwB,KAAAxB,EAAAyB,IAEAs+B,EAxCA,SAAAljB,EAAAu7B,EAAAgV,GACA,IAAAC,EACA,GAAAxwC,EAAA,IAAA,IAAA1gB,EAAA,EAAAA,EAAA0gB,EAAAzgB,SAAAD,EAAA,CACA,IAAAmpC,EAAAzoB,EAAA1gB,GAAA+lB,EAAAojB,EAAApjB,OAEA,GADA,MAAAojB,EAAA9jC,OAAA0gB,EAAAorC,cAAAhoB,EAAA9jC,MAAA42C,EAAA9S,EAAA9jC,KAAA42C,IACA9S,EAAA9jC,MAAA42C,GAAA,YAAAl2B,EAAA/Y,QAAAikD,IAAA9nB,EAAApjB,OAAAqrC,YAAA,CACA,IAAAC,EAAA,MAAAloB,EAAA7jC,KAAAygB,EAAAurC,eAAAnoB,EAAA7jC,IAAA22C,EAAA9S,EAAA7jC,GAAA22C,IACAiV,IAAAA,EAAA,KAAAlgD,KAAA,IAAAy/C,GAAA1qC,EAAAojB,EAAA9jC,KAAAgsD,EAAA,KAAAloB,EAAA7jC,IAFA,CAHA,CAQA,OAAA4rD,CAVA,CAwCAK,CAAAT,EAAA7U,EAAAgV,GACA1E,EA7BA,SAAA7rC,EAAAy7B,EAAA8U,GACA,IAAAC,EACA,GAAAxwC,EAAA,IAAA,IAAA1gB,EAAA,EAAAA,EAAA0gB,EAAAzgB,SAAAD,EAAA,CACA,IAAAmpC,EAAAzoB,EAAA1gB,GAAA+lB,EAAAojB,EAAApjB,OAEA,GADA,MAAAojB,EAAA7jC,KAAAygB,EAAAurC,eAAAnoB,EAAA7jC,IAAA62C,EAAAhT,EAAA7jC,GAAA62C,IACAhT,EAAA9jC,MAAA82C,GAAA,YAAAp2B,EAAA/Y,QAAAikD,GAAA9nB,EAAApjB,OAAAqrC,YAAA,CACA,IAAAI,EAAA,MAAAroB,EAAA9jC,OAAA0gB,EAAAorC,cAAAhoB,EAAA9jC,MAAA82C,EAAAhT,EAAA9jC,KAAA82C,IACA+U,IAAAA,EAAA,KAAAlgD,KAAA,IAAAy/C,GAAA1qC,EAAAyrC,EAAA,KAAAroB,EAAA9jC,KAAA82C,EACA,MAAAhT,EAAA7jC,GAAA,KAAA6jC,EAAA7jC,GAAA62C,GAHA,CAHA,CASA,OAAA+U,CAXA,CA6BAO,CAAAT,EAAA7U,EAAA8U,GAGAS,EAAA,GAAA7tD,EAAAa,KAAAzE,OAAA0xD,EAAA9N,GAAAhgD,EAAAa,MAAAzE,QAAAyxD,EAAAzV,EAAA,GACA,GAAArY,EAEA,IAAA,IAAA5jC,EAAA,EAAAA,EAAA4jC,EAAA3jC,SAAAD,EAAA,CACA,IAAAmpC,EAAAvF,EAAA5jC,GACA,GAAA,MAAAmpC,EAAA7jC,GAAA,CACA,IAAAqiB,EAAA+oC,GAAAnE,EAAApjB,EAAApjB,QACA4B,EACA+pC,IAAAvoB,EAAA7jC,GAAA,MAAAqiB,EAAAriB,GAAA,KAAAqiB,EAAAriB,GAAAqsD,GADAxoB,EAAA7jC,GAAA22C,CAFA,CAFA,CASA,GAAAsQ,EAEA,IAAA,IAAA1G,EAAA,EAAAA,EAAA0G,EAAAtsD,SAAA4lD,EAAA,CACA,IAAA+L,EAAArF,EAAA1G,GACA,MAAA+L,EAAAtsD,KAAAssD,EAAAtsD,IAAAqsD,GACA,MAAAC,EAAAvsD,KACAqrD,GAAA9sB,EAAAguB,EAAA7rC,UAEA6rC,EAAAvsD,KAAAssD,EACAD,IAAA9tB,IAAAA,EAAA,KAAA5yB,KAAA4gD,KAGAA,EAAAvsD,MAAAssD,EACAD,IAAA9tB,IAAAA,EAAA,KAAA5yB,KAAA4gD,GAXA,CAgBAhuB,IAAAA,EAAAiuB,GAAAjuB,IACA2oB,GAAAA,GAAA3oB,IAAA2oB,EAAAsF,GAAAtF,IAEA,IAAAuF,EAAA,CAAAluB,GACA,IAAA8tB,EAAA,CAEA,IAAAK,EAAAC,EAAAnuD,EAAAa,KAAAzE,OAAA,EACA,GAAA+xD,EAAA,GAAApuB,EACA,IAAA,IAAAkiB,EAAA,EAAAA,EAAAliB,EAAA3jC,SAAA6lD,EACA,MAAAliB,EAAAkiB,GAAAxgD,KACAysD,IAAAA,EAAA,KAAA/gD,KAAA,IAAAy/C,GAAA7sB,EAAAkiB,GAAA//B,OAAA,KAAA,OACA,IAAA,IAAAigC,EAAA,EAAAA,EAAAgM,IAAAhM,EACA8L,EAAA9gD,KAAA+gD,GACAD,EAAA9gD,KAAAu7C,EATA,CAWA,OAAAuF,CAzDA,CA8DA,SAAAD,GAAA1tC,GACA,IAAA,IAAAnkB,EAAA,EAAAA,EAAAmkB,EAAAlkB,SAAAD,EAAA,CACA,IAAAmpC,EAAAhlB,EAAAnkB,GACA,MAAAmpC,EAAA9jC,MAAA8jC,EAAA9jC,MAAA8jC,EAAA7jC,KAAA,IAAA6jC,EAAApjB,OAAAksC,gBACA9tC,EAAAsI,OAAAzsB,IAAA,EAHA,CAKA,OAAAmkB,EAAAlkB,OACAkkB,EADA,IANA,CAwCA,SAAA+tC,GAAA3pD,GACA,IAAA4b,EAAA5b,EAAAwoD,YACA,GAAA5sC,EAAA,CACA,IAAA,IAAAnkB,EAAA,EAAAA,EAAAmkB,EAAAlkB,SAAAD,EACAmkB,EAAAnkB,GAAA+lB,OAAAosC,WAAA5pD,GACAA,EAAAwoD,YAAA,IAHA,CAFA,CAOA,SAAAqB,GAAA7pD,EAAA4b,GACA,GAAAA,EAAA,CACA,IAAA,IAAAnkB,EAAA,EAAAA,EAAAmkB,EAAAlkB,SAAAD,EACAmkB,EAAAnkB,GAAA+lB,OAAAssC,WAAA9pD,GACAA,EAAAwoD,YAAA5sC,CAHA,CADA,CASA,SAAAmuC,GAAAvsC,GAAA,OAAAA,EAAAorC,eAAA,EAAA,CAAA,CACA,SAAAoB,GAAAxsC,GAAA,OAAAA,EAAAurC,eAAA,EAAA,CAAA,CAKA,SAAAkB,GAAAzwD,EAAAoe,GACA,IAAAsyC,EAAA1wD,EAAAilB,MAAA/mB,OAAAkgB,EAAA6G,MAAA/mB,OACA,GAAA,GAAAwyD,EAAA,OAAAA,EACA,IAAAC,EAAA3wD,EAAAkC,OAAA0uD,EAAAxyC,EAAAlc,OACA2uD,EAAA3X,GAAAyX,EAAArtD,KAAAstD,EAAAttD,OAAAitD,GAAAvwD,GAAAuwD,GAAAnyC,GACA,GAAAyyC,EAAA,OAAAA,EACA,IAAAC,EAAA5X,GAAAyX,EAAAptD,GAAAqtD,EAAArtD,KAAAitD,GAAAxwD,GAAAwwD,GAAApyC,GACA,OAAA0yC,GACA1yC,EAAAqG,GAAAzkB,EAAAykB,EARA,CAaA,SAAAssC,GAAAvqD,EAAAuN,GACA,IAAA6R,EAAAorC,EAAAvC,IAAAjoD,EAAAwoD,YACA,GAAAgC,EAAA,IAAA,IAAAC,OAAA,EAAAhzD,EAAA,EAAAA,EAAA+yD,EAAA9yD,SAAAD,GACAgzD,EAAAD,EAAA/yD,IACA+lB,OAAAktC,WAAA,OAAAn9C,EAAAk9C,EAAA3tD,KAAA2tD,EAAA1tD,OACAqiB,GAAA6qC,GAAA7qC,EAAAqrC,EAAAjtC,QAAA,KACA4B,EAAAqrC,EAAAjtC,QAEA,OAAA4B,CARA,CAUA,SAAAurC,GAAA3qD,GAAA,OAAAuqD,GAAAvqD,GAAA,EAAA,CACA,SAAA4qD,GAAA5qD,GAAA,OAAAuqD,GAAAvqD,GAAA,EAAA,CAEA,SAAA6qD,GAAA7qD,EAAAkF,GACA,IAAAka,EAAAorC,EAAAvC,IAAAjoD,EAAAwoD,YACA,GAAAgC,EAAA,IAAA,IAAA/yD,EAAA,EAAAA,EAAA+yD,EAAA9yD,SAAAD,EAAA,CACA,IAAAgzD,EAAAD,EAAA/yD,GACAgzD,EAAAjtC,OAAAktC,YAAA,MAAAD,EAAA3tD,MAAA2tD,EAAA3tD,KAAAoI,KAAA,MAAAulD,EAAA1tD,IAAA0tD,EAAA1tD,GAAAmI,MACAka,GAAA6qC,GAAA7qC,EAAAqrC,EAAAjtC,QAAA,KAAA4B,EAAAqrC,EAAAjtC,OAHA,CAKA,OAAA4B,CAPA,CAaA,SAAA0rC,GAAAvS,EAAAhK,EAAAzxC,EAAAC,EAAAygB,GACA,IAAAxd,EAAAozB,GAAAmlB,EAAAhK,GACAic,EAAAvC,IAAAjoD,EAAAwoD,YACA,GAAAgC,EAAA,IAAA,IAAA/yD,EAAA,EAAAA,EAAA+yD,EAAA9yD,SAAAD,EAAA,CACA,IAAAgzD,EAAAD,EAAA/yD,GACA,GAAAgzD,EAAAjtC,OAAAktC,UAAA,CACA,IAAAtrC,EAAAqrC,EAAAjtC,OAAA9hB,KAAA,GACA2uD,EAAA3X,GAAAtzB,EAAAtiB,KAAAA,IAAAitD,GAAAU,EAAAjtC,QAAAusC,GAAAvsC,GACA8sC,EAAA5X,GAAAtzB,EAAAriB,GAAAA,IAAAitD,GAAAS,EAAAjtC,QAAAwsC,GAAAxsC,GACA,KAAA6sC,GAAA,GAAAC,GAAA,GAAAD,GAAA,GAAAC,GAAA,KACAD,GAAA,IAAAI,EAAAjtC,OAAAurC,gBAAAvrC,EAAAorC,cAAAlW,GAAAtzB,EAAAriB,GAAAD,IAAA,EAAA41C,GAAAtzB,EAAAriB,GAAAD,GAAA,IACAutD,GAAA,IAAAI,EAAAjtC,OAAAurC,gBAAAvrC,EAAAorC,cAAAlW,GAAAtzB,EAAAtiB,KAAAC,IAAA,EAAA21C,GAAAtzB,EAAAtiB,KAAAC,GAAA,IACA,OAAA,CAPA,CAFA,CAHA,CAoBA,SAAAguD,GAAA/qD,GAEA,IADA,IAAAgrD,EACAA,EAAAL,GAAA3qD,IACAA,EAAAgrD,EAAAtvD,MAAA,GAAA,GAAAsE,KACA,OAAAA,CAJA,CA2BA,SAAAirD,GAAA1S,EAAA2S,GACA,IAAAlrD,EAAAozB,GAAAmlB,EAAA2S,GAAAC,EAAAJ,GAAA/qD,GACA,OAAAA,GAAAmrD,EAAAD,EACA3c,GAAA4c,EAHA,CAQA,SAAAC,GAAA7S,EAAA2S,GACA,GAAAA,EAAA3S,EAAAlM,WAAA,OAAA6e,EACA,IAAAF,EAAAhrD,EAAAozB,GAAAmlB,EAAA2S,GACA,IAAAG,GAAA9S,EAAAv4C,GAAA,OAAAkrD,EACA,KAAAF,EAAAJ,GAAA5qD,IACAA,EAAAgrD,EAAAtvD,KAAA,GAAA,GAAAsE,KACA,OAAAuuC,GAAAvuC,GAAA,CANA,CAYA,SAAAqrD,GAAA9S,EAAAv4C,GACA,IAAAwqD,EAAAvC,IAAAjoD,EAAAwoD,YACA,GAAAgC,EAAA,IAAA,IAAAC,OAAA,EAAAhzD,EAAA,EAAAA,EAAA+yD,EAAA9yD,SAAAD,EAEA,IADAgzD,EAAAD,EAAA/yD,IACA+lB,OAAAktC,UAAA,CACA,GAAA,MAAAD,EAAA3tD,KAAA,OAAA,EACA,IAAA2tD,EAAAjtC,OAAA8tC,YACA,GAAAb,EAAA3tD,MAAA2tD,EAAAjtC,OAAAorC,eAAA2C,GAAAhT,EAAAv4C,EAAAyqD,GACA,OAAA,CAJA,CAJA,CAWA,SAAAc,GAAAhT,EAAAv4C,EAAA4gC,GACA,GAAA,MAAAA,EAAA7jC,GAAA,CACA,IAAA+W,EAAA8sB,EAAApjB,OAAA9hB,KAAA,GAAA,GACA,OAAA6vD,GAAAhT,EAAAzkC,EAAA9T,KAAAmoD,GAAAr0C,EAAA9T,KAAAwoD,YAAA5nB,EAAApjB,QAFA,CAIA,GAAAojB,EAAApjB,OAAAurC,gBAAAnoB,EAAA7jC,IAAAiD,EAAA7D,KAAAzE,OACA,OAAA,EACA,IAAA,IAAA+yD,OAAA,EAAAhzD,EAAA,EAAAA,EAAAuI,EAAAwoD,YAAA9wD,SAAAD,EAEA,IADAgzD,EAAAzqD,EAAAwoD,YAAA/wD,IACA+lB,OAAAktC,YAAAD,EAAAjtC,OAAA8tC,YAAAb,EAAA3tD,MAAA8jC,EAAA7jC,KACA,MAAA0tD,EAAA1tD,IAAA0tD,EAAA1tD,IAAA6jC,EAAA9jC,QACA2tD,EAAAjtC,OAAAorC,eAAAhoB,EAAApjB,OAAAurC,iBACAwC,GAAAhT,EAAAv4C,EAAAyqD,GAAA,OAAA,CAZA,CAiBA,SAAAe,GAAAC,GAIA,IADA,IAAArI,EAAA,EAAAT,GAFA8I,EAAAV,GAAAU,IAEA1T,OACAtgD,EAAA,EAAAA,EAAAkrD,EAAAlkC,MAAA/mB,SAAAD,EAAA,CACA,IAAAuI,EAAA2iD,EAAAlkC,MAAAhnB,GACA,GAAAuI,GAAAyrD,EAAA,MACArI,GAAApjD,EAAAu3B,MAHA,CAKA,IAAA,IAAAz1B,EAAA6gD,EAAA5K,OAAAj2C,EAAAA,GAAA6gD,EAAA7gD,GAAAi2C,OACA,IAAA,IAAAuF,EAAA,EAAAA,EAAAx7C,EAAAugC,SAAA3qC,SAAA4lD,EAAA,CACA,IAAAj+C,EAAAyC,EAAAugC,SAAAib,GACA,GAAAj+C,GAAAsjD,EAAA,MACAS,GAAA/jD,EAAAk4B,MAHA,CAMA,OAAA6rB,CAhBA,CAsBA,SAAAsI,GAAA1rD,GACA,GAAA,GAAAA,EAAAu3B,OAAA,OAAA,EAEA,IADA,IAAAyzB,EAAAxiB,EAAAxoC,EAAA7D,KAAAzE,OAAA2H,EAAAW,EACAgrD,EAAAL,GAAAtrD,IAAA,CACA,IAAA+f,EAAA4rC,EAAAtvD,KAAA,GAAA,GACA2D,EAAA+f,EAAAtiB,KAAAkD,KACAwoC,GAAAppB,EAAAtiB,KAAAoI,GAAAka,EAAAriB,GAAAmI,EAHA,CAMA,IADA7F,EAAAW,EACAgrD,EAAAJ,GAAAvrD,IAAA,CACA,IAAAssD,EAAAX,EAAAtvD,KAAA,GAAA,GACA8sC,GAAAnpC,EAAAlD,KAAAzE,OAAAi0D,EAAA7uD,KAAAoI,GAEAsjC,IADAnpC,EAAAssD,EAAA5uD,GAAAiD,MACA7D,KAAAzE,OAAAi0D,EAAA5uD,GAAAmI,EAJA,CAMA,OAAAsjC,CAfA,CAmBA,SAAAojB,GAAAxxD,GACA,IAAAyxD,EAAAzxD,EAAAu9B,QAAA4gB,EAAAn+C,EAAAm+C,IACAsT,EAAAC,QAAA14B,GAAAmlB,EAAAA,EAAAld,OACAwwB,EAAAE,cAAAL,GAAAG,EAAAC,SACAD,EAAAG,gBAAA,EACAzT,EAAAxF,MAAA,SAAA/yC,GACA,IAAAwoC,EAAAkjB,GAAA1rD,GACAwoC,EAAAqjB,EAAAE,gBACAF,EAAAE,cAAAvjB,EACAqjB,EAAAC,QAAA9rD,EAJA,GALA,CAkBA,IAAAisD,GAAA,SAAA9vD,EAAAqsD,EAAA0D,GACA9lD,KAAAjK,KAAAA,EACA0tD,GAAAzjD,KAAAoiD,GACApiD,KAAAmxB,OAAA20B,EAAAA,EAAA9lD,MAAA,CAHA,EAwBA,SAAA+lD,GAAAnsD,GACAA,EAAA+3C,OAAA,KACA4R,GAAA3pD,EAFA,CAlBAisD,GAAA3zD,UAAAi2C,OAAA,WAAA,OAAAA,GAAAnoC,KAAA,EACAw5C,GAAAqM,IAyBA,IAAAG,GAAA,CAAA,EAAAC,GAAA,CAAA,EACA,SAAAC,GAAAtwD,EAAA+d,GACA,IAAA/d,GAAA,QAAAsC,KAAAtC,GAAA,OAAA,KACA,IAAAuwD,EAAAxyC,EAAA+tC,aAAAuE,GAAAD,GACA,OAAAG,EAAAvwD,KACAuwD,EAAAvwD,GAAAA,EAAAsrB,QAAA,OAAA,SAJA,CAYA,SAAAklC,GAAApyD,EAAAqyD,GAIA,IAAA7jD,EAAAqvC,EAAA,OAAA,KAAA,KAAA3B,EAAA,sBAAA,MACAoW,EAAA,CAAA7oD,IAAAo0C,EAAA,MAAA,CAAArvC,GAAA,mBAAAA,QAAAA,EACAjI,IAAA,EAAA0N,IAAA,EAAAjU,GAAAA,EACAuyD,eAAA,EACAC,YAAAxyD,EAAAkd,UAAA,iBACAm1C,EAAA7L,QAAA,CAAA,EAGA,IAAA,IAAAnpD,EAAA,EAAAA,IAAAg1D,EAAAI,KAAAJ,EAAAI,KAAAn1D,OAAA,GAAAD,IAAA,CACA,IAAAuI,EAAAvI,EAAAg1D,EAAAI,KAAAp1D,EAAA,GAAAg1D,EAAAzsD,KAAA08C,OAAA,EACAgQ,EAAAr+C,IAAA,EACAq+C,EAAAI,SAAAC,GAGAlM,GAAAzmD,EAAAu9B,QAAAipB,WAAAlE,EAAA+B,GAAAz+C,EAAA5F,EAAAm+C,IAAA6E,cACAsP,EAAAI,SAAAE,GAAAN,EAAAI,SAAApQ,IACAgQ,EAAAp+B,IAAA,GAEA2+B,GAAAjtD,EAAA0sD,EAAA9G,GAAAxrD,EAAA4F,EADAysD,GAAAryD,EAAAu9B,QAAAu1B,kBAAA3e,GAAAvuC,KAEAA,EAAAmmD,eACAnmD,EAAAmmD,aAAAT,UACAgH,EAAAhH,QAAAhN,EAAA14C,EAAAmmD,aAAAT,QAAAgH,EAAAhH,SAAA,KACA1lD,EAAAmmD,aAAAR,YACA+G,EAAA/G,UAAAjN,EAAA14C,EAAAmmD,aAAAR,UAAA+G,EAAA/G,WAAA,MAIA,GAAA+G,EAAAp+B,IAAA52B,QACAg1D,EAAAp+B,IAAA7lB,KAAA,EAAA,EAAAikD,EAAA9jD,QAAAoR,YAAA2mC,GAAAvmD,EAAAu9B,QAAAipB,WAGA,GAAAnpD,GACAg1D,EAAA7L,QAAAtyB,IAAAo+B,EAAAp+B,IACAm+B,EAAA7L,QAAA2L,MAAA,CAAA,KAEAE,EAAA7L,QAAAuM,OAAAV,EAAA7L,QAAAuM,KAAA,KAAA1kD,KAAAikD,EAAAp+B,MACAm+B,EAAA7L,QAAAwM,SAAAX,EAAA7L,QAAAwM,OAAA,KAAA3kD,KAAA,CAAA,GA5BA,CAiCA,GAAA6tC,EAAA,CACA,IAAA0N,EAAA0I,EAAA9jD,QAAAykD,WACA,aAAA/uD,KAAA0lD,EAAAvyC,YAAAuyC,EAAAsJ,eAAAtJ,EAAAsJ,cAAA,cACAZ,EAAA9jD,QAAA6I,UAAA,mBAHA,CAUA,OAJA8iB,GAAAn6B,EAAA,aAAAA,EAAAqyD,EAAAzsD,KAAA0sD,EAAA7oD,KACA6oD,EAAA7oD,IAAA4N,YACAi7C,EAAA/G,UAAAjN,EAAAgU,EAAA7oD,IAAA4N,UAAAi7C,EAAA/G,WAAA,KAEA+G,CAvDA,CA0DA,SAAAa,GAAAroD,GACA,IAAA9G,EAAAsa,EAAA,OAAA,IAAA,kBAGA,OAFAta,EAAA6iC,MAAA,MAAA/7B,EAAA+2C,WAAA,GAAAtB,SAAA,IACAv8C,EAAAq3B,aAAA,aAAAr3B,EAAA6iC,OACA7iC,CAJA,CASA,SAAA2uD,GAAAL,EAAAvwD,EAAAH,EAAAwxD,EAAAC,EAAAC,EAAAC,GACA,GAAAxxD,EAAA,CACA,IAEAyM,EAFAitB,EAAA62B,EAAAE,YAiEA,SAAAzwD,EAAAyxD,GACA,GAAAzxD,EAAAzE,OAAA,IAAA,KAAA4G,KAAAnC,GAAA,OAAAA,EAEA,IADA,IAAA0xD,EAAAD,EAAAh9C,EAAA,GACAnZ,EAAA,EAAAA,EAAA0E,EAAAzE,OAAAD,IAAA,CACA,IAAAyN,EAAA/I,EAAAmS,OAAA7W,GACA,KAAAyN,IAAA2oD,GAAAp2D,GAAA0E,EAAAzE,OAAA,GAAA,IAAAyE,EAAA8/C,WAAAxkD,EAAA,KACAyN,EAAA,KACA0L,GAAA1L,EACA2oD,EAAA,KAAA3oD,CALA,CAOA,OAAA0L,CAVA,CAjEAg8C,CAAAzwD,EAAAuwD,EAAAC,eAAAxwD,EACA2xD,EAAApB,EAAAtyD,GAAA+D,MAAA4vD,aAAAC,GAAA,EAEA,GAAAF,EAAAxvD,KAAAnC,GAMA,CACAyM,EAAAqQ,SAAAiD,yBAEA,IADA,IAAA7N,EAAA,IACA,CACAy/C,EAAAlrC,UAAAvU,EACA,IAAAH,EAAA4/C,EAAArxD,KAAAN,GACAg/C,EAAAjtC,EAAAA,EAAAC,MAAAE,EAAAlS,EAAAzE,OAAA2W,EACA,GAAA8sC,EAAA,CACA,IAAA2F,EAAA7nC,SAAA2E,eAAAiY,EAAAvoB,MAAAe,EAAAA,EAAA8sC,IACA/E,GAAAC,EAAA,EAAAztC,EAAAoR,YAAAtB,EAAA,OAAA,CAAAooC,KACAl4C,EAAAoR,YAAA8mC,GACA4L,EAAAp+B,IAAA7lB,KAAAikD,EAAAr+C,IAAAq+C,EAAAr+C,IAAA8sC,EAAA2F,GACA4L,EAAA/rD,KAAAw6C,EACAuR,EAAAr+C,KAAA8sC,CANA,CAQA,IAAAjtC,EAAA,MACAG,GAAA8sC,EAAA,EACA,IAAA8S,OAAA,EACA,GAAA,MAAA//C,EAAA,GAAA,CACA,IAAA6rC,EAAA2S,EAAAtyD,GAAA2f,QAAAggC,QAAAmU,EAAAnU,EAAA2S,EAAA/rD,IAAAo5C,GACAkU,EAAArlD,EAAAoR,YAAAtB,EAAA,OAAA2iC,EAAA6S,GAAA,YACAz4B,aAAA,OAAA,gBACAw4B,EAAAx4B,aAAA,UAAA,MACAi3B,EAAA/rD,KAAAutD,CALA,KAMA,MAAAhgD,EAAA,IAAA,MAAAA,EAAA,KACA+/C,EAAArlD,EAAAoR,YAAAtB,EAAA,OAAA,MAAAxK,EAAA,GAAA,IAAA,IAAA,oBACAunB,aAAA,UAAAvnB,EAAA,IACAw+C,EAAA/rD,KAAA,KAEAstD,EAAAvB,EAAAtyD,GAAA2f,QAAAo0C,uBAAAjgD,EAAA,KACAunB,aAAA,UAAAvnB,EAAA,IACAkoC,GAAAC,EAAA,EAAAztC,EAAAoR,YAAAtB,EAAA,OAAA,CAAAu1C,KACArlD,EAAAoR,YAAAi0C,GACAvB,EAAA/rD,KAAA,GAEA+rD,EAAAp+B,IAAA7lB,KAAAikD,EAAAr+C,IAAAq+C,EAAAr+C,IAAA,EAAA4/C,GACAvB,EAAAr+C,KAjCA,CAHA,MALAq+C,EAAA/rD,KAAAxE,EAAAzE,OACAkR,EAAAqQ,SAAA2E,eAAAiY,GACA62B,EAAAp+B,IAAA7lB,KAAAikD,EAAAr+C,IAAAq+C,EAAAr+C,IAAAlS,EAAAzE,OAAAkR,GACAwtC,GAAAC,EAAA,IAAA2X,GAAA,GACAtB,EAAAr+C,KAAAlS,EAAAzE,OAyCA,GADAg1D,EAAAC,cAAA,IAAA92B,EAAAomB,WAAA9/C,EAAAzE,OAAA,GACAsE,GAAAwxD,GAAAC,GAAAO,GAAAN,GAAAC,EAAA,CACA,IAAAS,EAAApyD,GAAA,GACAwxD,IAAAY,GAAAZ,GACAC,IAAAW,GAAAX,GACA,IAAArvD,EAAAsa,EAAA,OAAA,CAAA9P,GAAAwlD,EAAAV,GACA,GAAAC,EACA,IAAA,IAAAvxD,KAAAuxD,EAAAA,EAAAlvD,eAAArC,IAAA,SAAAA,GAAA,SAAAA,GACAgC,EAAAq3B,aAAAr5B,EAAAuxD,EAAAvxD,IAEA,OAAAswD,EAAA9jD,QAAAoR,YAAA5b,EATA,CAWAsuD,EAAA9jD,QAAAoR,YAAApR,EA7DA,CADA,CAkFA,SAAAokD,GAAA38C,EAAAqsC,GACA,OAAA,SAAAgQ,EAAAvwD,EAAAH,EAAAwxD,EAAAC,EAAAC,EAAAC,GACA3xD,EAAAA,EAAAA,EAAA,mBAAA,kBAEA,IADA,IAAAuR,EAAAm/C,EAAAr+C,IAAAyF,EAAAvG,EAAApR,EAAAzE,SACA,CAGA,IADA,IAAA22D,OAAA,EACA52D,EAAA,EAAAA,EAAAilD,EAAAhlD,WACA22D,EAAA3R,EAAAjlD,IACAsF,GAAAwQ,GAAA8gD,EAAAvxD,MAAAyQ,GAFA9V,KAIA,GAAA42D,EAAAtxD,IAAA+W,EAAA,OAAAzD,EAAAq8C,EAAAvwD,EAAAH,EAAAwxD,EAAAC,EAAAC,EAAAC,GACAt9C,EAAAq8C,EAAAvwD,EAAAmR,MAAA,EAAA+gD,EAAAtxD,GAAAwQ,GAAAvR,EAAAwxD,EAAA,KAAAE,EAAAC,GACAH,EAAA,KACArxD,EAAAA,EAAAmR,MAAA+gD,EAAAtxD,GAAAwQ,GACAA,EAAA8gD,EAAAtxD,EAXA,CAHA,CADA,CAoBA,SAAAuxD,GAAA5B,EAAA1pB,EAAAxlB,EAAA+wC,GACA,IAAAx7B,GAAAw7B,GAAA/wC,EAAA8tC,WACAv4B,GAAA25B,EAAAp+B,IAAA7lB,KAAAikD,EAAAr+C,IAAAq+C,EAAAr+C,IAAA20B,EAAAjQ,IACAw7B,GAAA7B,EAAAtyD,GAAAu9B,QAAA12B,MAAAutD,wBACAz7B,IACAA,EAAA25B,EAAA9jD,QAAAoR,YAAAf,SAAAC,cAAA,UACA6Z,EAAA0C,aAAA,YAAAjY,EAAAS,KAEA8U,IACA25B,EAAAtyD,GAAAu9B,QAAA12B,MAAAwtD,cAAA17B,GACA25B,EAAA9jD,QAAAoR,YAAA+Y,IAEA25B,EAAAr+C,KAAA20B,EACA0pB,EAAAC,eAAA,CAbA,CAkBA,SAAAM,GAAAjtD,EAAA0sD,EAAAlH,GACA,IAAA5pC,EAAA5b,EAAAwoD,YAAAkG,EAAA1uD,EAAA7D,KAAA6wC,EAAA,EACA,GAAApxB,EAQA,IAFA,IAAA5f,EAAA0xD,EACAiB,EAAAC,EAAAC,EAAAnE,EAAAiD,EADAnlB,EAAAkmB,EAAAh3D,OAAA2W,EAAA,EAAA5W,EAAA,EAAA0E,EAAA,GACA2yD,EAAA,IACA,CACA,GAAAA,GAAAzgD,EAAA,CACAsgD,EAAAC,EAAAC,EAAAnB,EAAA,GACAC,EAAA,KACAjD,EAAA,KAAAoE,EAAA/iD,IAEA,IADA,IAAAgjD,EAAA,GAAAC,OAAA,EACA3kC,EAAA,EAAAA,EAAAzO,EAAAlkB,SAAA2yB,EAAA,CACA,IAAAogC,EAAA7uC,EAAAyO,GAAAnc,EAAAu8C,EAAAjtC,OACA,GAAA,YAAAtP,EAAAzJ,MAAAgmD,EAAA3tD,MAAAuR,GAAAH,EAAAo9C,WACAyD,EAAAtmD,KAAAyF,QACA,GAAAu8C,EAAA3tD,MAAAuR,IAAA,MAAAo8C,EAAA1tD,IAAA0tD,EAAA1tD,GAAAsR,GAAAH,EAAAw8C,WAAAD,EAAA1tD,IAAAsR,GAAAo8C,EAAA3tD,MAAAuR,GAAA,CAYA,GAXA,MAAAo8C,EAAA1tD,IAAA0tD,EAAA1tD,IAAAsR,GAAAygD,EAAArE,EAAA1tD,KACA+xD,EAAArE,EAAA1tD,GACA6xD,EAAA,IAEA1gD,EAAAuD,YAAAk9C,GAAA,IAAAzgD,EAAAuD,WACAvD,EAAAw/C,MAAAA,GAAAA,EAAAA,EAAA,IAAA,IAAAx/C,EAAAw/C,KACAx/C,EAAAs/C,YAAA/C,EAAA3tD,MAAAuR,IAAAwgD,GAAA,IAAA3gD,EAAAs/C,YACAt/C,EAAAu/C,UAAAhD,EAAA1tD,IAAA+xD,IAAAE,IAAAA,EAAA,KAAAvmD,KAAAyF,EAAAu/C,SAAAhD,EAAA1tD,IAGAmR,EAAA+yB,SAAA0sB,IAAAA,EAAA,CAAA,IAAA1sB,MAAA/yB,EAAA+yB,OACA/yB,EAAAy/C,WACA,IAAA,IAAAvxD,KAAA8R,EAAAy/C,YACAA,IAAAA,EAAA,CAAA,IAAAvxD,GAAA8R,EAAAy/C,WAAAvxD,GAEA8R,EAAAw8C,aAAAA,GAAAT,GAAAS,EAAAltC,OAAAtP,GAAA,KACAw8C,EAAAD,EAjBA,MAkBAA,EAAA3tD,KAAAuR,GAAAygD,EAAArE,EAAA3tD,OACAgyD,EAAArE,EAAA3tD,KAvBA,CA0BA,GAAAkyD,EAAA,IAAA,IAAA5Q,EAAA,EAAAA,EAAA4Q,EAAAt3D,OAAA0mD,GAAA,EACA4Q,EAAA5Q,EAAA,IAAA0Q,IAAAF,GAAA,IAAAI,EAAA5Q,IAEA,IAAAsM,GAAAA,EAAA5tD,MAAAuR,EAAA,IAAA,IAAAkwC,EAAA,EAAAA,EAAAwQ,EAAAr3D,SAAA6mD,EACA+P,GAAA5B,EAAA,EAAAqC,EAAAxQ,IACA,GAAAmM,IAAAA,EAAA5tD,MAAA,IAAAuR,EAAA,CAGA,GAFAigD,GAAA5B,GAAA,MAAAhC,EAAA3tD,GAAAyrC,EAAA,EAAAkiB,EAAA3tD,IAAAsR,EACAq8C,EAAAltC,OAAA,MAAAktC,EAAA5tD,MACA,MAAA4tD,EAAA3tD,GAAA,OACA2tD,EAAA3tD,IAAAsR,IAAAq8C,GAAA,EAJA,CApCA,CA2CA,GAAAr8C,GAAAm6B,EAAA,MAGA,IADA,IAAAymB,EAAA71C,KAAAK,IAAA+uB,EAAAsmB,KACA,CACA,GAAA3yD,EAAA,CACA,IAAA2X,EAAAzF,EAAAlS,EAAAzE,OACA,IAAAgzD,EAAA,CACA,IAAAwE,EAAAp7C,EAAAm7C,EAAA9yD,EAAAmR,MAAA,EAAA2hD,EAAA5gD,GAAAlS,EACAuwD,EAAAI,SAAAJ,EAAAwC,EAAAlzD,EAAAA,EAAA2yD,EAAAA,EACAE,EAAAxgD,EAAA6gD,EAAAx3D,QAAAo3D,EAAAF,EAAA,GAAAlB,EAAAC,EAHA,CAKA,GAAA75C,GAAAm7C,EAAA,CAAA9yD,EAAAA,EAAAmR,MAAA2hD,EAAA5gD,GAAAA,EAAA4gD,EAAA,KAAA,CACA5gD,EAAAyF,EACA+6C,EAAA,EATA,CAWA1yD,EAAAuyD,EAAAphD,MAAA0/B,EAAAA,EAAAwY,EAAA/tD,MACAuE,EAAAswD,GAAA9G,EAAA/tD,KAAAi1D,EAAAtyD,GAAA2f,QAbA,CA/CA,MAPA,IAAA,IAAAujC,EAAA,EAAAA,EAAAkI,EAAA9tD,OAAA4lD,GAAA,EACAoP,EAAAI,SAAAJ,EAAAgC,EAAAphD,MAAA0/B,EAAAA,EAAAwY,EAAAlI,IAAAgP,GAAA9G,EAAAlI,EAAA,GAAAoP,EAAAtyD,GAAA2f,SAJA,CA+EA,SAAAo1C,GAAA5W,EAAAv4C,EAAAkrD,GAEA9kD,KAAApG,KAAAA,EAEAoG,KAAAymD,KAjbA,SAAA7sD,GAEA,IADA,IAAAgrD,EAAAvsC,EACAusC,EAAAJ,GAAA5qD,IACAA,EAAAgrD,EAAAtvD,KAAA,GAAA,GAAAsE,MACAye,IAAAA,EAAA,KAAAhW,KAAAzI,GAEA,OAAAye,CANA,CAibA2wC,CAAApvD,GAEAoG,KAAA48B,KAAA58B,KAAAymD,KAAAte,GAAA+M,GAAAl1C,KAAAymD,OAAA3B,EAAA,EAAA,EACA9kD,KAAA0S,KAAA1S,KAAAjK,KAAA,KACAiK,KAAAogC,OAAA6kB,GAAA9S,EAAAv4C,EARA,CAYA,SAAAqvD,GAAAj1D,EAAA0C,EAAAC,GAEA,IADA,IAAAuyD,EAAAtlB,EAAA,GACA37B,EAAAvR,EAAAuR,EAAAtR,EAAAsR,EAAAihD,EAAA,CACA,IAAAC,EAAA,IAAAJ,GAAA/0D,EAAAm+C,IAAAnlB,GAAAh5B,EAAAm+C,IAAAlqC,GAAAA,GACAihD,EAAAjhD,EAAAkhD,EAAAvsB,KACAgH,EAAAvhC,KAAA8mD,EAHA,CAKA,OAAAvlB,CAPA,CAUA,IAAAwlB,GAAA,KAwCAC,GAAA,KASA,SAAAC,GAAA/Q,EAAAl6C,GACA,IAAAq4B,EAAAiiB,GAAAJ,EAAAl6C,GACA,GAAAq4B,EAAAplC,OAAA,CACA,IAAAoY,EAAA6pC,EAAAj0B,MAAAptB,UAAAgV,MAAAvU,KAAA4W,UAAA,GACA6/C,GACA1/C,EAAA0/C,GAAAG,iBACAF,GACA3/C,EAAA2/C,IAEA3/C,EAAA2/C,GAAA,GACAl1C,WAAAq1C,GAAA,IAMA,IAJA,IAAAlwB,EAAA,SAAAjoC,GACAqY,EAAArH,MAAA,WAAA,OAAAq0B,EAAArlC,GAAAmY,MAAA,KAAA+pC,EAAA,GADA,EAIAliD,EAAA,EAAAA,EAAAqlC,EAAAplC,SAAAD,EACAioC,EAAAjoC,EAfA,CAFA,CAoBA,SAAAm4D,KACA,IAAAC,EAAAJ,GACAA,GAAA,KACA,IAAA,IAAAh4D,EAAA,EAAAA,EAAAo4D,EAAAn4D,SAAAD,EAAAo4D,EAAAp4D,IAHA,CASA,SAAAq4D,GAAA11D,EAAAqyD,EAAAvB,EAAA6E,GACA,IAAA,IAAA1lC,EAAA,EAAAA,EAAAoiC,EAAAuD,QAAAt4D,OAAA2yB,IAAA,CACA,IAAA5lB,EAAAgoD,EAAAuD,QAAA3lC,GACA,QAAA5lB,EAAAwrD,GAAA71D,EAAAqyD,GACA,UAAAhoD,EAAAyrD,GAAA91D,EAAAqyD,EAAAvB,EAAA6E,GACA,SAAAtrD,EAAA0rD,GAAA/1D,EAAAqyD,GACA,UAAAhoD,GAAA2rD,GAAAh2D,EAAAqyD,EAAAsD,EALA,CAOAtD,EAAAuD,QAAA,IARA,CAaA,SAAAK,GAAA5D,GAQA,OAPAA,EAAA3zC,MAAA2zC,EAAAtwD,OACAswD,EAAA3zC,KAAAJ,EAAA,MAAA,KAAA,KAAA,sBACA+zC,EAAAtwD,KAAAwc,YACA8zC,EAAAtwD,KAAAwc,WAAA23C,aAAA7D,EAAA3zC,KAAA2zC,EAAAtwD,MACAswD,EAAA3zC,KAAAkB,YAAAyyC,EAAAtwD,MACAi6C,GAAAC,EAAA,IAAAoW,EAAA3zC,KAAA9c,MAAAu0D,OAAA,IAEA9D,EAAA3zC,IARA,CA0BA,SAAA03C,GAAAp2D,EAAAqyD,GACA,IAAAgE,EAAAr2D,EAAAu9B,QAAAu1B,iBACA,OAAAuD,GAAAA,EAAAzwD,MAAAysD,EAAAzsD,MACA5F,EAAAu9B,QAAAu1B,iBAAA,KACAT,EAAA7L,QAAA6P,EAAA7P,QACA6P,EAAAC,OAEAlE,GAAApyD,EAAAqyD,EAPA,CAaA,SAAAwD,GAAA71D,EAAAqyD,GACA,IAAA/U,EAAA+U,EAAAtwD,KAAAsV,UACAi/C,EAAAF,GAAAp2D,EAAAqyD,GACAA,EAAAtwD,MAAAswD,EAAA3zC,OAAA2zC,EAAA3zC,KAAA43C,EAAA7sD,KACA4oD,EAAAtwD,KAAAwc,WAAA23C,aAAAI,EAAA7sD,IAAA4oD,EAAAtwD,MACAswD,EAAAtwD,KAAAu0D,EAAA7sD,IACA6sD,EAAAhL,SAAA+G,EAAA/G,SAAAgL,EAAA/K,WAAA8G,EAAA9G,WACA8G,EAAA/G,QAAAgL,EAAAhL,QACA+G,EAAA9G,UAAA+K,EAAA/K,UACAwK,GAAA/1D,EAAAqyD,IACA/U,IACA+U,EAAAtwD,KAAAsV,UAAAimC,EAXA,CAeA,SAAAyY,GAAA/1D,EAAAqyD,IA3CA,SAAAryD,EAAAqyD,GACA,IAAA/U,EAAA+U,EAAA/G,QAAA+G,EAAA/G,QAAA,KAAA+G,EAAAzsD,KAAA0lD,SAAA,IAAA+G,EAAAzsD,KAAA0lD,QAEA,GADAhO,IAAAA,GAAA,8BACA+U,EAAAkE,WACAjZ,EAAA+U,EAAAkE,WAAAl/C,UAAAimC,GACA+U,EAAAkE,WAAAh4C,WAAAC,YAAA6zC,EAAAkE,YAAAlE,EAAAkE,WAAA,WACA,GAAAjZ,EAAA,CACA,IAAAhS,EAAA2qB,GAAA5D,GACAA,EAAAkE,WAAAjrB,EAAAkrB,aAAAl4C,EAAA,MAAA,KAAAg/B,GAAAhS,EAAA5N,YACA19B,EAAAu9B,QAAA12B,MAAAwtD,cAAAhC,EAAAkE,WAHA,CANA,CA4CAE,CAAAz2D,EAAAqyD,GACAA,EAAAzsD,KAAAid,UACAozC,GAAA5D,GAAAh7C,UAAAg7C,EAAAzsD,KAAAid,UACAwvC,EAAA3zC,MAAA2zC,EAAAtwD,OACAswD,EAAA3zC,KAAArH,UAAA,IACA,IAAAk0C,EAAA8G,EAAA9G,UAAA8G,EAAA9G,UAAA,KAAA8G,EAAAzsD,KAAA2lD,WAAA,IAAA8G,EAAAzsD,KAAA2lD,UACA8G,EAAAtwD,KAAAsV,UAAAk0C,GAAA,EAPA,CAUA,SAAAuK,GAAA91D,EAAAqyD,EAAAvB,EAAA6E,GASA,GARAtD,EAAAqE,SACArE,EAAA3zC,KAAAF,YAAA6zC,EAAAqE,QACArE,EAAAqE,OAAA,MAEArE,EAAAsE,mBACAtE,EAAA3zC,KAAAF,YAAA6zC,EAAAsE,kBACAtE,EAAAsE,iBAAA,MAEAtE,EAAAzsD,KAAAgxD,YAAA,CACA,IAAAtrB,EAAA2qB,GAAA5D,GACAA,EAAAsE,iBAAAr4C,EAAA,MAAA,KAAA,gCAAA+zC,EAAAzsD,KAAAgxD,YACA,UAAA52D,EAAA2f,QAAAk3C,YAAAlB,EAAAhkC,UAAAgkC,EAAAmB,kBAAA,cAAAnB,EAAAmB,iBAAA,MACA92D,EAAAu9B,QAAA12B,MAAAwtD,cAAAhC,EAAAsE,kBACArrB,EAAAkrB,aAAAnE,EAAAsE,iBAAAtE,EAAAtwD,KALA,CAOA,IAAAg1D,EAAA1E,EAAAzsD,KAAAoxD,cACA,GAAAh3D,EAAA2f,QAAAtf,aAAA02D,EAAA,CACA,IAAAE,EAAAhB,GAAA5D,GACA6E,EAAA7E,EAAAqE,OAAAp4C,EAAA,MAAA,KAAA,4BAAA,UAAAte,EAAA2f,QAAAk3C,YAAAlB,EAAAhkC,UAAAgkC,EAAAmB,kBAAA,MAWA,GAVAI,EAAA77B,aAAA,cAAA,QACAr7B,EAAAu9B,QAAA12B,MAAAwtD,cAAA6C,GACAD,EAAAT,aAAAU,EAAA7E,EAAAtwD,MACAswD,EAAAzsD,KAAAgxD,cACAM,EAAA7/C,WAAA,IAAAg7C,EAAAzsD,KAAAgxD,cACA52D,EAAA2f,QAAAtf,aAAA02D,GAAAA,EAAA,4BACA1E,EAAA8E,WAAAD,EAAAt3C,YACAtB,EAAA,MAAA6qC,GAAAnpD,EAAA2f,QAAAmxC,GACA,8CACA,SAAA6E,EAAAyB,WAAA,0BAAA,cAAAp3D,EAAAu9B,QAAA85B,kBAAA,QACAN,EAAA,IAAA,IAAAO,EAAA,EAAAA,EAAAt3D,EAAAu9B,QAAAg6B,YAAAj6D,SAAAg6D,EAAA,CACA,IAAAzzC,EAAA7jB,EAAAu9B,QAAAg6B,YAAAD,GAAAjgD,UAAA2N,EAAA+xC,EAAA1yD,eAAAwf,IAAAkzC,EAAAlzC,GACAmB,GACAkyC,EAAAt3C,YAAAtB,EAAA,MAAA,CAAA0G,GAAA,wBACA,SAAA2wC,EAAAyB,WAAAvzC,GAAA,cAAA8xC,EAAA6B,YAAA3zC,GAAA,MAJA,CAbA,CAjBA,CAuCA,SAAAmyC,GAAAh2D,EAAAqyD,EAAAsD,GACAtD,EAAAoF,YAAApF,EAAAoF,UAAA,MAEA,IADA,IAAAC,EAAAra,EAAA,yBACA3+B,EAAA2zC,EAAA3zC,KAAAgf,WAAA3yB,OAAA,EAAA2T,EAAAA,EAAA3T,EACAA,EAAA2T,EAAAif,YACA+5B,EAAAxzD,KAAAwa,EAAArH,YAAAg7C,EAAA3zC,KAAAF,YAAAE,GAEAi5C,GAAA33D,EAAAqyD,EAAAsD,EAPA,CAWA,SAAAiC,GAAA53D,EAAAqyD,EAAAvB,EAAA6E,GACA,IAAAW,EAAAF,GAAAp2D,EAAAqyD,GAQA,OAPAA,EAAAtwD,KAAAswD,EAAA3zC,KAAA43C,EAAA7sD,IACA6sD,EAAAhL,UAAA+G,EAAA/G,QAAAgL,EAAAhL,SACAgL,EAAA/K,YAAA8G,EAAA9G,UAAA+K,EAAA/K,WAEAwK,GAAA/1D,EAAAqyD,GACAyD,GAAA91D,EAAAqyD,EAAAvB,EAAA6E,GACAgC,GAAA33D,EAAAqyD,EAAAsD,GACAtD,EAAA3zC,IATA,CAcA,SAAAi5C,GAAA33D,EAAAqyD,EAAAsD,GAEA,GADAkC,GAAA73D,EAAAqyD,EAAAzsD,KAAAysD,EAAAsD,GAAA,GACAtD,EAAAI,KAAA,IAAA,IAAAp1D,EAAA,EAAAA,EAAAg1D,EAAAI,KAAAn1D,OAAAD,IACAw6D,GAAA73D,EAAAqyD,EAAAI,KAAAp1D,GAAAg1D,EAAAsD,GAAA,EAHA,CAMA,SAAAkC,GAAA73D,EAAA4F,EAAAysD,EAAAsD,EAAAmC,GACA,GAAAlyD,EAAAmyD,QAEA,IADA,IAAAzsB,EAAA2qB,GAAA5D,GACAh1D,EAAA,EAAA26D,EAAApyD,EAAAmyD,QAAA16D,EAAA26D,EAAA16D,SAAAD,EAAA,CACA,IAAAs7B,EAAAq/B,EAAA36D,GAAAqhB,EAAAJ,EAAA,MAAA,CAAAqa,EAAAja,MAAA,yBAAAia,EAAAthB,UAAA,IAAAshB,EAAAthB,UAAA,KACAshB,EAAAs/B,mBAAAv5C,EAAA2c,aAAA,mBAAA,QACA68B,GAAAv/B,EAAAja,EAAA2zC,EAAAsD,GACA31D,EAAAu9B,QAAA12B,MAAAwtD,cAAA31C,GACAo5C,GAAAn/B,EAAAw/B,MACA7sB,EAAAkrB,aAAA93C,EAAA2zC,EAAAqE,QAAArE,EAAAtwD,MAEAupC,EAAA1rB,YAAAlB,GACA42C,GAAA38B,EAAA,SATA,CAHA,CAgBA,SAAAu/B,GAAAv/B,EAAAja,EAAA2zC,EAAAsD,GACA,GAAAh9B,EAAAy/B,UAAA,EACA/F,EAAAoF,YAAApF,EAAAoF,UAAA,KAAAppD,KAAAqQ,GACA,IAAA+e,EAAAk4B,EAAA0C,aACA35C,EAAA9c,MAAAwd,KAAAu2C,EAAAhkC,SAAA,KACAgH,EAAA2/B,cACA76B,GAAAk4B,EAAAmB,iBACAp4C,EAAA9c,MAAA22D,YAAA5C,EAAAmB,iBAAA,MAEAp4C,EAAA9c,MAAA67B,MAAAA,EAAA,IARA,CAUA9E,EAAA2/B,cACA55C,EAAA9c,MAAAu0D,OAAA,EACAz3C,EAAA9c,MAAAmd,SAAA,WACA4Z,EAAAy/B,YAAA15C,EAAA9c,MAAA42D,YAAA7C,EAAAmB,iBAAA,MAdA,CAkBA,SAAA2B,GAAA9/B,GACA,GAAA,MAAAA,EAAAwE,OAAA,OAAAxE,EAAAwE,OACA,IAAAn9B,EAAA24B,EAAAwlB,IAAAn+C,GACA,IAAAA,EAAA,OAAA,EACA,IAAA89C,EAAAj/B,SAAA3G,KAAAygB,EAAAja,MAAA,CACA,IAAAg6C,EAAA,sBACA//B,EAAA2/B,cACAI,GAAA,iBAAA14D,EAAAu9B,QAAAt8B,QAAAye,YAAA,OACAiZ,EAAAy/B,YACAM,GAAA,UAAA14D,EAAAu9B,QAAA2hB,QAAAyZ,YAAA,OACAjb,EAAA19C,EAAAu9B,QAAAipB,QAAAloC,EAAA,MAAA,CAAAqa,EAAAja,MAAA,KAAAg6C,GANA,CAQA,OAAA//B,EAAAwE,OAAAxE,EAAAja,KAAAH,WAAAY,YAZA,CAgBA,SAAAy5C,GAAAr7B,EAAA/+B,GACA,IAAA,IAAAS,EAAA+mD,GAAAxnD,GAAAS,GAAAs+B,EAAA2hB,QAAAjgD,EAAAA,EAAAsf,WACA,IAAAtf,GAAA,GAAAA,EAAAqhB,UAAA,QAAArhB,EAAA45D,aAAA,qBACA55D,EAAAsf,YAAAgf,EAAAu7B,OAAA75D,GAAAs+B,EAAAw7B,MACA,OAAA,CAJA,CAUA,SAAAC,GAAAz7B,GAAA,OAAAA,EAAA07B,UAAAj9B,SAAA,CACA,SAAAk9B,GAAA37B,GAAA,OAAAA,EAAAw7B,MAAA55C,aAAAoe,EAAA07B,UAAA95C,YAAA,CACA,SAAAg6C,GAAA57B,GACA,GAAAA,EAAA67B,eAAA,OAAA77B,EAAA67B,eACA,IAAA56D,EAAAk/C,EAAAngB,EAAAipB,QAAAloC,EAAA,MAAA,IAAA,yBACA1c,EAAAd,OAAAo7B,iBAAAp7B,OAAAo7B,iBAAA19B,GAAAA,EAAA66D,aACArzC,EAAA,CAAA5G,KAAAqS,SAAA7vB,EAAA22D,aAAAl3C,MAAAoQ,SAAA7vB,EAAAg8B,eAEA,OADAkY,MAAA9vB,EAAA5G,OAAA02B,MAAA9vB,EAAA3E,SAAAkc,EAAA67B,eAAApzC,GACAA,CANA,CASA,SAAAszC,GAAAt5D,GAAA,OAAAsgD,EAAAtgD,EAAAu9B,QAAAC,cAAA,CACA,SAAA+7B,GAAAv5D,GACA,OAAAA,EAAAu9B,QAAAi8B,SAAAb,YAAAW,GAAAt5D,GAAAA,EAAAu9B,QAAAk8B,QADA,CAGA,SAAAC,GAAA15D,GACA,OAAAA,EAAAu9B,QAAAi8B,SAAAv8B,aAAAq8B,GAAAt5D,GAAAA,EAAAu9B,QAAAo8B,SADA,CA6BA,SAAAC,GAAAvH,EAAAzsD,EAAAkrD,GACA,GAAAuB,EAAAzsD,MAAAA,EACA,MAAA,CAAAsuB,IAAAm+B,EAAA7L,QAAAtyB,IAAAi+B,MAAAE,EAAA7L,QAAA2L,OACA,GAAAE,EAAAI,KAAA,CACA,IAAA,IAAAp1D,EAAA,EAAAA,EAAAg1D,EAAAI,KAAAn1D,OAAAD,IACA,GAAAg1D,EAAAI,KAAAp1D,IAAAuI,EACA,MAAA,CAAAsuB,IAAAm+B,EAAA7L,QAAAuM,KAAA11D,GAAA80D,MAAAE,EAAA7L,QAAAwM,OAAA31D,IACA,IAAA,IAAA6lD,EAAA,EAAAA,EAAAmP,EAAAI,KAAAn1D,OAAA4lD,IACA,GAAA/O,GAAAke,EAAAI,KAAAvP,IAAA4N,EACA,MAAA,CAAA58B,IAAAm+B,EAAA7L,QAAAuM,KAAA7P,GAAAiP,MAAAE,EAAA7L,QAAAwM,OAAA9P,GAAAvV,QAAA,EANA,CAHA,CA4BA,SAAAksB,GAAA75D,EAAA4F,EAAAkF,EAAAgvD,GACA,OAAAC,GAAA/5D,EAAAg6D,GAAAh6D,EAAA4F,GAAAkF,EAAAgvD,EADA,CAKA,SAAAG,GAAAj6D,EAAA8wD,GACA,GAAAA,GAAA9wD,EAAAu9B,QAAAmvB,UAAAoE,EAAA9wD,EAAAu9B,QAAAovB,OACA,OAAA3sD,EAAAu9B,QAAA43B,KAAA+E,GAAAl6D,EAAA8wD,IACA,IAAAuF,EAAAr2D,EAAAu9B,QAAAu1B,iBACA,OAAAuD,GAAAvF,GAAAuF,EAAAvF,OAAAA,EAAAuF,EAAAvF,MAAAuF,EAAAztB,KACAytB,OADA,CAJA,CAaA,SAAA2D,GAAAh6D,EAAA4F,GACA,IAAAkrD,EAAA3c,GAAAvuC,GACAuvD,EAAA8E,GAAAj6D,EAAA8wD,GACAqE,IAAAA,EAAApzD,KACAozD,EAAA,KACAA,GAAAA,EAAAS,UACAF,GAAA11D,EAAAm1D,EAAArE,EAAAqJ,GAAAn6D,IACAA,EAAAqlD,MAAA+U,aAAA,GAEAjF,IACAA,EAzCA,SAAAn1D,EAAA4F,GAEA,IAAAkrD,EAAA3c,GADAvuC,EAAA+qD,GAAA/qD,IAEAuvD,EAAAn1D,EAAAu9B,QAAAu1B,iBAAA,IAAAiC,GAAA/0D,EAAAm+C,IAAAv4C,EAAAkrD,GACAqE,EAAArE,MAAAA,EACA,IAAAwF,EAAAnB,EAAAmB,MAAAlE,GAAApyD,EAAAm1D,GAGA,OAFAA,EAAApzD,KAAAu0D,EAAA7sD,IACAi0C,EAAA19C,EAAAu9B,QAAA88B,YAAA/D,EAAA7sD,KACA0rD,CARA,CAyCAmF,CAAAt6D,EAAA4F,IAEA,IAAA6O,EAAAmlD,GAAAzE,EAAAvvD,EAAAkrD,GACA,MAAA,CACAlrD,KAAAA,EAAAuvD,KAAAA,EAAAoF,KAAA,KACArmC,IAAAzf,EAAAyf,IAAAi+B,MAAA19C,EAAA09C,MAAAxkB,OAAAl5B,EAAAk5B,OACA6sB,YAAA,EAhBA,CAsBA,SAAAT,GAAA/5D,EAAAy6D,EAAA3vD,EAAAgvD,EAAAY,GACAD,EAAA9sB,SAAA7iC,GAAA,GACA,IAAAka,EAAAlnB,EAAAgN,GAAAgvD,GAAA,IAaA,OAZAW,EAAAtI,MAAA9tD,eAAAvG,GACAknB,EAAAy1C,EAAAtI,MAAAr0D,IAEA28D,EAAAF,OACAE,EAAAF,KAAAE,EAAAtF,KAAApzD,KAAAof,yBACAs5C,EAAAD,aAjGA,SAAAx6D,EAAAqyD,EAAAkI,GACA,IAAAI,EAAA36D,EAAA2f,QAAArf,aACAs6D,EAAAD,GAAApB,GAAAv5D,GACA,IAAAqyD,EAAA7L,QAAAqU,SAAAF,GAAAtI,EAAA7L,QAAA/oB,OAAAm9B,EAAA,CACA,IAAAC,EAAAxI,EAAA7L,QAAAqU,QAAA,GACA,GAAAF,EAAA,CACAtI,EAAA7L,QAAA/oB,MAAAm9B,EAEA,IADA,IAAAE,EAAAzI,EAAAtwD,KAAA27B,WAAAq9B,iBACA19D,EAAA,EAAAA,EAAAy9D,EAAAx9D,OAAA,EAAAD,IAAA,CACA,IAAA4H,EAAA61D,EAAAz9D,GAAA0N,EAAA+vD,EAAAz9D,EAAA,GACA2hB,KAAAg8C,IAAA/1D,EAAAsc,OAAAxW,EAAAwW,QAAA,GACAs5C,EAAAxsD,MAAApJ,EAAAsc,OAAAxW,EAAA4Q,KAAA,EAAA4+C,EAAA5+C,IAHA,CAHA,CASAk/C,EAAAxsD,KAAAksD,EAAAh5C,OAAAg5C,EAAA5+C,IAXA,CAHA,CAkGAs/C,CAAAj7D,EAAAy6D,EAAAtF,KAAAsF,EAAAF,MACAE,EAAAD,YAAA,GAEAx1C,EA0DA,SAAAhlB,EAAAy6D,EAAA3vD,EAAAgvD,GACA,IAGAS,EAHAW,EAAAC,GAAAV,EAAAvmC,IAAAppB,EAAAgvD,GACAp7C,EAAAw8C,EAAAx8C,KAAAvL,EAAA+nD,EAAA/nD,MAAAuG,EAAAwhD,EAAAxhD,IAAAolC,EAAAoc,EAAApc,SAGA,GAAA,GAAApgC,EAAA4B,SAAA,CACA,IAAA,IAAA4iC,EAAA,EAAAA,EAAA,EAAAA,IAAA,CACA,KAAA/vC,GAAAyuC,GAAA6Y,EAAA70D,KAAA7D,KAAAmS,OAAAgnD,EAAAE,WAAAjoD,OAAAA,EACA,KAAA+nD,EAAAE,WAAA1hD,EAAAwhD,EAAAG,UAAAzZ,GAAA6Y,EAAA70D,KAAA7D,KAAAmS,OAAAgnD,EAAAE,WAAA1hD,OAAAA,EAKA,IAHA6gD,EADAve,GAAAC,EAAA,GAAA,GAAA9oC,GAAAuG,GAAAwhD,EAAAG,SAAAH,EAAAE,WACA18C,EAAAH,WAAA4C,wBAEAm6C,GAAAr+C,EAAAyB,EAAAvL,EAAAuG,GAAAqhD,iBAAAjB,IACA16C,MAAAm7C,EAAAl5C,OAAA,GAAAlO,EAAA,MACAuG,EAAAvG,EACAA,GAAA,EACA2rC,EAAA,OAVA,CAYA9C,GAAAC,EAAA,KAAAse,EAmCA,SAAA/T,EAAA+T,GACA,IAAAz5D,OAAAy6D,QAAA,MAAAA,OAAAC,aACAD,OAAAC,aAAAD,OAAAE,aAlzDA,SAAAjV,GACA,GAAA,MAAAa,GAAA,OAAAA,GACA,IAAA3oC,EAAAg/B,EAAA8I,EAAAloC,EAAA,OAAA,MACAo9C,EAAAh9C,EAAAyC,wBACAw6C,EAAA1+C,EAAAyB,EAAA,EAAA,GAAAyC,wBACA,OAAAkmC,GAAAroC,KAAAg8C,IAAAU,EAAAt8C,KAAAu8C,EAAAv8C,MAAA,CALA,CAkzDAw8C,CAAApV,GACA,OAAA+T,EACA,IAAAsB,EAAAN,OAAAC,YAAAD,OAAAE,WACAK,EAAAP,OAAAQ,YAAAR,OAAAS,WACA,MAAA,CAAA58C,KAAAm7C,EAAAn7C,KAAAy8C,EAAAx6C,MAAAk5C,EAAAl5C,MAAAw6C,EACAlgD,IAAA4+C,EAAA5+C,IAAAmgD,EAAAv6C,OAAAg5C,EAAAh5C,OAAAu6C,EAPA,CAnCAG,CAAAj8D,EAAAu9B,QAAAipB,QAAA+T,GAbA,KAcA,CAEA,IAAAO,EADA3nD,EAAA,IAAA2rC,EAAAgb,EAAA,SAGAS,EADAv6D,EAAA2f,QAAArf,eAAAw6D,EAAAp8C,EAAAq8C,kBAAAz9D,OAAA,EACAw9D,EAAA,SAAAhB,EAAAgB,EAAAx9D,OAAA,EAAA,GAEAohB,EAAAyC,uBANA,CAQA,GAAA66B,GAAAC,EAAA,IAAA9oC,KAAAonD,IAAAA,EAAAn7C,OAAAm7C,EAAAl5C,OAAA,CACA,IAAA66C,EAAAx9C,EAAAH,WAAAw8C,iBAAA,GAEAR,EADA2B,EACA,CAAA98C,KAAA88C,EAAA98C,KAAAiC,MAAA66C,EAAA98C,KAAA+8C,GAAAn8D,EAAAu9B,SAAA5hB,IAAAugD,EAAAvgD,IAAA4F,OAAA26C,EAAA36C,QAEA66C,EALA,CAYA,IAJA,IAAAC,EAAA9B,EAAA5+C,IAAA8+C,EAAAF,KAAA5+C,IAAA2gD,EAAA/B,EAAAh5C,OAAAk5C,EAAAF,KAAA5+C,IACAumC,GAAAma,EAAAC,GAAA,EACAzB,EAAAJ,EAAAtF,KAAA3O,QAAAqU,QACAx9D,EAAA,EACAA,EAAAw9D,EAAAv9D,OAAA,KACA4kD,EAAA2Y,EAAAx9D,IADAA,KAEA,IAAAse,EAAAte,EAAAw9D,EAAAx9D,EAAA,GAAA,EAAAk/D,EAAA1B,EAAAx9D,GACAmZ,EAAA,CAAA4I,MAAA,SAAA0/B,EAAAyb,EAAAl5C,MAAAk5C,EAAAn7C,MAAAq7C,EAAAF,KAAAn7C,KACAiC,OAAA,QAAAy9B,EAAAyb,EAAAn7C,KAAAm7C,EAAAl5C,OAAAo5C,EAAAF,KAAAn7C,KACAzD,IAAAA,EAAA4F,OAAAg7C,GAIA,OAHAhC,EAAAn7C,MAAAm7C,EAAAl5C,QAAA7K,EAAAgmD,OAAA,GACAx8D,EAAA2f,QAAA88C,4BAAAjmD,EAAA6lD,KAAAA,EAAA7lD,EAAAkmD,QAAAJ,GAEA9lD,CAhDA,CA1DAmmD,CAAA38D,EAAAy6D,EAAA3vD,EAAAgvD,GACA90C,EAAAw3C,QAAA/B,EAAAtI,MAAAr0D,GAAAknB,IAEA,CAAA5F,KAAA4F,EAAA5F,KAAAiC,MAAA2D,EAAA3D,MACA1F,IAAA++C,EAAA11C,EAAAq3C,KAAAr3C,EAAArJ,IACA4F,OAAAm5C,EAAA11C,EAAA03C,QAAA13C,EAAAzD,OAjBA,CAoBA,IAwbAq7C,GAxbAR,GAAA,CAAAh9C,KAAA,EAAAiC,MAAA,EAAA1F,IAAA,EAAA4F,OAAA,GAEA,SAAA45C,GAAAjnC,EAAAppB,EAAAgvD,GAIA,IAHA,IAAAp7C,EAAAvL,EAAAuG,EAAAolC,EAAA+d,EAAAC,EAGAz/D,EAAA,EAAAA,EAAA62B,EAAA52B,OAAAD,GAAA,EAcA,GAbAw/D,EAAA3oC,EAAA72B,GACAy/D,EAAA5oC,EAAA72B,EAAA,GACAyN,EAAA+xD,GACA1pD,EAAA,EAAAuG,EAAA,EACAolC,EAAA,QACAh0C,EAAAgyD,EAEApjD,EAAA,GADAvG,EAAArI,EAAA+xD,IAEAx/D,GAAA62B,EAAA52B,OAAA,GAAAwN,GAAAgyD,GAAA5oC,EAAA72B,EAAA,GAAAyN,KAEAqI,GADAuG,EAAAojD,EAAAD,GACA,EACA/xD,GAAAgyD,IAAAhe,EAAA,UAEA,MAAA3rC,EAAA,CAIA,GAHAuL,EAAAwV,EAAA72B,EAAA,GACAw/D,GAAAC,GAAAhD,IAAAp7C,EAAA+vC,WAAA,OAAA,WACA3P,EAAAgb,GACA,QAAAA,GAAA,GAAA3mD,EACA,KAAA9V,GAAA62B,EAAA72B,EAAA,IAAA62B,EAAA72B,EAAA,IAAA62B,EAAA72B,EAAA,GAAAoxD,YACA/vC,EAAAwV,EAAA,GAAA72B,GAAA,IACAyhD,EAAA,OAEA,GAAA,SAAAgb,GAAA3mD,GAAA2pD,EAAAD,EACA,KAAAx/D,EAAA62B,EAAA52B,OAAA,GAAA42B,EAAA72B,EAAA,IAAA62B,EAAA72B,EAAA,KAAA62B,EAAA72B,EAAA,GAAAoxD,YACA/vC,EAAAwV,GAAA72B,GAAA,GAAA,GACAyhD,EAAA,QAEA,KAdA,CAiBA,MAAA,CAAApgC,KAAAA,EAAAvL,MAAAA,EAAAuG,IAAAA,EAAAolC,SAAAA,EAAAsc,WAAAyB,EAAAxB,SAAAyB,EAnCA,CAsCA,SAAAxB,GAAAR,EAAAhB,GACA,IAAAS,EAAA6B,GACA,GAAA,QAAAtC,EAAA,IAAA,IAAAz8D,EAAA,EAAAA,EAAAy9D,EAAAx9D,SACAi9D,EAAAO,EAAAz9D,IAAA+hB,MAAAm7C,EAAAl5C,MADAhkB,UAEA,IAAA,IAAA6lD,EAAA4X,EAAAx9D,OAAA,EAAA4lD,GAAA,IACAqX,EAAAO,EAAA5X,IAAA9jC,MAAAm7C,EAAAl5C,MADA6hC,KAGA,OAAAqX,CAPA,CAyEA,SAAAwC,GAAA1K,GACA,GAAAA,EAAA7L,UACA6L,EAAA7L,QAAA2L,MAAA,CAAA,EACAE,EAAA7L,QAAAqU,QAAA,KACAxI,EAAAI,MAAA,IAAA,IAAAp1D,EAAA,EAAAA,EAAAg1D,EAAAI,KAAAn1D,OAAAD,IACAg1D,EAAA7L,QAAAwM,OAAA31D,GAAA,CAAA,CALA,CASA,SAAA2/D,GAAAh9D,GACAA,EAAAu9B,QAAA0/B,gBAAA,KACAzf,EAAAx9C,EAAAu9B,QAAA88B,aACA,IAAA,IAAAh9D,EAAA,EAAAA,EAAA2C,EAAAu9B,QAAA43B,KAAA73D,OAAAD,IACA0/D,GAAA/8D,EAAAu9B,QAAA43B,KAAA93D,GAJA,CAOA,SAAA6/D,GAAAl9D,GACAg9D,GAAAh9D,GACAA,EAAAu9B,QAAA4/B,gBAAAn9D,EAAAu9B,QAAA6/B,iBAAAp9D,EAAAu9B,QAAA67B,eAAA,KACAp5D,EAAA2f,QAAArf,eAAAN,EAAAu9B,QAAAq0B,gBAAA,GACA5xD,EAAAu9B,QAAA8/B,aAAA,IAJA,CAOA,SAAAC,GAAAnf,GAIA,OAAA/B,GAAAS,IAAAsB,EAAAjmC,KAAAiJ,wBAAA/B,KAAAqS,SAAAyK,iBAAAiiB,EAAAjmC,MAAAsgD,aACAra,EAAA3+B,YAAA+9C,cAAApf,EAAA3hB,iBAAA2hB,EAAAjmC,MAAAmkB,UALA,CAOA,SAAAmhC,GAAArf,GACA,OAAA/B,GAAAS,IAAAsB,EAAAjmC,KAAAiJ,wBAAAxF,IAAA8V,SAAAyK,iBAAAiiB,EAAAjmC,MAAAulD,YACAtf,EAAA3+B,YAAA0gB,cAAAie,EAAA3hB,iBAAA2hB,EAAAjmC,MAAAokB,SAFA,CAKA,SAAAohC,GAAArM,GACA,IACA0G,EADApH,GAAAU,GACA0G,QACA56B,EAAA,EACA,GAAA46B,EAAA,IAAA,IAAA16D,EAAA,EAAAA,EAAA06D,EAAAz6D,SAAAD,EAAA06D,EAAA16D,GAAA86D,QACAh7B,GAAAs7B,GAAAV,EAAA16D,KACA,OAAA8/B,CANA,CAaA,SAAAwgC,GAAA39D,EAAAqxD,EAAAkJ,EAAAruD,EAAA0xD,GACA,IAAAA,EAAA,CACA,IAAAzgC,EAAAugC,GAAArM,GACAkJ,EAAA5+C,KAAAwhB,EAAAo9B,EAAAh5C,QAAA4b,CAFA,CAIA,GAAA,QAAAjxB,EAAA,OAAAquD,EACAruD,IAAAA,EAAA,SACA,IAAA2xD,EAAAzM,GAAAC,GAGA,GAFA,SAAAnlD,EAAA2xD,GAAA7E,GAAAh5D,EAAAu9B,SACAsgC,GAAA79D,EAAAu9B,QAAAugC,WACA,QAAA5xD,GAAA,UAAAA,EAAA,CACA,IAAA6xD,EAAA/9D,EAAAu9B,QAAA07B,UAAA93C,wBACA08C,GAAAE,EAAApiD,KAAA,UAAAzP,EAAA,EAAAsxD,GAAArf,EAAAn+C,KACA,IAAAg+D,EAAAD,EAAA3+C,MAAA,UAAAlT,EAAA,EAAAoxD,GAAAnf,EAAAn+C,KACAu6D,EAAAn7C,MAAA4+C,EAAAzD,EAAAl5C,OAAA28C,CAJA,CAOA,OADAzD,EAAA5+C,KAAAkiD,EAAAtD,EAAAh5C,QAAAs8C,EACAtD,CAjBA,CAsBA,SAAA0D,GAAAj+D,EAAA8kC,EAAA54B,GACA,GAAA,OAAAA,EAAA,OAAA44B,EACA,IAAA1lB,EAAA0lB,EAAA1lB,KAAAzD,EAAAmpB,EAAAnpB,IAEA,GAAA,QAAAzP,EACAkT,GAAAk+C,GAAAnf,EAAAn+C,IACA2b,GAAA6hD,GAAArf,EAAAn+C,SACA,GAAA,SAAAkM,IAAAA,EAAA,CACA,IAAAgyD,EAAAl+D,EAAAu9B,QAAAu7B,MAAA33C,wBACA/B,GAAA8+C,EAAA9+C,KACAzD,GAAAuiD,EAAAviD,GAHA,CAMA,IAAAwiD,EAAAn+D,EAAAu9B,QAAA07B,UAAA93C,wBACA,MAAA,CAAA/B,KAAAA,EAAA++C,EAAA/+C,KAAAzD,IAAAA,EAAAwiD,EAAAxiD,IAdA,CAiBA,SAAAyiD,GAAAp+D,EAAAiU,EAAA/H,EAAAmlD,EAAAyI,GAEA,OADAzI,IAAAA,EAAAr4B,GAAAh5B,EAAAm+C,IAAAlqC,EAAArO,OACA+3D,GAAA39D,EAAAqxD,EAAAwI,GAAA75D,EAAAqxD,EAAAp9C,EAAAnJ,GAAAgvD,GAAA5tD,EAFA,CAqBA,SAAA0vB,GAAA57B,EAAAiU,EAAA/H,EAAAmlD,EAAAgN,EAAA3D,GAGA,SAAAx6D,EAAA4K,EAAAuW,GACA,IAAAvN,EAAAimD,GAAA/5D,EAAAq+D,EAAAvzD,EAAAuW,EAAA,QAAA,OAAAq5C,GAEA,OADAr5C,EAAAvN,EAAAsL,KAAAtL,EAAAuN,MAAAvN,EAAAuN,MAAAvN,EAAAsL,KACAu+C,GAAA39D,EAAAqxD,EAAAv9C,EAAA5H,EAHA,CAFAmlD,EAAAA,GAAAr4B,GAAAh5B,EAAAm+C,IAAAlqC,EAAArO,MACAy4D,IAAAA,EAAArE,GAAAh6D,EAAAqxD,IAMA,IAAA/O,EAAA+B,GAAAgN,EAAArxD,EAAAm+C,IAAA6E,WAAAl4C,EAAAmJ,EAAAnJ,GAAAy3C,EAAAtuC,EAAAsuC,OAQA,GAPAz3C,GAAAumD,EAAAtvD,KAAAzE,QACAwN,EAAAumD,EAAAtvD,KAAAzE,OACAilD,EAAA,UACAz3C,GAAA,IACAA,EAAA,EACAy3C,EAAA,UAEAD,EAAA,OAAApiD,EAAA,UAAAqiD,EAAAz3C,EAAA,EAAAA,EAAA,UAAAy3C,GAEA,SAAA+b,EAAAxzD,EAAAyzD,EAAAC,GAEA,OAAAt+D,EAAAs+D,EAAA1zD,EAAA,EAAAA,EADA,GAAAw3C,EAAAic,GAAAxb,OACAyb,EAFA,CAIA,IAAAD,EAAAlc,GAAAC,EAAAx3C,EAAAy3C,GACA1P,EAAAuP,GACAjhD,EAAAm9D,EAAAxzD,EAAAyzD,EAAA,UAAAhc,GAEA,OADA,MAAA1P,IAAA1xC,EAAA0xC,MAAAyrB,EAAAxzD,EAAA+nC,EAAA,UAAA0P,IACAphD,CA1BA,CA+BA,SAAAs9D,GAAAz+D,EAAAiU,GACA,IAAAmL,EAAA,EACAnL,EAAA01C,GAAA3pD,EAAAm+C,IAAAlqC,GACAjU,EAAA2f,QAAArf,eAAA8e,EAAA+8C,GAAAn8D,EAAAu9B,SAAAtpB,EAAAnJ,IACA,IAAAumD,EAAAr4B,GAAAh5B,EAAAm+C,IAAAlqC,EAAArO,MACA+V,EAAAy1C,GAAAC,GAAA2H,GAAAh5D,EAAAu9B,SACA,MAAA,CAAAne,KAAAA,EAAAiC,MAAAjC,EAAAzD,IAAAA,EAAA4F,OAAA5F,EAAA01C,EAAAl0B,OANA,CAeA,SAAAuhC,GAAA94D,EAAAkF,EAAAy3C,EAAAoc,EAAAC,GACA,IAAA3qD,EAAA2P,GAAAhe,EAAAkF,EAAAy3C,GAGA,OAFAtuC,EAAA2qD,KAAAA,EACAD,IAAA1qD,EAAA0qD,QAAAA,GACA1qD,CAJA,CASA,SAAAyN,GAAA1hB,EAAAohB,EAAAE,GACA,IAAA68B,EAAAn+C,EAAAm+C,IAEA,IADA78B,GAAAthB,EAAAu9B,QAAAugC,YACA,EAAA,OAAAY,GAAAvgB,EAAAld,MAAA,EAAA,MAAA,GAAA,GACA,IAAA6vB,EAAA/H,GAAA5K,EAAA78B,GAAAsoC,EAAAzL,EAAAld,MAAAkd,EAAAvV,KAAA,EACA,GAAAkoB,EAAAlH,EACA,OAAA8U,GAAAvgB,EAAAld,MAAAkd,EAAAvV,KAAA,EAAA5P,GAAAmlB,EAAAyL,GAAA7nD,KAAAzE,OAAA,KAAA,EAAA,GACA8jB,EAAA,IAAAA,EAAA,GAGA,IADA,IAAAiwC,EAAAr4B,GAAAmlB,EAAA2S,KACA,CACA,IAAA9rC,EAAA65C,GAAA7+D,EAAAqxD,EAAAP,EAAA1vC,EAAAE,GACAgvC,EAAAG,GAAAY,EAAArsC,EAAAla,IAAAka,EAAA45C,KAAA,GAAA55C,EAAA25C,QAAA,EAAA,EAAA,IACA,IAAArO,EAAA,OAAAtrC,EACA,IAAA85C,EAAAxO,EAAAhvD,KAAA,GACA,GAAAw9D,EAAAl5D,MAAAkrD,EAAA,OAAAgO,EACAzN,EAAAr4B,GAAAmlB,EAAA2S,EAAAgO,EAAAl5D,KANA,CAVA,CAoBA,SAAAm5D,GAAA/+D,EAAAqxD,EAAAgN,EAAA/8C,GACAA,GAAAo8C,GAAArM,GACA,IAAA33C,EAAA23C,EAAAtvD,KAAAzE,OACA0hE,EAAAjd,IAAA,SAAAj3C,GAAA,OAAAivD,GAAA/5D,EAAAq+D,EAAAvzD,EAAA,GAAAyW,QAAAD,CAAA,GAAA5H,EAAA,GAEA,MAAA,CAAAslD,MAAAA,EAAAtlD,IADAA,EAAAqoC,IAAA,SAAAj3C,GAAA,OAAAivD,GAAA/5D,EAAAq+D,EAAAvzD,GAAA6Q,IAAA2F,CAAA,GAAA09C,EAAAtlD,GAJA,CAQA,SAAAulD,GAAAj/D,EAAAqxD,EAAAgN,EAAAlhE,GAGA,OAFAkhE,IAAAA,EAAArE,GAAAh6D,EAAAqxD,IAEA0N,GAAA/+D,EAAAqxD,EAAAgN,EADAV,GAAA39D,EAAAqxD,EAAA0I,GAAA/5D,EAAAq+D,EAAAlhE,GAAA,QAAAwe,IAFA,CAQA,SAAAujD,GAAAh+C,EAAAE,EAAAE,EAAAlC,GACA,QAAA8B,EAAAK,QAAAD,KAAAJ,EAAAvF,IAAA2F,IAAAlC,EAAA8B,EAAA9B,KAAA8B,EAAAG,OAAAD,EADA,CAIA,SAAAy9C,GAAA7+D,EAAAqxD,EAAAld,EAAA/yB,EAAAE,GAEAA,GAAA8vC,GAAAC,GACA,IAAAgN,EAAArE,GAAAh6D,EAAAqxD,GAGAoH,EAAAiF,GAAArM,GACA2N,EAAA,EAAAtlD,EAAA23C,EAAAtvD,KAAAzE,OAAA6hE,GAAA,EAEA7c,EAAA+B,GAAAgN,EAAArxD,EAAAm+C,IAAA6E,WAGA,GAAAV,EAAA,CACA,IAAA2R,GAAAj0D,EAAA2f,QAAArf,aAAA8+D,GAAAC,IACAr/D,EAAAqxD,EAAAld,EAAAkqB,EAAA/b,EAAAlhC,EAAAE,GAMA09C,GALAG,EAAA,GAAAlL,EAAAlR,OAKAkR,EAAAvxD,KAAAuxD,EAAAtxD,GAAA,EACA+W,EAAAylD,EAAAlL,EAAAtxD,GAAAsxD,EAAAvxD,KAAA,CATA,CAeA,IAYA48D,EAAA/c,EAZAgd,EAAA,KAAAC,EAAA,KACA10D,EAAAi3C,IAAA,SAAAj3C,GACA,IAAAoW,EAAA64C,GAAA/5D,EAAAq+D,EAAAvzD,GAEA,OADAoW,EAAAvF,KAAA88C,EAAAv3C,EAAAK,QAAAk3C,IACAyG,GAAAh+C,EAAAE,EAAAE,GAAA,KACAJ,EAAAvF,KAAA2F,GAAAJ,EAAA9B,MAAAgC,IACAm+C,EAAAz0D,EACA00D,EAAAt+C,IAEA,EARA,GASA89C,EAAAtlD,GAEAilD,GAAA,EAEA,GAAAa,EAAA,CAEA,IAAAC,EAAAr+C,EAAAo+C,EAAApgD,KAAAogD,EAAAn+C,MAAAD,EAAAs+C,EAAAD,GAAAN,EACAr0D,EAAAy0D,GAAAG,EAAA,EAAA,GACAnd,EAAAmd,EAAA,QAAA,SACAJ,EAAAG,EAAAD,EAAApgD,KAAAogD,EAAAn+C,KALA,KAMA,CAEA89C,GAAAr0D,GAAA4O,GAAA5O,GAAAk0D,GAAAl0D,IAIAy3C,EAAA,GAAAz3C,EAAA,QAAAA,GAAAumD,EAAAtvD,KAAAzE,OAAA,SACAy8D,GAAA/5D,EAAAq+D,EAAAvzD,GAAAq0D,EAAA,EAAA,IAAA59C,OAAAk3C,GAAAn3C,GAAA69C,EACA,QAAA,SAGA,IAAAr6B,EAAAlJ,GAAA57B,EAAA4jB,GAAAuwB,EAAArpC,EAAAy3C,GAAA,OAAA8O,EAAAgN,GACAiB,EAAAx6B,EAAA1lB,KACAu/C,EAAAr9C,EAAAwjB,EAAAnpB,KAAA,EAAA2F,GAAAwjB,EAAAvjB,OAAA,EAAA,CAbA,CAiBA,OAAAm9C,GAAAvqB,EADArpC,EAAAg3C,GAAAuP,EAAAtvD,KAAA+I,EAAA,GACAy3C,EAAAoc,EAAAv9C,EAAAk+C,EAhEA,CAmEA,SAAAD,GAAAr/D,EAAAqxD,EAAAld,EAAAkqB,EAAA/b,EAAAlhC,EAAAE,GAKA,IAAAvN,EAAAguC,IAAA,SAAA1kD,GACA,IAAA42D,EAAA3R,EAAAjlD,GAAA8hE,EAAA,GAAAlL,EAAAlR,MACA,OAAAmc,GAAAtjC,GAAA57B,EAAA4jB,GAAAuwB,EAAAgrB,EAAAlL,EAAAtxD,GAAAsxD,EAAAvxD,KAAAy8D,EAAA,SAAA,SACA,OAAA9N,EAAAgN,GAAAj9C,EAAAE,GAAA,EAHA,GAIA,EAAAghC,EAAAhlD,OAAA,GACA22D,EAAA3R,EAAAvuC,GAIA,GAAAA,EAAA,EAAA,CACA,IAAAorD,EAAA,GAAAlL,EAAAlR,MACA5vC,EAAAyoB,GAAA57B,EAAA4jB,GAAAuwB,EAAAgrB,EAAAlL,EAAAvxD,KAAAuxD,EAAAtxD,GAAAw8D,EAAA,QAAA,UACA,OAAA9N,EAAAgN,GACAa,GAAA/rD,EAAAiO,EAAAE,GAAA,IAAAnO,EAAAwI,IAAA2F,IACA2yC,EAAA3R,EAAAvuC,EAAA,GALA,CAOA,OAAAkgD,CArBA,CAwBA,SAAAmL,GAAAp/D,EAAAqxD,EAAAsO,EAAAtB,EAAA/b,EAAAlhC,EAAAE,GAQA,IAAAs+C,EAAAb,GAAA/+D,EAAAqxD,EAAAgN,EAAA/8C,GACA09C,EAAAY,EAAAZ,MACAtlD,EAAAkmD,EAAAlmD,IACA,KAAAxV,KAAAmtD,EAAAtvD,KAAAmS,OAAAwF,EAAA,KAAAA,IAEA,IADA,IAAAu6C,EAAA,KAAA4L,EAAA,KACAxiE,EAAA,EAAAA,EAAAilD,EAAAhlD,OAAAD,IAAA,CACA,IAAAqK,EAAA46C,EAAAjlD,GACA,KAAAqK,EAAAhF,MAAAgX,GAAAhS,EAAA/E,IAAAq8D,GAAA,CACA,IACAc,EAAA/F,GAAA/5D,EAAAq+D,EADA,GAAA32D,EAAAq7C,MACA/jC,KAAAK,IAAA3F,EAAAhS,EAAA/E,IAAA,EAAAqc,KAAAC,IAAA+/C,EAAAt3D,EAAAhF,OAAA2e,MAGA0+C,EAAAD,EAAA1+C,EAAAA,EAAA0+C,EAAA,IAAAA,EAAA1+C,IACA6yC,GAAA4L,EAAAE,KACA9L,EAAAvsD,EACAm4D,EAAAE,EARA,CAFA,CAiBA,OAJA9L,IAAAA,EAAA3R,EAAAA,EAAAhlD,OAAA,IAEA22D,EAAAvxD,KAAAs8D,IAAA/K,EAAA,CAAAvxD,KAAAs8D,EAAAr8D,GAAAsxD,EAAAtxD,GAAAogD,MAAAkR,EAAAlR,QACAkR,EAAAtxD,GAAA+W,IAAAu6C,EAAA,CAAAvxD,KAAAuxD,EAAAvxD,KAAAC,GAAA+W,EAAAqpC,MAAAkR,EAAAlR,QACAkR,CA9BA,CAmCA,SAAA+L,GAAAziC,GACA,GAAA,MAAAA,EAAA6/B,iBAAA,OAAA7/B,EAAA6/B,iBACA,GAAA,MAAAR,GAAA,CACAA,GAAAt+C,EAAA,MAAA,KAAA,wBAGA,IAAA,IAAAjhB,EAAA,EAAAA,EAAA,KAAAA,EACAu/D,GAAAh9C,YAAAf,SAAA2E,eAAA,MACAo5C,GAAAh9C,YAAAtB,EAAA,OAEAs+C,GAAAh9C,YAAAf,SAAA2E,eAAA,KARA,CAUAk6B,EAAAngB,EAAAipB,QAAAoW,IACA,IAAAz/B,EAAAy/B,GAAAz9C,aAAA,GAGA,OAFAge,EAAA,IAAAI,EAAA6/B,iBAAAjgC,GACAqgB,EAAAjgB,EAAAipB,SACArpB,GAAA,CAhBA,CAoBA,SAAAg/B,GAAA5+B,GACA,GAAA,MAAAA,EAAA4/B,gBAAA,OAAA5/B,EAAA4/B,gBACA,IAAA//C,EAAAkB,EAAA,OAAA,cACA7U,EAAA6U,EAAA,MAAA,CAAAlB,GAAA,wBACAsgC,EAAAngB,EAAAipB,QAAA/8C,GACA,IAAA8wD,EAAAn9C,EAAA+D,wBAAAsc,GAAA88B,EAAAl5C,MAAAk5C,EAAAn7C,MAAA,GAEA,OADAqe,EAAA,IAAAF,EAAA4/B,gBAAA1/B,GACAA,GAAA,EAPA,CAYA,SAAA08B,GAAAn6D,GAGA,IAFA,IAAAyxD,EAAAzxD,EAAAu9B,QAAAne,EAAA,CAAA,EAAAqe,EAAA,CAAA,EACA25B,EAAA3F,EAAAxwD,QAAAg/D,WACAhhE,EAAAwyD,EAAAxwD,QAAAy8B,WAAArgC,EAAA,EAAA4B,EAAAA,EAAAA,EAAA0+B,cAAAtgC,EAAA,CACA,IAAAwmB,EAAA7jB,EAAAu9B,QAAAg6B,YAAAl6D,GAAAga,UACA+H,EAAAyE,GAAA5kB,EAAA88B,WAAA98B,EAAAghE,WAAA7I,EACA35B,EAAA5Z,GAAA5kB,EAAA05D,WAHA,CAKA,MAAA,CAAAhnC,SAAAuuC,GAAAzO,GACAqF,iBAAArF,EAAAxwD,QAAAye,YACA03C,WAAAh4C,EACAo4C,YAAA/5B,EACA46B,aAAA5G,EAAAvS,QAAAyZ,YAZA,CAkBA,SAAAuH,GAAA3iC,GACA,OAAAA,EAAAi8B,SAAAr4C,wBAAA/B,KAAAme,EAAAu7B,MAAA33C,wBAAA/B,IADA,CAOA,SAAA0yC,GAAA9xD,GACA,IAAAgI,EAAAg4D,GAAAhgE,EAAAu9B,SAAAo9B,EAAA36D,EAAA2f,QAAArf,aACA6/D,EAAAxF,GAAA37C,KAAAC,IAAA,EAAAjf,EAAAu9B,QAAAi8B,SAAAb,YAAAwD,GAAAn8D,EAAAu9B,SAAA,GACA,OAAA,SAAA33B,GACA,GAAAqrD,GAAAjxD,EAAAm+C,IAAAv4C,GAAA,OAAA,EAEA,IAAAw6D,EAAA,EACA,GAAAx6D,EAAAmyD,QAAA,IAAA,IAAA16D,EAAA,EAAAA,EAAAuI,EAAAmyD,QAAAz6D,OAAAD,IACAuI,EAAAmyD,QAAA16D,GAAA8/B,SAAAijC,GAAAx6D,EAAAmyD,QAAA16D,GAAA8/B,QAGA,OAAAw9B,EACAyF,GAAAphD,KAAAmjC,KAAAv8C,EAAA7D,KAAAzE,OAAA6iE,IAAA,GAAAn4D,EAEAo4D,EAAAp4D,CAXA,CAHA,CAkBA,SAAAq4D,GAAArgE,GACA,IAAAm+C,EAAAn+C,EAAAm+C,IAAAmiB,EAAAxO,GAAA9xD,GACAm+C,EAAAxF,MAAA,SAAA/yC,GACA,IAAA26D,EAAAD,EAAA16D,GACA26D,GAAA36D,EAAAu3B,QAAAyrB,GAAAhjD,EAAA26D,EAFA,GAFA,CAaA,SAAAC,GAAAxgE,EAAAxB,EAAAiiE,EAAAC,GACA,IAAAnjC,EAAAv9B,EAAAu9B,QACA,IAAAkjC,GAAA,QAAAza,GAAAxnD,GAAAq6D,aAAA,kBAAA,OAAA,KAEA,IAAAz3C,EAAAE,EAAAq/C,EAAApjC,EAAA07B,UAAA93C,wBAEA,IAAAC,EAAA5iB,EAAA8gB,QAAAqhD,EAAAvhD,KAAAkC,EAAA9iB,EAAA0gB,QAAAyhD,EAAAhlD,GAAA,CACA,MAAAilD,GAAA,OAAA,IAAA,CACA,IAAAh7D,EAAAk/B,EAAApjB,GAAA1hB,EAAAohB,EAAAE,GACA,GAAAo/C,GAAA57B,EAAA85B,KAAA,IAAAh5D,EAAAozB,GAAAh5B,EAAAm+C,IAAArZ,EAAAl/B,MAAA7D,MAAAzE,QAAAwnC,EAAAh6B,GAAA,CACA,IAAA+1D,EAAAnhB,EAAA95C,EAAAA,EAAAtI,OAAA0C,EAAA2f,QAAAggC,SAAA/5C,EAAAtI,OACAwnC,EAAAlhB,GAAAkhB,EAAAl/B,KAAAoZ,KAAAC,IAAA,EAAAD,KAAA8hD,OAAA1/C,EAAA+3C,GAAAn5D,EAAAu9B,SAAAne,MAAA+8C,GAAAn8D,EAAAu9B,UAAAsjC,GAFA,CAIA,OAAA/7B,CAbA,CAkBA,SAAAo1B,GAAAl6D,EAAAf,GACA,GAAAA,GAAAe,EAAAu9B,QAAAovB,OAAA,OAAA,KAEA,IADA1tD,GAAAe,EAAAu9B,QAAAmvB,UACA,EAAA,OAAA,KAEA,IADA,IAAAyI,EAAAn1D,EAAAu9B,QAAA43B,KACA93D,EAAA,EAAAA,EAAA83D,EAAA73D,OAAAD,IAEA,IADA4B,GAAAk2D,EAAA93D,GAAAurC,MACA,EAAA,OAAAvrC,CAPA,CAiBA,SAAA0jE,GAAA/gE,EAAA0C,EAAAC,EAAAq+D,GACA,MAAAt+D,IAAAA,EAAA1C,EAAAm+C,IAAAld,OACA,MAAAt+B,IAAAA,EAAA3C,EAAAm+C,IAAAld,MAAAjhC,EAAAm+C,IAAAvV,MACAo4B,IAAAA,EAAA,GAEA,IAAAzjC,EAAAv9B,EAAAu9B,QAOA,GANAyjC,GAAAr+D,EAAA46B,EAAAovB,SACA,MAAApvB,EAAA0jC,mBAAA1jC,EAAA0jC,kBAAAv+D,KACA66B,EAAA0jC,kBAAAv+D,GAEA1C,EAAAqlD,MAAA6b,aAAA,EAEAx+D,GAAA66B,EAAAovB,OACAkB,IAAAgD,GAAA7wD,EAAAm+C,IAAAz7C,GAAA66B,EAAAovB,QACAwU,GAAAnhE,QACA,GAAA2C,GAAA46B,EAAAmvB,SACAmB,IAAAmD,GAAAhxD,EAAAm+C,IAAAx7C,EAAAq+D,GAAAzjC,EAAAmvB,SACAyU,GAAAnhE,IAEAu9B,EAAAmvB,UAAAsU,EACAzjC,EAAAovB,QAAAqU,QAEA,GAAAt+D,GAAA66B,EAAAmvB,UAAA/pD,GAAA46B,EAAAovB,OACAwU,GAAAnhE,QACA,GAAA0C,GAAA66B,EAAAmvB,SAAA,CACA,IAAA0U,EAAAC,GAAArhE,EAAA2C,EAAAA,EAAAq+D,EAAA,GACAI,GACA7jC,EAAA43B,KAAA53B,EAAA43B,KAAAjiD,MAAAkuD,EAAArtD,OACAwpB,EAAAmvB,SAAA0U,EAAAtQ,MACAvzB,EAAAovB,QAAAqU,GAEAG,GAAAnhE,EAPA,MASA,GAAA2C,GAAA46B,EAAAovB,OAAA,CACA,IAAA2U,EAAAD,GAAArhE,EAAA0C,EAAAA,GAAA,GACA4+D,GACA/jC,EAAA43B,KAAA53B,EAAA43B,KAAAjiD,MAAA,EAAAouD,EAAAvtD,OACAwpB,EAAAovB,OAAA2U,EAAAxQ,OAEAqQ,GAAAnhE,EANA,KAQA,CACA,IAAAuhE,EAAAF,GAAArhE,EAAA0C,EAAAA,GAAA,GACA8+D,EAAAH,GAAArhE,EAAA2C,EAAAA,EAAAq+D,EAAA,GACAO,GAAAC,GACAjkC,EAAA43B,KAAA53B,EAAA43B,KAAAjiD,MAAA,EAAAquD,EAAAxtD,OACAuV,OAAA2rC,GAAAj1D,EAAAuhE,EAAAzQ,MAAA0Q,EAAA1Q,QACAxnC,OAAAiU,EAAA43B,KAAAjiD,MAAAsuD,EAAAztD,QACAwpB,EAAAovB,QAAAqU,GAEAG,GAAAnhE,EATA,CAaA,IAAAq2D,EAAA94B,EAAAu1B,iBACAuD,IACA1zD,EAAA0zD,EAAAvF,MACAuF,EAAAvF,OAAAkQ,EACAt+D,EAAA2zD,EAAAvF,MAAAuF,EAAAztB,OACArL,EAAAu1B,iBAAA,MA3DA,CAiEA,SAAA2O,GAAAzhE,EAAA4F,EAAAyE,GACArK,EAAAqlD,MAAA6b,aAAA,EACA,IAAA3jC,EAAAv9B,EAAAu9B,QAAA84B,EAAAr2D,EAAAu9B,QAAAu1B,iBAIA,GAHAuD,GAAAzwD,GAAAywD,EAAAvF,OAAAlrD,EAAAywD,EAAAvF,MAAAuF,EAAAztB,OACArL,EAAAu1B,iBAAA,QAEAltD,EAAA23B,EAAAmvB,UAAA9mD,GAAA23B,EAAAovB,QAAA,CACA,IAAA0F,EAAA90B,EAAA43B,KAAA+E,GAAAl6D,EAAA4F,IACA,GAAA,MAAAysD,EAAA3zC,KAAA,CACA,IAAAgkB,EAAA2vB,EAAAuD,UAAAvD,EAAAuD,QAAA,KACA,GAAA/hD,EAAA6uB,EAAAr4B,IAAAq4B,EAAAr0B,KAAAhE,EAFA,CAFA,CANA,CAcA,SAAA82D,GAAAnhE,GACAA,EAAAu9B,QAAAmvB,SAAA1sD,EAAAu9B,QAAAovB,OAAA3sD,EAAAm+C,IAAAld,MACAjhC,EAAAu9B,QAAA43B,KAAA,GACAn1D,EAAAu9B,QAAAugC,WAAA,CAHA,CAMA,SAAAuD,GAAArhE,EAAA0hE,EAAAC,EAAAn5D,GACA,IAAAqgD,EAAA90C,EAAAmmD,GAAAl6D,EAAA0hE,GAAAvM,EAAAn1D,EAAAu9B,QAAA43B,KACA,IAAAtH,IAAA8T,GAAA3hE,EAAAm+C,IAAAld,MAAAjhC,EAAAm+C,IAAAvV,KACA,MAAA,CAAA70B,MAAAA,EAAA+8C,MAAA6Q,GAEA,IADA,IAAA1iE,EAAAe,EAAAu9B,QAAAmvB,SACArvD,EAAA,EAAAA,EAAA0W,EAAA1W,IACA4B,GAAAk2D,EAAA93D,GAAAurC,KACA,GAAA3pC,GAAAyiE,EAAA,CACA,GAAAl5D,EAAA,EAAA,CACA,GAAAuL,GAAAohD,EAAA73D,OAAA,EAAA,OAAA,KACAurD,EAAA5pD,EAAAk2D,EAAAphD,GAAA60B,KAAA84B,EACA3tD,GAHA,MAKA80C,EAAA5pD,EAAAyiE,EAEAA,GAAA7Y,EAAA8Y,GAAA9Y,CARA,CAUA,KAAAgI,GAAA7wD,EAAAm+C,IAAAwjB,IAAAA,GAAA,CACA,GAAA5tD,IAAAvL,EAAA,EAAA,EAAA2sD,EAAA73D,OAAA,GAAA,OAAA,KACAqkE,GAAAn5D,EAAA2sD,EAAAphD,GAAAvL,EAAA,EAAA,EAAA,IAAAogC,KACA70B,GAAAvL,CAHA,CAKA,MAAA,CAAAuL,MAAAA,EAAA+8C,MAAA6Q,EAtBA,CAgDA,SAAAC,GAAA5hE,GAEA,IADA,IAAAm1D,EAAAn1D,EAAAu9B,QAAA43B,KAAA0M,EAAA,EACAxkE,EAAA,EAAAA,EAAA83D,EAAA73D,OAAAD,IAAA,CACA,IAAAg1D,EAAA8C,EAAA93D,GACAg1D,EAAAjmB,QAAAimB,EAAA3zC,OAAA2zC,EAAAuD,WAAAiM,CAFA,CAIA,OAAAA,CANA,CASA,SAAAC,GAAA9hE,GACAA,EAAAu9B,QAAA12B,MAAAk7D,cAAA/hE,EAAAu9B,QAAA12B,MAAAm7D,mBADA,CAIA,SAAAA,GAAAhiE,EAAAy7C,QACA,IAAAA,IAAAA,GAAA,GAEA,IAAA0C,EAAAn+C,EAAAm+C,IAAA3nC,EAAA,CAAA,EACAyrD,EAAAzrD,EAAA0rD,QAAArjD,SAAAiD,yBACAqgD,EAAA3rD,EAAAw4B,UAAAnwB,SAAAiD,yBAEAsgD,EAAApiE,EAAA2f,QAAA0iD,cACAD,IAAA3mB,GAAA,GACA,IAAA,IAAAp+C,EAAA,EAAAA,EAAA8gD,EAAAtgC,IAAAd,OAAAzf,OAAAD,IACA,GAAAo+C,GAAAp+C,GAAA8gD,EAAAtgC,IAAAykD,UAAA,CACA,IAAArlD,EAAAkhC,EAAAtgC,IAAAd,OAAA1f,GACA,KAAA4f,EAAAva,OAAAkD,MAAA5F,EAAAu9B,QAAAovB,QAAA1vC,EAAAta,KAAAiD,KAAA5F,EAAAu9B,QAAAmvB,UAAA,CACA,IAAA4D,EAAArzC,EAAAK,QACA,GAAA8kD,EAAA,CACA,IAAA/kD,EAAA+kD,EAAApiE,EAAAid,GACAI,GAAAklD,GAAAviE,EAAAqd,EAAA4kD,EAFA,MAGA3R,GAAAtwD,EAAA2f,QAAA6iD,0BACAD,GAAAviE,EAAAid,EAAAI,KAAA4kD,GAEA3R,GACAmS,GAAAziE,EAAAid,EAAAklD,EATA,CAFA,CAaA,OAAA3rD,CAvBA,CA2BA,SAAA+rD,GAAAviE,EAAAqd,EAAA4I,GACA,IAAAhS,EAAA2nB,GAAA57B,EAAAqd,EAAA,MAAA,KAAA,MAAArd,EAAA2f,QAAA88C,2BAEAiG,EAAAz8C,EAAArG,YAAAtB,EAAA,MAAA,IAAA,sBAKA,GAJAokD,EAAA9gE,MAAAwd,KAAAnL,EAAAmL,KAAA,KACAsjD,EAAA9gE,MAAA+Z,IAAA1H,EAAA0H,IAAA,KACA+mD,EAAA9gE,MAAAu7B,OAAAne,KAAAC,IAAA,EAAAhL,EAAAsN,OAAAtN,EAAA0H,KAAA3b,EAAA2f,QAAAgjD,aAAA,KAEA,oBAAAz+D,KAAAlE,EAAA+f,oBAAA1I,WAAA,CACA,IAAAurD,EAAAxE,GAAAp+D,EAAAqd,EAAA,MAAA,KAAA,MACAogB,EAAAmlC,EAAAvhD,MAAAuhD,EAAAxjD,KACAsjD,EAAA9gE,MAAA67B,OAAAA,EAAA,EAAAA,EAAAz9B,EAAA6iE,oBAAA,IAHA,CAMA,GAAA5uD,EAAA4+B,MAAA,CAEA,IAAAiwB,EAAA78C,EAAArG,YAAAtB,EAAA,MAAA,IAAA,iDACAwkD,EAAAlhE,MAAA27B,QAAA,GACAulC,EAAAlhE,MAAAwd,KAAAnL,EAAA4+B,MAAAzzB,KAAA,KACA0jD,EAAAlhE,MAAA+Z,IAAA1H,EAAA4+B,MAAAl3B,IAAA,KACAmnD,EAAAlhE,MAAAu7B,OAAA,KAAAlpB,EAAA4+B,MAAAtxB,OAAAtN,EAAA4+B,MAAAl3B,KAAA,IANA,CAdA,CAwBA,SAAAonD,GAAA3jE,EAAAoe,GAAA,OAAApe,EAAAuc,IAAA6B,EAAA7B,KAAAvc,EAAAggB,KAAA5B,EAAA4B,IAAA,CAGA,SAAAqjD,GAAAziE,EAAAid,EAAAgJ,GACA,IAAAsX,EAAAv9B,EAAAu9B,QAAA4gB,EAAAn+C,EAAAm+C,IACA6kB,EAAAnkD,SAAAiD,yBACAmhD,EAAA9J,GAAAn5D,EAAAu9B,SAAA2lC,EAAAD,EAAA7jD,KACA+jD,EAAAnkD,KAAAC,IAAAse,EAAA6lC,WAAA7J,GAAAv5D,GAAAu9B,EAAAu7B,MAAA/8B,YAAAknC,EAAA5hD,MACAgiD,EAAA,OAAAllB,EAAA6E,UAEA,SAAA3T,EAAAjwB,EAAAzD,EAAA8hB,EAAAlc,GACA5F,EAAA,IAAAA,EAAA,GACAA,EAAAqD,KAAA8hD,MAAAnlD,GACA4F,EAAAvC,KAAA8hD,MAAAv/C,GACAyhD,EAAApjD,YAAAtB,EAAA,MAAA,KAAA,sBAAA,6BAAAc,EAAA,0CAAAzD,EAAA,eAAA,MAAA8hB,EAAA0lC,EAAA/jD,EAAAqe,GAAA,8CAAAlc,EAAA5F,GAAA,MAJA,CAOA,SAAA2nD,EAAA19D,EAAA29D,EAAAC,GACA,IAEArwD,EAAAuG,EAFA23C,EAAAr4B,GAAAmlB,EAAAv4C,GACA69D,EAAApS,EAAAtvD,KAAAzE,OAEA,SAAAwnC,EAAAh6B,EAAAgvD,GACA,OAAAsE,GAAAp+D,EAAA4jB,GAAAhe,EAAAkF,GAAA,MAAAumD,EAAAyI,EADA,CAIA,SAAA4J,EAAAzvD,EAAAzL,EAAAm7D,GACA,IAAAC,EAAA3E,GAAAj/D,EAAAqxD,EAAA,KAAAp9C,GACAxJ,EAAA,OAAAjC,IAAA,SAAAm7D,GAAA,OAAA,QAEA,OAAA7+B,EADA,SAAA6+B,EAAAC,EAAA5E,MAAA4E,EAAAlqD,KAAA,KAAAxV,KAAAmtD,EAAAtvD,KAAAmS,OAAA0vD,EAAAlqD,IAAA,IAAA,EAAA,GACAjP,GAAAA,EAJA,CAOA,IAAA63C,EAAA+B,GAAAgN,EAAAlT,EAAA6E,WAqCA,OA34FA,SAAAV,EAAA5/C,EAAAC,EAAAtD,GACA,IAAAijD,EAAA,OAAAjjD,EAAAqD,EAAAC,EAAA,MAAA,GAEA,IADA,IAAAqiB,GAAA,EACA3nB,EAAA,EAAAA,EAAAilD,EAAAhlD,SAAAD,EAAA,CACA,IAAA42D,EAAA3R,EAAAjlD,IACA42D,EAAAvxD,KAAAC,GAAAsxD,EAAAtxD,GAAAD,GAAAA,GAAAC,GAAAsxD,EAAAtxD,IAAAD,KACArD,EAAA2f,KAAAC,IAAAg1C,EAAAvxD,KAAAA,GAAAsc,KAAAK,IAAA40C,EAAAtxD,GAAAA,GAAA,GAAAsxD,EAAAlR,MAAA,MAAA,MAAA1lD,GACA2nB,GAAA,EAJA,CAOAA,GAAA3lB,EAAAqD,EAAAC,EAAA,MAVA,CAu2FAkhE,CAAAvhB,EAAAihB,GAAA,EAAA,MAAAC,EAAAC,EAAAD,GAAA,SAAA9gE,EAAAC,EAAA6F,EAAAnL,GACA,IAAA8hE,EAAA,OAAA32D,EACAs7D,EAAAh/B,EAAApiC,EAAAy8D,EAAA,OAAA,SACA4E,EAAAj/B,EAAAniC,EAAA,EAAAw8D,EAAA,QAAA,QAEA6E,EAAA,MAAAT,GAAA,GAAA7gE,EAAAuhE,EAAA,MAAAT,GAAA7gE,GAAA8gE,EACAxiC,EAAA,GAAA5jC,EAAAusD,GAAAtH,GAAAjlD,GAAAilD,EAAAhlD,OAAA,EACA,GAAAymE,EAAApoD,IAAAmoD,EAAAnoD,KAAA,EAAA,CACA,IACAuoD,GAAAb,EAAAY,EAAAD,IAAApa,EACAxqC,GAFAikD,EAAAW,EAAAC,IAAAhjC,EAEAiiC,GAAA/D,EAAA2E,EAAAC,GAAA3kD,KACAiC,EAAA6iD,EAAAf,GAAAhE,EAAA4E,EAAAD,GAAAziD,MACAguB,EAAAjwB,EAAA0kD,EAAAnoD,IAAA0F,EAAAjC,EAAA0kD,EAAAviD,OALA,KAMA,CACA,IAAA4iD,EAAAC,EAAAC,EAAAC,EACAnF,GACAgF,EAAAd,GAAAW,GAAA/iC,EAAAiiC,EAAAY,EAAA1kD,KACAglD,EAAAf,EAAAF,EAAAO,EAAAhhE,EAAA8F,EAAA,UACA67D,EAAAhB,EAAAH,EAAAQ,EAAA/gE,EAAA6F,EAAA,SACA87D,EAAAjB,GAAAY,GAAAra,EAAAuZ,EAAAY,EAAA1iD,QAEA8iD,EAAAd,EAAAK,EAAAhhE,EAAA8F,EAAA,UAAA06D,EACAkB,GAAAf,GAAAW,GAAA/iC,EAAAkiC,EAAAW,EAAAziD,MACAgjD,GAAAhB,GAAAY,GAAAra,EAAAsZ,EAAAa,EAAA3kD,KACAklD,EAAAjB,EAAAK,EAAA/gE,EAAA6F,EAAA,SAAA26D,GAEA9zB,EAAA80B,EAAAL,EAAAnoD,IAAAyoD,EAAAD,EAAAL,EAAAviD,QACAuiD,EAAAviD,OAAAwiD,EAAApoD,KAAA0zB,EAAA6zB,EAAAY,EAAAviD,OAAA,KAAAwiD,EAAApoD,KACA0zB,EAAAg1B,EAAAN,EAAApoD,IAAA2oD,EAAAD,EAAAN,EAAAxiD,OAfA,GAkBApO,GAAA4vD,GAAAe,EAAA3wD,GAAA,KAAAA,EAAA2wD,GACAf,GAAAgB,EAAA5wD,GAAA,IAAAA,EAAA4wD,KACArqD,GAAAqpD,GAAAe,EAAApqD,GAAA,KAAAA,EAAAoqD,GACAf,GAAAgB,EAAArqD,GAAA,IAAAA,EAAAqqD,EAlCA,IAoCA,CAAA5wD,MAAAA,EAAAuG,IAAAA,EApDA,CAuDA,IAAA6qD,EAAAtnD,EAAAva,OAAA8hE,EAAAvnD,EAAAta,KACA,GAAA4hE,EAAA3+D,MAAA4+D,EAAA5+D,KACA09D,EAAAiB,EAAA3+D,KAAA2+D,EAAAz5D,GAAA05D,EAAA15D,QACA,CACA,IAAA25D,EAAAzrC,GAAAmlB,EAAAomB,EAAA3+D,MAAA8+D,EAAA1rC,GAAAmlB,EAAAqmB,EAAA5+D,MACA++D,EAAAhU,GAAA8T,IAAA9T,GAAA+T,GACAE,EAAAtB,EAAAiB,EAAA3+D,KAAA2+D,EAAAz5D,GAAA65D,EAAAF,EAAA1iE,KAAAzE,OAAA,EAAA,MAAAoc,IACAmrD,EAAAvB,EAAAkB,EAAA5+D,KAAA++D,EAAA,EAAA,KAAAH,EAAA15D,IAAAqI,MACAwxD,IACAC,EAAAjpD,IAAAkpD,EAAAlpD,IAAA,GACA0zB,EAAAu1B,EAAAvjD,MAAAujD,EAAAjpD,IAAA,KAAAipD,EAAArjD,QACA8tB,EAAA6zB,EAAA2B,EAAAlpD,IAAAkpD,EAAAzlD,KAAAylD,EAAAtjD,SAEA8tB,EAAAu1B,EAAAvjD,MAAAujD,EAAAjpD,IAAAkpD,EAAAzlD,KAAAwlD,EAAAvjD,MAAAujD,EAAArjD,SAGAqjD,EAAArjD,OAAAsjD,EAAAlpD,KACA0zB,EAAA6zB,EAAA0B,EAAArjD,OAAA,KAAAsjD,EAAAlpD,IAdA,CAiBAsK,EAAArG,YAAAojD,EAzFA,CA6FA,SAAA8B,GAAA9kE,GACA,GAAAA,EAAA+D,MAAA2wC,QAAA,CACA,IAAAnX,EAAAv9B,EAAAu9B,QACA/c,cAAA+c,EAAAwnC,SACA,IAAAvjE,GAAA,EACA+7B,EAAAynC,UAAApjE,MAAAqjE,WAAA,GACAjlE,EAAA2f,QAAAulD,gBAAA,EACA3nC,EAAAwnC,QAAA1kD,aAAA,WACArgB,EAAAmlE,YAAAvlC,GAAA5/B,GACAu9B,EAAAynC,UAAApjE,MAAAqjE,YAAAzjE,GAAAA,GAAA,GAAA,QAFA,GAGAxB,EAAA2f,QAAAulD,iBACAllE,EAAA2f,QAAAulD,gBAAA,IACA3nC,EAAAynC,UAAApjE,MAAAqjE,WAAA,SAXA,CADA,CAeA,SAAAG,GAAAplE,GACAA,EAAAmlE,aACAnlE,EAAAu9B,QAAA12B,MAAAu5B,QACApgC,EAAA+D,MAAA2wC,SAAA7U,GAAA7/B,GAHA,CAOA,SAAAqlE,GAAArlE,GACAA,EAAA+D,MAAAuhE,mBAAA,EACAnlD,YAAA,WAAAngB,EAAA+D,MAAAuhE,oBACAtlE,EAAA+D,MAAAuhE,mBAAA,EACAtlE,EAAA+D,MAAA2wC,SAAA9U,GAAA5/B,GAFA,GAGA,IALA,CAQA,SAAA6/B,GAAA7/B,EAAAxB,GACAwB,EAAA+D,MAAAuhE,oBAAAtlE,EAAA+D,MAAAwhE,eAAAvlE,EAAA+D,MAAAuhE,mBAAA,GAEA,YAAAtlE,EAAA2f,QAAA9e,WACAb,EAAA+D,MAAA2wC,UACAva,GAAAn6B,EAAA,QAAAA,EAAAxB,GACAwB,EAAA+D,MAAA2wC,SAAA,EACA2J,EAAAr+C,EAAAu9B,QAAA2hB,QAAA,sBAIAl/C,EAAAqlD,OAAArlD,EAAAu9B,QAAAioC,mBAAAxlE,EAAAm+C,IAAAtgC,MACA7d,EAAAu9B,QAAA12B,MAAAgxB,QACAqkB,GAAA/7B,YAAA,WAAA,OAAAngB,EAAAu9B,QAAA12B,MAAAgxB,OAAA,EAAA,GAAA,KAEA73B,EAAAu9B,QAAA12B,MAAA4+D,iBAEAX,GAAA9kE,GAjBA,CAmBA,SAAA4/B,GAAA5/B,EAAAxB,GACAwB,EAAA+D,MAAAuhE,oBAEAtlE,EAAA+D,MAAA2wC,UACAva,GAAAn6B,EAAA,OAAAA,EAAAxB,GACAwB,EAAA+D,MAAA2wC,SAAA,EACA6I,EAAAv9C,EAAAu9B,QAAA2hB,QAAA,uBAEA1+B,cAAAxgB,EAAAu9B,QAAAwnC,SACA5kD,YAAA,WAAAngB,EAAA+D,MAAA2wC,UAAA10C,EAAAu9B,QAAAnJ,OAAA,EAAA,GAAA,KATA,CAcA,SAAAsxC,GAAA1lE,GAMA,IALA,IAAAu9B,EAAAv9B,EAAAu9B,QACAooC,EAAApoC,EAAAqoC,QAAA5pC,UACA6pC,EAAA7mD,KAAAC,IAAA,EAAAse,EAAAi8B,SAAAr4C,wBAAAxF,KACAmqD,EAAAvoC,EAAAqoC,QAAAzkD,wBAAAxF,IACAoqD,EAAA,EACA1oE,EAAA,EAAAA,EAAAkgC,EAAA43B,KAAA73D,OAAAD,IAAA,CACA,IAAA4H,EAAAs4B,EAAA43B,KAAA93D,GAAAs9D,EAAA36D,EAAA2f,QAAArf,aACA68B,OAAA,EAAAM,EAAA,EACA,IAAAx4B,EAAAmnC,OAAA,CAEA,GADA05B,GAAA7gE,EAAAW,KAAAu3B,OACA6e,GAAAC,EAAA,EAAA,CACA,IAAAsgB,EAAAt3D,EAAAyZ,KAAAsd,UAAA/2B,EAAAyZ,KAAAS,aACAge,EAAAo/B,EAAAoJ,EACAA,EAAApJ,CAHA,KAIA,CACA,IAAAr7C,EAAAjc,EAAAyZ,KAAAyC,wBACAgc,EAAAjc,EAAAK,OAAAL,EAAAvF,KAGAg/C,GAAA11D,EAAAlD,KAAA27B,aACAD,EAAAx4B,EAAAlD,KAAA27B,WAAAvc,wBAAAE,MAAAH,EAAA9B,KAAA,EANA,CAQA,IAAAypC,EAAA5jD,EAAAW,KAAAu3B,OAAAA,EACA,IAAA0rB,EAAA,MAAAA,GAAA,QACAid,EAAAD,IAAAE,GAAAld,GACAD,GAAA3jD,EAAAW,KAAAu3B,GACA6oC,GAAA/gE,EAAAW,MACAX,EAAAwtD,MAAA,IAAA,IAAAxiC,EAAA,EAAAA,EAAAhrB,EAAAwtD,KAAAn1D,OAAA2yB,IACA+1C,GAAA/gE,EAAAwtD,KAAAxiC,IAEA,GAAAwN,EAAAz9B,EAAAu9B,QAAA6lC,WAAA,CACA,IAAA6C,EAAAjnD,KAAAmjC,KAAA1kB,EAAA0+B,GAAAn8D,EAAAu9B,UACA0oC,EAAAjmE,EAAAu9B,QAAAo0B,gBACA3xD,EAAAu9B,QAAAo0B,cAAAsU,EACAjmE,EAAAu9B,QAAAm0B,QAAAzsD,EAAAW,KACA5F,EAAAu9B,QAAAq0B,gBAAA,EALA,CAtBA,CAHA,CAkCA5yC,KAAAg8C,IAAA+K,GAAA,IAAAxoC,EAAAi8B,SAAAl9B,WAAAypC,EAxCA,CA6CA,SAAAC,GAAApgE,GACA,GAAAA,EAAAmyD,QAAA,IAAA,IAAA16D,EAAA,EAAAA,EAAAuI,EAAAmyD,QAAAz6D,SAAAD,EAAA,CACA,IAAA6oE,EAAAtgE,EAAAmyD,QAAA16D,GAAAsgD,EAAAuoB,EAAAxnD,KAAAH,WACAo/B,IAAAuoB,EAAA/oC,OAAAwgB,EAAAx+B,aAFA,CADA,CAUA,SAAAgnD,GAAA5oC,EAAA4gB,EAAAioB,GACA,IAAAzqD,EAAAyqD,GAAA,MAAAA,EAAAzqD,IAAAqD,KAAAC,IAAA,EAAAmnD,EAAAzqD,KAAA4hB,EAAAi8B,SAAAl9B,UACA3gB,EAAAqD,KAAA+b,MAAApf,EAAAq9C,GAAAz7B,IACA,IAAAhc,EAAA6kD,GAAA,MAAAA,EAAA7kD,OAAA6kD,EAAA7kD,OAAA5F,EAAA4hB,EAAA2hB,QAAAjiB,aAEAv6B,EAAAqmD,GAAA5K,EAAAxiC,GAAAhZ,EAAAomD,GAAA5K,EAAA58B,GAGA,GAAA6kD,GAAAA,EAAAC,OAAA,CACA,IAAAC,EAAAF,EAAAC,OAAA3jE,KAAAkD,KAAA2gE,EAAAH,EAAAC,OAAA1jE,GAAAiD,KACA0gE,EAAA5jE,GACAA,EAAA4jE,EACA3jE,EAAAomD,GAAA5K,EAAAiT,GAAAp4B,GAAAmlB,EAAAmoB,IAAA/oC,EAAA2hB,QAAAjiB,eACAje,KAAAK,IAAAknD,EAAApoB,EAAAlM,aAAAtvC,IACAD,EAAAqmD,GAAA5K,EAAAiT,GAAAp4B,GAAAmlB,EAAAooB,IAAAhpC,EAAA2hB,QAAAjiB,cACAt6B,EAAA4jE,EAPA,CAUA,MAAA,CAAA7jE,KAAAA,EAAAC,GAAAqc,KAAAC,IAAAtc,EAAAD,EAAA,GAlBA,CAuFA,SAAA8jE,GAAAxmE,EAAAu6D,GACA,IAAAh9B,EAAAv9B,EAAAu9B,QAAAkpC,EAAAzG,GAAAhgE,EAAAu9B,SACAg9B,EAAA5+C,IAAA,IAAA4+C,EAAA5+C,IAAA,GACA,IAAA+qD,EAAA1mE,EAAAqlD,OAAA,MAAArlD,EAAAqlD,MAAA/oB,UAAAt8B,EAAAqlD,MAAA/oB,UAAAiB,EAAAi8B,SAAAl9B,UACAi/B,EAAA7B,GAAA15D,GAAAwW,EAAA,CAAA,EACA+jD,EAAAh5C,OAAAg5C,EAAA5+C,IAAA4/C,IAAAhB,EAAAh5C,OAAAg5C,EAAA5+C,IAAA4/C,GACA,IAAAoL,EAAA3mE,EAAAm+C,IAAAhhB,OAAA+7B,GAAA37B,GACAqpC,EAAArM,EAAA5+C,IAAA8qD,EAAAI,EAAAtM,EAAAh5C,OAAAolD,EAAAF,EACA,GAAAlM,EAAA5+C,IAAA+qD,EACAlwD,EAAA8lB,UAAAsqC,EAAA,EAAArM,EAAA5+C,SACA,GAAA4+C,EAAAh5C,OAAAmlD,EAAAnL,EAAA,CACA,IAAAv7B,EAAAhhB,KAAAK,IAAAk7C,EAAA5+C,KAAAkrD,EAAAF,EAAApM,EAAAh5C,QAAAg6C,GACAv7B,GAAA0mC,IAAAlwD,EAAA8lB,UAAA0D,EAFA,CAKA,IAAA8mC,EAAA9mE,EAAA2f,QAAAk3C,YAAA,EAAAt5B,EAAAt8B,QAAAye,YACAqnD,EAAA/mE,EAAAqlD,OAAA,MAAArlD,EAAAqlD,MAAAhpB,WAAAr8B,EAAAqlD,MAAAhpB,WAAAkB,EAAAi8B,SAAAn9B,WAAAyqC,EACAE,EAAAzN,GAAAv5D,GAAAu9B,EAAAt8B,QAAAye,YACAunD,EAAA1M,EAAAl5C,MAAAk5C,EAAAn7C,KAAA4nD,EAQA,OAPAC,IAAA1M,EAAAl5C,MAAAk5C,EAAAn7C,KAAA4nD,GACAzM,EAAAn7C,KAAA,GACA5I,EAAA6lB,WAAA,EACAk+B,EAAAn7C,KAAA2nD,EACAvwD,EAAA6lB,WAAArd,KAAAC,IAAA,EAAAs7C,EAAAn7C,KAAA0nD,GAAAG,EAAA,EAAA,KACA1M,EAAAl5C,MAAA2lD,EAAAD,EAAA,IACAvwD,EAAA6lB,WAAAk+B,EAAAl5C,OAAA4lD,EAAA,EAAA,IAAAD,GACAxwD,CA1BA,CA+BA,SAAA0wD,GAAAlnE,EAAA2b,GACA,MAAAA,IACAwrD,GAAAnnE,GACAA,EAAAqlD,MAAA/oB,WAAA,MAAAt8B,EAAAqlD,MAAA/oB,UAAAt8B,EAAAm+C,IAAA7hB,UAAAt8B,EAAAqlD,MAAA/oB,WAAA3gB,EAHA,CAQA,SAAAyrD,GAAApnE,GACAmnE,GAAAnnE,GACA,IAAAiF,EAAAjF,EAAA84B,YACA94B,EAAAqlD,MAAAgiB,YAAA,CAAA3kE,KAAAuC,EAAAtC,GAAAsC,EAAAy8B,OAAA1hC,EAAA2f,QAAA2nD,mBAHA,CAMA,SAAAC,GAAAvnE,EAAAohB,EAAAE,GACA,MAAAF,GAAA,MAAAE,GAAA6lD,GAAAnnE,GACA,MAAAohB,IAAAphB,EAAAqlD,MAAAhpB,WAAAjb,GACA,MAAAE,IAAAthB,EAAAqlD,MAAA/oB,UAAAhb,EAHA,CAeA,SAAA6lD,GAAAnnE,GACA,IAAAid,EAAAjd,EAAAqlD,MAAAgiB,YACApqD,IACAjd,EAAAqlD,MAAAgiB,YAAA,KAEAG,GAAAxnE,EADAy+D,GAAAz+D,EAAAid,EAAAva,MAAA+7D,GAAAz+D,EAAAid,EAAAta,IACAsa,EAAAykB,QALA,CASA,SAAA8lC,GAAAxnE,EAAA0C,EAAAC,EAAA++B,GACA,IAAA+lC,EAAAjB,GAAAxmE,EAAA,CACAof,KAAAJ,KAAAK,IAAA3c,EAAA0c,KAAAzc,EAAAyc,MACAzD,IAAAqD,KAAAK,IAAA3c,EAAAiZ,IAAAhZ,EAAAgZ,KAAA+lB,EACArgB,MAAArC,KAAAC,IAAAvc,EAAA2e,MAAA1e,EAAA0e,OACAE,OAAAvC,KAAAC,IAAAvc,EAAA6e,OAAA5e,EAAA4e,QAAAmgB,IAEA6lC,GAAAvnE,EAAAynE,EAAAprC,WAAAorC,EAAAnrC,UAPA,CAYA,SAAAorC,GAAA1nE,EAAAmB,GACA6d,KAAAg8C,IAAAh7D,EAAAm+C,IAAA7hB,UAAAn7B,GAAA,IACAy6C,GAAA+rB,GAAA3nE,EAAA,CAAA2b,IAAAxa,IACAymE,GAAA5nE,EAAAmB,GAAA,GACAy6C,GAAA+rB,GAAA3nE,GACA6nE,GAAA7nE,EAAA,KALA,CAQA,SAAA4nE,GAAA5nE,EAAAmB,EAAA2mE,GACA3mE,EAAA6d,KAAAC,IAAA,EAAAD,KAAAK,IAAArf,EAAAu9B,QAAAi8B,SAAAx8B,aAAAh9B,EAAAu9B,QAAAi8B,SAAAv8B,aAAA97B,KACAnB,EAAAu9B,QAAAi8B,SAAAl9B,WAAAn7B,GAAA2mE,KACA9nE,EAAAm+C,IAAA7hB,UAAAn7B,EACAnB,EAAAu9B,QAAAwqC,WAAAH,aAAAzmE,GACAnB,EAAAu9B,QAAAi8B,SAAAl9B,WAAAn7B,IAAAnB,EAAAu9B,QAAAi8B,SAAAl9B,UAAAn7B,GALA,CAUA,SAAA6mE,GAAAhoE,EAAAmB,EAAA8mE,EAAAH,GACA3mE,EAAA6d,KAAAC,IAAA,EAAAD,KAAAK,IAAAle,EAAAnB,EAAAu9B,QAAAi8B,SAAA0O,YAAAloE,EAAAu9B,QAAAi8B,SAAAb,eACAsP,EAAA9mE,GAAAnB,EAAAm+C,IAAA9hB,WAAArd,KAAAg8C,IAAAh7D,EAAAm+C,IAAA9hB,WAAAl7B,GAAA,KAAA2mE,IACA9nE,EAAAm+C,IAAA9hB,WAAAl7B,EACAgnE,GAAAnoE,GACAA,EAAAu9B,QAAAi8B,SAAAn9B,YAAAl7B,IAAAnB,EAAAu9B,QAAAi8B,SAAAn9B,WAAAl7B,GACAnB,EAAAu9B,QAAAwqC,WAAAC,cAAA7mE,GANA,CAaA,SAAAinE,GAAApoE,GACA,IAAAyxD,EAAAzxD,EAAAu9B,QAAA8qC,EAAA5W,EAAAxwD,QAAAye,YACA4oD,EAAAtpD,KAAA8hD,MAAA9gE,EAAAm+C,IAAAhhB,OAAA+7B,GAAAl5D,EAAAu9B,UACA,MAAA,CACAN,aAAAw0B,EAAA+H,SAAAv8B,aACAsrC,WAAA9W,EAAAvS,QAAAjiB,aACAirC,YAAAzW,EAAA+H,SAAA0O,YAAAvP,YAAAlH,EAAA+H,SAAAb,YACA6P,UAAA/W,EAAAvS,QAAAyZ,YACA8P,QAAAzoE,EAAA2f,QAAAk3C,YAAAwR,EAAA,EACAK,UAAAJ,EACAtrC,aAAAsrC,EAAAhP,GAAAt5D,GAAAyxD,EAAAkI,UACAn8B,eAAAi0B,EAAAj0B,eACAg6B,YAAA6Q,EAZA,CAgBA,IAAAM,GAAA,SAAAzN,EAAAza,EAAAzgD,GACAgM,KAAAhM,GAAAA,EACA,IAAA4oE,EAAA58D,KAAA48D,KAAAtqD,EAAA,MAAA,CAAAA,EAAA,MAAA,KAAA,KAAA,mBAAA,yBACAuqD,EAAA78D,KAAA68D,MAAAvqD,EAAA,MAAA,CAAAA,EAAA,MAAA,KAAA,KAAA,kCAAA,yBACAsqD,EAAAE,SAAAD,EAAAC,UAAA,EACA5N,EAAA0N,GAAA1N,EAAA2N,GAEArnE,GAAAonE,EAAA,UAAA,WACAA,EAAA3rC,cAAAwjB,EAAAmoB,EAAAtsC,UAAA,WADA,IAGA96B,GAAAqnE,EAAA,UAAA,WACAA,EAAAlQ,aAAAlY,EAAAooB,EAAAxsC,WAAA,aADA,IAIArwB,KAAA+8D,kBAAA,EAEA/sB,GAAAC,EAAA,IAAAjwC,KAAA68D,MAAAjnE,MAAAonE,UAAAh9D,KAAA48D,KAAAhnE,MAAAqnE,SAAA,OAhBA,EAmBAN,GAAAzqE,UAAAk8B,OAAA,SAAAosB,GACA,IAAA0iB,EAAA1iB,EAAA0hB,YAAA1hB,EAAAmS,YAAA,EACAwQ,EAAA3iB,EAAAxpB,aAAAwpB,EAAAvpB,aAAA,EACAmsC,EAAA5iB,EAAAhpB,eAEA,GAAA2rC,EAAA,CACAn9D,KAAA48D,KAAAhnE,MAAA27B,QAAA,QACAvxB,KAAA48D,KAAAhnE,MAAA2f,OAAA2nD,EAAAE,EAAA,KAAA,IACA,IAAAC,EAAA7iB,EAAA+hB,YAAAW,EAAAE,EAAA,GAEAp9D,KAAA48D,KAAAlrC,WAAA97B,MAAAu7B,OACAne,KAAAC,IAAA,EAAAunC,EAAAxpB,aAAAwpB,EAAAvpB,aAAAosC,GAAA,IANA,MAQAr9D,KAAA48D,KAAAtsC,UAAA,EACAtwB,KAAA48D,KAAAhnE,MAAA27B,QAAA,GACAvxB,KAAA48D,KAAAlrC,WAAA97B,MAAAu7B,OAAA,IAGA,GAAA+rC,EAAA,CACAl9D,KAAA68D,MAAAjnE,MAAA27B,QAAA,QACAvxB,KAAA68D,MAAAjnE,MAAAyf,MAAA8nD,EAAAC,EAAA,KAAA,IACAp9D,KAAA68D,MAAAjnE,MAAAwd,KAAAonC,EAAAiiB,QAAA,KACA,IAAAa,EAAA9iB,EAAAgiB,UAAAhiB,EAAAiiB,SAAAU,EAAAC,EAAA,GACAp9D,KAAA68D,MAAAnrC,WAAA97B,MAAA67B,MACAze,KAAAC,IAAA,EAAAunC,EAAA0hB,YAAA1hB,EAAAmS,YAAA2Q,GAAA,IANA,MAQAt9D,KAAA68D,MAAAjnE,MAAA27B,QAAA,GACAvxB,KAAA68D,MAAAnrC,WAAA97B,MAAA67B,MAAA,IAQA,OALAzxB,KAAA+8D,kBAAAviB,EAAAvpB,aAAA,IACA,GAAAmsC,GAAAp9D,KAAAu9D,gBACAv9D,KAAA+8D,kBAAA,GAGA,CAAA1nD,MAAA8nD,EAAAC,EAAA,EAAA7nD,OAAA2nD,EAAAE,EAAA,EAnCA,EAsCAT,GAAAzqE,UAAA8pE,cAAA,SAAA/zD,GACAjI,KAAA68D,MAAAxsC,YAAApoB,IAAAjI,KAAA68D,MAAAxsC,WAAApoB,GACAjI,KAAAw9D,cAAAx9D,KAAAy9D,mBAAAz9D,KAAA68D,MAAA78D,KAAAw9D,aAAA,QAFA,EAKAb,GAAAzqE,UAAA0pE,aAAA,SAAA3zD,GACAjI,KAAA48D,KAAAtsC,WAAAroB,IAAAjI,KAAA48D,KAAAtsC,UAAAroB,GACAjI,KAAA09D,aAAA19D,KAAAy9D,mBAAAz9D,KAAA48D,KAAA58D,KAAA09D,YAAA,OAFA,EAKAf,GAAAzqE,UAAAqrE,cAAA,WACA,IAAArD,EAAAnpB,IAAAN,EAAA,OAAA,OACAzwC,KAAA68D,MAAAjnE,MAAAu7B,OAAAnxB,KAAA48D,KAAAhnE,MAAA67B,MAAAyoC,EACAl6D,KAAA68D,MAAAjnE,MAAAqjE,WAAAj5D,KAAA48D,KAAAhnE,MAAAqjE,WAAA,SACAj5D,KAAAw9D,aAAA,IAAAtpB,EACAl0C,KAAA09D,YAAA,IAAAxpB,CALA,EAQAyoB,GAAAzqE,UAAAurE,mBAAA,SAAAE,EAAAvnD,EAAA/X,GACAs/D,EAAA/nE,MAAAqjE,WAAA,GAcA7iD,EAAA2rB,IAAA,KAbA,SAAA67B,IAOA,IAAA1oD,EAAAyoD,EAAAxoD,yBACA,QAAA9W,EAAAwU,SAAAgrD,iBAAA3oD,EAAAG,MAAA,GAAAH,EAAAvF,IAAAuF,EAAAK,QAAA,GACA1C,SAAAgrD,kBAAA3oD,EAAAG,MAAAH,EAAA9B,MAAA,EAAA8B,EAAAK,OAAA,KACAooD,EAAAA,EAAA/nE,MAAAqjE,WAAA,SACA7iD,EAAA2rB,IAAA,IAAA67B,EAXA,GAFA,EAkBAjB,GAAAzqE,UAAA6kB,MAAA,WACA,IAAA46B,EAAA3xC,KAAA68D,MAAAtqD,WACAo/B,EAAAn/B,YAAAxS,KAAA68D,OACAlrB,EAAAn/B,YAAAxS,KAAA48D,KAHA,EAMA,IAAAkB,GAAA,WAAA,EAOA,SAAAC,GAAA/pE,EAAAwmD,GACAA,IAAAA,EAAA4hB,GAAApoE,IACA,IAAAgqE,EAAAhqE,EAAAu9B,QAAAk8B,SAAAwQ,EAAAjqE,EAAAu9B,QAAAo8B,UACAuQ,GAAAlqE,EAAAwmD,GACA,IAAA,IAAAnpD,EAAA,EAAAA,EAAA,GAAA2sE,GAAAhqE,EAAAu9B,QAAAk8B,UAAAwQ,GAAAjqE,EAAAu9B,QAAAo8B,UAAAt8D,IACA2sE,GAAAhqE,EAAAu9B,QAAAk8B,UAAAz5D,EAAA2f,QAAArf,cACAolE,GAAA1lE,GACAkqE,GAAAlqE,EAAAooE,GAAApoE,IACAgqE,EAAAhqE,EAAAu9B,QAAAk8B,SAAAwQ,EAAAjqE,EAAAu9B,QAAAo8B,SARA,CAcA,SAAAuQ,GAAAlqE,EAAAwmD,GACA,IAAAiL,EAAAzxD,EAAAu9B,QACA+L,EAAAmoB,EAAAsW,WAAA3tC,OAAAosB,GAEAiL,EAAAqH,MAAAl3D,MAAAg8B,cAAA6zB,EAAAgI,SAAAnwB,EAAAjoB,OAAA,KACAowC,EAAAqH,MAAAl3D,MAAAuoE,eAAA1Y,EAAAkI,UAAArwB,EAAA/nB,QAAA,KACAkwC,EAAA2Y,aAAAxoE,MAAAyoE,aAAA/gC,EAAA/nB,OAAA,uBAEA+nB,EAAAjoB,OAAAioB,EAAA/nB,QACAkwC,EAAA6Y,gBAAA1oE,MAAA27B,QAAA,QACAk0B,EAAA6Y,gBAAA1oE,MAAAu7B,OAAAmM,EAAA/nB,OAAA,KACAkwC,EAAA6Y,gBAAA1oE,MAAA67B,MAAA6L,EAAAjoB,MAAA,MACAowC,EAAA6Y,gBAAA1oE,MAAA27B,QAAA,GACA+L,EAAA/nB,QAAAvhB,EAAA2f,QAAA4qD,4BAAAvqE,EAAA2f,QAAAk3C,aACApF,EAAA+Y,aAAA5oE,MAAA27B,QAAA,QACAk0B,EAAA+Y,aAAA5oE,MAAAu7B,OAAAmM,EAAA/nB,OAAA,KACAkwC,EAAA+Y,aAAA5oE,MAAA67B,MAAA+oB,EAAAgR,YAAA,MACA/F,EAAA+Y,aAAA5oE,MAAA27B,QAAA,EAjBA,CAnBAusC,GAAA5rE,UAAAk8B,OAAA,WAAA,MAAA,CAAA7Y,OAAA,EAAAF,MAAA,EAAA,EACAyoD,GAAA5rE,UAAA8pE,cAAA,WAAA,EACA8B,GAAA5rE,UAAA0pE,aAAA,WAAA,EACAkC,GAAA5rE,UAAA6kB,MAAA,WAAA,EAoCA,IAAA0nD,GAAA,CAAAC,OAAA/B,GAAAn3D,KAAAs4D,IAEA,SAAAa,GAAA3qE,GACAA,EAAAu9B,QAAAwqC,aACA/nE,EAAAu9B,QAAAwqC,WAAAhlD,QACA/iB,EAAAu9B,QAAAwqC,WAAA1pB,UACAd,EAAAv9C,EAAAu9B,QAAA2hB,QAAAl/C,EAAAu9B,QAAAwqC,WAAA1pB,WAGAr+C,EAAAu9B,QAAAwqC,WAAA,IAAA0C,GAAAzqE,EAAA2f,QAAAirD,iBAAA,SAAAlsD,GACA1e,EAAAu9B,QAAA2hB,QAAAsX,aAAA93C,EAAA1e,EAAAu9B,QAAA+sC,iBAEA9oE,GAAAkd,EAAA,aAAA,WACA1e,EAAA+D,MAAA2wC,SAAAv0B,YAAA,WAAA,OAAAngB,EAAAu9B,QAAA12B,MAAAu5B,OAAA,GAAA,EADA,IAGA1hB,EAAA2c,aAAA,iBAAA,OANA,IAOA,SAAApnB,EAAA42D,GACA,cAAAA,EAAA7C,GAAAhoE,EAAAiU,GACAyzD,GAAA1nE,EAAAiU,EAFA,GAGAjU,GACAA,EAAAu9B,QAAAwqC,WAAA1pB,UACAA,EAAAr+C,EAAAu9B,QAAA2hB,QAAAl/C,EAAAu9B,QAAAwqC,WAAA1pB,SAnBA,CA4BA,IAAAysB,GAAA,EAEA,SAAAC,GAAA/qE,GAlvDA,IAAAgrE,EAmvDAhrE,EAAAqlD,MAAA,CACArlD,GAAAA,EACAkhE,aAAA,EACA+I,YAAAjqE,EAAAm+C,IAAAhhB,OACAi9B,aAAA,EACA6Q,YAAA,EACAC,QAAA,EACAC,WAAA,KACA7lB,uBAAA,KACA8lB,qBAAA,EACAC,kBAAA,EACAC,eAAA,EACAjvC,WAAA,KAAAC,UAAA,KACA+qC,YAAA,KACAjnC,OAAA,EACAvc,KAAAinD,GACAS,WAAA,MAnwDAP,EAqwDAhrE,EAAAqlD,MApwDA+P,GACAA,GAAAoW,IAAAn9D,KAAA28D,GAEAA,EAAAS,UAAArW,GAAA,CACAoW,IAAA,CAAAR,GACAzV,iBAAA,GA4uDA,CAuBA,SAAAmW,GAAA1rE,GACA,IAAAgrE,EAAAhrE,EAAAqlD,MACA2lB,GAhvDA,SAAAA,EAAAW,GACA,IAAAC,EAAAZ,EAAAS,UACA,GAAAG,EAEA,KApBA,SAAAA,GAGA,IAAAC,EAAAD,EAAArW,iBAAAl4D,EAAA,EACA,EAAA,CACA,KAAAA,EAAAwuE,EAAAvuE,OAAAD,IACAwuE,EAAAxuE,GAAAsB,KAAA,MACA,IAAA,IAAAsxB,EAAA,EAAAA,EAAA27C,EAAAJ,IAAAluE,OAAA2yB,IAAA,CACA,IAAA+6C,EAAAY,EAAAJ,IAAAv7C,GACA,GAAA+6C,EAAA1lB,uBACA,KAAA0lB,EAAAI,qBAAAJ,EAAA1lB,uBAAAhoD,QACA0tE,EAAA1lB,uBAAA0lB,EAAAI,wBAAAzsE,KAAA,KAAAqsE,EAAAhrE,GAJA,CAHA,OASA3C,EAAAwuE,EAAAvuE,OAbA,CAoBAwuE,CAAAF,EAAA,CAAA,QAEAxW,GAAA,KACAuW,EAAAC,EAFA,CALA,CAgvDAG,CAAAf,GAAA,SAAAY,GACA,IAAA,IAAAvuE,EAAA,EAAAA,EAAAuuE,EAAAJ,IAAAluE,OAAAD,IACAuuE,EAAAJ,IAAAnuE,GAAA2C,GAAAqlD,MAAA,MAOA,SAAAumB,GAEA,IADA,IAAAJ,EAAAI,EAAAJ,IACAnuE,EAAA,EAAAA,EAAAmuE,EAAAluE,OAAAD,IACA2uE,GAAAR,EAAAnuE,IACA,IAAA,IAAA6lD,EAAA,EAAAA,EAAAsoB,EAAAluE,OAAA4lD,IACA+oB,GAAAT,EAAAtoB,IACA,IAAA,IAAAC,EAAA,EAAAA,EAAAqoB,EAAAluE,OAAA6lD,IACA+oB,GAAAV,EAAAroB,IACA,IAAA,IAAAE,EAAA,EAAAA,EAAAmoB,EAAAluE,OAAA+lD,IACA8oB,GAAAX,EAAAnoB,IACA,IAAA,IAAAG,EAAA,EAAAA,EAAAgoB,EAAAluE,OAAAkmD,IACA4oB,GAAAZ,EAAAhoB,GAXA,CANA6oB,CAAAT,EAHA,GAFA,CAyBA,SAAAI,GAAAhB,GACA,IAAAhrE,EAAAgrE,EAAAhrE,GAAAu9B,EAAAv9B,EAAAu9B,SAmNA,SAAAv9B,GACA,IAAAu9B,EAAAv9B,EAAAu9B,SACAA,EAAA+uC,mBAAA/uC,EAAAi8B,SAAA95C,cACA6d,EAAAC,eAAAD,EAAAi8B,SAAA95C,YAAA6d,EAAAi8B,SAAAb,YACAp7B,EAAA6sC,aAAAxoE,MAAAu7B,OAAAm8B,GAAAt5D,GAAA,KACAu9B,EAAAu7B,MAAAl3D,MAAA2qE,cAAAhvC,EAAAC,eAAA,KACAD,EAAAu7B,MAAAl3D,MAAA4qE,iBAAAlT,GAAAt5D,GAAA,KACAu9B,EAAA+uC,mBAAA,EAPA,CAlNAG,CAAAzsE,GACAgrE,EAAAM,eAAA9Z,GAAAxxD,GAEAgrE,EAAA0B,WAAA1B,EAAA9J,aAAA8J,EAAA5Q,aAAA,MAAA4Q,EAAA1uC,WACA0uC,EAAA3D,cAAA2D,EAAA3D,YAAA3kE,KAAAkD,KAAA23B,EAAAmvB,UACAse,EAAA3D,YAAA1kE,GAAAiD,MAAA23B,EAAAovB,SACApvB,EAAAq0B,gBAAA5xD,EAAA2f,QAAArf,aACA0qE,EAAA5wC,OAAA4wC,EAAA0B,YACA,IAAAC,GAAA3sE,EAAAgrE,EAAA0B,YAAA,CAAA/wD,IAAAqvD,EAAA1uC,UAAA+pC,OAAA2E,EAAA3D,aAAA2D,EAAA5Q,YAVA,CAaA,SAAA6R,GAAAjB,GACAA,EAAA4B,eAAA5B,EAAA0B,YAAAG,GAAA7B,EAAAhrE,GAAAgrE,EAAA5wC,OADA,CAIA,SAAA8xC,GAAAlB,GACA,IAAAhrE,EAAAgrE,EAAAhrE,GAAAu9B,EAAAv9B,EAAAu9B,QACAytC,EAAA4B,gBAAAlH,GAAA1lE,GAEAgrE,EAAA8B,WAAA1E,GAAApoE,GAKAu9B,EAAAq0B,iBAAA5xD,EAAA2f,QAAArf,eACA0qE,EAAA+B,cAAAlT,GAAA75D,EAAAu9B,EAAAm0B,QAAAn0B,EAAAm0B,QAAA3vD,KAAAzE,QAAA8hB,KAAA,EACApf,EAAAu9B,QAAA6lC,WAAA4H,EAAA+B,cACA/B,EAAA8B,WAAA5E,YACAlpD,KAAAC,IAAAse,EAAAi8B,SAAAb,YAAAp7B,EAAAu7B,MAAA/8B,WAAAivC,EAAA+B,cAAAzT,GAAAt5D,GAAAA,EAAAu9B,QAAAk8B,UACAuR,EAAAgC,cAAAhuD,KAAAC,IAAA,EAAAse,EAAAu7B,MAAA/8B,WAAAivC,EAAA+B,cAAAxT,GAAAv5D,MAGAgrE,EAAA4B,gBAAA5B,EAAAK,oBACAL,EAAAiC,kBAAA1vC,EAAA12B,MAAAm7D,mBAlBA,CAqBA,SAAAmK,GAAAnB,GACA,IAAAhrE,EAAAgrE,EAAAhrE,GAEA,MAAAgrE,EAAA+B,gBACA/sE,EAAAu9B,QAAAu7B,MAAAl3D,MAAAqnE,SAAA+B,EAAA+B,cAAA,KACA/B,EAAAgC,cAAAhtE,EAAAm+C,IAAA9hB,YACA2rC,GAAAhoE,EAAAgf,KAAAK,IAAArf,EAAAu9B,QAAAi8B,SAAAn9B,WAAA2uC,EAAAgC,gBAAA,GACAhtE,EAAAu9B,QAAAq0B,gBAAA,GAGA,IAAAsb,EAAAlC,EAAA5qC,OAAA4qC,EAAA5qC,OAAA4d,EAAAjP,EAAA/uC,IACAgrE,EAAAiC,mBACAjtE,EAAAu9B,QAAA12B,MAAAk7D,cAAAiJ,EAAAiC,kBAAAC,IACAlC,EAAA4B,gBAAA5B,EAAAf,aAAAjqE,EAAAm+C,IAAAhhB,SACA4sC,GAAA/pE,EAAAgrE,EAAA8B,YACA9B,EAAA4B,gBACAO,GAAAntE,EAAAgrE,EAAA8B,YAEA9B,EAAAK,kBAAAvG,GAAA9kE,GAEAA,EAAA+D,MAAA2wC,SAAAs2B,EAAAC,aACAjrE,EAAAu9B,QAAA12B,MAAAgxB,MAAAmzC,EAAAE,QACAgC,GAAA9H,GAAA4F,EAAAhrE,GAtBA,CAyBA,SAAAosE,GAAApB,GACA,IAAAhrE,EAAAgrE,EAAAhrE,GAAAu9B,EAAAv9B,EAAAu9B,QAAA4gB,EAAAn+C,EAAAm+C,IAaA,GAXA6sB,EAAA4B,gBAAAQ,GAAAptE,EAAAgrE,EAAA5wC,QAGA,MAAAmD,EAAA8vC,aAAA,MAAArC,EAAA1uC,WAAA,MAAA0uC,EAAA3uC,aAAA2uC,EAAA3D,cACA9pC,EAAA8vC,YAAA9vC,EAAA+vC,YAAA,MAGA,MAAAtC,EAAA1uC,WAAAsrC,GAAA5nE,EAAAgrE,EAAA1uC,UAAA0uC,EAAAlD,aAEA,MAAAkD,EAAA3uC,YAAA2rC,GAAAhoE,EAAAgrE,EAAA3uC,YAAA,GAAA,GAEA2uC,EAAA3D,YAAA,CACA,IAAA9M,EAtdA,SAAAv6D,EAAAiU,EAAAyF,EAAAgoB,GAEA,IAAA64B,EADA,MAAA74B,IAAAA,EAAA,GAEA1hC,EAAA2f,QAAArf,cAAA2T,GAAAyF,IAIAA,EAAA,UAAAzF,EAAAsuC,OAAA3+B,GAAA3P,EAAArO,KAAAqO,EAAAnJ,GAAA,EAAA,UAAAmJ,EACAA,EAAAA,EAAAnJ,GAAA8Y,GAAA3P,EAAArO,KAAA,UAAAqO,EAAAsuC,OAAAtuC,EAAAnJ,GAAA,EAAAmJ,EAAAnJ,GAAA,SAAAmJ,GAEA,IAAA,IAAAs5D,EAAA,EAAAA,EAAA,EAAAA,IAAA,CACA,IAAAC,GAAA,EACA1oC,EAAAlJ,GAAA57B,EAAAiU,GACAw5D,EAAA/zD,GAAAA,GAAAzF,EAAA2nB,GAAA57B,EAAA0Z,GAAAorB,EAKA4oC,EAAAlH,GAAAxmE,EAJAu6D,EAAA,CAAAn7C,KAAAJ,KAAAK,IAAAylB,EAAA1lB,KAAAquD,EAAAruD,MACAzD,IAAAqD,KAAAK,IAAAylB,EAAAnpB,IAAA8xD,EAAA9xD,KAAA+lB,EACArgB,MAAArC,KAAAC,IAAA6lB,EAAA1lB,KAAAquD,EAAAruD,MACAmC,OAAAvC,KAAAC,IAAA6lB,EAAAvjB,OAAAksD,EAAAlsD,QAAAmgB,IAEAisC,EAAA3tE,EAAAm+C,IAAA7hB,UAAAsxC,EAAA5tE,EAAAm+C,IAAA9hB,WASA,GARA,MAAAqxC,EAAApxC,YACAorC,GAAA1nE,EAAA0tE,EAAApxC,WACAtd,KAAAg8C,IAAAh7D,EAAAm+C,IAAA7hB,UAAAqxC,GAAA,IAAAH,GAAA,IAEA,MAAAE,EAAArxC,aACA2rC,GAAAhoE,EAAA0tE,EAAArxC,YACArd,KAAAg8C,IAAAh7D,EAAAm+C,IAAA9hB,WAAAuxC,GAAA,IAAAJ,GAAA,KAEAA,EAAA,KAlBA,CAoBA,OAAAjT,CA9BA,CAsdAsT,CAAA7tE,EAAA2pD,GAAAxL,EAAA6sB,EAAA3D,YAAA3kE,MACAinD,GAAAxL,EAAA6sB,EAAA3D,YAAA1kE,IAAAqoE,EAAA3D,YAAA3lC,SAzeA,SAAA1hC,EAAAu6D,GACA,IAAAxV,GAAA/kD,EAAA,wBAAA,CAEA,IAAAu9B,EAAAv9B,EAAAu9B,QAAArc,EAAAqc,EAAAu7B,MAAA33C,wBAAA2sD,EAAA,KACA3vB,EAAA5gB,EAAA2hB,QAAA3/B,cAGA,GAFAg7C,EAAA5+C,IAAAuF,EAAAvF,IAAA,EAAAmyD,GAAA,EACAvT,EAAAh5C,OAAAL,EAAAvF,KAAAwiC,EAAA3+B,YAAAkd,aAAAyhB,EAAA3hB,gBAAAS,gBAAA6wC,GAAA,GACA,MAAAA,IAAApxB,EAAA,CACA,IAAAqxB,EAAAzvD,EAAA,MAAA,IAAA,KAAA,uDAAAi8C,EAAA5+C,IAAA4hB,EAAAugC,WAAA9E,GAAAh5D,EAAAu9B,UAAA,0CAAAg9B,EAAAh5C,OAAAg5C,EAAA5+C,IAAA29C,GAAAt5D,GAAAu9B,EAAAo8B,WAAA,uCAAAY,EAAAn7C,KAAA,cAAAJ,KAAAC,IAAA,EAAAs7C,EAAAl5C,MAAAk5C,EAAAn7C,MAAA,OACApf,EAAAu9B,QAAA07B,UAAAr5C,YAAAmuD,GACAA,EAAAntC,eAAAktC,GACA9tE,EAAAu9B,QAAA07B,UAAAz6C,YAAAuvD,EAJA,CANA,CADA,CA0eAC,CAAAhuE,EAAAu6D,EAHA,CAQA,IAAAnuB,EAAA4+B,EAAAiD,mBAAAC,EAAAlD,EAAAmD,qBACA,GAAA/hC,EAAA,IAAA,IAAA/uC,EAAA,EAAAA,EAAA+uC,EAAA9uC,SAAAD,EACA+uC,EAAA/uC,GAAAgnB,MAAA/mB,QAAA68B,GAAAiS,EAAA/uC,GAAA,QACA,GAAA6wE,EAAA,IAAA,IAAAhrB,EAAA,EAAAA,EAAAgrB,EAAA5wE,SAAA4lD,EACAgrB,EAAAhrB,GAAA7+B,MAAA/mB,QAAA68B,GAAA+zC,EAAAhrB,GAAA,UAEA3lB,EAAA2hB,QAAA//B,eACAg/B,EAAA7hB,UAAAt8B,EAAAu9B,QAAAi8B,SAAAl9B,WAGA0uC,EAAAG,YACAhxC,GAAAn6B,EAAA,UAAAA,EAAAgrE,EAAAG,YACAH,EAAA5wC,QACA4wC,EAAA5wC,OAAAg0C,QAnCA,CAuCA,SAAAC,GAAAruE,EAAAX,GACA,GAAAW,EAAAqlD,MAAA,OAAAhmD,IACA0rE,GAAA/qE,GACA,IAAA,OAAAX,GAAA,CAAA,QACAqsE,GAAA1rE,EAAA,CAJA,CAOA,SAAA0d,GAAA1d,EAAAX,GACA,OAAA,WACA,GAAAW,EAAAqlD,MAAA,OAAAhmD,EAAAmW,MAAAxV,EAAAuV,WACAw1D,GAAA/qE,GACA,IAAA,OAAAX,EAAAmW,MAAAxV,EAAAuV,UAAA,CAAA,QACAm2D,GAAA1rE,EAAA,CAJA,CADA,CAUA,SAAAsuE,GAAAjvE,GACA,OAAA,WACA,GAAA2M,KAAAq5C,MAAA,OAAAhmD,EAAAmW,MAAAxJ,KAAAuJ,WACAw1D,GAAA/+D,MACA,IAAA,OAAA3M,EAAAmW,MAAAxJ,KAAAuJ,UAAA,CAAA,QACAm2D,GAAA1/D,KAAA,CAJA,CADA,CAQA,SAAAuiE,GAAAlvE,GACA,OAAA,WACA,IAAAW,EAAAgM,KAAAhM,GACA,IAAAA,GAAAA,EAAAqlD,MAAA,OAAAhmD,EAAAmW,MAAAxJ,KAAAuJ,WACAw1D,GAAA/qE,GACA,IAAA,OAAAX,EAAAmW,MAAAxJ,KAAAuJ,UAAA,CAAA,QACAm2D,GAAA1rE,EAAA,CALA,CADA,CAYA,SAAA6nE,GAAA7nE,EAAAwrC,GACAxrC,EAAAm+C,IAAA6N,kBAAAhsD,EAAAu9B,QAAAovB,QACA3sD,EAAA+D,MAAAyqE,UAAAzgC,IAAAvC,EAAA8T,EAAAmvB,GAAAzuE,GAFA,CAKA,SAAAyuE,GAAAzuE,GACA,IAAAm+C,EAAAn+C,EAAAm+C,IACA,KAAAA,EAAA6N,mBAAAhsD,EAAAu9B,QAAAovB,QAAA,CACA,IAAAjzC,GAAA,IAAA0mC,KAAApgD,EAAA2f,QAAA+uD,SACAxiE,EAAAw/C,GAAA1rD,EAAAm+C,EAAA6N,mBACA2iB,EAAA,GAEAxwB,EAAAxF,KAAAzsC,EAAAtG,KAAAoZ,KAAAK,IAAA8+B,EAAAld,MAAAkd,EAAAvV,KAAA5oC,EAAAu9B,QAAAovB,OAAA,MAAA,SAAA/mD,GACA,GAAAsG,EAAAtG,MAAA5F,EAAAu9B,QAAAmvB,SAAA,CACA,IAAAkiB,EAAAhpE,EAAAwlD,OACAO,EAAA/lD,EAAA7D,KAAAzE,OAAA0C,EAAA2f,QAAAisC,mBAAAnmD,GAAA04C,EAAA/9C,KAAA8L,EAAAnI,OAAA,KACA8qE,EAAAlkB,GAAA3qD,EAAA4F,EAAAsG,GAAA,GACAy/C,IAAAz/C,EAAAnI,MAAA4nD,GACA/lD,EAAAwlD,OAAAyjB,EAAAzjB,OACA,IAAA0jB,EAAAlpE,EAAAmmD,aAAAgjB,EAAAF,EAAAxjB,QACA0jB,EAAAnpE,EAAAmmD,aAAAgjB,EACAD,IAAAlpE,EAAAmmD,aAAA,MAGA,IAFA,IAAAijB,GAAAJ,GAAAA,EAAAtxE,QAAAsI,EAAAwlD,OAAA9tD,QACAwxE,GAAAC,KAAAD,IAAAC,GAAAD,EAAAxjB,SAAAyjB,EAAAzjB,SAAAwjB,EAAAvjB,WAAAwjB,EAAAxjB,WACAluD,EAAA,GAAA2xE,GAAA3xE,EAAAuxE,EAAAtxE,SAAAD,EAAA2xE,EAAAJ,EAAAvxE,IAAAuI,EAAAwlD,OAAA/tD,GACA2xE,GAAAL,EAAAtgE,KAAAnC,EAAAtG,MACAA,EAAAimD,WAAA3/C,EAAA4/C,OACA5/C,EAAAspC,UAdA,MAgBA5vC,EAAA7D,KAAAzE,QAAA0C,EAAA2f,QAAAisC,oBACAa,GAAAzsD,EAAA4F,EAAA7D,KAAAmK,GACAtG,EAAAimD,WAAA3/C,EAAAtG,KAAA,GAAA,EAAAsG,EAAA4/C,OAAA,KACA5/C,EAAAspC,WAEA,IAAA,IAAA4K,KAAA1mC,EAEA,OADAmuD,GAAA7nE,EAAAA,EAAA2f,QAAAsvD,YACA,CAxBA,IA2BA9wB,EAAA6N,kBAAA9/C,EAAAtG,KACAu4C,EAAA8N,aAAAjtC,KAAAC,IAAAk/B,EAAA8N,aAAA//C,EAAAtG,MACA+oE,EAAArxE,QAAA+wE,GAAAruE,GAAA,WACA,IAAA,IAAA3C,EAAA,EAAAA,EAAAsxE,EAAArxE,OAAAD,IACAokE,GAAAzhE,EAAA2uE,EAAAtxE,GAAA,OAFA,GAlCA,CAFA,CA4CA,IAAAsvE,GAAA,SAAA3sE,EAAAomE,EAAA8I,GACA,IAAA3xC,EAAAv9B,EAAAu9B,QAEAvxB,KAAAo6D,SAAAA,EAEAp6D,KAAAmjE,QAAAhJ,GAAA5oC,EAAAv9B,EAAAm+C,IAAAioB,GACAp6D,KAAAojE,gBAAA7xC,EAAA2hB,QAAAx/B,YACA1T,KAAAqjE,cAAA9xC,EAAA2hB,QAAAjiB,aACAjxB,KAAAqsD,aAAA96B,EAAA2hB,QAAAyZ,YACA3sD,KAAAsjE,gBAAA/V,GAAAv5D,GACAgM,KAAAkjE,MAAAA,EACAljE,KAAA2pD,KAAAwE,GAAAn6D,GACAgM,KAAAujE,OAAA,EAZA,EAsEA,SAAA1C,GAAA7sE,EAAAo6B,GACA,IAAAmD,EAAAv9B,EAAAu9B,QAAA4gB,EAAAn+C,EAAAm+C,IAEA,GAAA/jB,EAAAg1C,eAEA,OADAjO,GAAAnhE,IACA,EAIA,IAAAo6B,EAAA80C,OACA90C,EAAA+0C,QAAAzsE,MAAA66B,EAAAmvB,UAAAtyB,EAAA+0C,QAAAxsE,IAAA46B,EAAAovB,SACA,MAAApvB,EAAA0jC,mBAAA1jC,EAAA0jC,mBAAA1jC,EAAAovB,SACApvB,EAAAiyC,cAAAjyC,EAAA43B,MAAA,GAAAyM,GAAA5hE,GACA,OAAA,EAEAyvE,GAAAzvE,KACAmhE,GAAAnhE,GACAo6B,EAAAu7B,KAAAwE,GAAAn6D,IAIA,IAAA0Z,EAAAykC,EAAAld,MAAAkd,EAAAvV,KACAlmC,EAAAsc,KAAAC,IAAAmb,EAAA+0C,QAAAzsE,KAAA1C,EAAA2f,QAAA+vD,eAAAvxB,EAAAld,OACAt+B,EAAAqc,KAAAK,IAAA3F,EAAA0gB,EAAA+0C,QAAAxsE,GAAA3C,EAAA2f,QAAA+vD,gBACAnyC,EAAAmvB,SAAAhqD,GAAAA,EAAA66B,EAAAmvB,SAAA,KAAAhqD,EAAAsc,KAAAC,IAAAk/B,EAAAld,MAAA1D,EAAAmvB,WACAnvB,EAAAovB,OAAAhqD,GAAA46B,EAAAovB,OAAAhqD,EAAA,KAAAA,EAAAqc,KAAAK,IAAA3F,EAAA6jB,EAAAovB,SACAkB,KACAnrD,EAAAmuD,GAAA7wD,EAAAm+C,IAAAz7C,GACAC,EAAAquD,GAAAhxD,EAAAm+C,IAAAx7C,IAGA,IAAAgtE,EAAAjtE,GAAA66B,EAAAmvB,UAAA/pD,GAAA46B,EAAAovB,QACApvB,EAAAqyC,gBAAAx1C,EAAAi1C,eAAA9xC,EAAAsyC,eAAAz1C,EAAAi+B,cAhgCA,SAAAr4D,EAAA0C,EAAAC,GACA,IAAA46B,EAAAv9B,EAAAu9B,QACA,GADAA,EAAA43B,KACA73D,QAAAoF,GAAA66B,EAAAovB,QAAAhqD,GAAA46B,EAAAmvB,UACAnvB,EAAA43B,KAAAF,GAAAj1D,EAAA0C,EAAAC,GACA46B,EAAAmvB,SAAAhqD,IAEA66B,EAAAmvB,SAAAhqD,EACA66B,EAAA43B,KAAAF,GAAAj1D,EAAA0C,EAAA66B,EAAAmvB,UAAApjC,OAAAiU,EAAA43B,MACA53B,EAAAmvB,SAAAhqD,IACA66B,EAAA43B,KAAA53B,EAAA43B,KAAAjiD,MAAAgnD,GAAAl6D,EAAA0C,KACA66B,EAAAmvB,SAAAhqD,EACA66B,EAAAovB,OAAAhqD,EACA46B,EAAA43B,KAAA53B,EAAA43B,KAAA7rC,OAAA2rC,GAAAj1D,EAAAu9B,EAAAovB,OAAAhqD,IACA46B,EAAAovB,OAAAhqD,IACA46B,EAAA43B,KAAA53B,EAAA43B,KAAAjiD,MAAA,EAAAgnD,GAAAl6D,EAAA2C,MAEA46B,EAAAovB,OAAAhqD,CAhBA,CAigCAmtE,CAAA9vE,EAAA0C,EAAAC,GAEA46B,EAAAugC,WAAA1M,GAAAp4B,GAAAh5B,EAAAm+C,IAAA5gB,EAAAmvB,WAEA1sD,EAAAu9B,QAAAw7B,MAAAn3D,MAAA+Z,IAAA4hB,EAAAugC,WAAA,KAEA,IAAAiS,EAAAnO,GAAA5hE,GACA,IAAA2vE,GAAA,GAAAI,IAAA31C,EAAA80C,OAAA3xC,EAAAiyC,cAAAjyC,EAAA43B,OACA,MAAA53B,EAAA0jC,mBAAA1jC,EAAA0jC,mBAAA1jC,EAAAovB,QACA,OAAA,EAIA,IAAAqjB,EAjFA,SAAAhwE,GACA,GAAAA,EAAAmlE,WAAA,OAAA,KACA,IAAAnoD,EAAAghC,EAAAjP,EAAA/uC,IACA,IAAAgd,IAAA8gC,EAAA99C,EAAAu9B,QAAAqoC,QAAA5oD,GAAA,OAAA,KACA,IAAAxG,EAAA,CAAAwnC,UAAAhhC,GACA,GAAAlc,OAAAm4B,aAAA,CACA,IAAApb,EAAAwhC,EAAAr/C,GAAAi5B,eACApb,EAAAoyD,YAAApyD,EAAAqyD,QAAApyB,EAAA99C,EAAAu9B,QAAAqoC,QAAA/nD,EAAAoyD,cACAz5D,EAAAy5D,WAAApyD,EAAAoyD,WACAz5D,EAAA25D,aAAAtyD,EAAAsyD,aACA35D,EAAA45D,UAAAvyD,EAAAuyD,UACA55D,EAAA65D,YAAAxyD,EAAAwyD,YANA,CASA,OAAA75D,CAdA,CAiFA85D,CAAAtwE,GAuBA,OAtBA+vE,EAAA,IAAAxyC,EAAAqoC,QAAAhkE,MAAA27B,QAAA,QA0EA,SAAAv9B,EAAAuwE,EAAA5a,GACA,IAAAp4B,EAAAv9B,EAAAu9B,QAAAl9B,EAAAL,EAAA2f,QAAAtf,YACAs7B,EAAA4B,EAAAqoC,QAAA3gE,EAAA02B,EAAA+B,WAEA,SAAArf,EAAAK,GACA,IAAA3T,EAAA2T,EAAAif,YAMA,OAJAue,GAAAa,GAAA/8C,EAAAu9B,QAAAizC,oBAAA9xD,EACAA,EAAA9c,MAAA27B,QAAA,OAEA7e,EAAAH,WAAAC,YAAAE,GACA3T,CAPA,CAaA,IAHA,IAAAoqD,EAAA53B,EAAA43B,KAAArE,EAAAvzB,EAAAmvB,SAGArvD,EAAA,EAAAA,EAAA83D,EAAA73D,OAAAD,IAAA,CACA,IAAAg1D,EAAA8C,EAAA93D,GACA,GAAAg1D,EAAAjmB,aAAA,GAAAimB,EAAA3zC,MAAA2zC,EAAA3zC,KAAAH,YAAAod,EAGA,CACA,KAAA12B,GAAAotD,EAAA3zC,MAAAzZ,EAAAoZ,EAAApZ,GACA,IAAAwrE,EAAApwE,GAAA,MAAAkwE,GACAA,GAAAzf,GAAAuB,EAAA8E,WACA9E,EAAAuD,UACA/hD,EAAAw+C,EAAAuD,QAAA,WAAA,IAAA6a,GAAA,GACA/a,GAAA11D,EAAAqyD,EAAAvB,EAAA6E,IAEA8a,IACAjzB,EAAA6U,EAAA8E,YACA9E,EAAA8E,WAAAv3C,YAAAf,SAAA2E,eAAA2lC,GAAAnpD,EAAA2f,QAAAmxC,MAEA7rD,EAAAotD,EAAA3zC,KAAAif,WAZA,KAHA,CACA,IAAAjf,EAAAk5C,GAAA53D,EAAAqyD,EAAAvB,EAAA6E,GACAh6B,EAAA66B,aAAA93C,EAAAzZ,EAFA,CAiBA6rD,GAAAuB,EAAAzpB,IAnBA,CAqBA,KAAA3jC,GAAAA,EAAAoZ,EAAApZ,EAtCA,CAzEAyrE,CAAA1wE,EAAAu9B,EAAA0jC,kBAAA7mC,EAAAu7B,MACAoa,EAAA,IAAAxyC,EAAAqoC,QAAAhkE,MAAA27B,QAAA,IACAA,EAAAiyC,aAAAjyC,EAAA43B,KApEA,SAAAwb,GACA,GAAAA,GAAAA,EAAA3yB,WAAA2yB,EAAA3yB,WAAAA,EAAAC,EAAA0yB,EAAA3yB,cACA2yB,EAAA3yB,UAAA5d,SACA,qBAAAl8B,KAAAysE,EAAA3yB,UAAApjB,WACA+1C,EAAAV,YAAAnyB,EAAAj/B,SAAA3G,KAAAy4D,EAAAV,aAAAnyB,EAAAj/B,SAAA3G,KAAAy4D,EAAAP,YAAA,CACA,IAAAjyB,EAAAwyB,EAAA3yB,UAAAz+B,cACA1B,EAAAsgC,EAAA3+B,YAAAyZ,eAAAhc,EAAAkhC,EAAAK,cACAvhC,EAAAyhC,OAAAiyB,EAAAV,WAAAU,EAAAR,cACAlzD,EAAA6hC,UAAA,GACAjhC,EAAA+yD,kBACA/yD,EAAAgzD,SAAA5zD,GACAY,EAAAqyD,OAAAS,EAAAP,UAAAO,EAAAN,YAPA,CAJA,CAuEAS,CAAAd,GAIAxyB,EAAAjgB,EAAAynC,WACAxnB,EAAAjgB,EAAAwzC,cACAxzC,EAAAt8B,QAAAW,MAAAu7B,OAAAI,EAAAu7B,MAAAl3D,MAAAonE,UAAA,EAEA2G,IACApyC,EAAAqyC,eAAAx1C,EAAAi1C,cACA9xC,EAAAsyC,cAAAz1C,EAAAi+B,aACAwP,GAAA7nE,EAAA,MAGAu9B,EAAA0jC,kBAAA,MAEA,CArEA,CAwEA,SAAAmM,GAAAptE,EAAAo6B,GAGA,IAFA,IAAAgsC,EAAAhsC,EAAAgsC,SAEAnlC,GAAA,GAAAA,GAAA,EAAA,CACA,GAAAA,GAAAjhC,EAAA2f,QAAArf,cAAA85B,EAAAk1C,iBAAA/V,GAAAv5D,GASAihC,IACA7G,EAAA+0C,QAAAhJ,GAAAnmE,EAAAu9B,QAAAv9B,EAAAm+C,IAAAioB,SAHA,GALAA,GAAA,MAAAA,EAAAzqD,MACAyqD,EAAA,CAAAzqD,IAAAqD,KAAAK,IAAArf,EAAAm+C,IAAAhhB,OAAA+7B,GAAAl5D,EAAAu9B,SAAAm8B,GAAA15D,GAAAomE,EAAAzqD,OAGAye,EAAA+0C,QAAAhJ,GAAAnmE,EAAAu9B,QAAAv9B,EAAAm+C,IAAAioB,GACAhsC,EAAA+0C,QAAAzsE,MAAA1C,EAAAu9B,QAAAmvB,UAAAtyB,EAAA+0C,QAAAxsE,IAAA3C,EAAAu9B,QAAAovB,OACA,MAIA,IAAAkgB,GAAA7sE,EAAAo6B,GAAA,MACAsrC,GAAA1lE,GACA,IAAA8sE,EAAA1E,GAAApoE,GACA8hE,GAAA9hE,GACA+pE,GAAA/pE,EAAA8sE,GACAK,GAAAntE,EAAA8sE,GACA1yC,EAAA80C,OAAA,CAnBA,CAsBA90C,EAAAD,OAAAn6B,EAAA,SAAAA,GACAA,EAAAu9B,QAAAmvB,UAAA1sD,EAAAu9B,QAAAyzC,kBAAAhxE,EAAAu9B,QAAAovB,QAAA3sD,EAAAu9B,QAAA0zC,iBACA72C,EAAAD,OAAAn6B,EAAA,iBAAAA,EAAAA,EAAAu9B,QAAAmvB,SAAA1sD,EAAAu9B,QAAAovB,QACA3sD,EAAAu9B,QAAAyzC,iBAAAhxE,EAAAu9B,QAAAmvB,SAAA1sD,EAAAu9B,QAAA0zC,eAAAjxE,EAAAu9B,QAAAovB,OA5BA,CAgCA,SAAAgb,GAAA3nE,EAAAomE,GACA,IAAAhsC,EAAA,IAAAuyC,GAAA3sE,EAAAomE,GACA,GAAAyG,GAAA7sE,EAAAo6B,GAAA,CACAsrC,GAAA1lE,GACAotE,GAAAptE,EAAAo6B,GACA,IAAA0yC,EAAA1E,GAAApoE,GACA8hE,GAAA9hE,GACA+pE,GAAA/pE,EAAA8sE,GACAK,GAAAntE,EAAA8sE,GACA1yC,EAAAg0C,QAPA,CAFA,CA0DA,SAAA8C,GAAA3zC,GACA,IAAAE,EAAAF,EAAAt8B,QAAAye,YACA6d,EAAAu7B,MAAAl3D,MAAA42D,WAAA/6B,EAAA,KAEA63B,GAAA/3B,EAAA,gBAAAA,EAJA,CAOA,SAAA4vC,GAAAntE,EAAAwmD,GACAxmD,EAAAu9B,QAAAu7B,MAAAl3D,MAAAonE,UAAAxiB,EAAAkiB,UAAA,KACA1oE,EAAAu9B,QAAA6sC,aAAAxoE,MAAA+Z,IAAA6qC,EAAAkiB,UAAA,KACA1oE,EAAAu9B,QAAAt8B,QAAAW,MAAAu7B,OAAAqpB,EAAAkiB,UAAA1oE,EAAAu9B,QAAAo8B,UAAAL,GAAAt5D,GAAA,IAHA,CAQA,SAAAmoE,GAAAnoE,GACA,IAAAu9B,EAAAv9B,EAAAu9B,QAAA43B,EAAA53B,EAAA43B,KACA,GAAA53B,EAAA4zC,cAAA5zC,EAAAt8B,QAAAy8B,YAAA19B,EAAA2f,QAAAk3C,YAAA,CAGA,IAFA,IAAAua,EAAAlR,GAAA3iC,GAAAA,EAAAi8B,SAAAn9B,WAAAr8B,EAAAm+C,IAAA9hB,WACAgsC,EAAA9qC,EAAAt8B,QAAAye,YAAAN,EAAAgyD,EAAA,KACA/zE,EAAA,EAAAA,EAAA83D,EAAA73D,OAAAD,IAAA,IAAA83D,EAAA93D,GAAA+uC,OAAA,CACApsC,EAAA2f,QAAAk3C,cACA1B,EAAA93D,GAAAq5D,SACAvB,EAAA93D,GAAAq5D,OAAA90D,MAAAwd,KAAAA,GACA+1C,EAAA93D,GAAAs5D,mBACAxB,EAAA93D,GAAAs5D,iBAAA/0D,MAAAwd,KAAAA,IAEA,IAAA5K,EAAA2gD,EAAA93D,GAAAo6D,UACA,GAAAjjD,EAAA,IAAA,IAAAyb,EAAA,EAAAA,EAAAzb,EAAAlX,OAAA2yB,IACAzb,EAAAyb,GAAAruB,MAAAwd,KAAAA,CATA,CAWApf,EAAA2f,QAAAk3C,cACAt5B,EAAAt8B,QAAAW,MAAAwd,KAAAgyD,EAAA/I,EAAA,KAfA,CAFA,CAuBA,SAAAoH,GAAAzvE,GACA,IAAAA,EAAA2f,QAAAtf,YAAA,OAAA,EACA,IAAA89C,EAAAn+C,EAAAm+C,IAAAyL,EAAAT,GAAAnpD,EAAA2f,QAAAw+B,EAAAld,MAAAkd,EAAAvV,KAAA,GAAArL,EAAAv9B,EAAAu9B,QACA,GAAAqsB,EAAAtsD,QAAAigC,EAAA8/B,aAAA,CACA,IAAAn5D,EAAAq5B,EAAAipB,QAAA5mC,YAAAtB,EAAA,MAAA,CAAAA,EAAA,MAAAsrC,IACA,gDACAynB,EAAAntE,EAAAw5B,WAAAhe,YAAAujD,EAAA/+D,EAAAwb,YAAA2xD,EAOA,OANA9zC,EAAA+zC,WAAA1vE,MAAA67B,MAAA,GACAF,EAAA85B,kBAAAr4C,KAAAC,IAAAoyD,EAAA9zC,EAAA+zC,WAAA5xD,YAAAujD,GAAA,EACA1lC,EAAAg0C,aAAAh0C,EAAA85B,kBAAA4L,EACA1lC,EAAA8/B,aAAA9/B,EAAA85B,kBAAAzN,EAAAtsD,QAAA,EACAigC,EAAA+zC,WAAA1vE,MAAA67B,MAAAF,EAAAg0C,aAAA,KACAL,GAAAlxE,EAAAu9B,UACA,CAVA,CAYA,OAAA,CAfA,CAkBA,SAAAi0C,GAAAvwE,EAAAZ,GAEA,IADA,IAAAmW,EAAA,GAAAi7D,GAAA,EACAp0E,EAAA,EAAAA,EAAA4D,EAAA3D,OAAAD,IAAA,CACA,IAAAgG,EAAApC,EAAA5D,GAAAuE,EAAA,KAEA,GADA,iBAAAyB,IAAAzB,EAAAyB,EAAAzB,MAAAyB,EAAAA,EAAAgU,WACA,0BAAAhU,EAAA,CACA,IAAAhD,EAAA,SACAoxE,GAAA,CAFA,CAIAj7D,EAAAnI,KAAA,CAAAgJ,UAAAhU,EAAAzB,MAAAA,GAPA,CAUA,OADAvB,IAAAoxE,GAAAj7D,EAAAnI,KAAA,CAAAgJ,UAAA,yBAAAzV,MAAA,OACA4U,CAZA,CAiBA,SAAAk7D,GAAAn0C,GACA,IAAAt8B,EAAAs8B,EAAAt8B,QAAA0wE,EAAAp0C,EAAAg6B,YACA/Z,EAAAv8C,GACAs8B,EAAA+zC,WAAA,KACA,IAAA,IAAAj0E,EAAA,EAAAA,EAAAs0E,EAAAr0E,SAAAD,EAAA,CACA,IAAAuiE,EAAA+R,EAAAt0E,GACAga,EAAAuoD,EAAAvoD,UACAzV,EAAAg+D,EAAAh+D,MACAgwE,EAAA3wE,EAAA2e,YAAAtB,EAAA,MAAA,KAAA,qBAAAjH,IACAzV,IAAAgwE,EAAAhwE,MAAAg8C,QAAAh8C,GACA,0BAAAyV,IACAkmB,EAAA+zC,WAAAM,EACAA,EAAAhwE,MAAA67B,OAAAF,EAAAg0C,cAAA,GAAA,KARA,CAWAtwE,EAAAW,MAAA27B,QAAAo0C,EAAAr0E,OAAA,GAAA,OACA4zE,GAAA3zC,EAhBA,CAmBA,SAAAs0C,GAAA7xE,GACA0xE,GAAA1xE,EAAAu9B,SACAwjC,GAAA/gE,GACAmoE,GAAAnoE,EAHA,CAUA,SAAA8xE,GAAA5W,EAAA/c,EAAAt3C,EAAA8Y,GACA,IAAA8xC,EAAAzlD,KACAA,KAAAnF,MAAAA,EAGA4qD,EAAA6Y,gBAAAhsD,EAAA,MAAA,KAAA,+BACAmzC,EAAA6Y,gBAAAjvC,aAAA,iBAAA,QAGAo2B,EAAA+Y,aAAAlsD,EAAA,MAAA,KAAA,4BACAmzC,EAAA+Y,aAAAnvC,aAAA,iBAAA,QAEAo2B,EAAAmU,QAAA/nB,EAAA,MAAA,KAAA,mBAEA4T,EAAAsf,aAAAzyD,EAAA,MAAA,KAAA,KAAA,kCACAmzC,EAAAuT,UAAA1mD,EAAA,MAAA,KAAA,sBAEAmzC,EAAAjL,QAAAloC,EAAA,MAAA,KAAA,sBAEAmzC,EAAA4I,YAAA/7C,EAAA,MAAA,KAAA,sBAEAmzC,EAAAwH,UAAApb,EAAA,MAAA,CAAA4T,EAAAjL,QAAAiL,EAAA4I,YAAA5I,EAAAsf,aAAAtf,EAAAuT,UAAAvT,EAAAmU,SACA,KAAA,qCACA,IAAAvhD,EAAAw5B,EAAA,MAAA,CAAA4T,EAAAwH,WAAA,oBAEAxH,EAAAsH,MAAAz6C,EAAA,MAAA,CAAA+F,GAAA,KAAA,sBAEAotC,EAAAqH,MAAAx6C,EAAA,MAAA,CAAAmzC,EAAAsH,OAAA,oBACAtH,EAAA2R,WAAA,KAIA3R,EAAA2Y,aAAA9rD,EAAA,MAAA,KAAA,KAAA,+BAAAgiC,EAAA,mBAEAmR,EAAAxwD,QAAAqd,EAAA,MAAA,KAAA,sBACAmzC,EAAA6f,WAAA,KAEA7f,EAAA+H,SAAAl7C,EAAA,MAAA,CAAAmzC,EAAAqH,MAAArH,EAAA2Y,aAAA3Y,EAAAxwD,SAAA,qBACAwwD,EAAA+H,SAAAn+B,aAAA,WAAA,MAEAo2B,EAAAvS,QAAA5gC,EAAA,MAAA,CAAAmzC,EAAA6Y,gBAAA7Y,EAAA+Y,aAAA/Y,EAAA+H,UAAA,cAEApd,GAAAC,GAAA,MAAAoV,EAAAvS,QAAAt9C,MAAAmwE,SAAA,cAIAtgB,EAAAvS,QAAA7jB,aAAA,YAAA,MAGA2gB,GAAAC,EAAA,IAAAwV,EAAAxwD,QAAAW,MAAAu0D,QAAA,EAAA1E,EAAA+H,SAAA53D,MAAAg8B,aAAA,GACAse,GAAAN,GAAAkB,IAAA2U,EAAA+H,SAAAttB,WAAA,GAEAgvB,IACAA,EAAAt7C,YAAAs7C,EAAAt7C,YAAA6xC,EAAAvS,SACAgc,EAAAzJ,EAAAvS,UAIAuS,EAAA/E,SAAA+E,EAAA9E,OAAAxO,EAAAld,MACAwwB,EAAAuf,iBAAAvf,EAAAwf,eAAA9yB,EAAAld,MAEAwwB,EAAA0D,KAAA,GACA1D,EAAA+d,aAAA,KAGA/d,EAAAqB,iBAAA,KAEArB,EAAAqM,WAAA,EACArM,EAAAme,eAAAne,EAAAoe,cAAA,EACApe,EAAAwP,kBAAA,KAEAxP,EAAAj0B,eAAAi0B,EAAAkI,UAAAlI,EAAAgI,SAAA,EACAhI,EAAA6a,mBAAA,EAIA7a,EAAA8f,aAAA9f,EAAA4F,kBAAA5F,EAAA4L,aAAA,KAIA5L,EAAA0f,cAAA,EAEA1f,EAAA0L,gBAAA1L,EAAA2L,iBAAA3L,EAAA2H,eAAA,KAIA3H,EAAAC,QAAA,KACAD,EAAAE,cAAA,EACAF,EAAAG,gBAAA,EAGAH,EAAAugB,QAAAvgB,EAAAwgB,QAAAxgB,EAAA4b,YAAA5b,EAAA6b,YAAA,KAGA7b,EAAAr9B,OAAA,EAIAq9B,EAAA+T,kBAAA,KAEA/T,EAAAygB,YAAA,KAEAzgB,EAAA8F,YAAAia,GAAA7xD,EAAA1e,QAAA0e,EAAAtf,aACAqxE,GAAAjgB,GAEA5qD,EAAAgkB,KAAA4mC,EAzGA,CA/TAkb,GAAAzuE,UAAAi8B,OAAA,SAAAoqB,EAAAl6C,GACAk7C,GAAAhB,EAAAl6C,IACA2B,KAAAujE,OAAAlhE,KAAAkH,UAFA,EAIAo3D,GAAAzuE,UAAAkwE,OAAA,WACA,IAAA,IAAA/wE,EAAA,EAAAA,EAAA2O,KAAAujE,OAAAjyE,OAAAD,IACA88B,GAAA3kB,MAAA,KAAAxJ,KAAAujE,OAAAlyE,GAFA,EAkbA,IAAA80E,GAAA,EAAAC,GAAA,KAUA,SAAAC,GAAA7zE,GACA,IAAA8zE,EAAA9zE,EAAA+zE,YAAAC,EAAAh0E,EAAAi0E,YAIA,OAHA,MAAAH,GAAA9zE,EAAAk0E,QAAAl0E,EAAAqsE,MAAArsE,EAAAm0E,kBAAAL,EAAA9zE,EAAAk0E,QACA,MAAAF,GAAAh0E,EAAAk0E,QAAAl0E,EAAAqsE,MAAArsE,EAAAo0E,cAAAJ,EAAAh0E,EAAAk0E,OACA,MAAAF,IAAAA,EAAAh0E,EAAAq0E,YACA,CAAAzxD,EAAAkxD,EAAAhxD,EAAAkxD,EALA,CAOA,SAAAM,GAAAt0E,GACA,IAAAu0E,EAAAV,GAAA7zE,GAGA,OAFAu0E,EAAA3xD,GAAAgxD,GACAW,EAAAzxD,GAAA8wD,GACAW,CAJA,CAOA,SAAAC,GAAAhzE,EAAAxB,GAIA49C,GAAA,KAAAC,IACA,MAAAr8C,EAAAu9B,QAAA01C,iBAAAjzE,EAAAu9B,QAAAu7B,MAAAl3D,MAAAsxE,cAAA,OACAruD,aAAA7kB,EAAAu9B,QAAA01C,kBACAjzE,EAAAu9B,QAAA01C,iBAAA9yD,YAAA,WACAngB,EAAAu9B,QAAA01C,iBAAA,KACAjzE,EAAAu9B,QAAAu7B,MAAAl3D,MAAAsxE,cAAA,EAFA,GAGA,MAEA,IAAAH,EAAAV,GAAA7zE,GAAA8zE,EAAAS,EAAA3xD,EAAAoxD,EAAAO,EAAAzxD,EACA6xD,EAAAf,GACA,IAAA5zE,EAAA40E,YACAd,EAAA9zE,EAAA60E,OACAb,EAAAh0E,EAAA80E,OACAH,EAAA,GAGA,IAAA51C,EAAAv9B,EAAAu9B,QAAAkjB,EAAAljB,EAAAi8B,SAEA+Z,EAAA9yB,EAAAynB,YAAAznB,EAAAkY,YACA6a,EAAA/yB,EAAAzjB,aAAAyjB,EAAAxjB,aACA,GAAAq1C,GAAAiB,GAAAf,GAAAgB,EAAA,CAMA,GAAAhB,GAAAz1B,GAAAb,EACAzlC,EAAA,IAAA,IAAAxR,EAAAzG,EAAArB,OAAAg4D,EAAA53B,EAAA43B,KAAAlwD,GAAAw7C,EAAAx7C,EAAAA,EAAAsZ,WACA,IAAA,IAAAlhB,EAAA,EAAAA,EAAA83D,EAAA73D,OAAAD,IACA,GAAA83D,EAAA93D,GAAAqhB,MAAAzZ,EAAA,CACAjF,EAAAu9B,QAAAizC,mBAAAvrE,EACA,MAAAwR,CAFA,CAcA,GAAA67D,IAAA12B,IAAAU,GAAA,MAAA62B,EAWA,OAVAX,GAAAgB,GACA9L,GAAA1nE,EAAAgf,KAAAC,IAAA,EAAAwhC,EAAAnkB,UAAAk2C,EAAAW,IACAnL,GAAAhoE,EAAAgf,KAAAC,IAAA,EAAAwhC,EAAApkB,WAAAi2C,EAAAa,MAKAX,GAAAA,GAAAgB,IACA9tB,GAAAlnD,QACA++B,EAAA8vC,YAAA,MAMA,GAAAmF,GAAA,MAAAW,EAAA,CACA,IAAAM,EAAAjB,EAAAW,EACAx3D,EAAA3b,EAAAm+C,IAAA7hB,UAAAigC,EAAA5gD,EAAA4hB,EAAA2hB,QAAAjiB,aACAw2C,EAAA,EAAA93D,EAAAqD,KAAAC,IAAA,EAAAtD,EAAA83D,EAAA,IACAlX,EAAAv9C,KAAAK,IAAArf,EAAAm+C,IAAAhhB,OAAAo/B,EAAAkX,EAAA,IACA9L,GAAA3nE,EAAA,CAAA2b,IAAAA,EAAA4F,OAAAg7C,GALA,CAQA4V,GAAA,IAAA,IAAA3zE,EAAA40E,YACA,MAAA71C,EAAA8vC,aACA9vC,EAAA8vC,YAAA5sB,EAAApkB,WAAAkB,EAAA+vC,YAAA7sB,EAAAnkB,UACAiB,EAAAy0C,QAAAM,EAAA/0C,EAAA00C,QAAAO,EACAryD,YAAA,WACA,GAAA,MAAAod,EAAA8vC,YAAA,CACA,IAAAqG,EAAAjzB,EAAApkB,WAAAkB,EAAA8vC,YACAsG,EAAAlzB,EAAAnkB,UAAAiB,EAAA+vC,YACAsG,EAAAD,GAAAp2C,EAAA00C,SAAA0B,EAAAp2C,EAAA00C,SACAyB,GAAAn2C,EAAAy0C,SAAA0B,EAAAn2C,EAAAy0C,QACAz0C,EAAA8vC,YAAA9vC,EAAA+vC,YAAA,KACAsG,IACAxB,IAAAA,GAAAD,GAAAyB,IAAAzB,GAAA,KACAA,GARA,CADA,GAUA,OAEA50C,EAAAy0C,SAAAM,EAAA/0C,EAAA00C,SAAAO,GA/DA,CAxBA,CAnBAx2B,EAAAo2B,IAAA,IACAx2B,EAAAw2B,GAAA,GACAh2B,EAAAg2B,IAAA,GACA71B,IAAA61B,IAAA,EAAA,GAiHA,IAAAyB,GAAA,SAAA92D,EAAAulD,GACAt2D,KAAA+Q,OAAAA,EACA/Q,KAAAs2D,UAAAA,CAFA,EAKAuR,GAAA31E,UAAAu9C,QAAA,WAAA,OAAAzvC,KAAA+Q,OAAA/Q,KAAAs2D,UAAA,EAEAuR,GAAA31E,UAAA41E,OAAA,SAAAjhC,GACA,GAAAA,GAAA7mC,KAAA,OAAA,EACA,GAAA6mC,EAAAyvB,WAAAt2D,KAAAs2D,WAAAzvB,EAAA91B,OAAAzf,QAAA0O,KAAA+Q,OAAAzf,OAAA,OAAA,EACA,IAAA,IAAAD,EAAA,EAAAA,EAAA2O,KAAA+Q,OAAAzf,OAAAD,IAAA,CACA,IAAAs8C,EAAA3tC,KAAA+Q,OAAA1f,GAAA02E,EAAAlhC,EAAA91B,OAAA1f,GACA,IAAAisD,GAAA3P,EAAAv8B,OAAA22D,EAAA32D,UAAAksC,GAAA3P,EAAAt8B,KAAA02D,EAAA12D,MAAA,OAAA,CAFA,CAIA,OAAA,CAPA,EAUAw2D,GAAA31E,UAAA81E,SAAA,WAEA,IADA,IAAAt6C,EAAA,GACAr8B,EAAA,EAAAA,EAAA2O,KAAA+Q,OAAAzf,OAAAD,IACAq8B,EAAAr8B,GAAA,IAAA42E,GAAA1qB,GAAAv9C,KAAA+Q,OAAA1f,GAAA+f,QAAAmsC,GAAAv9C,KAAA+Q,OAAA1f,GAAAggB,OACA,OAAA,IAAAw2D,GAAAn6C,EAAA1tB,KAAAs2D,UAJA,EAOAuR,GAAA31E,UAAA67B,kBAAA,WACA,IAAA,IAAA18B,EAAA,EAAAA,EAAA2O,KAAA+Q,OAAAzf,OAAAD,IACA,IAAA2O,KAAA+Q,OAAA1f,GAAAigB,QAAA,OAAA,EACA,OAAA,CAHA,EAMAu2D,GAAA31E,UAAA4/C,SAAA,SAAA7pC,EAAAyF,GACAA,IAAAA,EAAAzF,GACA,IAAA,IAAA5W,EAAA,EAAAA,EAAA2O,KAAA+Q,OAAAzf,OAAAD,IAAA,CACA,IAAA4f,EAAAjR,KAAA+Q,OAAA1f,GACA,GAAAi7C,GAAA5+B,EAAAuD,EAAAva,SAAA,GAAA41C,GAAArkC,EAAAgJ,EAAAta,OAAA,EACA,OAAAtF,CAHA,CAKA,OAAA,CAPA,EAUA,IAAA42E,GAAA,SAAA72D,EAAAC,GACArR,KAAAoR,OAAAA,EAAApR,KAAAqR,KAAAA,CADA,EAWA,SAAA62D,GAAAl0E,EAAA+c,EAAAulD,GACA,IAAA6R,EAAAn0E,GAAAA,EAAA2f,QAAAy0D,mBACAC,EAAAt3D,EAAAulD,GACAvlD,EAAAyP,MAAA,SAAAptB,EAAAoe,GAAA,OAAA86B,GAAAl5C,EAAAsD,OAAA8a,EAAA9a,OAAA,IACA4/D,EAAAzuD,EAAAkJ,EAAAs3D,GACA,IAAA,IAAAh3E,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAA4H,EAAA8X,EAAA1f,GAAA4O,EAAA8Q,EAAA1f,EAAA,GACAwrD,EAAAvQ,GAAArsC,EAAAtJ,KAAAsC,EAAAvC,QACA,GAAAyxE,IAAAlvE,EAAAqY,QAAAurC,EAAA,EAAAA,GAAA,EAAA,CACA,IAAAnmD,EAAA+mD,GAAAx9C,EAAAvJ,OAAAuC,EAAAvC,QAAAC,EAAA6mD,GAAAv9C,EAAAtJ,KAAAsC,EAAAtC,MACA2xE,EAAAroE,EAAAqR,QAAArY,EAAAvC,QAAAuC,EAAAoY,KAAApR,EAAAvJ,QAAAuJ,EAAAoR,KACAhgB,GAAAilE,KAAAA,EACAvlD,EAAA+M,SAAAzsB,EAAA,EAAA,IAAA42E,GAAAK,EAAA3xE,EAAAD,EAAA4xE,EAAA5xE,EAAAC,GAJA,CAHA,CAUA,OAAA,IAAAkxE,GAAA92D,EAAAulD,EAfA,CAkBA,SAAAiS,GAAAn3D,EAAAC,GACA,OAAA,IAAAw2D,GAAA,CAAA,IAAAI,GAAA72D,EAAAC,GAAAD,IAAA,EADA,CAMA,SAAAo3D,GAAAtzE,GACA,OAAAA,EAAAa,KACA6hB,GAAA1iB,EAAAwB,KAAAkD,KAAA1E,EAAAa,KAAAzE,OAAA,EACA4jD,GAAAhgD,EAAAa,MAAAzE,QAAA,GAAA4D,EAAAa,KAAAzE,OAAA4D,EAAAwB,KAAAoI,GAAA,IAFA5J,EAAAyB,EADA,CAQA,SAAA8xE,GAAAxgE,EAAA/S,GACA,GAAAo3C,GAAArkC,EAAA/S,EAAAwB,MAAA,EAAA,OAAAuR,EACA,GAAAqkC,GAAArkC,EAAA/S,EAAAyB,KAAA,EAAA,OAAA6xE,GAAAtzE,GAEA,IAAA0E,EAAAqO,EAAArO,KAAA1E,EAAAa,KAAAzE,QAAA4D,EAAAyB,GAAAiD,KAAA1E,EAAAwB,KAAAkD,MAAA,EAAAkF,EAAAmJ,EAAAnJ,GAEA,OADAmJ,EAAArO,MAAA1E,EAAAyB,GAAAiD,OAAAkF,GAAA0pE,GAAAtzE,GAAA4J,GAAA5J,EAAAyB,GAAAmI,IACA8Y,GAAAhe,EAAAkF,EANA,CASA,SAAA4pE,GAAAv2B,EAAAj9C,GAEA,IADA,IAAAw4B,EAAA,GACAr8B,EAAA,EAAAA,EAAA8gD,EAAAtgC,IAAAd,OAAAzf,OAAAD,IAAA,CACA,IAAA4f,EAAAkhC,EAAAtgC,IAAAd,OAAA1f,GACAq8B,EAAArrB,KAAA,IAAA4lE,GAAAQ,GAAAx3D,EAAAG,OAAAlc,GACAuzE,GAAAx3D,EAAAI,KAAAnc,IAHA,CAKA,OAAAgzE,GAAA/1B,EAAAn+C,GAAA05B,EAAAykB,EAAAtgC,IAAAykD,UAPA,CAUA,SAAAqS,GAAA1gE,EAAA8J,EAAAwwC,GACA,OAAAt6C,EAAArO,MAAAmY,EAAAnY,KACAge,GAAA2qC,EAAA3oD,KAAAqO,EAAAnJ,GAAAiT,EAAAjT,GAAAyjD,EAAAzjD,IAEA8Y,GAAA2qC,EAAA3oD,MAAAqO,EAAArO,KAAAmY,EAAAnY,MAAAqO,EAAAnJ,GAJA,CA8BA,SAAA8pE,GAAA50E,GACAA,EAAAm+C,IAAA/9C,KAAAgD,GAAApD,EAAA2f,QAAA3f,EAAAm+C,IAAA02B,YACAC,GAAA90E,EAFA,CAKA,SAAA80E,GAAA90E,GACAA,EAAAm+C,IAAAxF,MAAA,SAAA/yC,GACAA,EAAAimD,aAAAjmD,EAAAimD,WAAA,MACAjmD,EAAAwlD,SAAAxlD,EAAAwlD,OAAA,KAFA,IAIAprD,EAAAm+C,IAAA8N,aAAAjsD,EAAAm+C,IAAA6N,kBAAAhsD,EAAAm+C,IAAAld,MACA4mC,GAAA7nE,EAAA,KACAA,EAAA+D,MAAA8mD,UACA7qD,EAAAqlD,OAAA0b,GAAA/gE,EARA,CAgBA,SAAA+0E,GAAA52B,EAAAj9C,GACA,OAAA,GAAAA,EAAAwB,KAAAoI,IAAA,GAAA5J,EAAAyB,GAAAmI,IAAA,IAAAo2C,GAAAhgD,EAAAa,SACAo8C,EAAAn+C,IAAAm+C,EAAAn+C,GAAA2f,QAAAq1D,sBAFA,CAMA,SAAAC,GAAA92B,EAAAj9C,EAAAktD,EAAA0D,GACA,SAAAojB,EAAAj2E,GAAA,OAAAmvD,EAAAA,EAAAnvD,GAAA,IAAA,CACA,SAAAm7B,EAAAx0B,EAAA7D,EAAAyf,IAhgGA,SAAA5b,EAAA7D,EAAAqsD,EAAA0D,GACAlsD,EAAA7D,KAAAA,EACA6D,EAAAimD,aAAAjmD,EAAAimD,WAAA,MACAjmD,EAAAwlD,SAAAxlD,EAAAwlD,OAAA,MACA,MAAAxlD,EAAA08C,QAAA18C,EAAA08C,MAAA,MACAiN,GAAA3pD,GACA6pD,GAAA7pD,EAAAwoD,GACA,IAAAmS,EAAAzO,EAAAA,EAAAlsD,GAAA,EACA26D,GAAA36D,EAAAu3B,QAAAyrB,GAAAhjD,EAAA26D,EARA,CAigGA4U,CAAAvvE,EAAA7D,EAAAyf,EAAAswC,GACAwD,GAAA1vD,EAAA,SAAAA,EAAA1E,EAFA,CAIA,SAAAk0E,EAAAjiE,EAAAuG,GAEA,IADA,IAAAlD,EAAA,GACAnZ,EAAA8V,EAAA9V,EAAAqc,IAAArc,EACAmZ,EAAAnI,KAAA,IAAAwjD,GAAA9vD,EAAA1E,GAAA63E,EAAA73E,GAAAy0D,IACA,OAAAt7C,CAJA,CAOA,IAAA9T,EAAAxB,EAAAwB,KAAAC,EAAAzB,EAAAyB,GAAAZ,EAAAb,EAAAa,KACAiwC,EAAAhZ,GAAAmlB,EAAAz7C,EAAAkD,MAAAqsC,EAAAjZ,GAAAmlB,EAAAx7C,EAAAiD,MACAyvE,EAAAn0B,GAAAn/C,GAAAuzE,EAAAJ,EAAAnzE,EAAAzE,OAAA,GAAAi4E,EAAA5yE,EAAAiD,KAAAlD,EAAAkD,KAGA,GAAA1E,EAAAgtD,KACA/P,EAAAq3B,OAAA,EAAAJ,EAAA,EAAArzE,EAAAzE,SACA6gD,EAAAs3B,OAAA1zE,EAAAzE,OAAA6gD,EAAAvV,KAAA7mC,EAAAzE,aACA,GAAAy3E,GAAA52B,EAAAj9C,GAAA,CAGA,IAAAw0E,EAAAN,EAAA,EAAArzE,EAAAzE,OAAA,GACA88B,EAAA6X,EAAAA,EAAAlwC,KAAAuzE,GACAC,GAAAp3B,EAAAs3B,OAAA/yE,EAAAkD,KAAA2vE,GACAG,EAAAp4E,QAAA6gD,EAAAq3B,OAAA9yE,EAAAkD,KAAA8vE,EANA,MAOA,GAAA1jC,GAAAC,EACA,GAAA,GAAAlwC,EAAAzE,OACA88B,EAAA4X,EAAAA,EAAAjwC,KAAAmR,MAAA,EAAAxQ,EAAAoI,IAAAuqE,EAAArjC,EAAAjwC,KAAAmR,MAAAvQ,EAAAmI,IAAAwqE,OACA,CACA,IAAAK,EAAAP,EAAA,EAAArzE,EAAAzE,OAAA,GACAq4E,EAAAtnE,KAAA,IAAAwjD,GAAAwjB,EAAArjC,EAAAjwC,KAAAmR,MAAAvQ,EAAAmI,IAAAwqE,EAAAxjB,IACA13B,EAAA4X,EAAAA,EAAAjwC,KAAAmR,MAAA,EAAAxQ,EAAAoI,IAAA/I,EAAA,GAAAmzE,EAAA,IACA/2B,EAAAq3B,OAAA9yE,EAAAkD,KAAA,EAAA+vE,EAJA,MAMA,GAAA,GAAA5zE,EAAAzE,OACA88B,EAAA4X,EAAAA,EAAAjwC,KAAAmR,MAAA,EAAAxQ,EAAAoI,IAAA/I,EAAA,GAAAkwC,EAAAlwC,KAAAmR,MAAAvQ,EAAAmI,IAAAoqE,EAAA,IACA/2B,EAAAs3B,OAAA/yE,EAAAkD,KAAA,EAAA2vE,OACA,CACAn7C,EAAA4X,EAAAA,EAAAjwC,KAAAmR,MAAA,EAAAxQ,EAAAoI,IAAA/I,EAAA,GAAAmzE,EAAA,IACA96C,EAAA6X,EAAAojC,EAAApjC,EAAAlwC,KAAAmR,MAAAvQ,EAAAmI,IAAAwqE,GACA,IAAAM,EAAAR,EAAA,EAAArzE,EAAAzE,OAAA,GACAi4E,EAAA,GAAAp3B,EAAAs3B,OAAA/yE,EAAAkD,KAAA,EAAA2vE,EAAA,GACAp3B,EAAAq3B,OAAA9yE,EAAAkD,KAAA,EAAAgwE,EALA,CAQAtgB,GAAAnX,EAAA,SAAAA,EAAAj9C,EAhDA,CAoDA,SAAA20E,GAAA13B,EAAA9+C,EAAAy2E,IACA,SAAAC,EAAA53B,EAAA63B,EAAAC,GACA,GAAA93B,EAAA+3B,OAAA,IAAA,IAAA74E,EAAA,EAAAA,EAAA8gD,EAAA+3B,OAAA54E,SAAAD,EAAA,CACA,IAAA2vC,EAAAmR,EAAA+3B,OAAA74E,GACA,GAAA2vC,EAAAmR,KAAA63B,EAAA,CACA,IAAAG,EAAAF,GAAAjpC,EAAAipC,WACAH,IAAAK,IACA92E,EAAA2tC,EAAAmR,IAAAg4B,GACAJ,EAAA/oC,EAAAmR,IAAAA,EAAAg4B,GAJA,CAFA,CADA,CAUAJ,CAAA53B,EAAA,MAAA,EAXA,CAeA,SAAAi4B,GAAAp2E,EAAAm+C,GACA,GAAAA,EAAAn+C,GAAA,MAAA,IAAAV,MAAA,oCACAU,EAAAm+C,IAAAA,EACAA,EAAAn+C,GAAAA,EACAqgE,GAAArgE,GACA40E,GAAA50E,GACAq2E,GAAAr2E,GACAA,EAAA2f,QAAAqjC,UAAA7E,EAAA6E,UACAhjD,EAAA2f,QAAArf,cAAAkxD,GAAAxxD,GACAA,EAAA2f,QAAAvf,KAAA+9C,EAAA02B,WACA9T,GAAA/gE,EAVA,CAaA,SAAAq2E,GAAAr2E,IACA,OAAAA,EAAAm+C,IAAA6E,UAAA3E,EAAAd,GAAAv9C,EAAAu9B,QAAAqoC,QAAA,iBADA,CAWA,SAAA0Q,GAAArqE,GAIAD,KAAAuqE,KAAA,GAAAvqE,KAAAwqE,OAAA,GACAxqE,KAAAyqE,UAAAxqE,EAAAA,EAAAwqE,UAAA9kE,IAGA3F,KAAA0qE,YAAA1qE,KAAA2qE,YAAA,EACA3qE,KAAA4qE,OAAA5qE,KAAA6qE,UAAA,KACA7qE,KAAA8qE,WAAA9qE,KAAA+qE,cAAA,KAEA/qE,KAAAgrE,WAAAhrE,KAAAirE,cAAAhrE,EAAAA,EAAAgrE,cAAA,CAZA,CAiBA,SAAAC,GAAA/4B,EAAAj9C,GACA,IAAAi2E,EAAA,CAAAz0E,KAAA6mD,GAAAroD,EAAAwB,MAAAC,GAAA6xE,GAAAtzE,GAAAa,KAAA2mD,GAAAvK,EAAAj9C,EAAAwB,KAAAxB,EAAAyB,KAGA,OAFAy0E,GAAAj5B,EAAAg5B,EAAAj2E,EAAAwB,KAAAkD,KAAA1E,EAAAyB,GAAAiD,KAAA,GACAiwE,GAAA13B,GAAA,SAAAA,GAAA,OAAAi5B,GAAAj5B,EAAAg5B,EAAAj2E,EAAAwB,KAAAkD,KAAA1E,EAAAyB,GAAAiD,KAAA,EAAA,IAAA,GACAuxE,CAJA,CASA,SAAAE,GAAAznC,GACA,KAAAA,EAAAtyC,QACA4jD,GAAAtR,GACA7yB,QAAA6yB,EAAA16B,KAHA,CAyBA,SAAAoiE,GAAAn5B,EAAAj9C,EAAAq2E,EAAAC,GACA,IAAAC,EAAAt5B,EAAAu5B,QACAD,EAAAjB,OAAAl5E,OAAA,EACA,IAAA2H,EACA2kD,EADApe,GAAA,IAAA4U,KAGA,IAAAq3B,EAAAb,QAAAY,GACAC,EAAAX,YAAA51E,EAAAy/C,QAAAz/C,EAAAy/C,SACA,KAAAz/C,EAAAy/C,OAAAzsC,OAAA,IAAAujE,EAAAf,YAAAlrC,GAAA2S,EAAAn+C,GAAAm+C,EAAAn+C,GAAA2f,QAAAg4D,kBAAA,MACA,KAAAz2E,EAAAy/C,OAAAzsC,OAAA,OACAjP,EAzBA,SAAAwyE,EAAAvI,GACA,OAAAA,GACAmI,GAAAI,EAAAlB,MACAr1B,GAAAu2B,EAAAlB,OACAkB,EAAAlB,KAAAj5E,SAAA4jD,GAAAu2B,EAAAlB,MAAAx5D,OACAmkC,GAAAu2B,EAAAlB,MACAkB,EAAAlB,KAAAj5E,OAAA,IAAAm6E,EAAAlB,KAAAkB,EAAAlB,KAAAj5E,OAAA,GAAAyf,QACA06D,EAAAlB,KAAArhE,MACAgsC,GAAAu2B,EAAAlB,YAFA,CANA,CAyBAqB,CAAAH,EAAAA,EAAAb,QAAAY,IAEA5tB,EAAA1I,GAAAj8C,EAAA2wD,SACA,GAAAtd,GAAAp3C,EAAAwB,KAAAxB,EAAAyB,KAAA,GAAA21C,GAAAp3C,EAAAwB,KAAAknD,EAAAjnD,IAGAinD,EAAAjnD,GAAA6xE,GAAAtzE,GAGA+D,EAAA2wD,QAAAvnD,KAAA6oE,GAAA/4B,EAAAj9C,QAEA,CAEA,IAAAysC,EAAAuT,GAAAu2B,EAAAlB,MAMA,IALA5oC,GAAAA,EAAA5wB,QACA86D,GAAA15B,EAAAtgC,IAAA45D,EAAAlB,MACAtxE,EAAA,CAAA2wD,QAAA,CAAAshB,GAAA/4B,EAAAj9C,IACA81E,WAAAS,EAAAT,YACAS,EAAAlB,KAAAloE,KAAApJ,GACAwyE,EAAAlB,KAAAj5E,OAAAm6E,EAAAhB,WACAgB,EAAAlB,KAAAniD,QACAqjD,EAAAlB,KAAA,GAAAx5D,QAAA06D,EAAAlB,KAAAniD,OAVA,CAaAqjD,EAAAlB,KAAAloE,KAAAkpE,GACAE,EAAAT,aAAAS,EAAAR,cACAQ,EAAAf,YAAAe,EAAAd,YAAAnrC,EACAisC,EAAAb,OAAAa,EAAAZ,UAAAW,EACAC,EAAAX,WAAAW,EAAAV,cAAA71E,EAAAy/C,OAEAiJ,GAAAzvB,GAAAgkB,EAAA,eAxCA,CAwDA,SAAA25B,GAAA35B,EAAAtgC,EAAA25D,EAAA73D,GACA,IAAA83D,EAAAt5B,EAAAu5B,QAAA/2B,EAAAhhC,GAAAA,EAAAghC,OAMA62B,GAAAC,EAAAZ,WACAl2B,GAAA82B,EAAAV,eAAAp2B,IACA82B,EAAAf,aAAAe,EAAAd,aAAAc,EAAAX,YAAAn2B,GAtBA,SAAAxC,EAAAwC,EAAA10C,EAAA4R,GACA,IAAA/S,EAAA61C,EAAAzsC,OAAA,GACA,MAAA,KAAApJ,GACA,KAAAA,GACAmB,EAAA8Q,OAAAzf,QAAAugB,EAAAd,OAAAzf,QACA2O,EAAA8tB,qBAAAlc,EAAAkc,qBACA,IAAAqmB,KAAAjC,EAAAu5B,QAAAf,cAAAx4B,EAAAn+C,GAAAm+C,EAAAn+C,GAAA2f,QAAAg4D,kBAAA,IANA,CAuBAI,CAAA55B,EAAAwC,EAAAO,GAAAu2B,EAAAlB,MAAA14D,IACA45D,EAAAlB,KAAAkB,EAAAlB,KAAAj5E,OAAA,GAAAugB,EAEAg6D,GAAAh6D,EAAA45D,EAAAlB,MAEAkB,EAAAd,aAAA,IAAAv2B,KACAq3B,EAAAV,cAAAp2B,EACA82B,EAAAZ,UAAAW,EACA73D,IAAA,IAAAA,EAAAq4D,WACAX,GAAAI,EAAAjB,OAnBA,CAsBA,SAAAqB,GAAAh6D,EAAAhb,GACA,IAAA8Y,EAAAulC,GAAAr+C,GACA8Y,GAAAA,EAAAoB,QAAApB,EAAAm4D,OAAAj2D,IACAhb,EAAAwL,KAAAwP,EAHA,CAOA,SAAAu5D,GAAAj5B,EAAAj9C,EAAAwB,EAAAC,GACA,IAAAs1E,EAAA/2E,EAAA,SAAAi9C,EAAAt6B,IAAA5kB,EAAA,EACAk/C,EAAAxF,KAAA35B,KAAAC,IAAAk/B,EAAAld,MAAAv+B,GAAAsc,KAAAK,IAAA8+B,EAAAld,MAAAkd,EAAAvV,KAAAjmC,IAAA,SAAAiD,GACAA,EAAAwoD,eACA6pB,IAAAA,EAAA/2E,EAAA,SAAAi9C,EAAAt6B,IAAA,CAAA,IAAA5kB,GAAA2G,EAAAwoD,eACAnvD,CAHA,GAFA,CAWA,SAAAi5E,GAAA12D,GACA,IAAAA,EAAA,OAAA,KAEA,IADA,IAAAkY,EACAr8B,EAAA,EAAAA,EAAAmkB,EAAAlkB,SAAAD,EACAmkB,EAAAnkB,GAAA+lB,OAAA+0D,kBAAAz+C,IAAAA,EAAAlY,EAAAtO,MAAA,EAAA7V,IACAq8B,GAAAA,EAAArrB,KAAAmT,EAAAnkB,IAEA,OAAAq8B,EAAAA,EAAAp8B,OAAAo8B,EAAA,KAAAlY,CAPA,CAwBA,SAAA42D,GAAAj6B,EAAAj9C,GACA,IAAA6c,EAdA,SAAAogC,EAAAj9C,GACA,IAAA8jB,EAAA9jB,EAAA,SAAAi9C,EAAAt6B,IACA,IAAAmB,EAAA,OAAA,KAEA,IADA,IAAAupC,EAAA,GACAlxD,EAAA,EAAAA,EAAA6D,EAAAa,KAAAzE,SAAAD,EACAkxD,EAAAlgD,KAAA6pE,GAAAlzD,EAAA3nB,KACA,OAAAkxD,CANA,CAcA8pB,CAAAl6B,EAAAj9C,GACAo3E,EAAArqB,GAAA9P,EAAAj9C,GACA,IAAA6c,EAAA,OAAAu6D,EACA,IAAAA,EAAA,OAAAv6D,EAEA,IAAA,IAAA1gB,EAAA,EAAAA,EAAA0gB,EAAAzgB,SAAAD,EAAA,CACA,IAAAk7E,EAAAx6D,EAAA1gB,GAAAm7E,EAAAF,EAAAj7E,GACA,GAAAk7E,GAAAC,EACAh3D,EAAA,IAAA,IAAAyO,EAAA,EAAAA,EAAAuoD,EAAAl7E,SAAA2yB,EAAA,CAEA,IADA,IAAAuW,EAAAgyC,EAAAvoD,GACAqnC,EAAA,EAAAA,EAAAihB,EAAAj7E,SAAAg6D,EACA,GAAAihB,EAAAjhB,GAAAl0C,QAAAojB,EAAApjB,OAAA,SAAA5B,EACA+2D,EAAAlqE,KAAAm4B,EAJA,MAMAgyC,IACAz6D,EAAA1gB,GAAAm7E,EAVA,CAaA,OAAAz6D,CAnBA,CAwBA,SAAA06D,GAAAlJ,EAAAmJ,EAAAC,GAEA,IADA,IAAA3rB,EAAA,GACA3vD,EAAA,EAAAA,EAAAkyE,EAAAjyE,SAAAD,EAAA,CACA,IAAA0sB,EAAAwlD,EAAAlyE,GACA,GAAA0sB,EAAAhN,OACAiwC,EAAA3+C,KAAAsqE,EAAA9E,GAAA31E,UAAA81E,SAAAr1E,KAAAorB,GAAAA,OADA,CAIA,IAAA6rC,EAAA7rC,EAAA6rC,QAAAgjB,EAAA,GACA5rB,EAAA3+C,KAAA,CAAAunD,QAAAgjB,IACA,IAAA,IAAA3oD,EAAA,EAAAA,EAAA2lC,EAAAt4D,SAAA2yB,EAAA,CACA,IAAA/uB,EAAA00D,EAAA3lC,GAAAnc,OAAA,EAEA,GADA8kE,EAAAvqE,KAAA,CAAA3L,KAAAxB,EAAAwB,KAAAC,GAAAzB,EAAAyB,GAAAZ,KAAAb,EAAAa,OACA22E,EAAA,IAAA,IAAAjuE,KAAAvJ,GAAA4S,EAAArJ,EAAAxI,MAAA,mBACA4R,EAAA6kE,EAAA95E,OAAAkV,EAAA,MAAA,IACAotC,GAAA03B,GAAAnuE,GAAAvJ,EAAAuJ,UACAvJ,EAAAuJ,GANA,CANA,CAFA,CAmBA,OAAAuiD,CArBA,CAgCA,SAAA6rB,GAAA57D,EAAAI,EAAAw1B,EAAAq9B,GACA,GAAAA,EAAA,CACA,IAAA9yD,EAAAH,EAAAG,OACA,GAAAy1B,EAAA,CACA,IAAAimC,EAAAxgC,GAAAj7B,EAAAD,GAAA,EACA07D,GAAAxgC,GAAAzF,EAAAz1B,GAAA,GACAA,EAAAC,EACAA,EAAAw1B,GACAimC,GAAAxgC,GAAAj7B,EAAAw1B,GAAA,IACAx1B,EAAAw1B,EANA,CASA,OAAA,IAAAohC,GAAA72D,EAAAC,EAXA,CAaA,OAAA,IAAA42D,GAAAphC,GAAAx1B,EAAAA,EAdA,CAmBA,SAAA41B,GAAAkL,EAAA9gC,EAAAw1B,EAAAlzB,EAAAuwD,GACA,MAAAA,IAAAA,EAAA/xB,EAAAn+C,KAAAm+C,EAAAn+C,GAAAu9B,QAAAnJ,OAAA+pB,EAAA+xB,SACA6I,GAAA56B,EAAA,IAAA01B,GAAA,CAAAgF,GAAA16B,EAAAtgC,IAAA49B,UAAAp+B,EAAAw1B,EAAAq9B,IAAA,GAAAvwD,EAFA,CAOA,SAAAq5D,GAAA76B,EAAA86B,EAAAt5D,GAGA,IAFA,IAAA+Z,EAAA,GACAw2C,EAAA/xB,EAAAn+C,KAAAm+C,EAAAn+C,GAAAu9B,QAAAnJ,OAAA+pB,EAAA+xB,QACA7yE,EAAA,EAAAA,EAAA8gD,EAAAtgC,IAAAd,OAAAzf,OAAAD,IACAq8B,EAAAr8B,GAAAw7E,GAAA16B,EAAAtgC,IAAAd,OAAA1f,GAAA47E,EAAA57E,GAAA,KAAA6yE,GAEA6I,GAAA56B,EADA+1B,GAAA/1B,EAAAn+C,GAAA05B,EAAAykB,EAAAtgC,IAAAykD,WACA3iD,EANA,CAUA,SAAAu5D,GAAA/6B,EAAA9gD,EAAA4f,EAAA0C,GACA,IAAA5C,EAAAohC,EAAAtgC,IAAAd,OAAA7J,MAAA,GACA6J,EAAA1f,GAAA4f,EACA87D,GAAA56B,EAAA+1B,GAAA/1B,EAAAn+C,GAAA+c,EAAAohC,EAAAtgC,IAAAykD,WAAA3iD,EAHA,CAOA,SAAAw5D,GAAAh7B,EAAA/gC,EAAAC,EAAAsC,GACAo5D,GAAA56B,EAAAo2B,GAAAn3D,EAAAC,GAAAsC,EADA,CAuBA,SAAAy5D,GAAAj7B,EAAAtgC,EAAA8B,GACA,IAAA42D,EAAAp4B,EAAAu5B,QAAAnB,KAAA3sB,EAAA1I,GAAAq1B,GACA3sB,GAAAA,EAAA7sC,QACAw5D,EAAAA,EAAAj5E,OAAA,GAAAugB,EACAw7D,GAAAl7B,EAAAtgC,EAAA8B,IAEAo5D,GAAA56B,EAAAtgC,EAAA8B,EANA,CAWA,SAAAo5D,GAAA56B,EAAAtgC,EAAA8B,GACA05D,GAAAl7B,EAAAtgC,EAAA8B,GACAm4D,GAAA35B,EAAAA,EAAAtgC,IAAAsgC,EAAAn+C,GAAAm+C,EAAAn+C,GAAAqlD,MAAAxhC,GAAAnS,IAAAiO,EAFA,CAKA,SAAA05D,GAAAl7B,EAAAtgC,EAAA8B,IACA4lC,GAAApH,EAAA,0BAAAA,EAAAn+C,IAAAulD,GAAApH,EAAAn+C,GAAA,4BACA6d,EAnCA,SAAAsgC,EAAAtgC,EAAA8B,GACA,IAAAkI,EAAA,CACA9K,OAAAc,EAAAd,OACAqd,OAAA,SAAArd,GACA/Q,KAAA+Q,OAAA,GACA,IAAA,IAAA1f,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IACA2O,KAAA+Q,OAAA1f,GAAA,IAAA42E,GAAAtqB,GAAAxL,EAAAphC,EAAA1f,GAAA+f,QACAusC,GAAAxL,EAAAphC,EAAA1f,GAAAggB,MAJA,EAMAsjC,OAAAhhC,GAAAA,EAAAghC,QAIA,OAFAxmB,GAAAgkB,EAAA,wBAAAA,EAAAt2B,GACAs2B,EAAAn+C,IAAAm6B,GAAAgkB,EAAAn+C,GAAA,wBAAAm+C,EAAAn+C,GAAA6nB,GACAA,EAAA9K,QAAAc,EAAAd,OAAAm3D,GAAA/1B,EAAAn+C,GAAA6nB,EAAA9K,OAAA8K,EAAA9K,OAAAzf,OAAA,GACAugB,CAdA,CAmCAy7D,CAAAn7B,EAAAtgC,EAAA8B,IAEA,IAAAm6C,EAAAn6C,GAAAA,EAAAm6C,OACAxhB,GAAAz6B,EAAA49B,UAAAp+B,KAAA8gC,EAAAtgC,IAAA49B,UAAAp+B,MAAA,GAAA,EAAA,GACAk8D,GAAAp7B,EAAAq7B,GAAAr7B,EAAAtgC,EAAAi8C,GAAA,IAEAn6C,IAAA,IAAAA,EAAA8gC,SAAAtC,EAAAn+C,IAAA,YAAAm+C,EAAAn+C,GAAAkd,UAAA,aACAkqD,GAAAjpB,EAAAn+C,GATA,CAYA,SAAAu5E,GAAAp7B,EAAAtgC,GACAA,EAAAi2D,OAAA31B,EAAAtgC,OAEAsgC,EAAAtgC,IAAAA,EAEAsgC,EAAAn+C,KACAm+C,EAAAn+C,GAAAqlD,MAAA4lB,YAAA,EACA9sB,EAAAn+C,GAAAqlD,MAAAgmB,kBAAA,EACAjmB,GAAAjH,EAAAn+C,KAEAs1D,GAAAnX,EAAA,iBAAAA,GAVA,CAeA,SAAAs7B,GAAAt7B,GACAo7B,GAAAp7B,EAAAq7B,GAAAr7B,EAAAA,EAAAtgC,IAAA,MAAA,GADA,CAMA,SAAA27D,GAAAr7B,EAAAtgC,EAAAi8C,EAAA4f,GAEA,IADA,IAAAhgD,EACAr8B,EAAA,EAAAA,EAAAwgB,EAAAd,OAAAzf,OAAAD,IAAA,CACA,IAAA4f,EAAAY,EAAAd,OAAA1f,GACA0gB,EAAAF,EAAAd,OAAAzf,QAAA6gD,EAAAtgC,IAAAd,OAAAzf,QAAA6gD,EAAAtgC,IAAAd,OAAA1f,GACAs8E,EAAAC,GAAAz7B,EAAAlhC,EAAAG,OAAAW,GAAAA,EAAAX,OAAA08C,EAAA4f,GACAG,EAAA58D,EAAAI,MAAAJ,EAAAG,OAAAu8D,EAAAC,GAAAz7B,EAAAlhC,EAAAI,KAAAU,GAAAA,EAAAV,KAAAy8C,EAAA4f,IACAhgD,GAAAigD,GAAA18D,EAAAG,QAAAy8D,GAAA58D,EAAAI,QACAqc,IAAAA,EAAA7b,EAAAd,OAAA7J,MAAA,EAAA7V,IACAq8B,EAAAr8B,GAAA,IAAA42E,GAAA0F,EAAAE,GAPA,CAUA,OAAAngD,EAAAw6C,GAAA/1B,EAAAn+C,GAAA05B,EAAA7b,EAAAykD,WAAAzkD,CAZA,CAeA,SAAAi8D,GAAA37B,EAAAlqC,EAAA8lE,EAAAvxE,EAAAkxE,GACA,IAAA9zE,EAAAozB,GAAAmlB,EAAAlqC,EAAArO,MACA,GAAAA,EAAAwoD,YAAA,IAAA,IAAA/wD,EAAA,EAAAA,EAAAuI,EAAAwoD,YAAA9wD,SAAAD,EAAA,CACA,IAAAgzD,EAAAzqD,EAAAwoD,YAAA/wD,GAAAyW,EAAAu8C,EAAAjtC,OAKA42D,EAAA,eAAAlmE,GAAAA,EAAAmmE,WAAAnmE,EAAA06C,cACA0rB,EAAA,gBAAApmE,GAAAA,EAAAqmE,YAAArmE,EAAA66C,eAEA,IAAA,MAAA0B,EAAA3tD,OAAAs3E,EAAA3pB,EAAA3tD,MAAAuR,EAAAnJ,GAAAulD,EAAA3tD,KAAAuR,EAAAnJ,OACA,MAAAulD,EAAA1tD,KAAAu3E,EAAA7pB,EAAA1tD,IAAAsR,EAAAnJ,GAAAulD,EAAA1tD,GAAAsR,EAAAnJ,KAAA,CACA,GAAA4uE,IACAv/C,GAAArmB,EAAA,qBACAA,EAAAqkE,mBAAA,CACA,GAAAvyE,EAAAwoD,YACA,GAAA/wD,EAAA,QAAA,CADA,KADA,CAKA,IAAAyW,EAAAsmE,OAAA,SAEA,GAAAL,EAAA,CACA,IAAAM,EAAAvmE,EAAAxS,KAAAkH,EAAA,EAAA,GAAA,GAAAqgD,OAAA,EAGA,IAFArgD,EAAA,EAAA0xE,EAAAF,KACAK,EAAAC,GAAAn8B,EAAAk8B,GAAA7xE,EAAA6xE,GAAAA,EAAAz0E,MAAAqO,EAAArO,KAAAA,EAAA,OACAy0E,GAAAA,EAAAz0E,MAAAqO,EAAArO,OAAAijD,EAAAvQ,GAAA+hC,EAAAN,MAAAvxE,EAAA,EAAAqgD,EAAA,EAAAA,EAAA,GACA,OAAAixB,GAAA37B,EAAAk8B,EAAApmE,EAAAzL,EAAAkxE,EALA,CAQA,IAAAa,EAAAzmE,EAAAxS,KAAAkH,EAAA,GAAA,EAAA,GAGA,OAFAA,EAAA,EAAAwxE,EAAAE,KACAK,EAAAD,GAAAn8B,EAAAo8B,EAAA/xE,EAAA+xE,EAAA30E,MAAAqO,EAAArO,KAAAA,EAAA,OACA20E,EAAAT,GAAA37B,EAAAo8B,EAAAtmE,EAAAzL,EAAAkxE,GAAA,IArBA,CAVA,CAkCA,OAAAzlE,CApCA,CAwCA,SAAA2lE,GAAAz7B,EAAAlqC,EAAA8lE,EAAAjgB,EAAA4f,GACA,IAAAlxE,EAAAsxD,GAAA,EACA90C,EAAA80D,GAAA37B,EAAAlqC,EAAA8lE,EAAAvxE,EAAAkxE,KACAA,GAAAI,GAAA37B,EAAAlqC,EAAA8lE,EAAAvxE,GAAA,IACAsxE,GAAA37B,EAAAlqC,EAAA8lE,GAAAvxE,EAAAkxE,KACAA,GAAAI,GAAA37B,EAAAlqC,EAAA8lE,GAAAvxE,GAAA,GACA,OAAAwc,IACAm5B,EAAAq8B,UAAA,EACA52D,GAAAu6B,EAAAld,MAAA,GARA,CAaA,SAAAq5C,GAAAn8B,EAAAlqC,EAAAzL,EAAA5C,GACA,OAAA4C,EAAA,GAAA,GAAAyL,EAAAnJ,GACAmJ,EAAArO,KAAAu4C,EAAAld,MAAA0oB,GAAAxL,EAAAv6B,GAAA3P,EAAArO,KAAA,IACA,KACA4C,EAAA,GAAAyL,EAAAnJ,KAAAlF,GAAAozB,GAAAmlB,EAAAlqC,EAAArO,OAAA7D,KAAAzE,OACA2W,EAAArO,KAAAu4C,EAAAld,MAAAkd,EAAAvV,KAAA,EAAAhlB,GAAA3P,EAAArO,KAAA,EAAA,GACA,KAEA,IAAAge,GAAA3P,EAAArO,KAAAqO,EAAAnJ,GAAAtC,EARA,CAYA,SAAAiyE,GAAAz6E,GACAA,EAAA+4E,aAAAn1D,GAAA5jB,EAAAgyC,YAAA,GAAApuB,GAAA5jB,EAAAiyC,YAAAuO,EADA,CAOA,SAAAk6B,GAAAv8B,EAAAj9C,EAAAk5B,GACA,IAAAvS,EAAA,CACA8yD,UAAA,EACAj4E,KAAAxB,EAAAwB,KACAC,GAAAzB,EAAAyB,GACAZ,KAAAb,EAAAa,KACA4+C,OAAAz/C,EAAAy/C,OACAi6B,OAAA,WAAA,OAAA/yD,EAAA8yD,UAAA,CAAA,GAWA,OATAvgD,IAAAvS,EAAAuS,OAAA,SAAA13B,EAAAC,EAAAZ,EAAA4+C,GACAj+C,IAAAmlB,EAAAnlB,KAAAinD,GAAAxL,EAAAz7C,IACAC,IAAAklB,EAAAllB,GAAAgnD,GAAAxL,EAAAx7C,IACAZ,IAAA8lB,EAAA9lB,KAAAA,QACA0P,IAAAkvC,IAAA94B,EAAA84B,OAAAA,EAJA,GAMAxmB,GAAAgkB,EAAA,eAAAA,EAAAt2B,GACAs2B,EAAAn+C,IAAAm6B,GAAAgkB,EAAAn+C,GAAA,eAAAm+C,EAAAn+C,GAAA6nB,GAEAA,EAAA8yD,UACAx8B,EAAAn+C,KAAAm+C,EAAAn+C,GAAAqlD,MAAA4lB,YAAA,GACA,MAEA,CAAAvoE,KAAAmlB,EAAAnlB,KAAAC,GAAAklB,EAAAllB,GAAAZ,KAAA8lB,EAAA9lB,KAAA4+C,OAAA94B,EAAA84B,OAtBA,CA2BA,SAAAk6B,GAAA18B,EAAAj9C,EAAA45E,GACA,GAAA38B,EAAAn+C,GAAA,CACA,IAAAm+C,EAAAn+C,GAAAqlD,MAAA,OAAA3nC,GAAAygC,EAAAn+C,GAAA66E,GAAAn9D,CAAAygC,EAAAj9C,EAAA45E,GACA,GAAA38B,EAAAn+C,GAAA+D,MAAAg3E,cAAA,MAFA,CAKA,KAAAx1B,GAAApH,EAAA,iBAAAA,EAAAn+C,IAAAulD,GAAApH,EAAAn+C,GAAA,mBACAkB,EAAAw5E,GAAAv8B,EAAAj9C,GAAA,IADA,CAOA,IAAA6mB,EAAA6lC,KAAAktB,GA9yHA,SAAA38B,EAAAz7C,EAAAC,GACA,IAAAo0D,EAAA,KAQA,GAPA5Y,EAAAxF,KAAAj2C,EAAAkD,KAAAjD,EAAAiD,KAAA,GAAA,SAAAA,GACA,GAAAA,EAAAwoD,YAAA,IAAA,IAAA/wD,EAAA,EAAAA,EAAAuI,EAAAwoD,YAAA9wD,SAAAD,EAAA,CACA,IAAAksC,EAAA3jC,EAAAwoD,YAAA/wD,GAAA+lB,QACAmmB,EAAA1oC,UAAAk2D,IAAA,GAAAljD,EAAAkjD,EAAAxtB,KACAwtB,IAAAA,EAAA,KAAA1oD,KAAAk7B,EAHA,CADA,KAOAwtB,EAAA,OAAA,KAEA,IADA,IAAAikB,EAAA,CAAA,CAAAt4E,KAAAA,EAAAC,GAAAA,IACAtF,EAAA,EAAAA,EAAA05D,EAAAz5D,SAAAD,EAEA,IADA,IAAA49E,EAAAlkB,EAAA15D,GAAAyW,EAAAmnE,EAAA35E,KAAA,GACA2uB,EAAA,EAAAA,EAAA+qD,EAAA19E,SAAA2yB,EAAA,CACA,IAAAvoB,EAAAszE,EAAA/qD,GACA,KAAAqoB,GAAA5wC,EAAA/E,GAAAmR,EAAApR,MAAA,GAAA41C,GAAA5wC,EAAAhF,KAAAoR,EAAAnR,IAAA,GAAA,CACA,IAAAu4E,EAAA,CAAAjrD,EAAA,GAAAkrD,EAAA7iC,GAAA5wC,EAAAhF,KAAAoR,EAAApR,MAAA04E,EAAA9iC,GAAA5wC,EAAA/E,GAAAmR,EAAAnR,KACAw4E,EAAA,IAAAF,EAAAzsB,gBAAA2sB,IACAD,EAAA7sE,KAAA,CAAA3L,KAAAgF,EAAAhF,KAAAC,GAAAmR,EAAApR,QACA04E,EAAA,IAAAH,EAAAtsB,iBAAAysB,IACAF,EAAA7sE,KAAA,CAAA3L,KAAAoR,EAAAnR,GAAAA,GAAA+E,EAAA/E,KACAq4E,EAAAlxD,OAAAtU,MAAAwlE,EAAAE,GACAjrD,GAAAirD,EAAA59E,OAAA,CAPA,CAFA,CAYA,OAAA09E,CAzBA,CA8yHAK,CAAAl9B,EAAAj9C,EAAAwB,KAAAxB,EAAAyB,IACA,GAAAolB,EACA,IAAA,IAAA1qB,EAAA0qB,EAAAzqB,OAAA,EAAAD,GAAA,IAAAA,EACAi+E,GAAAn9B,EAAA,CAAAz7C,KAAAqlB,EAAA1qB,GAAAqF,KAAAC,GAAAolB,EAAA1qB,GAAAsF,GAAAZ,KAAA1E,EAAA,CAAA,IAAA6D,EAAAa,KAAA4+C,OAAAz/C,EAAAy/C,cAEA26B,GAAAn9B,EAAAj9C,EAZA,CANA,CAsBA,SAAAo6E,GAAAn9B,EAAAj9C,GACA,GAAA,GAAAA,EAAAa,KAAAzE,QAAA,IAAA4D,EAAAa,KAAA,IAAA,GAAAu2C,GAAAp3C,EAAAwB,KAAAxB,EAAAyB,IAAA,CACA,IAAA40E,EAAA7C,GAAAv2B,EAAAj9C,GACAo2E,GAAAn5B,EAAAj9C,EAAAq2E,EAAAp5B,EAAAn+C,GAAAm+C,EAAAn+C,GAAAqlD,MAAAxhC,GAAAnS,KAEA6pE,GAAAp9B,EAAAj9C,EAAAq2E,EAAAtpB,GAAA9P,EAAAj9C,IACA,IAAAs6E,EAAA,GAEA3F,GAAA13B,GAAA,SAAAA,EAAA83B,GACAA,IAAA,GAAApiE,EAAA2nE,EAAAr9B,EAAAu5B,WACA+D,GAAAt9B,EAAAu5B,QAAAx2E,GACAs6E,EAAAntE,KAAA8vC,EAAAu5B,UAEA6D,GAAAp9B,EAAAj9C,EAAA,KAAA+sD,GAAA9P,EAAAj9C,GALA,GAPA,CADA,CAkBA,SAAAw6E,GAAAv9B,EAAA9zC,EAAAsxE,GACA,IAAAC,EAAAz9B,EAAAn+C,IAAAm+C,EAAAn+C,GAAA+D,MAAAg3E,cACA,IAAAa,GAAAD,EAAA,CAQA,IANA,IAAA5xD,EAAA0tD,EAAAt5B,EAAAu5B,QAAAH,EAAAp5B,EAAAtgC,IACA/a,EAAA,QAAAuH,EAAAotE,EAAAlB,KAAAkB,EAAAjB,OAAA3zE,EAAA,QAAAwH,EAAAotE,EAAAjB,OAAAiB,EAAAlB,KAIAl5E,EAAA,EACAA,EAAAyF,EAAAxF,SACAysB,EAAAjnB,EAAAzF,GACAs+E,GAAA5xD,EAAAhN,QAAAgN,EAAA+pD,OAAA31B,EAAAtgC,KAAAkM,EAAAhN,QAFA1f,KAKA,GAAAA,GAAAyF,EAAAxF,OAAA,CAGA,IAFAm6E,EAAAX,WAAAW,EAAAV,cAAA,OAEA,CAEA,KADAhtD,EAAAjnB,EAAAoS,OACA6H,OAOA,IAAA6+D,EAEA,YADA94E,EAAAuL,KAAA0b,GAEA,KAAA,CARA,GADA8tD,GAAA9tD,EAAAlnB,GACA84E,IAAA5xD,EAAA+pD,OAAA31B,EAAAtgC,KAEA,YADAk7D,GAAA56B,EAAAp0B,EAAA,CAAAiuD,WAAA,IAGAT,EAAAxtD,CARA,CAiBA,IAAA8xD,EAAA,GACAhE,GAAAN,EAAA10E,GACAA,EAAAwL,KAAA,CAAAunD,QAAAimB,EAAA7E,WAAAS,EAAAT,aACAS,EAAAT,WAAAjtD,EAAAitD,cAAAS,EAAAR,cA6BA,IA3BA,IAAA6E,EAAAv2B,GAAApH,EAAA,iBAAAA,EAAAn+C,IAAAulD,GAAApH,EAAAn+C,GAAA,gBAEAslC,EAAA,SAAAjoC,GACA,IAAA6D,EAAA6oB,EAAA6rC,QAAAv4D,GAEA,GADA6D,EAAAy/C,OAAAt2C,EACAyxE,IAAApB,GAAAv8B,EAAAj9C,GAAA,GAEA,OADA4B,EAAAxF,OAAA,EACA,CAAA,EAGAu+E,EAAAxtE,KAAA6oE,GAAA/4B,EAAAj9C,IAEA,IAAAstC,EAAAnxC,EAAAq3E,GAAAv2B,EAAAj9C,GAAAggD,GAAAp+C,GACAy4E,GAAAp9B,EAAAj9C,EAAAstC,EAAA4pC,GAAAj6B,EAAAj9C,KACA7D,GAAA8gD,EAAAn+C,IAAAm+C,EAAAn+C,GAAA4gC,eAAA,CAAAl+B,KAAAxB,EAAAwB,KAAAC,GAAA6xE,GAAAtzE,KACA,IAAAs6E,EAAA,GAGA3F,GAAA13B,GAAA,SAAAA,EAAA83B,GACAA,IAAA,GAAApiE,EAAA2nE,EAAAr9B,EAAAu5B,WACA+D,GAAAt9B,EAAAu5B,QAAAx2E,GACAs6E,EAAAntE,KAAA8vC,EAAAu5B,UAEA6D,GAAAp9B,EAAAj9C,EAAA,KAAAk3E,GAAAj6B,EAAAj9C,GALA,GAhBA,EAyBAgiD,EAAAn5B,EAAA6rC,QAAAt4D,OAAA,EAAA4lD,GAAA,IAAAA,EAAA,CACA,IAAA64B,EAAAz2C,EAAA4d,GAEA,GAAA64B,EAAA,OAAAA,EAAAnnE,CAHA,CApDA,CAbA,CAFA,CA4EA,SAAAonE,GAAA79B,EAAA89B,GACA,GAAA,GAAAA,IACA99B,EAAAld,OAAAg7C,EACA99B,EAAAtgC,IAAA,IAAAg2D,GAAA3/C,GAAAiqB,EAAAtgC,IAAAd,QAAA,SAAAE,GAAA,OAAA,IAAAg3D,GACArwD,GAAA3G,EAAAG,OAAAxX,KAAAq2E,EAAAh/D,EAAAG,OAAAtS,IACA8Y,GAAA3G,EAAAI,KAAAzX,KAAAq2E,EAAAh/D,EAAAI,KAAAvS,IAFA,IAGAqzC,EAAAtgC,IAAAykD,WACAnkB,EAAAn+C,IAAA,CACA+gE,GAAA5iB,EAAAn+C,GAAAm+C,EAAAld,MAAAkd,EAAAld,MAAAg7C,EAAAA,GACA,IAAA,IAAAxqB,EAAAtT,EAAAn+C,GAAAu9B,QAAA/9B,EAAAiyD,EAAA/E,SAAAltD,EAAAiyD,EAAA9E,OAAAntD,IACAiiE,GAAAtjB,EAAAn+C,GAAAR,EAAA,SAHA,CAPA,CAgBA,SAAA+7E,GAAAp9B,EAAAj9C,EAAAq2E,EAAA/1D,GACA,GAAA28B,EAAAn+C,KAAAm+C,EAAAn+C,GAAAqlD,MACA,OAAA3nC,GAAAygC,EAAAn+C,GAAAu7E,GAAA79D,CAAAygC,EAAAj9C,EAAAq2E,EAAA/1D,GAEA,GAAAtgB,EAAAyB,GAAAiD,KAAAu4C,EAAAld,MACA+6C,GAAA79B,EAAAj9C,EAAAa,KAAAzE,OAAA,GAAA4D,EAAAyB,GAAAiD,KAAA1E,EAAAwB,KAAAkD,YAGA,KAAA1E,EAAAwB,KAAAkD,KAAAu4C,EAAAlM,YAAA,CAGA,GAAA/wC,EAAAwB,KAAAkD,KAAAu4C,EAAAld,MAAA,CACA,IAAA7M,EAAAlzB,EAAAa,KAAAzE,OAAA,GAAA6gD,EAAAld,MAAA//B,EAAAwB,KAAAkD,MACAo2E,GAAA79B,EAAA/pB,GACAlzB,EAAA,CAAAwB,KAAAkhB,GAAAu6B,EAAAld,MAAA,GAAAt+B,GAAAihB,GAAA1iB,EAAAyB,GAAAiD,KAAAwuB,EAAAlzB,EAAAyB,GAAAmI,IACA/I,KAAA,CAAAm/C,GAAAhgD,EAAAa,OAAA4+C,OAAAz/C,EAAAy/C,OAJA,CAMA,IAAAiJ,EAAAzL,EAAAlM,WACA/wC,EAAAyB,GAAAiD,KAAAgkD,IACA1oD,EAAA,CAAAwB,KAAAxB,EAAAwB,KAAAC,GAAAihB,GAAAgmC,EAAA5wB,GAAAmlB,EAAAyL,GAAA7nD,KAAAzE,QACAyE,KAAA,CAAAb,EAAAa,KAAA,IAAA4+C,OAAAz/C,EAAAy/C,SAGAz/C,EAAAg7E,QAAAxzB,GAAAvK,EAAAj9C,EAAAwB,KAAAxB,EAAAyB,IAEA40E,IAAAA,EAAA7C,GAAAv2B,EAAAj9C,IACAi9C,EAAAn+C,GAUA,SAAAA,EAAAkB,EAAAsgB,GACA,IAAA28B,EAAAn+C,EAAAm+C,IAAA5gB,EAAAv9B,EAAAu9B,QAAA76B,EAAAxB,EAAAwB,KAAAC,EAAAzB,EAAAyB,GAEAw5E,GAAA,EAAAC,EAAA15E,EAAAkD,KACA5F,EAAA2f,QAAArf,eACA87E,EAAAjoC,GAAAwc,GAAA33B,GAAAmlB,EAAAz7C,EAAAkD,QACAu4C,EAAAxF,KAAAyjC,EAAAz5E,EAAAiD,KAAA,GAAA,SAAAA,GACA,GAAAA,GAAA23B,EAAAm0B,QAEA,OADAyqB,GAAA,GACA,CAHA,KAQAh+B,EAAAtgC,IAAAigC,SAAA58C,EAAAwB,KAAAxB,EAAAyB,KAAA,GACAyiD,GAAAplD,GAEAi1E,GAAA92B,EAAAj9C,EAAAsgB,EAAAswC,GAAA9xD,IAEAA,EAAA2f,QAAArf,eACA69C,EAAAxF,KAAAyjC,EAAA15E,EAAAkD,KAAA1E,EAAAa,KAAAzE,QAAA,SAAAsI,GACA,IAAAwoC,EAAAkjB,GAAA1rD,GACAwoC,EAAA7Q,EAAAo0B,gBACAp0B,EAAAm0B,QAAA9rD,EACA23B,EAAAo0B,cAAAvjB,EACA7Q,EAAAq0B,gBAAA,EACAuqB,GAAA,EANA,IASAA,IAAAn8E,EAAAqlD,MAAAimB,eAAA,IAnpIA,SAAAntB,EAAAl/C,GAEA,GADAk/C,EAAA8N,aAAAjtC,KAAAK,IAAA8+B,EAAA8N,aAAAhtD,KACAk/C,EAAA6N,kBAAA/sD,EAAA,IAAA,CAEA,IADA,IAAAkU,EAAAgrC,EAAAld,MACAr7B,EAAA3G,EAAA,EAAA2G,EAAAuN,EAAAvN,IAAA,CACA,IAAA2mD,EAAAvzB,GAAAmlB,EAAAv4C,GAAAimD,WAIA,GAAAU,MAAAA,aAAAhC,KAAA3kD,EAAA2mD,EAAApX,UAAAl2C,GAAA,CACAkU,EAAAvN,EAAA,EACA,KAFA,CALA,CAUAu4C,EAAA6N,kBAAAhtC,KAAAK,IAAA8+B,EAAA6N,kBAAA74C,EAZA,CAFA,CAspIAkpE,CAAAl+B,EAAAz7C,EAAAkD,MACAiiE,GAAA7nE,EAAA,KAEA,IAAAghE,EAAA9/D,EAAAa,KAAAzE,QAAAqF,EAAAiD,KAAAlD,EAAAkD,MAAA,EAEA1E,EAAAgtD,KACA6S,GAAA/gE,GACA0C,EAAAkD,MAAAjD,EAAAiD,MAAA,GAAA1E,EAAAa,KAAAzE,QAAAy3E,GAAA/0E,EAAAm+C,IAAAj9C,GAGA6/D,GAAA/gE,EAAA0C,EAAAkD,KAAAjD,EAAAiD,KAAA,EAAAo7D,GAFAS,GAAAzhE,EAAA0C,EAAAkD,KAAA,QAIA,IAAA02E,EAAA/2B,GAAAvlD,EAAA,WAAAu8E,EAAAh3B,GAAAvlD,EAAA,UACA,GAAAu8E,GAAAD,EAAA,CACA,IAAAz0D,EAAA,CACAnlB,KAAAA,EAAAC,GAAAA,EACAZ,KAAAb,EAAAa,KACAm6E,QAAAh7E,EAAAg7E,QACAv7B,OAAAz/C,EAAAy/C,QAEA47B,GAAAjnB,GAAAt1D,EAAA,SAAAA,EAAA6nB,GACAy0D,IAAAt8E,EAAAqlD,MAAA8lB,aAAAnrE,EAAAqlD,MAAA8lB,WAAA,KAAA98D,KAAAwZ,EARA,CAUA7nB,EAAAu9B,QAAAioC,kBAAA,IAvDA,CAVAgX,CAAAr+B,EAAAn+C,GAAAkB,EAAAsgB,GACAyzD,GAAA92B,EAAAj9C,EAAAsgB,GACA63D,GAAAl7B,EAAAo5B,EAAA/2B,GAEArC,EAAAq8B,UAAAZ,GAAAz7B,EAAAv6B,GAAAu6B,EAAAnM,YAAA,MACAmM,EAAAq8B,UAAA,EAvBA,CARA,CA8FA,SAAA75C,GAAAwd,EAAA5+C,EAAAmD,EAAAC,EAAAg+C,GACA,IAAA5sB,EAEApxB,IAAAA,EAAAD,GACA41C,GAAA31C,EAAAD,GAAA,IAAAA,GAAAqxB,EAAA,CAAApxB,EAAAD,IAAA,GAAAC,EAAAoxB,EAAA,IACA,iBAAAx0B,IAAAA,EAAA4+C,EAAAs+B,WAAAl9E,IACAs7E,GAAA18B,EAAA,CAAAz7C,KAAAA,EAAAC,GAAAA,EAAAZ,KAAAxC,EAAAohD,OAAAA,GANA,CAWA,SAAA+7B,GAAAzoE,EAAAvR,EAAAC,EAAAkmD,GACAlmD,EAAAsR,EAAArO,KACAqO,EAAArO,MAAAijD,EACAnmD,EAAAuR,EAAArO,OACAqO,EAAArO,KAAAlD,EACAuR,EAAAnJ,GAAA,EALA,CAgBA,SAAA6xE,GAAA/sC,EAAAltC,EAAAC,EAAAkmD,GACA,IAAA,IAAAxrD,EAAA,EAAAA,EAAAuyC,EAAAtyC,SAAAD,EAAA,CACA,IAAAwtC,EAAA+E,EAAAvyC,GAAAu/E,GAAA,EACA,GAAA/xC,EAAA9tB,OAAA,CACA8tB,EAAAgyC,UAAAhyC,EAAA+E,EAAAvyC,GAAAwtC,EAAAmpC,YAAA6I,QAAA,GACA,IAAA,IAAA5sD,EAAA,EAAAA,EAAA4a,EAAA9tB,OAAAzf,OAAA2yB,IACAysD,GAAA7xC,EAAA9tB,OAAAkT,GAAA7S,OAAA1a,EAAAC,EAAAkmD,GACA6zB,GAAA7xC,EAAA9tB,OAAAkT,GAAA5S,KAAA3a,EAAAC,EAAAkmD,EAJA,KAAA,CAQA,IAAA,IAAA7E,EAAA,EAAAA,EAAAnZ,EAAA+qB,QAAAt4D,SAAA0mD,EAAA,CACA,IAAA/+C,EAAA4lC,EAAA+qB,QAAA5R,GACA,GAAArhD,EAAAsC,EAAAvC,KAAAkD,KACAX,EAAAvC,KAAAkhB,GAAA3e,EAAAvC,KAAAkD,KAAAijD,EAAA5jD,EAAAvC,KAAAoI,IACA7F,EAAAtC,GAAAihB,GAAA3e,EAAAtC,GAAAiD,KAAAijD,EAAA5jD,EAAAtC,GAAAmI,SACA,GAAApI,GAAAuC,EAAAtC,GAAAiD,KAAA,CACAg3E,GAAA,EACA,KAFA,CALA,CAUAA,IACAhtC,EAAA9lB,OAAA,EAAAzsB,EAAA,GACAA,EAAA,EApBA,CAFA,CADA,CA4BA,SAAAo+E,GAAAhE,EAAAv2E,GACA,IAAAwB,EAAAxB,EAAAwB,KAAAkD,KAAAjD,EAAAzB,EAAAyB,GAAAiD,KAAAijD,EAAA3nD,EAAAa,KAAAzE,QAAAqF,EAAAD,GAAA,EACAi6E,GAAAlF,EAAAlB,KAAA7zE,EAAAC,EAAAkmD,GACA8zB,GAAAlF,EAAAjB,OAAA9zE,EAAAC,EAAAkmD,EAHA,CASA,SAAAi0B,GAAA3+B,EAAApgB,EAAAg/C,EAAA/R,GACA,IAAAliB,EAAA/qB,EAAAn4B,EAAAm4B,EAGA,MAFA,iBAAAA,EAAAn4B,EAAAozB,GAAAmlB,EAAAuL,GAAAvL,EAAApgB,IACA+qB,EAAA3U,GAAApW,GACA,MAAA+qB,EAAA,MACAkiB,EAAAplE,EAAAkjD,IAAA3K,EAAAn+C,IAAAyhE,GAAAtjB,EAAAn+C,GAAA8oD,EAAAi0B,GACAn3E,EANA,CAsBA,SAAAo3E,GAAA34D,GACArY,KAAAqY,MAAAA,EACArY,KAAA2xC,OAAA,KAEA,IADA,IAAAxgB,EAAA,EACA9/B,EAAA,EAAAA,EAAAgnB,EAAA/mB,SAAAD,EACAgnB,EAAAhnB,GAAAsgD,OAAA3xC,KACAmxB,GAAA9Y,EAAAhnB,GAAA8/B,OAEAnxB,KAAAmxB,OAAAA,CARA,CA6CA,SAAA8/C,GAAAh1C,GACAj8B,KAAAi8B,SAAAA,EAEA,IADA,IAAAW,EAAA,EAAAzL,EAAA,EACA9/B,EAAA,EAAAA,EAAA4qC,EAAA3qC,SAAAD,EAAA,CACA,IAAAyN,EAAAm9B,EAAA5qC,GACAurC,GAAA99B,EAAA29C,YAAAtrB,GAAAryB,EAAAqyB,OACAryB,EAAA6yC,OAAA3xC,IAHA,CAKAA,KAAA48B,KAAAA,EACA58B,KAAAmxB,OAAAA,EACAnxB,KAAA2xC,OAAA,IAVA,CA3/BAs2B,GAAA/1E,UAAAwE,KAAA,WAAA,OAAA+mD,GAAAz9C,KAAAoR,OAAApR,KAAAqR,KAAA,EACA42D,GAAA/1E,UAAAyE,GAAA,WAAA,OAAA6mD,GAAAx9C,KAAAoR,OAAApR,KAAAqR,KAAA,EACA42D,GAAA/1E,UAAAof,MAAA,WAAA,OAAAtR,KAAAqR,KAAAzX,MAAAoG,KAAAoR,OAAAxX,MAAAoG,KAAAqR,KAAAvS,IAAAkB,KAAAoR,OAAAtS,EAAA,EAu9BAkyE,GAAA9+E,UAAA,CACAuqD,UAAA,WAAA,OAAAz8C,KAAAqY,MAAA/mB,MAAA,EAGA4/E,YAAA,SAAAtqC,EAAA3zC,GACA,IAAA,IAAA5B,EAAAu1C,EAAAp0C,EAAAo0C,EAAA3zC,EAAA5B,EAAAmB,IAAAnB,EAAA,CACA,IAAAuI,EAAAoG,KAAAqY,MAAAhnB,GACA2O,KAAAmxB,QAAAv3B,EAAAu3B,OACA40B,GAAAnsD,GACA0vD,GAAA1vD,EAAA,SAJA,CAMAoG,KAAAqY,MAAAyF,OAAA8oB,EAAA3zC,EAPA,EAWA6/C,SAAA,SAAAz6B,GACAA,EAAAhW,KAAAmH,MAAA6O,EAAArY,KAAAqY,MADA,EAMA84D,YAAA,SAAAvqC,EAAAvuB,EAAA8Y,GACAnxB,KAAAmxB,QAAAA,EACAnxB,KAAAqY,MAAArY,KAAAqY,MAAAnR,MAAA,EAAA0/B,GAAAtpB,OAAAjF,GAAAiF,OAAAtd,KAAAqY,MAAAnR,MAAA0/B,IACA,IAAA,IAAAv1C,EAAA,EAAAA,EAAAgnB,EAAA/mB,SAAAD,EAAAgnB,EAAAhnB,GAAAsgD,OAAA3xC,IAHA,EAOAoxE,MAAA,SAAAxqC,EAAA3zC,EAAA+rE,GACA,IAAA,IAAAxsE,EAAAo0C,EAAA3zC,EAAA2zC,EAAAp0C,IAAAo0C,EACA,GAAAo4B,EAAAh/D,KAAAqY,MAAAuuB,IAAA,OAAA,CAFA,GAmBAqqC,GAAA/+E,UAAA,CACAuqD,UAAA,WAAA,OAAAz8C,KAAA48B,IAAA,EAEAs0C,YAAA,SAAAtqC,EAAA3zC,GACA+M,KAAA48B,MAAA3pC,EACA,IAAA,IAAA5B,EAAA,EAAAA,EAAA2O,KAAAi8B,SAAA3qC,SAAAD,EAAA,CACA,IAAA0gD,EAAA/xC,KAAAi8B,SAAA5qC,GAAAmrD,EAAAzK,EAAA0K,YACA,GAAA7V,EAAA4V,EAAA,CACA,IAAAnqC,EAAAW,KAAAK,IAAApgB,EAAAupD,EAAA5V,GAAAkzB,EAAA/nB,EAAA5gB,OAIA,GAHA4gB,EAAAm/B,YAAAtqC,EAAAv0B,GACArS,KAAAmxB,QAAA2oC,EAAA/nB,EAAA5gB,OACAqrB,GAAAnqC,IAAArS,KAAAi8B,SAAAne,OAAAzsB,IAAA,GAAA0gD,EAAAJ,OAAA,MACA,IAAA1+C,GAAAof,GAAA,MACAu0B,EAAA,CANA,MAOAA,GAAA4V,CATA,CAaA,GAAAx8C,KAAA48B,KAAA3pC,EAAA,KACA+M,KAAAi8B,SAAA3qC,OAAA,KAAA0O,KAAAi8B,SAAA,aAAA+0C,KAAA,CACA,IAAA34D,EAAA,GACArY,KAAA8yC,SAAAz6B,GACArY,KAAAi8B,SAAA,CAAA,IAAA+0C,GAAA34D,IACArY,KAAAi8B,SAAA,GAAA0V,OAAA3xC,IAJA,CAhBA,EAwBA8yC,SAAA,SAAAz6B,GACA,IAAA,IAAAhnB,EAAA,EAAAA,EAAA2O,KAAAi8B,SAAA3qC,SAAAD,EAAA2O,KAAAi8B,SAAA5qC,GAAAyhD,SAAAz6B,EADA,EAIA84D,YAAA,SAAAvqC,EAAAvuB,EAAA8Y,GACAnxB,KAAA48B,MAAAvkB,EAAA/mB,OACA0O,KAAAmxB,QAAAA,EACA,IAAA,IAAA9/B,EAAA,EAAAA,EAAA2O,KAAAi8B,SAAA3qC,SAAAD,EAAA,CACA,IAAA0gD,EAAA/xC,KAAAi8B,SAAA5qC,GAAAmrD,EAAAzK,EAAA0K,YACA,GAAA7V,GAAA4V,EAAA,CAEA,GADAzK,EAAAo/B,YAAAvqC,EAAAvuB,EAAA8Y,GACA4gB,EAAA15B,OAAA05B,EAAA15B,MAAA/mB,OAAA,GAAA,CAIA,IADA,IAAA+/E,EAAAt/B,EAAA15B,MAAA/mB,OAAA,GAAA,GACA2W,EAAAopE,EAAAppE,EAAA8pC,EAAA15B,MAAA/mB,QAAA,CACA,IAAAggF,EAAA,IAAAN,GAAAj/B,EAAA15B,MAAAnR,MAAAe,EAAAA,GAAA,KACA8pC,EAAA5gB,QAAAmgD,EAAAngD,OACAnxB,KAAAi8B,SAAAne,SAAAzsB,EAAA,EAAAigF,GACAA,EAAA3/B,OAAA3xC,IAJA,CAMA+xC,EAAA15B,MAAA05B,EAAA15B,MAAAnR,MAAA,EAAAmqE,GACArxE,KAAAuxE,YAXA,CAaA,KAfA,CAiBA3qC,GAAA4V,CAnBA,CAHA,EA2BA+0B,WAAA,WACA,KAAAvxE,KAAAi8B,SAAA3qC,QAAA,IAAA,CACA,IAAA2b,EAAAjN,KACA,EAAA,CACA,IACAwxE,EAAA,IAAAP,GADAhkE,EAAAgvB,SAAAne,OAAA7Q,EAAAgvB,SAAA3qC,OAAA,EAAA,IAEA,GAAA2b,EAAA0kC,OAKA,CACA1kC,EAAA2vB,MAAA40C,EAAA50C,KACA3vB,EAAAkkB,QAAAqgD,EAAArgD,OACA,IAAAsgD,EAAA5pE,EAAAoF,EAAA0kC,OAAA1V,SAAAhvB,GACAA,EAAA0kC,OAAA1V,SAAAne,OAAA2zD,EAAA,EAAA,EAAAD,EAJA,KALA,CACA,IAAAxwB,EAAA,IAAAiwB,GAAAhkE,EAAAgvB,UACA+kB,EAAArP,OAAA1kC,EACAA,EAAAgvB,SAAA,CAAA+kB,EAAAwwB,GACAvkE,EAAA+zC,CAJA,CAWAwwB,EAAA7/B,OAAA1kC,EAAA0kC,MAdA,OAeA1kC,EAAAgvB,SAAA3qC,OAAA,IACA2b,EAAA0kC,OAAA4/B,YAlBA,CADA,EAsBAH,MAAA,SAAAxqC,EAAA3zC,EAAA+rE,GACA,IAAA,IAAA3tE,EAAA,EAAAA,EAAA2O,KAAAi8B,SAAA3qC,SAAAD,EAAA,CACA,IAAA0gD,EAAA/xC,KAAAi8B,SAAA5qC,GAAAmrD,EAAAzK,EAAA0K,YACA,GAAA7V,EAAA4V,EAAA,CACA,IAAAk1B,EAAA1+D,KAAAK,IAAApgB,EAAAupD,EAAA5V,GACA,GAAAmL,EAAAq/B,MAAAxqC,EAAA8qC,EAAA1S,GAAA,OAAA,EACA,GAAA,IAAA/rE,GAAAy+E,GAAA,MACA9qC,EAAA,CAJA,MAKAA,GAAA4V,CAPA,CADA,GAeA,IAAAm1B,GAAA,SAAAx/B,EAAAz/B,EAAAiB,GACA,GAAAA,EAAA,IAAA,IAAAytB,KAAAztB,EAAAA,EAAAtb,eAAA+oC,KACAphC,KAAAohC,GAAAztB,EAAAytB,IACAphC,KAAAmyC,IAAAA,EACAnyC,KAAA0S,KAAAA,CAJA,EAyCA,SAAAk/D,GAAA59E,EAAA4F,EAAAijD,GACAuI,GAAAxrD,IAAA5F,EAAAqlD,OAAArlD,EAAAqlD,MAAA/oB,WAAAt8B,EAAAm+C,IAAA7hB,YACA4qC,GAAAlnE,EAAA6oD,EAFA,CAlCA80B,GAAAz/E,UAAA6kB,MAAA,WACA,IAAA/iB,EAAAgM,KAAAmyC,IAAAn+C,GAAAg4D,EAAAhsD,KAAApG,KAAAmyD,QAAAnyD,EAAAoG,KAAApG,KAAAkjD,EAAA3U,GAAAvuC,GACA,GAAA,MAAAkjD,GAAAkP,EAAA,CACA,IAAA,IAAA36D,EAAA,EAAAA,EAAA26D,EAAA16D,SAAAD,EAAA26D,EAAA36D,IAAA2O,MAAAgsD,EAAAluC,OAAAzsB,IAAA,GACA26D,EAAA16D,SAAAsI,EAAAmyD,QAAA,MACA,IAAA56B,EAAAs7B,GAAAzsD,MACA48C,GAAAhjD,EAAAoZ,KAAAC,IAAA,EAAArZ,EAAAu3B,OAAAA,IACAn9B,IACAquE,GAAAruE,GAAA,WACA49E,GAAA59E,EAAA4F,GAAAu3B,GACAskC,GAAAzhE,EAAA8oD,EAAA,SAFA,IAIAwM,GAAAt1D,EAAA,oBAAAA,EAAAgM,KAAA88C,GAVA,CAFA,EAgBA60B,GAAAz/E,UAAAsvE,QAAA,WACA,IAAAqQ,EAAA7xE,KAEA8xE,EAAA9xE,KAAAmxB,OAAAn9B,EAAAgM,KAAAmyC,IAAAn+C,GAAA4F,EAAAoG,KAAApG,KACAoG,KAAAmxB,OAAA,KACA,IAAA0rB,EAAA4P,GAAAzsD,MAAA8xE,EACAj1B,IACAoI,GAAAjlD,KAAAmyC,IAAAv4C,IAAAgjD,GAAAhjD,EAAAA,EAAAu3B,OAAA0rB,GACA7oD,GACAquE,GAAAruE,GAAA,WACAA,EAAAqlD,MAAA+U,aAAA,EACAwjB,GAAA59E,EAAA4F,EAAAijD,GACAyM,GAAAt1D,EAAA,oBAAAA,EAAA69E,EAAA1pC,GAAAvuC,GAHA,IATA,EAgBA4/C,GAAAm4B,IA2CA,IAAAI,GAAA,EAEAC,GAAA,SAAA7/B,EAAA9zC,GACA2B,KAAAqY,MAAA,GACArY,KAAA3B,KAAAA,EACA2B,KAAAmyC,IAAAA,EACAnyC,KAAA6X,KAAAk6D,EAJA,EAsHA,SAAAr5D,GAAAy5B,EAAAz7C,EAAAC,EAAAgd,EAAAtV,GAIA,GAAAsV,GAAAA,EAAAw2D,OAAA,OA2FA,SAAAh4B,EAAAz7C,EAAAC,EAAAgd,EAAAtV,IACAsV,EAAA6/B,EAAA7/B,IACAw2D,QAAA,EACA,IAAApf,EAAA,CAAAryC,GAAAy5B,EAAAz7C,EAAAC,EAAAgd,EAAAtV,IAAAoxC,EAAAsb,EAAA,GACAp+B,EAAAhZ,EAAAuxC,WAQA,OAPA2kB,GAAA13B,GAAA,SAAAA,GACAxlB,IAAAhZ,EAAAuxC,WAAAv4B,EAAA9Y,WAAA,IACAk3C,EAAA1oD,KAAAqW,GAAAy5B,EAAAwL,GAAAxL,EAAAz7C,GAAAinD,GAAAxL,EAAAx7C,GAAAgd,EAAAtV,IACA,IAAA,IAAAhN,EAAA,EAAAA,EAAA8gD,EAAA+3B,OAAA54E,SAAAD,EACA,GAAA8gD,EAAA+3B,OAAA74E,GAAA4gF,SAAA,OACAxiC,EAAAyF,GAAA6V,EALA,IAOA,IAAAmnB,GAAAnnB,EAAAtb,EAZA,CA3FA0iC,CAAAhgC,EAAAz7C,EAAAC,EAAAgd,EAAAtV,GAEA,GAAA8zC,EAAAn+C,KAAAm+C,EAAAn+C,GAAAqlD,MAAA,OAAA3nC,GAAAygC,EAAAn+C,GAAA0kB,GAAAhH,CAAAygC,EAAAz7C,EAAAC,EAAAgd,EAAAtV,GAEA,IAAA+Y,EAAA,IAAA46D,GAAA7/B,EAAA9zC,GAAAw+C,EAAAvQ,GAAA51C,EAAAC,GAGA,GAFAgd,GAAA6/B,EAAA7/B,EAAAyD,GAAA,GAEAylC,EAAA,GAAA,GAAAA,IAAA,IAAAzlC,EAAAksC,eACA,OAAAlsC,EAQA,GAPAA,EAAAg7D,eAEAh7D,EAAAktC,WAAA,EACAltC,EAAA8tC,WAAArT,EAAA,OAAA,CAAAz6B,EAAAg7D,cAAA,qBACAz+D,EAAAs4C,mBAAA70C,EAAA8tC,WAAA71B,aAAA,mBAAA,QACA1b,EAAA8uC,aAAArrC,EAAA8tC,WAAAzC,YAAA,IAEArrC,EAAAktC,UAAA,CACA,GAAAI,GAAAvS,EAAAz7C,EAAAkD,KAAAlD,EAAAC,EAAAygB,IACA1gB,EAAAkD,MAAAjD,EAAAiD,MAAA8qD,GAAAvS,EAAAx7C,EAAAiD,KAAAlD,EAAAC,EAAAygB,GACA,MAAA,IAAA9jB,MAAA,oEAvmJAuuD,IAAA,CAomJA,CAOAzqC,EAAAi7D,cACA/G,GAAAn5B,EAAA,CAAAz7C,KAAAA,EAAAC,GAAAA,EAAAg+C,OAAA,YAAAxC,EAAAtgC,IAAAnM,KAEA,IAAA45D,EAAA15B,EAAAlvC,EAAAkD,KAAA5F,EAAAm+C,EAAAn+C,GA0BA,GAzBAm+C,EAAAxF,KAAA/G,EAAAjvC,EAAAiD,KAAA,GAAA,SAAAA,GACA5F,GAAAojB,EAAAktC,YAAAtwD,EAAA2f,QAAArf,cAAAqwD,GAAA/qD,IAAA5F,EAAAu9B,QAAAm0B,UACA4Z,GAAA,GACAloD,EAAAktC,WAAA1e,GAAAlvC,EAAAkD,MAAAgjD,GAAAhjD,EAAA,GAtlJA,SAAAA,EAAA4gC,EAAAwkC,GACA,IAAAsT,EAAAtT,GAAAlqE,OAAAy9E,UAAAvT,EAAA5c,cAAA4c,EAAA5c,YAAA,IAAAmwB,UACAD,GAAA14E,EAAAwoD,aAAAkwB,EAAA17D,IAAAhd,EAAAwoD,aACAxoD,EAAAwoD,YAAA//C,KAAAm4B,IAEA5gC,EAAAwoD,YAAAxoD,EAAAwoD,YAAAxoD,EAAAwoD,YAAA9kC,OAAA,CAAAkd,IAAA,CAAAA,GACA83C,GAAAA,EAAAjvC,IAAAzpC,EAAAwoD,cAEA5nB,EAAApjB,OAAAssC,WAAA9pD,EARA,CAulJA44E,CAAA54E,EAAA,IAAAkoD,GAAA1qC,EACAwuB,GAAAlvC,EAAAkD,KAAAlD,EAAAoI,GAAA,KACA8mC,GAAAjvC,EAAAiD,KAAAjD,EAAAmI,GAAA,MAAAqzC,EAAAn+C,IAAAm+C,EAAAn+C,GAAAqlD,SACAzT,CAPA,IAUAxuB,EAAAktC,WAAAnS,EAAAxF,KAAAj2C,EAAAkD,KAAAjD,EAAAiD,KAAA,GAAA,SAAAA,GACAqrD,GAAA9S,EAAAv4C,IAAAgjD,GAAAhjD,EAAA,EADA,IAIAwd,EAAAq7D,cAAAj9E,GAAA4hB,EAAA,qBAAA,WAAA,OAAAA,EAAAL,OAAA,IAEAK,EAAAviB,WAnoJA+sD,IAAA,GAqoJAzP,EAAAu5B,QAAAnB,KAAAj5E,QAAA6gD,EAAAu5B,QAAAlB,OAAAl5E,SACA6gD,EAAAugC,gBAEAt7D,EAAAktC,YACAltC,EAAAS,KAAAk6D,GACA36D,EAAAg3D,QAAA,GAEAp6E,EAAA,CAGA,GADAsrE,IAAAtrE,EAAAqlD,MAAAimB,eAAA,GACAloD,EAAAktC,UACAyQ,GAAA/gE,EAAA0C,EAAAkD,KAAAjD,EAAAiD,KAAA,QACA,GAAAwd,EAAA/L,WAAA+L,EAAAgwC,YAAAhwC,EAAAiwC,UAAAjwC,EAAAkwC,KACAlwC,EAAAmwC,YAAAnwC,EAAAyjB,MACA,IAAA,IAAAxpC,EAAAqF,EAAAkD,KAAAvI,GAAAsF,EAAAiD,KAAAvI,IAAAokE,GAAAzhE,EAAA3C,EAAA,QACA+lB,EAAAg3D,QAAAX,GAAAz5E,EAAAm+C,KACAmX,GAAAt1D,EAAA,cAAAA,EAAAojB,EATA,CAWA,OAAAA,CAnEA,CA9GA46D,GAAA9/E,UAAA6kB,MAAA,WACA,IAAA/W,KAAAmsE,kBAAA,CACA,IAAAn4E,EAAAgM,KAAAmyC,IAAAn+C,GAAA2+E,EAAA3+E,IAAAA,EAAAqlD,MAEA,GADAs5B,GAAA5T,GAAA/qE,GACAulD,GAAAv5C,KAAA,SAAA,CACA,IAAAgZ,EAAAhZ,KAAA1K,OACA0jB,GAAAswC,GAAAtpD,KAAA,QAAAgZ,EAAAtiB,KAAAsiB,EAAAriB,GAFA,CAKA,IADA,IAAA0c,EAAA,KAAAJ,EAAA,KACA5hB,EAAA,EAAAA,EAAA2O,KAAAqY,MAAA/mB,SAAAD,EAAA,CACA,IAAAuI,EAAAoG,KAAAqY,MAAAhnB,GACAmpC,EAAAunB,GAAAnoD,EAAAwoD,YAAApiD,MACAhM,IAAAgM,KAAAskD,UAAAmR,GAAAzhE,EAAAm0C,GAAAvuC,GAAA,QACA5F,IACA,MAAAwmC,EAAA7jC,KAAAsc,EAAAk1B,GAAAvuC,IACA,MAAA4gC,EAAA9jC,OAAA2c,EAAA80B,GAAAvuC,KAEAA,EAAAwoD,YAAAJ,GAAApoD,EAAAwoD,YAAA5nB,GACA,MAAAA,EAAA9jC,MAAAsJ,KAAAskD,YAAAW,GAAAjlD,KAAAmyC,IAAAv4C,IAAA5F,GACA4oD,GAAAhjD,EAAAo6D,GAAAhgE,EAAAu9B,SAVA,CAYA,GAAAv9B,GAAAgM,KAAAskD,YAAAtwD,EAAA2f,QAAArf,aAAA,IAAA,IAAA4iD,EAAA,EAAAA,EAAAl3C,KAAAqY,MAAA/mB,SAAA4lD,EAAA,CACA,IAAA07B,EAAAjuB,GAAA3kD,KAAAqY,MAAA6+B,IAAA9U,EAAAkjB,GAAAstB,GACAxwC,EAAApuC,EAAAu9B,QAAAo0B,gBACA3xD,EAAAu9B,QAAAm0B,QAAAktB,EACA5+E,EAAAu9B,QAAAo0B,cAAAvjB,EACApuC,EAAAu9B,QAAAq0B,gBAAA,EALA,CASA,MAAAvyC,GAAArf,GAAAgM,KAAAskD,WAAAyQ,GAAA/gE,EAAAqf,EAAAJ,EAAA,GACAjT,KAAAqY,MAAA/mB,OAAA,EACA0O,KAAAmsE,mBAAA,EACAnsE,KAAAouE,QAAApuE,KAAAmyC,IAAAq8B,WACAxuE,KAAAmyC,IAAAq8B,UAAA,EACAx6E,GAAAy5E,GAAAz5E,EAAAm+C,MAEAn+C,GAAAs1D,GAAAt1D,EAAA,gBAAAA,EAAAgM,KAAAqT,EAAAJ,GACA0/D,GAAAjT,GAAA1rE,GACAgM,KAAA2xC,QAAA3xC,KAAA2xC,OAAA56B,OAtCA,CADA,EA+CAi7D,GAAA9/E,UAAAoD,KAAA,SAAAqiE,EAAAtS,GAEA,IAAA3uD,EAAAC,EADA,MAAAghE,GAAA,YAAA33D,KAAA3B,OAAAs5D,EAAA,GAEA,IAAA,IAAAtmE,EAAA,EAAAA,EAAA2O,KAAAqY,MAAA/mB,SAAAD,EAAA,CACA,IAAAuI,EAAAoG,KAAAqY,MAAAhnB,GACAmpC,EAAAunB,GAAAnoD,EAAAwoD,YAAApiD,MACA,GAAA,MAAAw6B,EAAA9jC,OACAA,EAAAkhB,GAAAytC,EAAAzrD,EAAAuuC,GAAAvuC,GAAA4gC,EAAA9jC,OACA,GAAAihE,GAAA,OAAAjhE,EAEA,GAAA,MAAA8jC,EAAA7jC,KACAA,EAAAihB,GAAAytC,EAAAzrD,EAAAuuC,GAAAvuC,GAAA4gC,EAAA7jC,IACA,GAAAghE,GAAA,OAAAhhE,CATA,CAYA,OAAAD,GAAA,CAAAA,KAAAA,EAAAC,GAAAA,EAfA,EAoBAq7E,GAAA9/E,UAAAsvE,QAAA,WACA,IAAAqQ,EAAA7xE,KAEAiI,EAAAjI,KAAA1K,MAAA,GAAA,GAAAq3B,EAAA3sB,KAAAhM,EAAAgM,KAAAmyC,IAAAn+C,GACAiU,GAAAjU,GACAquE,GAAAruE,GAAA,WACA,IAAA4F,EAAAqO,EAAArO,KAAAkrD,EAAA3c,GAAAlgC,EAAArO,MACAuvD,EAAA8E,GAAAj6D,EAAA8wD,GAMA,GALAqE,IACA4H,GAAA5H,GACAn1D,EAAAqlD,MAAAgmB,iBAAArrE,EAAAqlD,MAAA+U,aAAA,GAEAp6D,EAAAqlD,MAAAimB,eAAA,GACAra,GAAAt4B,EAAAwlB,IAAAv4C,IAAA,MAAA+yB,EAAAwE,OAAA,CACA,IAAA2oC,EAAAntC,EAAAwE,OACAxE,EAAAwE,OAAA,KACA,IAAA0hD,EAAApmB,GAAA9/B,GAAAmtC,EACA+Y,GACAj2B,GAAAhjD,EAAAA,EAAAu3B,OAAA0hD,EALA,CAOAvpB,GAAAt1D,EAAA,gBAAAA,EAAA69E,EAfA,GALA,EAwBAG,GAAA9/E,UAAAwxD,WAAA,SAAA9pD,GACA,IAAAoG,KAAAqY,MAAA/mB,QAAA0O,KAAAmyC,IAAAn+C,GAAA,CACA,IAAAgrE,EAAAh/D,KAAAmyC,IAAAn+C,GAAAqlD,MACA2lB,EAAAiD,qBAAA,GAAAp6D,EAAAm3D,EAAAiD,mBAAAjiE,QACAg/D,EAAAmD,uBAAAnD,EAAAmD,qBAAA,KAAA9/D,KAAArC,KAHA,CAKAA,KAAAqY,MAAAhW,KAAAzI,EANA,EASAo4E,GAAA9/E,UAAAsxD,WAAA,SAAA5pD,GAEA,GADAoG,KAAAqY,MAAAyF,OAAAjW,EAAA7H,KAAAqY,MAAAze,GAAA,IACAoG,KAAAqY,MAAA/mB,QAAA0O,KAAAmyC,IAAAn+C,GAAA,CACA,IAAAgrE,EAAAh/D,KAAAmyC,IAAAn+C,GAAAqlD,OACA2lB,EAAAiD,qBAAAjD,EAAAiD,mBAAA,KAAA5/D,KAAArC,KAFA,CAFA,EAOAw5C,GAAAw4B,IA8EA,IAAAE,GAAA,SAAAnnB,EAAAtb,GACAzvC,KAAA+qD,QAAAA,EACA/qD,KAAAyvC,QAAAA,EACA,IAAA,IAAAp+C,EAAA,EAAAA,EAAA05D,EAAAz5D,SAAAD,EACA05D,EAAA15D,GAAAsgD,OAAA3xC,IAJA,EAmCA,SAAA8yE,GAAA3gC,GACA,OAAAA,EAAA4gC,UAAAn7D,GAAAu6B,EAAAld,MAAA,GAAAkd,EAAAwL,QAAA/lC,GAAAu6B,EAAAlM,cAAA,SAAAn+B,GAAA,OAAAA,EAAA6pC,MAAA,GADA,CAgBA,SAAAqhC,GAAAjoB,GAaA,IAZA,IAAAzxB,EAAA,SAAAjoC,GACA,IAAA+lB,EAAA2zC,EAAA15D,GAAA64E,EAAA,CAAA9yD,EAAAq4B,QAAA0C,KACA03B,GAAAzyD,EAAAq4B,QAAA0C,KAAA,SAAAsT,GAAA,OAAAykB,EAAA7nE,KAAAojD,EAAA,IACA,IAAA,IAAAxhC,EAAA,EAAAA,EAAA7M,EAAA2zC,QAAAz5D,OAAA2yB,IAAA,CACA,IAAAgvD,EAAA77D,EAAA2zC,QAAA9mC,IACA,GAAApc,EAAAqiE,EAAA+I,EAAA9gC,OACA8gC,EAAAthC,OAAA,KACAv6B,EAAA2zC,QAAAjtC,OAAAmG,IAAA,GAJA,CAHA,EAYA5yB,EAAA,EAAAA,EAAA05D,EAAAz5D,OAAAD,IAAAioC,EAAAjoC,EAbA,CA5CA6gF,GAAAhgF,UAAA6kB,MAAA,WACA,IAAA/W,KAAAmsE,kBAAA,CACAnsE,KAAAmsE,mBAAA,EACA,IAAA,IAAA96E,EAAA,EAAAA,EAAA2O,KAAA+qD,QAAAz5D,SAAAD,EACA2O,KAAA+qD,QAAA15D,GAAA0lB,QACAuyC,GAAAtpD,KAAA,QAJA,CADA,EAQAkyE,GAAAhgF,UAAAoD,KAAA,SAAAqiE,EAAAtS,GACA,OAAArlD,KAAAyvC,QAAAn6C,KAAAqiE,EAAAtS,EADA,EAGA7L,GAAA04B,IAiDA,IAAAgB,GAAA,EACAC,GAAA,SAAAA,EAAAp9E,EAAA3B,EAAA4xC,EAAAotC,EAAAp8B,GACA,KAAAh3C,gBAAAmzE,GAAA,OAAA,IAAAA,EAAAp9E,EAAA3B,EAAA4xC,EAAAotC,EAAAp8B,GACA,MAAAhR,IAAAA,EAAA,GAEAirC,GAAAt+E,KAAAqN,KAAA,CAAA,IAAAgxE,GAAA,CAAA,IAAAnrB,GAAA,GAAA,UACA7lD,KAAAi1B,MAAA+Q,EACAhmC,KAAAswB,UAAAtwB,KAAAqwB,WAAA,EACArwB,KAAAwuE,UAAA,EACAxuE,KAAAqzE,gBAAA,EACArzE,KAAAigD,aAAAjgD,KAAAggD,kBAAAha,EACA,IAAA7+B,EAAAyQ,GAAAouB,EAAA,GACAhmC,KAAA6R,IAAA02D,GAAAphE,GACAnH,KAAA0rE,QAAA,IAAApB,GAAA,MACAtqE,KAAA6X,KAAAq7D,GACAlzE,KAAA6oE,WAAAz0E,EACA4L,KAAAozE,QAAAA,EACApzE,KAAAg3C,UAAA,OAAAA,EAAA,MAAA,MACAh3C,KAAAkkE,QAAA,EAEA,iBAAAnuE,IAAAA,EAAAiK,KAAAywE,WAAA16E,IACAkzE,GAAAjpE,KAAA,CAAAtJ,KAAAyQ,EAAAxQ,GAAAwQ,EAAApR,KAAAA,IACAg3E,GAAA/sE,KAAAuoE,GAAAphE,GAAAqtC,EArBA,EAwBA2+B,GAAAjhF,UAAAkjD,GAAA67B,GAAA/+E,UAAA,CACAa,YAAAogF,GAKAxmC,KAAA,SAAAj2C,EAAAC,EAAAqoE,GACAA,EAAAh/D,KAAAoxE,MAAA16E,EAAAsJ,KAAAi1B,MAAAt+B,EAAAD,EAAAsoE,GACAh/D,KAAAoxE,MAAApxE,KAAAi1B,MAAAj1B,KAAAi1B,MAAAj1B,KAAA48B,KAAAlmC,EAFA,EAMA8yE,OAAA,SAAA5iC,EAAAvuB,GAEA,IADA,IAAA8Y,EAAA,EACA9/B,EAAA,EAAAA,EAAAgnB,EAAA/mB,SAAAD,EAAA8/B,GAAA9Y,EAAAhnB,GAAA8/B,OACAnxB,KAAAmxE,YAAAvqC,EAAA5mC,KAAAi1B,MAAA5c,EAAA8Y,EAHA,EAKAs4C,OAAA,SAAA7iC,EAAA3zC,GAAA+M,KAAAkxE,YAAAtqC,EAAA5mC,KAAAi1B,MAAAhiC,EAAA,EAKAmC,SAAA,SAAAg+E,GACA,IAAA/6D,EAAAskC,GAAA38C,KAAAA,KAAAi1B,MAAAj1B,KAAAi1B,MAAAj1B,KAAA48B,MACA,OAAA,IAAAw2C,EAAA/6D,EACAA,EAAA6E,KAAAk2D,GAAApzE,KAAAuuC,gBAHA,EAKA+kC,SAAA/Q,IAAA,SAAAhvE,GACA,IAAAoc,EAAAiI,GAAA5X,KAAAi1B,MAAA,GAAA2oB,EAAA59C,KAAAi1B,MAAAj1B,KAAA48B,KAAA,EACAiyC,GAAA7uE,KAAA,CAAAtJ,KAAAiZ,EAAAhZ,GAAAihB,GAAAgmC,EAAA5wB,GAAAhtB,KAAA49C,GAAA7nD,KAAAzE,QACAyE,KAAAiK,KAAAywE,WAAAl9E,GAAAohD,OAAA,WAAAuN,MAAA,IAAA,GACAliD,KAAAhM,IAAAunE,GAAAv7D,KAAAhM,GAAA,EAAA,GACA+4E,GAAA/sE,KAAAuoE,GAAA54D,GAAA6kC,EALA,IAOA7f,aAAA,SAAAphC,EAAAmD,EAAAC,EAAAg+C,GAGAhgB,GAAA30B,KAAAzM,EAFAmD,EAAAinD,GAAA39C,KAAAtJ,GACAC,EAAAA,EAAAgnD,GAAA39C,KAAArJ,GAAAD,EACAi+C,EAHA,EAKAxS,SAAA,SAAAzrC,EAAAC,EAAAy8E,GACA,IAAA/6D,EAAAqkC,GAAA18C,KAAA29C,GAAA39C,KAAAtJ,GAAAinD,GAAA39C,KAAArJ,IACA,OAAA,IAAAy8E,EAAA/6D,EACA,KAAA+6D,EAAA/6D,EAAA6E,KAAA,IACA7E,EAAA6E,KAAAk2D,GAAApzE,KAAAuuC,gBAJA,EAOAvhB,QAAA,SAAApzB,GAAA,IAAApG,EAAAwM,KAAAynC,cAAA7tC,GAAA,OAAApG,GAAAA,EAAAuC,IAAA,EAEA0xC,cAAA,SAAA7tC,GAAA,GAAAsjD,GAAAl9C,KAAApG,GAAA,OAAAozB,GAAAhtB,KAAApG,EAAA,EACA25E,cAAA,SAAA35E,GAAA,OAAAuuC,GAAAvuC,EAAA,EAEA2X,yBAAA,SAAA3X,GAEA,MADA,iBAAAA,IAAAA,EAAAozB,GAAAhtB,KAAApG,IACA+qD,GAAA/qD,EAFA,EAKAskB,UAAA,WAAA,OAAAle,KAAA48B,IAAA,EACAoJ,UAAA,WAAA,OAAAhmC,KAAAi1B,KAAA,EACAgR,SAAA,WAAA,OAAAjmC,KAAAi1B,MAAAj1B,KAAA48B,KAAA,CAAA,EAEA+gB,QAAA,SAAA11C,GAAA,OAAA01C,GAAA39C,KAAAiI,EAAA,EAEA6kB,UAAA,SAAA3lB,GACA,IAAA8J,EAAAjR,KAAA6R,IAAA49B,UAKA,OAJA,MAAAtoC,GAAA,QAAAA,EAAA8J,EAAAI,KACA,UAAAlK,EAAA8J,EAAAG,OACA,OAAAjK,GAAA,MAAAA,IAAA,IAAAA,EAAA8J,EAAAta,KACAsa,EAAAva,MALA,EAQAwb,eAAA,WAAA,OAAAlS,KAAA6R,IAAAd,MAAA,EACAgd,kBAAA,WAAA,OAAA/tB,KAAA6R,IAAAkc,mBAAA,EAEAylD,UAAAjR,IAAA,SAAA3oE,EAAAkF,EAAA6U,GACAw5D,GAAAntE,KAAA29C,GAAA39C,KAAA,iBAAApG,EAAAge,GAAAhe,EAAAkF,GAAA,GAAAlF,GAAA,KAAA+Z,EADA,IAGAo5D,aAAAxK,IAAA,SAAAnxD,EAAAC,EAAAsC,GACAw5D,GAAAntE,KAAA29C,GAAA39C,KAAAoR,GAAAusC,GAAA39C,KAAAqR,GAAAD,GAAAuC,EADA,IAGAszB,gBAAAs7B,IAAA,SAAAlxD,EAAAw1B,EAAAlzB,GACAszB,GAAAjnC,KAAA29C,GAAA39C,KAAAqR,GAAAw1B,GAAA8W,GAAA39C,KAAA6mC,GAAAlzB,EADA,IAGAq5D,iBAAAzK,IAAA,SAAA0K,EAAAt5D,GACAq5D,GAAAhtE,KAAA+9C,GAAA/9C,KAAAitE,GAAAt5D,EADA,IAGA8/D,mBAAAlR,IAAA,SAAAlvE,EAAAsgB,GAEAq5D,GAAAhtE,KAAA+9C,GAAA/9C,KADAkoB,GAAAloB,KAAA6R,IAAAd,OAAA1d,IACAsgB,EAFA,IAIA83B,cAAA82B,IAAA,SAAAxxD,EAAA0+B,EAAA97B,GACA,GAAA5C,EAAAzf,OAAA,CAEA,IADA,IAAAo8B,EAAA,GACAr8B,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IACAq8B,EAAAr8B,GAAA,IAAA42E,GAAAtqB,GAAA39C,KAAA+Q,EAAA1f,GAAA+f,QACAusC,GAAA39C,KAAA+Q,EAAA1f,GAAAggB,MAAAN,EAAA1f,GAAA+f,SACA,MAAAq+B,IAAAA,EAAAz8B,KAAAK,IAAAtC,EAAAzf,OAAA,EAAA0O,KAAA6R,IAAAykD,YACAyW,GAAA/sE,KAAAkoE,GAAAloE,KAAAhM,GAAA05B,EAAA+hB,GAAA97B,EANA,CADA,IASA+/D,aAAAnR,IAAA,SAAAnxD,EAAAC,EAAAsC,GACA,IAAA5C,EAAA/Q,KAAA6R,IAAAd,OAAA7J,MAAA,GACA6J,EAAA1O,KAAA,IAAA4lE,GAAAtqB,GAAA39C,KAAAoR,GAAAusC,GAAA39C,KAAAqR,GAAAD,KACA27D,GAAA/sE,KAAAkoE,GAAAloE,KAAAhM,GAAA+c,EAAAA,EAAAzf,OAAA,GAAAqiB,EAHA,IAMAsZ,aAAA,SAAAmmD,GAEA,IADA,IAAA/6D,EAAAtH,EAAA/Q,KAAA6R,IAAAd,OACA1f,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAAwgB,EAAA6qC,GAAA18C,KAAA+Q,EAAA1f,GAAAqF,OAAAqa,EAAA1f,GAAAsF,MACA0hB,EAAAA,EAAAA,EAAAiF,OAAAzL,GAAAA,CAFA,CAIA,OAAA,IAAAuhE,EAAA/6D,EACAA,EAAA6E,KAAAk2D,GAAApzE,KAAAuuC,gBAPA,EASAW,cAAA,SAAAkkC,GAEA,IADA,IAAApE,EAAA,GAAAj+D,EAAA/Q,KAAA6R,IAAAd,OACA1f,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAAwgB,EAAA6qC,GAAA18C,KAAA+Q,EAAA1f,GAAAqF,OAAAqa,EAAA1f,GAAAsF,OACA,IAAAy8E,IAAAvhE,EAAAA,EAAAqL,KAAAk2D,GAAApzE,KAAAuuC,kBACAygC,EAAA39E,GAAAwgB,CAHA,CAKA,OAAAm9D,CAPA,EASAxgC,iBAAA,SAAAj7C,EAAAu/C,EAAA6B,GAEA,IADA,IAAAg/B,EAAA,GACAtiF,EAAA,EAAAA,EAAA2O,KAAA6R,IAAAd,OAAAzf,OAAAD,IACAsiF,EAAAtiF,GAAAkC,EACAyM,KAAA0qC,kBAAAipC,EAAA7gC,EAAA6B,GAAA,SAJA,EAMAjK,kBAAA63B,IAAA,SAAAhvE,EAAAu/C,EAAA6B,GAEA,IADA,IAAAiV,EAAA,GAAA/3C,EAAA7R,KAAA6R,IACAxgB,EAAA,EAAAA,EAAAwgB,EAAAd,OAAAzf,OAAAD,IAAA,CACA,IAAA4f,EAAAY,EAAAd,OAAA1f,GACAu4D,EAAAv4D,GAAA,CAAAqF,KAAAua,EAAAva,OAAAC,GAAAsa,EAAAta,KAAAZ,KAAAiK,KAAAywE,WAAAl9E,EAAAlC,IAAAsjD,OAAAA,EAFA,CAKA,IADA,IAAAi/B,EAAA9gC,GAAA,OAAAA,GA3hDA,SAAAX,EAAAyX,EAAAtvC,GAGA,IAFA,IAAAoT,EAAA,GACAmmD,EAAAj8D,GAAAu6B,EAAAld,MAAA,GAAA6+C,EAAAD,EACAxiF,EAAA,EAAAA,EAAAu4D,EAAAt4D,OAAAD,IAAA,CACA,IAAA6D,EAAA00D,EAAAv4D,GACAqF,EAAAiyE,GAAAzzE,EAAAwB,KAAAm9E,EAAAC,GACAn9E,EAAAgyE,GAAAH,GAAAtzE,GAAA2+E,EAAAC,GAGA,GAFAD,EAAA3+E,EAAAyB,GACAm9E,EAAAn9E,EACA,UAAA2jB,EAAA,CACA,IAAArJ,EAAAkhC,EAAAtgC,IAAAd,OAAA1f,GAAAi3E,EAAAh8B,GAAAr7B,EAAAI,KAAAJ,EAAAG,QAAA,EACAsc,EAAAr8B,GAAA,IAAA42E,GAAAK,EAAA3xE,EAAAD,EAAA4xE,EAAA5xE,EAAAC,EAFA,MAIA+2B,EAAAr8B,GAAA,IAAA42E,GAAAvxE,EAAAA,EAVA,CAaA,OAAA,IAAAmxE,GAAAn6C,EAAAykB,EAAAtgC,IAAAykD,UAhBA,CA2hDAyd,CAAA/zE,KAAA4pD,EAAA9W,GACAoE,EAAA0S,EAAAt4D,OAAA,EAAA4lD,GAAA,EAAAA,IACA23B,GAAA7uE,KAAA4pD,EAAA1S,IACA08B,EAAAxG,GAAAptE,KAAA4zE,GACA5zE,KAAAhM,IAAAonE,GAAAp7D,KAAAhM,GAVA,IAYAggF,KAAAzR,IAAA,WAAAmN,GAAA1vE,KAAA,OAAA,IACAi0E,KAAA1R,IAAA,WAAAmN,GAAA1vE,KAAA,OAAA,IACAk0E,cAAA3R,IAAA,WAAAmN,GAAA1vE,KAAA,QAAA,EAAA,IACAm0E,cAAA5R,IAAA,WAAAmN,GAAA1vE,KAAA,QAAA,EAAA,IAEAo0E,aAAA,SAAAj/E,GAAA6K,KAAAkkE,OAAA/uE,CAAA,EACAk/E,aAAA,WAAA,OAAAr0E,KAAAkkE,MAAA,EAEAoQ,YAAA,WAEA,IADA,IAAA7I,EAAAzrE,KAAA0rE,QAAAnB,EAAA,EAAAC,EAAA,EACAn5E,EAAA,EAAAA,EAAAo6E,EAAAlB,KAAAj5E,OAAAD,IAAAo6E,EAAAlB,KAAAl5E,GAAA0f,UAAAw5D,EACA,IAAA,IAAArzB,EAAA,EAAAA,EAAAu0B,EAAAjB,OAAAl5E,OAAA4lD,IAAAu0B,EAAAjB,OAAAtzB,GAAAnmC,UAAAy5D,EACA,MAAA,CAAAwJ,KAAAzJ,EAAA0J,KAAAzJ,EAJA,EAMAkI,aAAA,WACA,IAAAb,EAAA7xE,KAEAA,KAAA0rE,QAAA,IAAApB,GAAAtqE,KAAA0rE,SACA7B,GAAA7pE,MAAA,SAAAmyC,GAAA,OAAAA,EAAAu5B,QAAAmG,EAAAnG,OAAA,IAAA,EAJA,EAOA6I,UAAA,WACAv0E,KAAAqzE,gBAAArzE,KAAAw0E,kBAAA,EADA,EAGAA,iBAAA,SAAAC,GAGA,OAFAA,IACAz0E,KAAA0rE,QAAAd,OAAA5qE,KAAA0rE,QAAAb,UAAA7qE,KAAA0rE,QAAAZ,WAAA,MACA9qE,KAAA0rE,QAAAV,UAHA,EAKA0J,QAAA,SAAAC,GACA,OAAA30E,KAAA0rE,QAAAV,aAAA2J,GAAA30E,KAAAqzE,gBADA,EAIAuB,WAAA,WACA,MAAA,CAAArK,KAAAkC,GAAAzsE,KAAA0rE,QAAAnB,MACAC,OAAAiC,GAAAzsE,KAAA0rE,QAAAlB,QAFA,EAIAqK,WAAA,SAAAC,GACA,IAAArJ,EAAAzrE,KAAA0rE,QAAA,IAAApB,GAAAtqE,KAAA0rE,SACAD,EAAAlB,KAAAkC,GAAAqI,EAAAvK,KAAArjE,MAAA,GAAA,MAAA,GACAukE,EAAAjB,OAAAiC,GAAAqI,EAAAtK,OAAAtjE,MAAA,GAAA,MAAA,EAHA,EAMAyR,gBAAA4pD,IAAA,SAAA3oE,EAAAm7E,EAAAjqE,GACA,OAAAgmE,GAAA9wE,KAAApG,EAAA,UAAA,SAAAA,GACA,IAAAmxD,EAAAnxD,EAAAoxD,gBAAApxD,EAAAoxD,cAAA,CAAA,GAGA,OAFAD,EAAAgqB,GAAAjqE,GACAA,GAAA4qC,GAAAqV,KAAAnxD,EAAAoxD,cAAA,OACA,CAJA,GADA,IASAt0C,YAAA6rD,IAAA,SAAAwS,GACA,IAAAlD,EAAA7xE,KAEAA,KAAA2sC,MAAA,SAAA/yC,GACAA,EAAAoxD,eAAApxD,EAAAoxD,cAAA+pB,IACAjE,GAAAe,EAAAj4E,EAAA,UAAA,WAGA,OAFAA,EAAAoxD,cAAA+pB,GAAA,KACAr/B,GAAA97C,EAAAoxD,iBAAApxD,EAAAoxD,cAAA,OACA,CAHA,GAFA,GAHA,IAcAgqB,SAAA,SAAAp7E,GACA,IAAA3G,EACA,GAAA,iBAAA2G,EAAA,CACA,IAAAsjD,GAAAl9C,KAAApG,GAAA,OAAA,KAGA,GAFA3G,EAAA2G,IACAA,EAAAozB,GAAAhtB,KAAApG,IACA,OAAA,IAJA,MAOA,GAAA,OADA3G,EAAAk1C,GAAAvuC,IACA,OAAA,KAEA,MAAA,CAAAA,KAAA3G,EAAA8+B,OAAAn4B,EAAA7D,KAAA6D,EAAA7D,KAAAi1D,cAAApxD,EAAAoxD,cACAzL,UAAA3lD,EAAA2lD,UAAAD,QAAA1lD,EAAA0lD,QAAAzoC,UAAAjd,EAAAid,UACAk1C,QAAAnyD,EAAAmyD,QAbA,EAgBAp6C,aAAA4wD,IAAA,SAAAxwC,EAAAyV,EAAA8J,GACA,OAAAw/B,GAAA9wE,KAAA+xB,EAAA,UAAAyV,EAAA,SAAA,SAAA,SAAA5tC,GACA,IAAA6E,EAAA,QAAA+oC,EAAA,YACA,cAAAA,EAAA,UACA,UAAAA,EAAA,cAAA,YACA,GAAA5tC,EAAA6E,GACA,IAAA4yC,EAAAC,GAAAp5C,KAAA0B,EAAA6E,IAAA,OAAA,EACA7E,EAAA6E,IAAA,IAAA6yC,CAAA,MAFA13C,EAAA6E,GAAA6yC,EAGA,OAAA,CAPA,GADA,IAWAzgC,gBAAA0xD,IAAA,SAAAxwC,EAAAyV,EAAA8J,GACA,OAAAw/B,GAAA9wE,KAAA+xB,EAAA,UAAAyV,EAAA,SAAA,SAAA,SAAA5tC,GACA,IAAA6E,EAAA,QAAA+oC,EAAA,YACA,cAAAA,EAAA,UACA,UAAAA,EAAA,cAAA,YACAvuC,EAAAW,EAAA6E,GACA,IAAAxF,EAAA,OAAA,EACA,GAAA,MAAAq4C,EAAA13C,EAAA6E,GAAA,SACA,CACA,IAAAua,EAAA/f,EAAAhD,MAAAo7C,EAAAC,IACA,IAAAt4B,EAAA,OAAA,EACA,IAAAtL,EAAAsL,EAAAjR,MAAAiR,EAAA,GAAA1nB,OACAsI,EAAA6E,GAAAxF,EAAAiO,MAAA,EAAA8R,EAAAjR,QAAAiR,EAAAjR,OAAA2F,GAAAzU,EAAA3H,OAAA,IAAA,IAAA2H,EAAAiO,MAAAwG,IAAA,IAJA,CAMA,OAAA,CAbA,GADA,IAkBAunE,cAAA1S,IAAA,SAAAxwC,EAAArf,EAAAiB,GACA,OA/jBA,SAAAw+B,EAAApgB,EAAArf,EAAAiB,GACA,IAAAgZ,EAAA,IAAAglD,GAAAx/B,EAAAz/B,EAAAiB,GACA3f,EAAAm+C,EAAAn+C,GAgBA,OAfAA,GAAA24B,EAAAy/B,YAAAp4D,EAAAu9B,QAAA4zC,cAAA,GACA2L,GAAA3+B,EAAApgB,EAAA,UAAA,SAAAn4B,GACA,IAAAmyD,EAAAnyD,EAAAmyD,UAAAnyD,EAAAmyD,QAAA,IAIA,GAHA,MAAAp/B,EAAAuoD,SAAAnpB,EAAA1pD,KAAAsqB,GACAo/B,EAAAjuC,OAAA9K,KAAAK,IAAA04C,EAAAz6D,OAAA0hB,KAAAC,IAAA,EAAA0Z,EAAAuoD,WAAA,EAAAvoD,GACAA,EAAA/yB,KAAAA,EACA5F,IAAAixD,GAAA9S,EAAAv4C,GAAA,CACA,IAAAu7E,EAAA/vB,GAAAxrD,GAAAu4C,EAAA7hB,UACAssB,GAAAhjD,EAAAA,EAAAu3B,OAAAs7B,GAAA9/B,IACAwoD,GAAAja,GAAAlnE,EAAA24B,EAAAwE,QACAn9B,EAAAqlD,MAAA+U,aAAA,CAJA,CAMA,OAAA,CAXA,IAaAp6D,GAAAs1D,GAAAt1D,EAAA,kBAAAA,EAAA24B,EAAA,iBAAAoF,EAAAA,EAAAoW,GAAApW,IACApF,CAlBA,CA+jBAsoD,CAAAj1E,KAAA+xB,EAAArf,EAAAiB,EADA,IAGAyhE,iBAAA,SAAAzoD,GAAAA,EAAA5V,OAAA,EAEA2B,SAAA,SAAAhiB,EAAAC,EAAAgd,GACA,OAAA+E,GAAA1Y,KAAA29C,GAAA39C,KAAAtJ,GAAAinD,GAAA39C,KAAArJ,GAAAgd,EAAAA,GAAAA,EAAAtV,MAAA,QADA,EAGAg3E,YAAA,SAAAptE,EAAA0L,GACA,IAAA2hE,EAAA,CAAAlD,aAAAz+D,IAAA,MAAAA,EAAAW,SAAAX,EAAAgZ,OAAAhZ,GACA8uC,WAAA9uC,GAAAA,EAAA8uC,WACAa,gBAAA,EAAA6mB,OAAAx2D,GAAAA,EAAAw2D,OACAle,kBAAAt4C,GAAAA,EAAAs4C,mBAEA,OAAAvzC,GAAA1Y,KADAiI,EAAA01C,GAAA39C,KAAAiI,GACAA,EAAAqtE,EAAA,WANA,EAQA7/D,YAAA,SAAAxN,GAEA,IAAA8iD,EAAA,GAAAv1C,EAAAwX,GAAAhtB,MADAiI,EAAA01C,GAAA39C,KAAAiI,IACArO,MAAAwoD,YACA,GAAA5sC,EAAA,IAAA,IAAAnkB,EAAA,EAAAA,EAAAmkB,EAAAlkB,SAAAD,EAAA,CACA,IAAAmpC,EAAAhlB,EAAAnkB,IACA,MAAAmpC,EAAA9jC,MAAA8jC,EAAA9jC,MAAAuR,EAAAnJ,MACA,MAAA07B,EAAA7jC,IAAA6jC,EAAA7jC,IAAAsR,EAAAnJ,KACAisD,EAAA1oD,KAAAm4B,EAAApjB,OAAAu6B,QAAAnX,EAAApjB,OAJA,CAMA,OAAA2zC,CATA,EAWAgoB,UAAA,SAAAr8E,EAAAC,EAAAm5E,GACAp5E,EAAAinD,GAAA39C,KAAAtJ,GAAAC,EAAAgnD,GAAA39C,KAAArJ,GACA,IAAAqiB,EAAA,GAAAmvB,EAAAzxC,EAAAkD,KAaA,OAZAoG,KAAA2sC,KAAAj2C,EAAAkD,KAAAjD,EAAAiD,KAAA,GAAA,SAAAA,GACA,IAAA4b,EAAA5b,EAAAwoD,YACA,GAAA5sC,EAAA,IAAA,IAAAnkB,EAAA,EAAAA,EAAAmkB,EAAAlkB,OAAAD,IAAA,CACA,IAAAmpC,EAAAhlB,EAAAnkB,GACA,MAAAmpC,EAAA7jC,IAAAwxC,GAAAzxC,EAAAkD,MAAAlD,EAAAoI,IAAA07B,EAAA7jC,IACA,MAAA6jC,EAAA9jC,MAAAyxC,GAAAzxC,EAAAkD,MACA,MAAA4gC,EAAA9jC,MAAAyxC,GAAAxxC,EAAAiD,MAAA4gC,EAAA9jC,MAAAC,EAAAmI,IACAgxE,IAAAA,EAAAt1C,EAAApjB,SACA4B,EAAA3W,KAAAm4B,EAAApjB,OAAAu6B,QAAAnX,EAAApjB,OANA,GAQA+wB,CAVA,IAYAnvB,CAfA,EAiBAu8D,YAAA,WACA,IAAAxqB,EAAA,GAMA,OALA/qD,KAAA2sC,MAAA,SAAA/yC,GACA,IAAAwqD,EAAAxqD,EAAAwoD,YACA,GAAAgC,EAAA,IAAA,IAAA/yD,EAAA,EAAAA,EAAA+yD,EAAA9yD,SAAAD,EACA,MAAA+yD,EAAA/yD,GAAAqF,MAAAq0D,EAAA1oD,KAAA+hD,EAAA/yD,GAAA+lB,OAHA,IAKA2zC,CAPA,EAUAyqB,aAAA,SAAAvjE,GACA,IAAAnT,EAAAqpC,EAAAnoC,KAAAi1B,MAAAwgD,EAAAz1E,KAAAuuC,gBAAAj9C,OAOA,OANA0O,KAAA2sC,MAAA,SAAA/yC,GACA,IAAA4iD,EAAA5iD,EAAA7D,KAAAzE,OAAAmkF,EACA,GAAAj5B,EAAAvqC,EAAA,OAAAnT,EAAAmT,GAAA,EACAA,GAAAuqC,IACArU,CAJA,IAMAwV,GAAA39C,KAAA4X,GAAAuwB,EAAArpC,GARA,EAUA42E,aAAA,SAAA58C,GAEA,IAAA/wB,GADA+wB,EAAA6kB,GAAA39C,KAAA84B,IACAh6B,GACA,GAAAg6B,EAAAl/B,KAAAoG,KAAAi1B,OAAA6D,EAAAh6B,GAAA,EAAA,OAAA,EACA,IAAA22E,EAAAz1E,KAAAuuC,gBAAAj9C,OAIA,OAHA0O,KAAA2sC,KAAA3sC,KAAAi1B,MAAA6D,EAAAl/B,MAAA,SAAAA,GACAmO,GAAAnO,EAAA7D,KAAAzE,OAAAmkF,CADA,IAGA1tE,CARA,EAWAi5C,KAAA,SAAA20B,GACA,IAAAxjC,EAAA,IAAAghC,GAAAx2B,GAAA38C,KAAAA,KAAAi1B,MAAAj1B,KAAAi1B,MAAAj1B,KAAA48B,MACA58B,KAAA6oE,WAAA7oE,KAAAi1B,MAAAj1B,KAAAozE,QAAApzE,KAAAg3C,WAQA,OAPA7E,EAAA7hB,UAAAtwB,KAAAswB,UAAA6hB,EAAA9hB,WAAArwB,KAAAqwB,WACA8hB,EAAAtgC,IAAA7R,KAAA6R,IACAsgC,EAAA+xB,QAAA,EACAyR,IACAxjC,EAAAu5B,QAAAjB,UAAAzqE,KAAA0rE,QAAAjB,UACAt4B,EAAA0iC,WAAA70E,KAAA40E,eAEAziC,CAVA,EAaAyjC,UAAA,SAAAjiE,GACAA,IAAAA,EAAA,CAAA,GACA,IAAAjd,EAAAsJ,KAAAi1B,MAAAt+B,EAAAqJ,KAAAi1B,MAAAj1B,KAAA48B,KACA,MAAAjpB,EAAAjd,MAAAid,EAAAjd,KAAAA,IAAAA,EAAAid,EAAAjd,MACA,MAAAid,EAAAhd,IAAAgd,EAAAhd,GAAAA,IAAAA,EAAAgd,EAAAhd,IACA,IAAAqqD,EAAA,IAAAmyB,GAAAx2B,GAAA38C,KAAAtJ,EAAAC,GAAAgd,EAAAvf,MAAA4L,KAAA6oE,WAAAnyE,EAAAsJ,KAAAozE,QAAApzE,KAAAg3C,WAKA,OAJArjC,EAAAs2D,aAAAjpB,EAAA0qB,QAAA1rE,KAAA0rE,UACA1rE,KAAAkqE,SAAAlqE,KAAAkqE,OAAA,KAAA7nE,KAAA,CAAA8vC,IAAA6O,EAAAipB,WAAAt2D,EAAAs2D,aACAjpB,EAAAkpB,OAAA,CAAA,CAAA/3B,IAAAnyC,KAAAiyE,UAAA,EAAAhI,WAAAt2D,EAAAs2D,aAhZA,SAAA93B,EAAA4Y,GACA,IAAA,IAAA15D,EAAA,EAAAA,EAAA05D,EAAAz5D,OAAAD,IAAA,CACA,IAAA+lB,EAAA2zC,EAAA15D,GAAA4W,EAAAmP,EAAA9hB,OACAugF,EAAA1jC,EAAAwL,QAAA11C,EAAAvR,MAAAo/E,EAAA3jC,EAAAwL,QAAA11C,EAAAtR,IACA,GAAA21C,GAAAupC,EAAAC,GAAA,CACA,IAAAC,EAAAr9D,GAAAy5B,EAAA0jC,EAAAC,EAAA1+D,EAAAq4B,QAAAr4B,EAAAq4B,QAAApxC,MACA+Y,EAAA2zC,QAAA1oD,KAAA0zE,GACAA,EAAApkC,OAAAv6B,CAHA,CAHA,CADA,CAiZA4+D,CAAAh1B,EAAA8xB,GAAA9yE,OACAghD,CAVA,EAYAi1B,UAAA,SAAApvC,GAEA,GADAA,aAAAjzC,KAAAizC,EAAAA,EAAAsL,KACAnyC,KAAAkqE,OAAA,IAAA,IAAA74E,EAAA,EAAAA,EAAA2O,KAAAkqE,OAAA54E,SAAAD,EAEA,GADA2O,KAAAkqE,OAAA74E,GACA8gD,KAAAtL,EAAA,CACA7mC,KAAAkqE,OAAApsD,OAAAzsB,EAAA,GACAw1C,EAAAovC,UAAAj2E,MACAgzE,GAAAF,GAAA9yE,OACA,KAJA,CAOA,GAAA6mC,EAAA6kC,SAAA1rE,KAAA0rE,QAAA,CACA,IAAAwK,EAAA,CAAArvC,EAAAhvB,IACAgyD,GAAAhjC,GAAA,SAAAsL,GAAA,OAAA+jC,EAAA7zE,KAAA8vC,EAAAt6B,GAAA,IAAA,GACAgvB,EAAA6kC,QAAA,IAAApB,GAAA,MACAzjC,EAAA6kC,QAAAnB,KAAAkC,GAAAzsE,KAAA0rE,QAAAnB,KAAA2L,GACArvC,EAAA6kC,QAAAlB,OAAAiC,GAAAzsE,KAAA0rE,QAAAlB,OAAA0L,EALA,CAXA,EAmBAC,eAAA,SAAA9iF,GAAAw2E,GAAA7pE,KAAA3M,EAAA,EAEA+D,QAAA,WAAA,OAAA4I,KAAA5L,IAAA,EACAgiF,UAAA,WAAA,OAAAp2E,KAAAhM,EAAA,EAEAy8E,WAAA,SAAAp3D,GACA,OAAArZ,KAAAozE,QAAA/5D,EAAA0C,MAAA/b,KAAAozE,SACAv4B,GAAAxhC,EAFA,EAIAk1B,cAAA,WAAA,OAAAvuC,KAAAozE,SAAA,IAAA,EAEAiD,aAAA9T,IAAA,SAAA/lE,GA9oDA,IAAAxI,EA+oDA,OAAAwI,IAAAA,EAAA,OACAA,GAAAwD,KAAAg3C,YACAh3C,KAAAg3C,UAAAx6C,EACAwD,KAAA2sC,MAAA,SAAA/yC,GAAA,OAAAA,EAAA08C,MAAA,IAAA,IACAt2C,KAAAhM,IAlpDAquE,GADAruE,EAmpDAgM,KAAAhM,IAlpDA,WACAq2E,GAAAr2E,GACA+gE,GAAA/gE,EAFA,IA6oDA,MAUAm/E,GAAAjhF,UAAAykB,SAAAw8D,GAAAjhF,UAAAy6C,KAIA,IAAA2pC,GAAA,EAEA,SAAAC,GAAA/jF,GACA,IAAAwB,EAAAgM,KAEA,GADAw2E,GAAAxiF,IACA+kD,GAAA/kD,EAAAxB,KAAAo6D,GAAA54D,EAAAu9B,QAAA/+B,GAAA,CAEAknD,GAAAlnD,GACAw9C,IAAAsmC,IAAA,IAAAliC,MACA,IAAAnsC,EAAAusD,GAAAxgE,EAAAxB,GAAA,GAAAikF,EAAAjkF,EAAAkkF,aAAAD,MACA,GAAAxuE,IAAAjU,EAAA2iF,aAGA,GAAAF,GAAAA,EAAAnlF,QAAAwD,OAAA8hF,YAAA9hF,OAAA+hF,KAkCA,IAjCA,IAAA5jF,EAAAwjF,EAAAnlF,OAAAyE,EAAAupB,MAAArsB,GAAA6jF,EAAA,EACAC,EAAA,aACAD,GAAA7jF,GACAye,GAAA1d,GAAA,WAEA,IAAAkB,EAAA,CAAAwB,KADAuR,EAAA01C,GAAA3pD,EAAAm+C,IAAAlqC,GACAtR,GAAAsR,EACAlS,KAAA/B,EAAAm+C,IAAAs+B,WACA16E,EAAA+5E,QAAA,SAAA39E,GAAA,OAAA,MAAAA,CAAA,IAAA+qB,KAAAlpB,EAAAm+C,IAAA5D,kBACAoG,OAAA,SACAk6B,GAAA76E,EAAAm+C,IAAAj9C,GACAk4E,GAAAp5E,EAAAm+C,IAAAo2B,GAAA5qB,GAAA3pD,EAAAm+C,IAAAlqC,GAAA01C,GAAA3pD,EAAAm+C,IAAAq2B,GAAAtzE,KAPA,GAAAwc,EAFA,EAaAslE,EAAA,SAAAC,EAAA5lF,GACA,GAAA2C,EAAA2f,QAAAujE,qBACA,GAAArvE,EAAA7T,EAAA2f,QAAAujE,mBAAAD,EAAA54E,MACA04E,QAFA,CAKA,IAAAI,EAAA,IAAAP,WACAO,EAAAC,QAAA,WAAA,OAAAL,GAAA,EACAI,EAAAE,OAAA,WACA,IAAA70E,EAAA20E,EAAA3sE,OACA,0BAAAtS,KAAAsK,KAIAzM,EAAA1E,GAAAmR,GAHAu0E,GAHA,EASAI,EAAAG,WAAAL,EAfA,CAFA,EAmBA5lF,EAAA,EAAAA,EAAAolF,EAAAnlF,OAAAD,IAAA2lF,EAAAP,EAAAplF,GAAAA,OACA,CAEA,GAAA2C,EAAA+D,MAAAwhE,cAAAvlE,EAAAm+C,IAAAtgC,IAAAigC,SAAA7pC,IAAA,EAIA,OAHAjU,EAAA+D,MAAAwhE,aAAA/mE,QAEA2hB,YAAA,WAAA,OAAAngB,EAAAu9B,QAAA12B,MAAAu5B,OAAA,GAAA,IAGA,IACA,IAAAmjD,EAAA/kF,EAAAkkF,aAAAc,QAAA,QACA,GAAAD,EAAA,CACA,IAAAr5C,EAIA,GAHAlqC,EAAA+D,MAAAwhE,eAAAvlE,EAAA+D,MAAAwhE,aAAAvY,OACA9iB,EAAAlqC,EAAAke,kBACAm7D,GAAAr5E,EAAAm+C,IAAAo2B,GAAAtgE,EAAAA,IACAi2B,EAAA,IAAA,IAAAgZ,EAAA,EAAAA,EAAAhZ,EAAA5sC,SAAA4lD,EACAviB,GAAA3gC,EAAAm+C,IAAA,GAAAjU,EAAAgZ,GAAA9lC,OAAA8sB,EAAAgZ,GAAA7lC,KAAA,QACArd,EAAAw6C,iBAAA+oC,EAAA,SAAA,SACAvjF,EAAAu9B,QAAA12B,MAAAu5B,OARA,CAFA,CAaA,MAAAwgC,GAAA,CArBA,CA1CA,CAJA,CA0GA,SAAA4hB,GAAAxiF,GACAA,EAAAu9B,QAAAkmD,aACAzjF,EAAAu9B,QAAA07B,UAAAz6C,YAAAxe,EAAAu9B,QAAAkmD,YACAzjF,EAAAu9B,QAAAkmD,WAAA,KAHA,CAWA,SAAAC,GAAArkF,GACA,GAAAwf,SAAA8kE,uBAAA,CAEA,IADA,IAAAC,EAAA/kE,SAAA8kE,uBAAA,cAAAE,EAAA,GACAxmF,EAAA,EAAAA,EAAAumF,EAAAtmF,OAAAD,IAAA,CACA,IAAA2C,EAAA4jF,EAAAvmF,GAAAuC,WACAI,GAAA6jF,EAAAx1E,KAAArO,EAFA,CAIA6jF,EAAAvmF,QAAAumF,EAAA,GAAAnmE,WAAA,WACA,IAAA,IAAArgB,EAAA,EAAAA,EAAAwmF,EAAAvmF,OAAAD,IAAAgC,EAAAwkF,EAAAxmF,GADA,GANA,CADA,CAYA,IAAAymF,IAAA,EACA,SAAAC,KAKA,IAEAC,EANAF,KAOAtiF,GAAAV,OAAA,UAAA,WACA,MAAAkjF,IAAAA,EAAA7jE,YAAA,WACA6jE,EAAA,KACAN,GAAAO,GAFA,GAGA,KAJA,IAOAziF,GAAAV,OAAA,QAAA,WAAA,OAAA4iF,GAAA9jD,GAAA,IAZAkkD,IAAA,EAHA,CAkBA,SAAAG,GAAAjkF,GACA,IAAAyxD,EAAAzxD,EAAAu9B,QAEAk0B,EAAA0L,gBAAA1L,EAAA2L,iBAAA3L,EAAA2H,eAAA,KACA3H,EAAA6a,mBAAA,EACAtsE,EAAAkkF,SALA,CAoBA,IAZA,IAAAC,GAAA,CACA,EAAA,QAAA,EAAA,YAAA,EAAA,MAAA,GAAA,QAAA,GAAA,QAAA,GAAA,OAAA,GAAA,MACA,GAAA,QAAA,GAAA,WAAA,GAAA,MAAA,GAAA,QAAA,GAAA,SAAA,GAAA,WAAA,GAAA,MACA,GAAA,OAAA,GAAA,OAAA,GAAA,KAAA,GAAA,QAAA,GAAA,OAAA,GAAA,YAAA,GAAA,SACA,GAAA,SAAA,GAAA,IAAA,GAAA,IAAA,GAAA,MAAA,GAAA,MAAA,GAAA,MACA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,aACA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KACA,IAAA,IAAA,IAAA,IAAA,IAAA,MAAA,MAAA,KAAA,MAAA,OAAA,MAAA,OAAA,MAAA,QAAA,MAAA,SACA,MAAA,OAAA,MAAA,MAAA,MAAA,SAAA,MAAA,WAAA,MAAA,UAIA9mF,GAAA,EAAAA,GAAA,GAAAA,KAAA8mF,GAAA9mF,GAAA,IAAA8mF,GAAA9mF,GAAA,IAAAiB,OAAAjB,IAEA,IAAA,IAAA6lD,GAAA,GAAAA,IAAA,GAAAA,KAAAihC,GAAAjhC,IAAA5kD,OAAA8lF,aAAAlhC,IAEA,IAAA,IAAAC,GAAA,EAAAA,IAAA,GAAAA,KAAAghC,GAAAhhC,GAAA,KAAAghC,GAAAhhC,GAAA,OAAA,IAAAA,GAEA,IAAArlB,GAAA,CAAA,EA4CA,SAAAumD,GAAAhhF,GACA,IAEAwhC,EAAAy/C,EAAAlwD,EAAAmwD,EAFAvJ,EAAA33E,EAAA0kB,MAAA,UACA1kB,EAAA23E,EAAAA,EAAA19E,OAAA,GAEA,IAAA,IAAAD,EAAA,EAAAA,EAAA29E,EAAA19E,OAAA,EAAAD,IAAA,CACA,IAAAoE,EAAAu5E,EAAA39E,GACA,GAAA,kBAAA6G,KAAAzC,GAAA8iF,GAAA,OACA,GAAA,YAAArgF,KAAAzC,GAAAojC,GAAA,OACA,GAAA,sBAAA3gC,KAAAzC,GAAA6iF,GAAA,MACA,KAAA,cAAApgF,KAAAzC,GACA,MAAA,IAAAnC,MAAA,+BAAAmC,GADA2yB,GAAA,CACA,CANA,CAYA,OAJAyQ,IAAAxhC,EAAA,OAAAA,GACAihF,IAAAjhF,EAAA,QAAAA,GACAkhF,IAAAlhF,EAAA,OAAAA,GACA+wB,IAAA/wB,EAAA,SAAAA,GACAA,CAhBA,CAwBA,SAAAmhF,GAAAC,GACA,IAAAz3B,EAAA,CAAA,EACA,IAAA,IAAA03B,KAAAD,EAAA,GAAAA,EAAApgF,eAAAqgF,GAAA,CACA,IAAA5tE,EAAA2tE,EAAAC,GACA,GAAA,mCAAAxgF,KAAAwgF,GAAA,SACA,GAAA,OAAA5tE,EAAA,QAAA2tE,EAAAC,GAAA,QAAA,CAGA,IADA,IAAAvtD,EAAAjD,GAAAwwD,EAAA38D,MAAA,KAAAs8D,IACAhnF,EAAA,EAAAA,EAAA85B,EAAA75B,OAAAD,IAAA,CACA,IAAA8D,OAAA,EAAAkC,OAAA,EACAhG,GAAA85B,EAAA75B,OAAA,GACA+F,EAAA8zB,EAAAjO,KAAA,KACA/nB,EAAA2V,IAEAzT,EAAA8zB,EAAAjkB,MAAA,EAAA7V,EAAA,GAAA6rB,KAAA,KACA/nB,EAAA,OAEA,IAAA8K,EAAA+gD,EAAA3pD,GACA,GAAA4I,GACA,GAAAA,GAAA9K,EAAA,MAAA,IAAA7B,MAAA,6BAAA+D,QADA2pD,EAAA3pD,GAAAlC,CAVA,QAaAsjF,EAAAC,EAnBA,CAqBA,IAAA,IAAAj6E,KAAAuiD,EAAAy3B,EAAAh6E,GAAAuiD,EAAAviD,GACA,OAAAg6E,CAxBA,CA2BA,SAAAE,GAAA7mF,EAAAo2B,EAAA6J,EAAA7xB,GAEA,IAAA8Y,GADAkP,EAAA0wD,GAAA1wD,IACAv1B,KAAAu1B,EAAAv1B,KAAAb,EAAAoO,GAAAgoB,EAAAp2B,GACA,IAAA,IAAAknB,EAAA,MAAA,UACA,GAAA,QAAAA,EAAA,MAAA,QACA,GAAA,MAAAA,GAAA+Y,EAAA/Y,GAAA,MAAA,UAEA,GAAAkP,EAAA2wD,YAAA,CACA,GAAA,kBAAAlnF,OAAAO,UAAAqiD,SAAA5hD,KAAAu1B,EAAA2wD,aACA,OAAAF,GAAA7mF,EAAAo2B,EAAA2wD,YAAA9mD,EAAA7xB,GACA,IAAA,IAAA7O,EAAA,EAAAA,EAAA62B,EAAA2wD,YAAAvnF,OAAAD,IAAA,CACA,IAAAmZ,EAAAmuE,GAAA7mF,EAAAo2B,EAAA2wD,YAAAxnF,GAAA0gC,EAAA7xB,GACA,GAAAsK,EAAA,OAAAA,CAFA,CAHA,CAPA,CAmBA,SAAAsuE,GAAAhuE,GACA,IAAAzT,EAAA,iBAAAyT,EAAAA,EAAAqtE,GAAArtE,EAAAiuE,SACA,MAAA,QAAA1hF,GAAA,OAAAA,GAAA,SAAAA,GAAA,OAAAA,CAFA,CAKA,SAAA2hF,GAAA3hF,EAAA0mB,EAAAk7D,GACA,IAAA5+E,EAAAhD,EAKA,OAJA0mB,EAAAm7D,QAAA,OAAA7+E,IAAAhD,EAAA,OAAAA,IACA85C,EAAApzB,EAAAo7D,QAAAp7D,EAAAo8B,UAAA,QAAA9/C,IAAAhD,EAAA,QAAAA,IACA85C,EAAApzB,EAAAo8B,QAAAp8B,EAAAo7D,UAAA,OAAA9+E,IAAAhD,EAAA,OAAAA,IACA4hF,GAAAl7D,EAAAq7D,UAAA,SAAA/+E,IAAAhD,EAAA,SAAAA,GACAA,CANA,CAUA,SAAAgiF,GAAAt7D,EAAAk7D,GACA,GAAA3oC,GAAA,IAAAvyB,EAAAg7D,SAAAh7D,EAAA,KAAA,OAAA,EACA,IAAA1mB,EAAA8gF,GAAAp6D,EAAAg7D,SACA,OAAA,MAAA1hF,IAAA0mB,EAAAu7D,cAGA,GAAAv7D,EAAAg7D,SAAAh7D,EAAAxqB,OAAA8D,EAAA0mB,EAAAxqB,MACAylF,GAAA3hF,EAAA0mB,EAAAk7D,GAPA,CAUA,SAAAL,GAAAzjF,GACA,MAAA,iBAAAA,EAAA28B,GAAA38B,GAAAA,CADA,CAMA,SAAAokF,GAAAvlF,EAAAwlF,GAIA,IAHA,IAAAzoE,EAAA/c,EAAAm+C,IAAAtgC,IAAAd,OAAA0oE,EAAA,GAGApoF,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CAEA,IADA,IAAAqoF,EAAAF,EAAAzoE,EAAA1f,IACAooF,EAAAnoF,QAAAg7C,GAAAotC,EAAAhjF,KAAAw+C,GAAAukC,GAAA9iF,KAAA,GAAA,CACA,IAAAgjF,EAAAF,EAAAvwE,MACA,GAAAojC,GAAAqtC,EAAAjjF,KAAAgjF,EAAAhjF,MAAA,EAAA,CACAgjF,EAAAhjF,KAAAijF,EAAAjjF,KACA,KAFA,CAFA,CAOA+iF,EAAAp3E,KAAAq3E,EATA,CAYArX,GAAAruE,GAAA,WACA,IAAA,IAAA3C,EAAAooF,EAAAnoF,OAAA,EAAAD,GAAA,EAAAA,IACAsjC,GAAA3gC,EAAAm+C,IAAA,GAAAsnC,EAAApoF,GAAAqF,KAAA+iF,EAAApoF,GAAAsF,GAAA,WACAykE,GAAApnE,EAHA,GAhBA,CAuBA,SAAA4lF,GAAAhgF,EAAAkF,EAAAtC,GACA,IAAArL,EAAA2kD,GAAAl8C,EAAA7D,KAAA+I,EAAAtC,EAAAA,GACA,OAAArL,EAAA,GAAAA,EAAAyI,EAAA7D,KAAAzE,OAAA,KAAAH,CAFA,CAKA,SAAA0oF,GAAAjgF,EAAAuN,EAAA3K,GACA,IAAAsC,EAAA86E,GAAAhgF,EAAAuN,EAAArI,GAAAtC,GACA,OAAA,MAAAsC,EAAA,KAAA,IAAA8Y,GAAAzQ,EAAAvN,KAAAkF,EAAAtC,EAAA,EAAA,QAAA,SAFA,CAKA,SAAAs9E,GAAAC,EAAA/lF,EAAAqxD,EAAAld,EAAA3rC,GACA,GAAAu9E,EAAA,CACA,OAAA/lF,EAAAm+C,IAAA6E,YAAAx6C,GAAAA,GACA,IAAA85C,EAAA+B,GAAAgN,EAAArxD,EAAAm+C,IAAA6E,WACA,GAAAV,EAAA,CACA,IAGAx3C,EAHAmpD,EAAAzrD,EAAA,EAAA04C,GAAAoB,GAAAA,EAAA,GAEAC,EADA/5C,EAAA,IAAA,GAAAyrD,EAAAlR,OACA,QAAA,SAQA,GAAAkR,EAAAlR,MAAA,GAAA,OAAA/iD,EAAAm+C,IAAA6E,UAAA,CACA,IAAAgjC,EAAAhsB,GAAAh6D,EAAAqxD,GACAvmD,EAAAtC,EAAA,EAAA6oD,EAAAtvD,KAAAzE,OAAA,EAAA,EACA,IAAA2oF,EAAAlsB,GAAA/5D,EAAAgmF,EAAAl7E,GAAA6Q,IACA7Q,EAAAi3C,IAAA,SAAAj3C,GAAA,OAAAivD,GAAA/5D,EAAAgmF,EAAAl7E,GAAA6Q,KAAAsqE,CAAA,GAAAz9E,EAAA,IAAA,GAAAyrD,EAAAlR,OAAAkR,EAAAvxD,KAAAuxD,EAAAtxD,GAAA,EAAAmI,GACA,UAAAy3C,IAAAz3C,EAAA86E,GAAAv0B,EAAAvmD,EAAA,GALA,MAMAA,EAAAtC,EAAA,EAAAyrD,EAAAtxD,GAAAsxD,EAAAvxD,KACA,OAAA,IAAAkhB,GAAAuwB,EAAArpC,EAAAy3C,EAlBA,CAHA,CAwBA,OAAA,IAAA3+B,GAAAuwB,EAAA3rC,EAAA,EAAA6oD,EAAAtvD,KAAAzE,OAAA,EAAAkL,EAAA,EAAA,SAAA,QAzBA,CAhLAs1B,GAAAooD,MAAA,CACAC,KAAA,aAAAC,MAAA,cAAAnoD,GAAA,WAAAE,KAAA,aACAM,IAAA,YAAAF,KAAA,mBAAAH,OAAA,WAAAE,SAAA,aACA+nD,OAAA,eAAAnsC,UAAA,gBAAA,kBAAA,gBACAtb,IAAA,aAAA,YAAA,aACAF,MAAA,mBAAA4nD,OAAA,kBACAznD,IAAA,mBAKAf,GAAAyoD,UAAA,CACA,SAAA,YAAA,SAAA,aAAA,SAAA,OAAA,eAAA,OAAA,SAAA,OACA,YAAA,aAAA,WAAA,WAAA,UAAA,WAAA,YAAA,aACA,YAAA,cAAA,aAAA,eAAA,WAAA,cAAA,YAAA,YACA,iBAAA,iBAAA,cAAA,gBAAA,SAAA,OAAA,SAAA,OACA,SAAA,WAAA,eAAA,WAAA,eAAA,UAAA,eAAA,aACA,SAAA,aAAA,SAAA,aACA,SAAA,gBAAA,eAAA,gBAAA,QAAA,gBACA1B,YAAA,SAGA/mD,GAAA0oD,OAAA,CACA,SAAA,cAAA,SAAA,aAAA,SAAA,WAAA,SAAA,aACA,SAAA,cAAA,SAAA,YAAA,SAAA,aAAA,eAAA,WACA,SAAA,eAAA,SAAA,gBAAA,gBAAA,gBAAA,SAAA,WACA,SAAA,iBAAA,SAAA,YAEA1oD,GAAA2oD,WAAA,CACA,QAAA,YAAA,QAAA,aAAA,QAAA,OAAA,cAAA,OAAA,QAAA,OACA,WAAA,aAAA,SAAA,aAAA,UAAA,WAAA,WAAA,WAAA,WAAA,cACA,YAAA,eAAA,WAAA,aAAA,YAAA,cAAA,gBAAA,iBACA,qBAAA,gBAAA,aAAA,gBAAA,QAAA,OAAA,QAAA,OACA,QAAA,WAAA,cAAA,WAAA,YAAA,UAAA,kBAAA,aACA,QAAA,aAAA,QAAA,aAAA,gBAAA,qBAAA,aAAA,sBACA,QAAA,gBAAA,cAAA,gBAAA,UAAA,aAAA,YAAA,WACA5B,YAAA,CAAA,QAAA,WAEA/mD,GAAA,QAAAif,EAAAjf,GAAA2oD,WAAA3oD,GAAAyoD,UA6OA,IAAAhkD,GAAA,CACAk4C,UAAAA,GACAiM,gBAAA,SAAA1mF,GAAA,OAAAA,EAAA+4E,aAAA/4E,EAAA84B,UAAA,UAAA94B,EAAA84B,UAAA,QAAA0nB,EAAA,EACAmmC,SAAA,SAAA3mF,GAAA,OAAAulF,GAAAvlF,GAAA,SAAAid,GACA,GAAAA,EAAAK,QAAA,CACA,IAAA8wB,EAAApV,GAAAh5B,EAAAm+C,IAAAlhC,EAAAI,KAAAzX,MAAA7D,KAAAzE,OACA,OAAA2f,EAAAI,KAAAvS,IAAAsjC,GAAAnxB,EAAAI,KAAAzX,KAAA5F,EAAAiyC,WACA,CAAAvvC,KAAAua,EAAAI,KAAA1a,GAAAihB,GAAA3G,EAAAI,KAAAzX,KAAA,EAAA,IAEA,CAAAlD,KAAAua,EAAAI,KAAA1a,GAAAihB,GAAA3G,EAAAI,KAAAzX,KAAAwoC,GALA,CAOA,MAAA,CAAA1rC,KAAAua,EAAAva,OAAAC,GAAAsa,EAAAta,KARA,GAAA,EAWAikF,WAAA,SAAA5mF,GAAA,OAAAulF,GAAAvlF,GAAA,SAAAid,GAAA,MAAA,CACAva,KAAAkhB,GAAA3G,EAAAva,OAAAkD,KAAA,GACAjD,GAAAgnD,GAAA3pD,EAAAm+C,IAAAv6B,GAAA3G,EAAAta,KAAAiD,KAAA,EAAA,IAFA,GAAA,EAIAihF,YAAA,SAAA7mF,GAAA,OAAAulF,GAAAvlF,GAAA,SAAAid,GAAA,MAAA,CACAva,KAAAkhB,GAAA3G,EAAAva,OAAAkD,KAAA,GAAAjD,GAAAsa,EAAAva,OADA,GAAA,EAGAokF,mBAAA,SAAA9mF,GAAA,OAAAulF,GAAAvlF,GAAA,SAAAid,GACA,IAAAtB,EAAA3b,EAAAo+D,WAAAnhD,EAAAI,KAAA,OAAA1B,IAAA,EAEA,MAAA,CAAAjZ,KADA1C,EAAA0hB,WAAA,CAAAtC,KAAA,EAAAzD,IAAAA,GAAA,OACAhZ,GAAAsa,EAAAva,OAHA,GAAA,EAKAqkF,oBAAA,SAAA/mF,GAAA,OAAAulF,GAAAvlF,GAAA,SAAAid,GACA,IAAAtB,EAAA3b,EAAAo+D,WAAAnhD,EAAAI,KAAA,OAAA1B,IAAA,EACAqrE,EAAAhnF,EAAA0hB,WAAA,CAAAtC,KAAApf,EAAAu9B,QAAAqoC,QAAAlmD,YAAA,IAAA/D,IAAAA,GAAA,OACA,MAAA,CAAAjZ,KAAAua,EAAAva,OAAAC,GAAAqkF,EAHA,GAAA,EAKAhH,KAAA,SAAAhgF,GAAA,OAAAA,EAAAggF,MAAA,EACAC,KAAA,SAAAjgF,GAAA,OAAAA,EAAAigF,MAAA,EACAC,cAAA,SAAAlgF,GAAA,OAAAA,EAAAkgF,eAAA,EACAC,cAAA,SAAAngF,GAAA,OAAAA,EAAAmgF,eAAA,EACA8G,WAAA,SAAAjnF,GAAA,OAAAA,EAAAizC,gBAAArvB,GAAA5jB,EAAAgyC,YAAA,GAAA,EACAk1C,SAAA,SAAAlnF,GAAA,OAAAA,EAAAizC,gBAAArvB,GAAA5jB,EAAAiyC,YAAA,EACAk1C,YAAA,SAAAnnF,GAAA,OAAAA,EAAAy/E,oBAAA,SAAAxiE,GAAA,OAAAqrC,GAAAtoD,EAAAid,EAAAI,KAAAzX,KAAA,GACA,CAAA+6C,OAAA,QAAAmZ,KAAA,GADA,EAGAstB,iBAAA,SAAApnF,GAAA,OAAAA,EAAAy/E,oBAAA,SAAAxiE,GAAA,OAAAoqE,GAAArnF,EAAAid,EAAAI,KAAA,GACA,CAAAsjC,OAAA,QAAAmZ,KAAA,GADA,EAGAwtB,UAAA,SAAAtnF,GAAA,OAAAA,EAAAy/E,oBAAA,SAAAxiE,GAAA,OAwGA,SAAAjd,EAAA8wD,GACA,IAAAlrD,EAAAozB,GAAAh5B,EAAAm+C,IAAA2S,GACA8tB,EAn9KA,SAAAh5E,GAEA,IADA,IAAAgrD,EACAA,EAAAJ,GAAA5qD,IACAA,EAAAgrD,EAAAtvD,KAAA,GAAA,GAAAsE,KACA,OAAAA,CAJA,CAm9KA2hF,CAAA3hF,GAEA,OADAg5E,GAAAh5E,IAAAkrD,EAAA3c,GAAAyqC,IACAkH,IAAA,EAAA9lF,EAAA4F,EAAAkrD,GAAA,EAJA,CAxGA5c,CAAAl0C,EAAAid,EAAAI,KAAAzX,KAAA,GACA,CAAA+6C,OAAA,QAAAmZ,MAAA,GADA,EAGA0tB,YAAA,SAAAxnF,GAAA,OAAAA,EAAAy/E,oBAAA,SAAAxiE,GACA,IAAAtB,EAAA3b,EAAA47B,aAAA3e,EAAAI,KAAA,OAAA1B,IAAA,EACA,OAAA3b,EAAA0hB,WAAA,CAAAtC,KAAApf,EAAAu9B,QAAAqoC,QAAAlmD,YAAA,IAAA/D,IAAAA,GAAA,MAFA,GAGAilC,EAHA,EAIA6mC,WAAA,SAAAznF,GAAA,OAAAA,EAAAy/E,oBAAA,SAAAxiE,GACA,IAAAtB,EAAA3b,EAAA47B,aAAA3e,EAAAI,KAAA,OAAA1B,IAAA,EACA,OAAA3b,EAAA0hB,WAAA,CAAAtC,KAAA,EAAAzD,IAAAA,GAAA,MAFA,GAGAilC,EAHA,EAIA8mC,gBAAA,SAAA1nF,GAAA,OAAAA,EAAAy/E,oBAAA,SAAAxiE,GACA,IAAAtB,EAAA3b,EAAA47B,aAAA3e,EAAAI,KAAA,OAAA1B,IAAA,EACA1H,EAAAjU,EAAA0hB,WAAA,CAAAtC,KAAA,EAAAzD,IAAAA,GAAA,OACA,OAAA1H,EAAAnJ,GAAA9K,EAAAg5B,QAAA/kB,EAAArO,MAAAT,OAAA,MAAAkiF,GAAArnF,EAAAid,EAAAI,MACApJ,CAJA,GAKA2sC,EALA,EAMA+mC,SAAA,SAAA3nF,GAAA,OAAAA,EAAA4nF,OAAA,EAAA,OAAA,EACAC,WAAA,SAAA7nF,GAAA,OAAAA,EAAA4nF,MAAA,EAAA,OAAA,EACAE,SAAA,SAAA9nF,GAAA,OAAAA,EAAA4nF,OAAA,EAAA,OAAA,EACAG,WAAA,SAAA/nF,GAAA,OAAAA,EAAA4nF,MAAA,EAAA,OAAA,EACAI,WAAA,SAAAhoF,GAAA,OAAAA,EAAAioF,OAAA,EAAA,OAAA,EACAC,YAAA,SAAAloF,GAAA,OAAAA,EAAAioF,MAAA,EAAA,OAAA,EACAE,aAAA,SAAAnoF,GAAA,OAAAA,EAAAioF,OAAA,EAAA,SAAA,EACAG,cAAA,SAAApoF,GAAA,OAAAA,EAAAioF,MAAA,EAAA,SAAA,EACAI,WAAA,SAAAroF,GAAA,OAAAA,EAAAioF,OAAA,EAAA,OAAA,EACAK,aAAA,SAAAtoF,GAAA,OAAAA,EAAAioF,MAAA,EAAA,QAAA,EACAM,YAAA,SAAAvoF,GAAA,OAAAA,EAAAioF,OAAA,EAAA,QAAA,EACAO,YAAA,SAAAxoF,GAAA,OAAAA,EAAAioF,MAAA,EAAA,OAAA,EACAQ,cAAA,SAAAzoF,GAAA,OAAAA,EAAA0oF,SAAA,EAAA,YAAA,EACAC,aAAA,SAAA3oF,GAAA,OAAAA,EAAA0oF,QAAA,EAAA,OAAA,EACAE,cAAA,SAAA5oF,GAAA,OAAAA,EAAA0oF,SAAA,EAAA,OAAA,EACAG,aAAA,SAAA7oF,GAAA,OAAAA,EAAA0oF,QAAA,EAAA,OAAA,EACAI,eAAA,SAAA9oF,GAAA,OAAAA,EAAA0oF,SAAA,EAAA,QAAA,EACAK,cAAA,SAAA/oF,GAAA,OAAAA,EAAA0oF,QAAA,EAAA,QAAA,EACAM,WAAA,SAAAhpF,GAAA,OAAAA,EAAAipF,gBAAA,QAAA,EACAC,WAAA,SAAAlpF,GAAA,OAAAA,EAAAipF,gBAAA,MAAA,EACAE,WAAA,SAAAnpF,GAAA,OAAAA,EAAAipF,gBAAA,WAAA,EACAG,UAAA,SAAAppF,GAAA,OAAAA,EAAAw6C,iBAAA,KAAA,EACA6uC,cAAA,SAAArpF,GAEA,IADA,IAAAspF,EAAA,GAAAvsE,EAAA/c,EAAAke,iBAAAyhC,EAAA3/C,EAAA2f,QAAAggC,QACAtiD,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAA4W,EAAA8I,EAAA1f,GAAAqF,OACA6D,EAAAm5C,EAAA1/C,EAAAg5B,QAAA/kB,EAAArO,MAAAqO,EAAAnJ,GAAA60C,GACA2pC,EAAAj7E,KAAA4yC,EAAAtB,EAAAp5C,EAAAo5C,GAHA,CAKA3/C,EAAA02C,kBAAA4yC,EAPA,EASAC,WAAA,SAAAvpF,GACAA,EAAA+5B,oBAAA/5B,EAAAipF,gBAAA,OACAjpF,EAAAm2C,YAAA,YAFA,EAWAqzC,eAAA,SAAAxpF,GAAA,OAAAquE,GAAAruE,GAAA,WAEA,IADA,IAAA+c,EAAA/c,EAAAke,iBAAA0hE,EAAA,GACAviF,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IACA,GAAA0f,EAAA1f,GAAAigB,QAAA,CACA,IAAArY,EAAA8X,EAAA1f,GAAAggB,KAAAzX,EAAAozB,GAAAh5B,EAAAm+C,IAAAl5C,EAAAW,MAAA7D,KACA,GAAA6D,EAEA,GADAX,EAAA6F,IAAAlF,EAAAtI,SAAA2H,EAAA,IAAA2e,GAAA3e,EAAAW,KAAAX,EAAA6F,GAAA,IACA7F,EAAA6F,GAAA,EACA7F,EAAA,IAAA2e,GAAA3e,EAAAW,KAAAX,EAAA6F,GAAA,GACA9K,EAAA2gC,aAAA/6B,EAAAsO,OAAAjP,EAAA6F,GAAA,GAAAlF,EAAAsO,OAAAjP,EAAA6F,GAAA,GACA8Y,GAAA3e,EAAAW,KAAAX,EAAA6F,GAAA,GAAA7F,EAAA,mBACA,GAAAA,EAAAW,KAAA5F,EAAAm+C,IAAAld,MAAA,CACA,IAAAh1B,EAAA+sB,GAAAh5B,EAAAm+C,IAAAl5C,EAAAW,KAAA,GAAA7D,KACAkK,IACAhH,EAAA,IAAA2e,GAAA3e,EAAAW,KAAA,GACA5F,EAAA2gC,aAAA/6B,EAAAsO,OAAA,GAAAlU,EAAAm+C,IAAA5D,gBACAtuC,EAAAiI,OAAAjI,EAAA3O,OAAA,GACAsmB,GAAA3e,EAAAW,KAAA,EAAAqG,EAAA3O,OAAA,GAAA2H,EAAA,cANA,CAUA26E,EAAAvxE,KAAA,IAAA4lE,GAAAhvE,EAAAA,GAlBA,CAoBAjF,EAAAy3C,cAAAmoC,EAvBA,GAAA,EAyBA6J,iBAAA,SAAAzpF,GAAA,OAAAquE,GAAAruE,GAAA,WAEA,IADA,IAAAi7C,EAAAj7C,EAAAke,iBACA7gB,EAAA49C,EAAA39C,OAAA,EAAAD,GAAA,EAAAA,IACA2C,EAAA2gC,aAAA3gC,EAAAm+C,IAAA5D,gBAAAU,EAAA59C,GAAA+f,OAAA69B,EAAA59C,GAAAggB,KAAA,UACA49B,EAAAj7C,EAAAke,iBACA,IAAA,IAAAglC,EAAA,EAAAA,EAAAjI,EAAA39C,OAAA4lD,IACAljD,EAAA03C,WAAAuD,EAAAiI,GAAAxgD,OAAAkD,KAAA,MAAA,GACAwhE,GAAApnE,EAPA,GAAA,EASA0pF,SAAA,SAAA1pF,GAAA,OAAAA,EAAAw6C,iBAAA,KAAA,QAAA,EACAmvC,gBAAA,SAAA3pF,GAAA,OAAAA,EAAA2pF,iBAAA,GAIA,SAAArhC,GAAAtoD,EAAA8wD,GACA,IAAAlrD,EAAAozB,GAAAh5B,EAAAm+C,IAAA2S,GACA8tB,EAAAjuB,GAAA/qD,GAEA,OADAg5E,GAAAh5E,IAAAkrD,EAAA3c,GAAAyqC,IACAkH,IAAA,EAAA9lF,EAAA4+E,EAAA9tB,EAAA,EAJA,CAYA,SAAAu2B,GAAArnF,EAAAiU,GACA,IAAAd,EAAAm1C,GAAAtoD,EAAAiU,EAAArO,MACAA,EAAAozB,GAAAh5B,EAAAm+C,IAAAhrC,EAAAvN,MACA08C,EAAA+B,GAAAz+C,EAAA5F,EAAAm+C,IAAA6E,WACA,IAAAV,GAAA,GAAAA,EAAA,GAAAS,MAAA,CACA,IAAA6mC,EAAA5qE,KAAAC,IAAA9L,EAAArI,GAAAlF,EAAA7D,KAAAoD,OAAA,OACA0kF,EAAA51E,EAAArO,MAAAuN,EAAAvN,MAAAqO,EAAAnJ,IAAA8+E,GAAA31E,EAAAnJ,GACA,OAAA8Y,GAAAzQ,EAAAvN,KAAAikF,EAAA,EAAAD,EAAAz2E,EAAAovC,OAHA,CAKA,OAAApvC,CATA,CAaA,SAAA22E,GAAA9pF,EAAAo/B,EAAA2qD,GACA,GAAA,iBAAA3qD,KACAA,EAAAmD,GAAAnD,IACA,OAAA,EAIAp/B,EAAAu9B,QAAA12B,MAAAmjF,eACA,IAAAC,EAAAjqF,EAAAu9B,QAAAnJ,MAAAmiD,GAAA,EACA,IACAv2E,EAAA2iF,eAAA3iF,EAAA+D,MAAAg3E,eAAA,GACAgP,IAAA/pF,EAAAu9B,QAAAnJ,OAAA,GACAmiD,EAAAn3C,EAAAp/B,IAAA6F,CAHA,CAAA,QAKA7F,EAAAu9B,QAAAnJ,MAAA61D,EACAjqF,EAAA+D,MAAAg3E,eAAA,CAFA,CAIA,OAAAxE,CAjBA,CAgCA,IAAA2T,GAAA,IAAAhqC,EAEA,SAAAiqC,GAAAnqF,EAAAqD,EAAA7E,EAAAu/B,GACA,IAAAqsD,EAAApqF,EAAA+D,MAAAsmF,OACA,GAAAD,EAAA,CACA,GAAAtF,GAAAzhF,GAAA,MAAA,UAUA,GATA,MAAAa,KAAAb,GACArD,EAAA+D,MAAAsmF,OAAA,KAEAH,GAAAn8C,IAAA,IAAA,WACA/tC,EAAA+D,MAAAsmF,QAAAD,IACApqF,EAAA+D,MAAAsmF,OAAA,KACArqF,EAAAu9B,QAAA12B,MAAAgxB,QAHA,IAMAyyD,GAAAtqF,EAAAoqF,EAAA,IAAA/mF,EAAA7E,EAAAu/B,GAAA,OAAA,CAXA,CAaA,OAAAusD,GAAAtqF,EAAAqD,EAAA7E,EAAAu/B,EAfA,CAkBA,SAAAusD,GAAAtqF,EAAAqD,EAAA7E,EAAAu/B,GACA,IAAAvnB,EAjCA,SAAAxW,EAAAqD,EAAA06B,GACA,IAAA,IAAA1gC,EAAA,EAAAA,EAAA2C,EAAA+D,MAAAwmF,QAAAjtF,OAAAD,IAAA,CACA,IAAAmZ,EAAAmuE,GAAAthF,EAAArD,EAAA+D,MAAAwmF,QAAAltF,GAAA0gC,EAAA/9B,GACA,GAAAwW,EAAA,OAAAA,CAFA,CAIA,OAAAxW,EAAA2f,QAAA2f,WAAAqlD,GAAAthF,EAAArD,EAAA2f,QAAA2f,UAAAvB,EAAA/9B,IACA2kF,GAAAthF,EAAArD,EAAA2f,QAAAme,OAAAC,EAAA/9B,EANA,CAiCAwqF,CAAAxqF,EAAAqD,EAAA06B,GAYA,MAVA,SAAAvnB,IACAxW,EAAA+D,MAAAsmF,OAAAhnF,GACA,WAAAmT,GACA8+C,GAAAt1D,EAAA,aAAAA,EAAAqD,EAAA7E,GAEA,WAAAgY,GAAA,SAAAA,IACAkvC,GAAAlnD,GACAsmE,GAAA9kE,MAGAwW,CAbA,CAiBA,SAAAi0E,GAAAzqF,EAAAxB,GACA,IAAA6E,EAAAgiF,GAAA7mF,GAAA,GACA,QAAA6E,IAEA7E,EAAA4mF,WAAAplF,EAAA+D,MAAAsmF,OAIAF,GAAAnqF,EAAA,SAAAqD,EAAA7E,GAAA,SAAAgf,GAAA,OAAAssE,GAAA9pF,EAAAwd,GAAA,EAAA,KACA2sE,GAAAnqF,EAAAqD,EAAA7E,GAAA,SAAAgf,GACA,GAAA,iBAAAA,EAAA,WAAAtZ,KAAAsZ,GAAAA,EAAAktE,OACA,OAAAZ,GAAA9pF,EAAAwd,EAFA,IAKA2sE,GAAAnqF,EAAAqD,EAAA7E,GAAA,SAAAgf,GAAA,OAAAssE,GAAA9pF,EAAAwd,EAAA,IAdA,CAuBA,IAAAmtE,GAAA,KACA,SAAAC,GAAApsF,GACA,IAAAwB,EAAAgM,KACA,KAAAxN,EAAArB,QAAAqB,EAAArB,QAAA6C,EAAAu9B,QAAA12B,MAAAgkF,aACA7qF,EAAAqlD,MAAAjlB,MAAA4d,EAAAjP,EAAA/uC,IACA+kD,GAAA/kD,EAAAxB,KAAA,CAEAw9C,GAAAC,EAAA,IAAA,IAAAz9C,EAAAumF,UAAAvmF,EAAAmnD,aAAA,GACA,IAAApmD,EAAAf,EAAAumF,QACA/kF,EAAAu9B,QAAAnJ,MAAA,IAAA70B,GAAAf,EAAA4mF,SACA,IAAA0F,EAAAL,GAAAzqF,EAAAxB,GACA89C,IACAquC,GAAAG,EAAAvrF,EAAA,KAEAurF,GAAA,IAAAvrF,GAAA4nD,MAAApK,EAAAv+C,EAAA2mF,QAAA3mF,EAAA2nD,UACAnmD,EAAAw6C,iBAAA,GAAA,KAAA,QAEAoB,IAAAmB,IAAA+tC,GAAA,IAAAvrF,GAAAf,EAAA4mF,WAAA5mF,EAAA2nD,SAAAtnC,SAAAs3B,aACAt3B,SAAAs3B,YAAA,OAGA,IAAA52C,GAAA,2BAAA2E,KAAAlE,EAAAu9B,QAAAqoC,QAAAvuD,YAIA,SAAArX,GACA,IAAA4lE,EAAA5lE,EAAAu9B,QAAAqoC,QAGA,SAAAmlB,EAAAvsF,GACA,IAAAA,EAAAumF,SAAAvmF,EAAA0mF,SACA3nC,EAAAqoB,EAAA,wBACA3nD,GAAAY,SAAA,QAAAksE,GACA9sE,GAAAY,SAAA,YAAAksE,GAJA,CAFA1sC,EAAAunB,EAAA,wBASApkE,GAAAqd,SAAA,QAAAksE,GACAvpF,GAAAqd,SAAA,YAAAksE,EAZA,CAHAC,CAAAhrF,EAjBA,CAJA,CAuCA,SAAAirF,GAAAzsF,GACA,IAAAA,EAAAumF,UAAA/4E,KAAAmyC,IAAAtgC,IAAAuW,OAAA,GACA2wB,GAAA/4C,KAAAxN,EAFA,CAKA,SAAA0sF,GAAA1sF,GACA,IAAAwB,EAAAgM,KACA,KAAAxN,EAAArB,QAAAqB,EAAArB,QAAA6C,EAAAu9B,QAAA12B,MAAAgkF,YACAjyB,GAAA54D,EAAAu9B,QAAA/+B,IAAAumD,GAAA/kD,EAAAxB,IAAAA,EAAA2nD,UAAA3nD,EAAA0mF,QAAAnoC,GAAAv+C,EAAA2mF,SAAA,CACA,IAAAJ,EAAAvmF,EAAAumF,QAAAoG,EAAA3sF,EAAA2sF,SACA,GAAA7uC,GAAAyoC,GAAA4F,GAAA,OAAAA,GAAA,UAAAjlC,GAAAlnD,GACA,IAAA89C,GAAA99C,EAAA0nD,SAAA1nD,EAAA0nD,MAAA,MAAAukC,GAAAzqF,EAAAxB,GAAA,CACA,IAAAsM,EAAAxM,OAAA8lF,aAAA,MAAA+G,EAAApG,EAAAoG,GAEA,MAAArgF,IA1DA,SAAA9K,EAAAxB,EAAAsM,GACA,OAAAq/E,GAAAnqF,EAAA,IAAA8K,EAAA,IAAAtM,GAAA,SAAAgf,GAAA,OAAAssE,GAAA9pF,EAAAwd,GAAA,EAAA,GADA,CA2DA4tE,CAAAprF,EAAAxB,EAAAsM,IACA9K,EAAAu9B,QAAA12B,MAAAqkF,WAAA1sF,GALA,CAHA,CAHA,CAcA,IAaA6sF,GAAAC,GAXAC,GAAA,SAAA//C,EAAAv3B,EAAA4xB,GACA75B,KAAAw/B,KAAAA,EACAx/B,KAAAiI,IAAAA,EACAjI,KAAA65B,OAAAA,CAHA,EAiCA,SAAA2lD,GAAAhtF,GACA,IAAAwB,EAAAgM,KAAAuxB,EAAAv9B,EAAAu9B,QACA,KAAAwnB,GAAA/kD,EAAAxB,IAAA++B,EAAA20C,aAAA30C,EAAA12B,MAAA4kF,iBAIA,GAHAluD,EAAA12B,MAAAmjF,eACAzsD,EAAAnJ,MAAA51B,EAAA4mF,SAEAxsB,GAAAr7B,EAAA/+B,GACA09C,IAGA3e,EAAAi8B,SAAAttB,WAAA,EACA/rB,YAAA,WAAA,OAAAod,EAAAi8B,SAAAttB,WAAA,CAAA,GAAA,WAIA,IAAAw/C,GAAA1rF,EAAAxB,GAAA,CACA,IAAAyV,EAAAusD,GAAAxgE,EAAAxB,GAAAqnC,EAAAogB,GAAAznD,GAAAmtF,EAAA13E,EArCA,SAAAA,EAAA4xB,GACA,IAAA+lD,GAAA,IAAAxrC,KACA,OAAAkrC,IAAAA,GAAAO,QAAAD,EAAA33E,EAAA4xB,IACAwlD,GAAAC,GAAA,KACA,UACAD,IAAAA,GAAAQ,QAAAD,EAAA33E,EAAA4xB,IACAylD,GAAA,IAAAC,GAAAK,EAAA33E,EAAA4xB,GACAwlD,GAAA,KACA,WAEAA,GAAA,IAAAE,GAAAK,EAAA33E,EAAA4xB,GACAylD,GAAA,KACA,SAZA,CAqCAQ,CAAA73E,EAAA4xB,GAAA,SACAwZ,EAAAr/C,GAAAogC,QAGA,GAAAyF,GAAA7lC,EAAA+D,MAAAgoF,eACA/rF,EAAA+D,MAAAgoF,cAAAvtF,GAEAyV,GAcA,SAAAjU,EAAA6lC,EAAA5xB,EAAA03E,EAAA5hE,GACA,IAAA1mB,EAAA,QAKA,MAJA,UAAAsoF,EAAAtoF,EAAA,SAAAA,EACA,UAAAsoF,IAAAtoF,EAAA,SAAAA,GAGA8mF,GAAAnqF,EAAAglF,GAFA3hF,GAAA,GAAAwiC,EAAA,OAAA,GAAAA,EAAA,SAAA,SAAAxiC,EAEA0mB,GAAAA,GAAA,SAAAqV,GAEA,GADA,iBAAAA,IAAAA,EAAAmD,GAAAnD,KACAA,EAAA,OAAA,EACA,IAAAm3C,GAAA,EACA,IACAv2E,EAAA2iF,eAAA3iF,EAAA+D,MAAAg3E,eAAA,GACAxE,EAAAn3C,EAAAp/B,EAAAiU,IAAApO,CAFA,CAAA,QAIA7F,EAAA+D,MAAAg3E,eAAA,CADA,CAGA,OAAAxE,CAVA,GANA,CAdAyV,CAAAhsF,EAAA6lC,EAAA5xB,EAAA03E,EAAAntF,KAEA,GAAAqnC,EACA5xB,EA4CA,SAAAjU,EAAAiU,EAAA03E,EAAA5hE,GACAiyB,EAAA77B,WAAAm/B,EAAA8lB,GAAAplE,GAAA,GACAA,EAAAqlD,MAAAjlB,MAAA4d,EAAAjP,EAAA/uC,IAEA,IAEAisF,EAFAC,EAjBA,SAAAlsF,EAAA2rF,EAAA5hE,GACA,IAAAtiB,EAAAzH,EAAAkd,UAAA,kBACApG,EAAArP,EAAAA,EAAAzH,EAAA2rF,EAAA5hE,GAAA,CAAA,EACA,GAAA,MAAAjT,EAAAq1E,KAAA,CACA,IAAA5xB,EAAAvd,EAAAjzB,EAAAq7D,UAAAr7D,EAAAo7D,QAAAp7D,EAAAm7D,OACApuE,EAAAq1E,KAAA5xB,EAAA,YAAA,UAAAoxB,EAAA,OAAA,UAAAA,EAAA,OAAA,MAFA,CAOA,OAHA,MAAA70E,EAAAo5D,QAAAlwE,EAAAm+C,IAAA+xB,UAAAp5D,EAAAo5D,OAAAlwE,EAAAm+C,IAAA+xB,QAAAnmD,EAAAq7D,UACA,MAAAtuE,EAAAs1E,SAAAt1E,EAAAs1E,OAAArvC,EAAAhzB,EAAAo7D,QAAAp7D,EAAAo8B,SACA,MAAArvC,EAAAu1E,aAAAv1E,EAAAu1E,aAAAtvC,EAAAhzB,EAAAm7D,OAAAn7D,EAAAo8B,UACArvC,CAVA,CAiBAw1E,CAAAtsF,EAAA2rF,EAAA5hE,GAEAlM,EAAA7d,EAAAm+C,IAAAtgC,IACA7d,EAAA2f,QAAA4sE,UAAAjmC,KAAAtmD,EAAA2iF,cACA,UAAAgJ,IAAAM,EAAApuE,EAAAigC,SAAA7pC,KAAA,IACAqkC,IAAA2zC,EAAApuE,EAAAd,OAAAkvE,IAAAvpF,OAAAuR,GAAA,GAAAA,EAAA2qD,KAAA,KACAtmB,GAAA2zC,EAAAtpF,KAAAsR,GAAA,GAAAA,EAAA2qD,KAAA,GAQA,SAAA5+D,EAAA+pB,EAAA9V,EAAAi4E,GACA,IAAA3uD,EAAAv9B,EAAAu9B,QAAAivD,GAAA,EACAC,EAAA/uE,GAAA1d,GAAA,SAAAxB,GACA09C,IAAA3e,EAAAi8B,SAAAttB,WAAA,GACAlsC,EAAA+D,MAAAwhE,cAAA,EACAvlE,EAAA+D,MAAAuhE,oBACAtlE,EAAAmlE,WAAAnlE,EAAA+D,MAAAuhE,mBAAA,EACAD,GAAArlE,IAEAie,GAAAsf,EAAA2hB,QAAA3/B,cAAA,UAAAktE,GACAxuE,GAAAsf,EAAA2hB,QAAA3/B,cAAA,YAAAmtE,GACAzuE,GAAAsf,EAAAi8B,SAAA,YAAAmzB,GACA1uE,GAAAsf,EAAAi8B,SAAA,OAAAizB,GACAD,IACA9mC,GAAAlnD,GACA0tF,EAAAE,QACAn5C,GAAAjzC,EAAAm+C,IAAAlqC,EAAA,KAAA,KAAAi4E,EAAAhc,QAEAh0B,IAAAK,GAAAP,GAAA,GAAAC,EACA97B,YAAA,WAAAod,EAAA2hB,QAAA3/B,cAAArH,KAAAkoB,MAAA,CAAAwsD,eAAA,IAAArvD,EAAA12B,MAAAu5B,OAAA,GAAA,IAEA7C,EAAA12B,MAAAu5B,QAnBA,IAsBAssD,EAAA,SAAAG,GACAL,EAAAA,GAAAxtE,KAAAg8C,IAAAjxC,EAAAzK,QAAAutE,EAAAvtE,SAAAN,KAAAg8C,IAAAjxC,EAAA7K,QAAA2tE,EAAA3tE,UAAA,EADA,EAGAytE,EAAA,WAAA,OAAAH,GAAA,CAAA,EAEAtwC,IAAA3e,EAAAi8B,SAAAttB,WAAA,GACAlsC,EAAA+D,MAAAwhE,aAAAknB,EACAA,EAAAz/B,MAAAk/B,EAAAG,WACA7qF,GAAA+7B,EAAA2hB,QAAA3/B,cAAA,UAAAktE,GACAjrF,GAAA+7B,EAAA2hB,QAAA3/B,cAAA,YAAAmtE,GACAlrF,GAAA+7B,EAAAi8B,SAAA,YAAAmzB,GACAnrF,GAAA+7B,EAAAi8B,SAAA,OAAAizB,GAEAzsF,EAAA+D,MAAAuhE,mBAAA,EACAnlD,YAAA,WAAA,OAAAod,EAAA12B,MAAAu5B,OAAA,GAAA,IAEA7C,EAAAi8B,SAAA+yB,UAAAhvD,EAAAi8B,SAAA+yB,UAxCA,CAPAO,CAAA9sF,EAAA+pB,EAAA9V,EAAAi4E,GA2DA,SAAAlsF,EAAA+pB,EAAA5W,EAAA+4E,GACAlwC,GAAAqpB,GAAArlE,GACA,IAAAu9B,EAAAv9B,EAAAu9B,QAAA4gB,EAAAn+C,EAAAm+C,IACAuH,GAAA37B,GAEA,IAAAgjE,EAAAC,EAAAC,EAAA9uC,EAAAtgC,IAAAd,EAAAkwE,EAAAlwE,OAYA,GAXAmvE,EAAAE,SAAAF,EAAAhc,QACA8c,EAAA7uC,EAAAtgC,IAAAigC,SAAA3qC,GAEA45E,EADAC,GAAA,EACAjwE,EAAAiwE,GAEA,IAAA/Y,GAAA9gE,EAAAA,KAEA45E,EAAA5uC,EAAAtgC,IAAA49B,UACAuxC,EAAA7uC,EAAAtgC,IAAAykD,WAGA,aAAA4pB,EAAAC,KACAD,EAAAE,SAAAW,EAAA,IAAA9Y,GAAA9gE,EAAAA,IACAA,EAAAqtD,GAAAxgE,EAAA+pB,GAAA,GAAA,GACAijE,GAAA,MACA,CACA,IAAA/vE,EAAAiwE,GAAAltF,EAAAmT,EAAA+4E,EAAAC,MAEAY,EADAb,EAAAhc,OACA2I,GAAAkU,EAAA9vE,EAAAG,OAAAH,EAAAI,KAAA6uE,EAAAhc,QAEAjzD,CALA,CAQAivE,EAAAE,QAIA,GAAAY,GACAA,EAAAjwE,EAAAzf,OACAy7E,GAAA56B,EAAA+1B,GAAAl0E,EAAA+c,EAAAuM,OAAA,CAAAyjE,IAAAC,GACA,CAAAvsC,QAAA,EAAAE,OAAA,YACA5jC,EAAAzf,OAAA,GAAAyf,EAAAiwE,GAAA1vE,SAAA,QAAA4uE,EAAAC,OAAAD,EAAAhc,QACA6I,GAAA56B,EAAA+1B,GAAAl0E,EAAA+c,EAAA7J,MAAA,EAAA85E,GAAA1jE,OAAAvM,EAAA7J,MAAA85E,EAAA,IAAA,GACA,CAAAvsC,QAAA,EAAAE,OAAA,WACAssC,EAAA9uC,EAAAtgC,KAEAq7D,GAAA/6B,EAAA6uC,EAAAD,EAAArsC,IAZAssC,EAAA,EACAjU,GAAA56B,EAAA,IAAA01B,GAAA,CAAAkZ,GAAA,GAAArsC,GACAusC,EAAA9uC,EAAAtgC,KAaA,IAAAsvE,EAAAh6E,EACA,SAAAi6E,EAAAn5E,GACA,GAAA,GAAAqkC,GAAA60C,EAAAl5E,GAGA,GAFAk5E,EAAAl5E,EAEA,aAAAi4E,EAAAC,KAAA,CAKA,IAJA,IAAApvE,EAAA,GAAA4iC,EAAA3/C,EAAA2f,QAAAggC,QACA14B,EAAAy4B,EAAA1mB,GAAAmlB,EAAAhrC,EAAAvN,MAAA7D,KAAAoR,EAAArI,GAAA60C,GACA0tC,EAAA3tC,EAAA1mB,GAAAmlB,EAAAlqC,EAAArO,MAAA7D,KAAAkS,EAAAnJ,GAAA60C,GACAvgC,EAAAJ,KAAAK,IAAA4H,EAAAomE,GAAAhsE,EAAArC,KAAAC,IAAAgI,EAAAomE,GACAznF,EAAAoZ,KAAAK,IAAAlM,EAAAvN,KAAAqO,EAAArO,MAAA8T,EAAAsF,KAAAK,IAAArf,EAAAiyC,WAAAjzB,KAAAC,IAAA9L,EAAAvN,KAAAqO,EAAArO,OACAA,GAAA8T,EAAA9T,IAAA,CACA,IAAA7D,EAAAi3B,GAAAmlB,EAAAv4C,GAAA7D,KAAAurF,EAAAzsC,EAAA9+C,EAAAqd,EAAAugC,GACAvgC,GAAAiC,EACAtE,EAAA1O,KAAA,IAAA4lE,GAAArwD,GAAAhe,EAAA0nF,GAAA1pE,GAAAhe,EAAA0nF,KACAvrF,EAAAzE,OAAAgwF,GACAvwE,EAAA1O,KAAA,IAAA4lE,GAAArwD,GAAAhe,EAAA0nF,GAAA1pE,GAAAhe,EAAAi7C,EAAA9+C,EAAAsf,EAAAs+B,KALA,CAOA5iC,EAAAzf,QAAAyf,EAAA1O,KAAA,IAAA4lE,GAAA9gE,EAAAA,IACA4lE,GAAA56B,EAAA+1B,GAAAl0E,EAAAitF,EAAAlwE,OAAA7J,MAAA,EAAA85E,GAAA1jE,OAAAvM,GAAAiwE,GACA,CAAArsC,OAAA,SAAAF,QAAA,IACAzgD,EAAA4gC,eAAA3sB,EAhBA,KAiBA,CACA,IAEAoJ,EAFAkwE,EAAAR,EACA9vE,EAAAiwE,GAAAltF,EAAAiU,EAAAi4E,EAAAC,MACA/uE,EAAAmwE,EAAAnwE,OACAk7B,GAAAr7B,EAAAG,OAAAA,GAAA,GACAC,EAAAJ,EAAAI,KACAD,EAAAqsC,GAAA8jC,EAAA7qF,OAAAua,EAAAG,UAEAC,EAAAJ,EAAAG,OACAA,EAAAosC,GAAA+jC,EAAA5qF,KAAAsa,EAAAI,OAEA,IAAAmwE,EAAAP,EAAAlwE,OAAA7J,MAAA,GACAs6E,EAAAR,GA2DA,SAAAhtF,EAAAid,GACA,IAAAG,EAAAH,EAAAG,OACAC,EAAAJ,EAAAI,KACAowE,EAAAz0D,GAAAh5B,EAAAm+C,IAAA/gC,EAAAxX,MACA,GAAA,GAAA0yC,GAAAl7B,EAAAC,IAAAD,EAAAmlC,QAAAllC,EAAAklC,OAAA,OAAAtlC,EACA,IAAAqlC,EAAA+B,GAAAopC,GACA,IAAAnrC,EAAA,OAAArlC,EACA,IAAAlJ,EAAAsuC,GAAAC,EAAAllC,EAAAtS,GAAAsS,EAAAmlC,QAAA0R,EAAA3R,EAAAvuC,GACA,GAAAkgD,EAAAvxD,MAAA0a,EAAAtS,IAAAmpD,EAAAtxD,IAAAya,EAAAtS,GAAA,OAAAmS,EACA,IAKAimD,EALAwqB,EAAA35E,GAAAkgD,EAAAvxD,MAAA0a,EAAAtS,KAAA,GAAAmpD,EAAAlR,OAAA,EAAA,GACA,GAAA,GAAA2qC,GAAAA,GAAAprC,EAAAhlD,OAAA,OAAA2f,EAKA,GAAAI,EAAAzX,MAAAwX,EAAAxX,KACAs9D,GAAA7lD,EAAAzX,KAAAwX,EAAAxX,OAAA,OAAA5F,EAAAm+C,IAAA6E,UAAA,GAAA,GAAA,MACA,CACA,IAAA2qC,EAAAtrC,GAAAC,EAAAjlC,EAAAvS,GAAAuS,EAAAklC,QACA/5C,EAAAmlF,EAAA55E,IAAAsJ,EAAAvS,GAAAsS,EAAAtS,KAAA,GAAAmpD,EAAAlR,OAAA,EAAA,GAEAmgB,EADAyqB,GAAAD,EAAA,GAAAC,GAAAD,EACAllF,EAAA,EAEAA,EAAA,CANA,CASA,IAAAolF,EAAAtrC,EAAAorC,GAAAxqB,GAAA,EAAA,IACAxgE,EAAAwgE,IAAA,GAAA0qB,EAAA7qC,OACAj4C,EAAApI,EAAAkrF,EAAAlrF,KAAAkrF,EAAAjrF,GAAA4/C,EAAA7/C,EAAA,QAAA,SACA,OAAA0a,EAAAtS,IAAAA,GAAAsS,EAAAmlC,QAAAA,EAAAtlC,EAAA,IAAAg3D,GAAA,IAAArwD,GAAAxG,EAAAxX,KAAAkF,EAAAy3C,GAAAllC,EA7BA,CA3DAwwE,CAAA7tF,EAAA,IAAAi0E,GAAAtqB,GAAAxL,EAAA/gC,GAAAC,IACA07D,GAAA56B,EAAA+1B,GAAAl0E,EAAAwtF,EAAAR,GAAAtsC,EAbA,CArBA,CAsCA,IAAAotC,EAAAvwD,EAAA2hB,QAAA/9B,wBAKA4sE,EAAA,EAEA,SAAA7d,EAAA1xE,GACA,IAAAwvF,IAAAD,EACA9oF,EAAAu7D,GAAAxgE,EAAAxB,GAAA,EAAA,aAAA0tF,EAAAC,MACA,GAAAlnF,EACA,GAAA,GAAAqzC,GAAArzC,EAAAkoF,GAAA,CACAntF,EAAAqlD,MAAAjlB,MAAA4d,EAAAjP,EAAA/uC,IACAotF,EAAAnoF,GACA,IAAAkqE,EAAAhJ,GAAA5oC,EAAA4gB,IACAl5C,EAAAW,MAAAupE,EAAAxsE,IAAAsC,EAAAW,KAAAupE,EAAAzsE,OACAyd,WAAAzC,GAAA1d,GAAA,WAAA+tF,GAAAC,GAAA9d,EAAA1xE,EAAA,IAAA,IALA,KAMA,CACA,IAAAmgE,EAAAngE,EAAA0gB,QAAA4uE,EAAAnyE,KAAA,GAAAnd,EAAA0gB,QAAA4uE,EAAAvsE,OAAA,GAAA,EACAo9C,GAAAx+C,WAAAzC,GAAA1d,GAAA,WACA+tF,GAAAC,IACAzwD,EAAAi8B,SAAAl9B,WAAAqiC,EACAuR,EAAA1xE,GAHA,IAIA,GANA,CAVA,CAoBA,SAAA+3E,EAAA/3E,GACAwB,EAAA+D,MAAAgoF,eAAA,EACAgC,EAAAp8E,IAIAnT,IACAknD,GAAAlnD,GACA++B,EAAA12B,MAAAu5B,SAEAniB,GAAAsf,EAAA2hB,QAAA3/B,cAAA,YAAA0uE,GACAhwE,GAAAsf,EAAA2hB,QAAA3/B,cAAA,UAAAwrE,GACA5sC,EAAAu5B,QAAAX,cAAA,IAZA,CAeA,IAAAkX,EAAAvwE,GAAA1d,GAAA,SAAAxB,GACA,IAAAA,EAAA0vF,SAAAjoC,GAAAznD,GACA0xE,EAAA1xE,GADA+3E,EAAA/3E,EADA,IAIAusF,EAAArtE,GAAA1d,EAAAu2E,GACAv2E,EAAA+D,MAAAgoF,cAAAhB,EACAvpF,GAAA+7B,EAAA2hB,QAAA3/B,cAAA,YAAA0uE,GACAzsF,GAAA+7B,EAAA2hB,QAAA3/B,cAAA,UAAAwrE,EArIA,CAzDAoD,CAAAnuF,EAAA+pB,EAAA9V,EAAAi4E,EAbA,CA5CAkC,CAAApuF,EAAAiU,EAAA03E,EAAAntF,GACAwnD,GAAAxnD,IAAA++B,EAAAi8B,UAAA9T,GAAAlnD,GACA,GAAAqnC,GACA5xB,GAAAg/B,GAAAjzC,EAAAm+C,IAAAlqC,GACAkM,YAAA,WAAA,OAAAod,EAAA12B,MAAAu5B,OAAA,GAAA,KACA,GAAAyF,IACAuX,EAAAp9C,EAAAu9B,QAAA12B,MAAAwnF,cAAA7vF,GACA6mE,GAAArlE,IAlBA,CAfA,CAmIA,SAAAktF,GAAAltF,EAAAiU,EAAAk4E,GACA,GAAA,QAAAA,EAAA,OAAA,IAAAlY,GAAAhgE,EAAAA,GACA,GAAA,QAAAk4E,EAAA,OAAAnsF,EAAAsuF,WAAAr6E,GACA,GAAA,QAAAk4E,EAAA,OAAA,IAAAlY,GAAArwD,GAAA3P,EAAArO,KAAA,GAAA+jD,GAAA3pD,EAAAm+C,IAAAv6B,GAAA3P,EAAArO,KAAA,EAAA,KACA,IAAA4Q,EAAA21E,EAAAnsF,EAAAiU,GACA,OAAA,IAAAggE,GAAAz9D,EAAA9T,KAAA8T,EAAA7T,GALA,CAsLA,SAAA4rF,GAAAvuF,EAAAxB,EAAA6L,EAAAmkF,GACA,IAAAC,EAAAC,EACA,GAAAlwF,EAAAmwF,QACAF,EAAAjwF,EAAAmwF,QAAA,GAAArvE,QACAovE,EAAAlwF,EAAAmwF,QAAA,GAAAzvE,aAEA,IAAAuvE,EAAAjwF,EAAA8gB,QAAAovE,EAAAlwF,EAAA0gB,OAAA,CACA,MAAA0hD,GAAA,OAAA,CAAA,CAEA,GAAA6tB,GAAAzvE,KAAA+b,MAAA/6B,EAAAu9B,QAAAt8B,QAAAkgB,wBAAAE,OAAA,OAAA,EACAmtE,GAAA9oC,GAAAlnD,GAEA,IAAA++B,EAAAv9B,EAAAu9B,QACAqxD,EAAArxD,EAAAqoC,QAAAzkD,wBAEA,GAAAutE,EAAAE,EAAArtE,SAAAgkC,GAAAvlD,EAAAqK,GAAA,OAAA66C,GAAA1mD,GACAkwF,GAAAE,EAAAjzE,IAAA4hB,EAAAugC,WAEA,IAAA,IAAAzgE,EAAA,EAAAA,EAAA2C,EAAAu9B,QAAAg6B,YAAAj6D,SAAAD,EAAA,CACA,IAAAwxF,EAAAtxD,EAAAt8B,QAAAu/B,WAAAnjC,GACA,GAAAwxF,GAAAA,EAAA1tE,wBAAAE,OAAAotE,EAIA,OADAt0D,GAAAn6B,EAAAqK,EAAArK,EAFA+oD,GAAA/oD,EAAAm+C,IAAAuwC,GACA1uF,EAAAu9B,QAAAg6B,YAAAl6D,GACAga,UAAA7Y,GACA0mD,GAAA1mD,EANA,CAlBA,CA6BA,SAAAktF,GAAA1rF,EAAAxB,GACA,OAAA+vF,GAAAvuF,EAAAxB,EAAA,eAAA,EADA,CASA,SAAA6vF,GAAAruF,EAAAxB,GACAo6D,GAAA54D,EAAAu9B,QAAA/+B,IAKA,SAAAwB,EAAAxB,GACA,QAAA+mD,GAAAvlD,EAAA,sBACAuuF,GAAAvuF,EAAAxB,EAAA,qBAAA,EAFA,CALAswF,CAAA9uF,EAAAxB,IACAumD,GAAA/kD,EAAAxB,EAAA,gBACA4+C,GAAAp9C,EAAAu9B,QAAA12B,MAAAwnF,cAAA7vF,EAHA,CAWA,SAAAuwF,GAAA/uF,GACAA,EAAAu9B,QAAA2hB,QAAA7nC,UAAArX,EAAAu9B,QAAA2hB,QAAA7nC,UAAA6V,QAAA,eAAA,IACAltB,EAAA2f,QAAAxf,MAAA+sB,QAAA,aAAA,UACAgwC,GAAAl9D,EAHA,CArYAurF,GAAArtF,UAAA2tF,QAAA,SAAArgD,EAAAv3B,EAAA4xB,GACA,OAAA75B,KAAAw/B,KATA,IASAA,GACA,GAAA8M,GAAArkC,EAAAjI,KAAAiI,MAAA4xB,GAAA75B,KAAA65B,MAFA,EA2YA,IAAA7nB,GAAA,CAAAuiC,SAAA,WAAA,MAAA,iBAAA,GAEA/1C,GAAA,CAAA,EACAwkF,GAAA,CAAA,EAkJA,SAAAC,GAAAjvF,EAAA8W,EAAAiH,GAEA,IAAAjH,KADAiH,GAAAA,GAAAC,IACA,CACA,IAAAkxE,EAAAlvF,EAAAu9B,QAAA4xD,cACAC,EAAAt4E,EAAAtV,GAAAyc,GACAmxE,EAAApvF,EAAAu9B,QAAAi8B,SAAA,YAAA01B,EAAA/7E,OACAi8E,EAAApvF,EAAAu9B,QAAAi8B,SAAA,YAAA01B,EAAAG,OACAD,EAAApvF,EAAAu9B,QAAAi8B,SAAA,WAAA01B,EAAAI,MACAF,EAAApvF,EAAAu9B,QAAAi8B,SAAA,YAAA01B,EAAAK,OACAH,EAAApvF,EAAAu9B,QAAAi8B,SAAA,OAAA01B,EAAAM,KAPA,CAFA,CAaA,SAAAC,GAAAzvF,GACAA,EAAA2f,QAAArf,cACA+9C,EAAAr+C,EAAAu9B,QAAA2hB,QAAA,mBACAl/C,EAAAu9B,QAAAu7B,MAAAl3D,MAAAqnE,SAAA,GACAjpE,EAAAu9B,QAAA6lC,WAAA,OAEA7lB,EAAAv9C,EAAAu9B,QAAA2hB,QAAA,mBACAsS,GAAAxxD,IAEAqgE,GAAArgE,GACA+gE,GAAA/gE,GACAk9D,GAAAl9D,GACAmgB,YAAA,WAAA,OAAA4pD,GAAA/pE,EAAA,GAAA,IAZA,CAkBA,SAAAJ,GAAAs7D,EAAAv7C,GACA,IAAAk+D,EAAA7xE,KAEA,KAAAA,gBAAApM,IAAA,OAAA,IAAAA,GAAAs7D,EAAAv7C,GAEA3T,KAAA2T,QAAAA,EAAAA,EAAA6/B,EAAA7/B,GAAA,CAAA,EAEA6/B,EAAAh1C,GAAAmV,GAAA,GAEA,IAAAw+B,EAAAx+B,EAAA7I,MACA,iBAAAqnC,EAAAA,EAAA,IAAAghC,GAAAhhC,EAAAx+B,EAAAvf,KAAA,KAAAuf,EAAA46B,cAAA56B,EAAAqjC,WACArjC,EAAAvf,OAAA+9C,EAAA02B,WAAAl1D,EAAAvf,MACA4L,KAAAmyC,IAAAA,EAEA,IAAAt3C,EAAA,IAAAjH,GAAA8vF,YAAA/vE,EAAAgwE,YAAA3jF,MACAuxB,EAAAvxB,KAAAuxB,QAAA,IAAAu0C,GAAA5W,EAAA/c,EAAAt3C,EAAA8Y,GA2CA,IAAA,IAAAytB,KA1CA7P,EAAA2hB,QAAAt/C,WAAAoM,KACA+iF,GAAA/iF,MACA2T,EAAArf,eACA0L,KAAAuxB,QAAA2hB,QAAA7nC,WAAA,oBACAszD,GAAA3+D,MAEAA,KAAAjI,MAAA,CACAwmF,QAAA,GACAt/B,SAAA,GACAJ,QAAA,EACApL,WAAA,EACA6lB,mBAAA,EACA5wB,SAAA,EACAqmC,eAAA,EACA6U,eAAA,EAAAC,aAAA,EACA9D,eAAA,EACAxmB,cAAA,EACAiJ,UAAA,IAAAtuB,EACAmqC,OAAA,KACA12B,aAAA,MAGAh0C,EAAAomB,YAAA+W,GAAAvf,EAAA12B,MAAAu5B,QAIA4b,GAAAC,EAAA,IAAA97B,YAAA,WAAA,OAAA09D,EAAAtgD,QAAA12B,MAAAgxB,OAAA,EAAA,GAAA,IAmCA,SAAA73B,GACA,IAAAyxD,EAAAzxD,EAAAu9B,QACA/7B,GAAAiwD,EAAA+H,SAAA,YAAA97C,GAAA1d,EAAAwrF,KAGAhqF,GAAAiwD,EAAA+H,SAAA,WADAxd,GAAAC,EAAA,GACAv+B,GAAA1d,GAAA,SAAAxB,GACA,IAAAumD,GAAA/kD,EAAAxB,GAAA,CACA,IAAAyV,EAAAusD,GAAAxgE,EAAAxB,GACA,GAAAyV,IAAAy3E,GAAA1rF,EAAAxB,KAAAo6D,GAAA54D,EAAAu9B,QAAA/+B,GAAA,CACAknD,GAAAlnD,GACA,IAAA6U,EAAArT,EAAAsuF,WAAAr6E,GACAg/B,GAAAjzC,EAAAm+C,IAAA9qC,EAAA+J,OAAA/J,EAAAgK,KAHA,CAFA,CADA,IASA,SAAA7e,GAAA,OAAAumD,GAAA/kD,EAAAxB,IAAAknD,GAAAlnD,EAAA,GAIAgD,GAAAiwD,EAAA+H,SAAA,eAAA,SAAAh7D,GAAA,OAAA6vF,GAAAruF,EAAAxB,EAAA,IACAgD,GAAAiwD,EAAA5qD,MAAAgkF,WAAA,eAAA,SAAArsF,GACAizD,EAAA+H,SAAA1b,SAAAt/C,EAAArB,SAAAkxF,GAAAruF,EAAAxB,EADA,IAKA,IAAAsxF,EAAAC,EAAA,CAAAr2E,IAAA,GACA,SAAAs2E,IACAv+B,EAAAygB,cACA4d,EAAA3vE,YAAA,WAAA,OAAAsxC,EAAAygB,YAAA,IAAA,GAAA,MACA6d,EAAAt+B,EAAAygB,aACAx4D,KAAA,IAAA0mC,KAJA,CAOA,SAAA6vC,EAAAzxF,GACA,GAAA,GAAAA,EAAAmwF,QAAArxF,OAAA,OAAA,EACA,IAAA4yF,EAAA1xF,EAAAmwF,QAAA,GACA,OAAAuB,EAAAC,SAAA,GAAAD,EAAAE,SAAA,CAHA,CAKA,SAAAC,EAAAH,EAAAr9C,GACA,GAAA,MAAAA,EAAAzzB,KAAA,OAAA,EACA,IAAAkzD,EAAAz/B,EAAAzzB,KAAA8wE,EAAA9wE,KAAAozD,EAAA3/B,EAAAl3B,IAAAu0E,EAAAv0E,IACA,OAAA22D,EAAAA,EAAAE,EAAAA,EAAA,GAHA,CAKAhxE,GAAAiwD,EAAA+H,SAAA,cAAA,SAAAh7D,GACA,IAAAumD,GAAA/kD,EAAAxB,KAAAyxF,EAAAzxF,KAAAktF,GAAA1rF,EAAAxB,GAAA,CACAizD,EAAA5qD,MAAAmjF,eACAnlE,aAAAirE,GACA,IAAAlE,GAAA,IAAAxrC,KACAqR,EAAAygB,YAAA,CAAA/+D,MAAAy4E,EAAAY,OAAA,EACAvgF,KAAA2/E,EAAAmE,EAAAr2E,KAAA,IAAAq2E,EAAA,MACA,GAAAvxF,EAAAmwF,QAAArxF,SACAm0D,EAAAygB,YAAA9yD,KAAA5gB,EAAAmwF,QAAA,GAAA2B,MACA7+B,EAAAygB,YAAAv2D,IAAAnd,EAAAmwF,QAAA,GAAA4B,MARA,CADA,IAaA/uF,GAAAiwD,EAAA+H,SAAA,aAAA,WACA/H,EAAAygB,cAAAzgB,EAAAygB,YAAAsa,OAAA,EADA,IAGAhrF,GAAAiwD,EAAA+H,SAAA,YAAA,SAAAh7D,GACA,IAAA0xF,EAAAz+B,EAAAygB,YACA,GAAAge,IAAAt3B,GAAAnH,EAAAjzD,IAAA,MAAA0xF,EAAA9wE,OACA8wE,EAAA1D,OAAA,IAAApsC,KAAA8vC,EAAA/8E,MAAA,IAAA,CACA,IAAA8J,EAAAhJ,EAAAjU,EAAA0hB,WAAA+vC,EAAAygB,YAAA,QAEAj1D,GADAizE,EAAAjkF,MAAAokF,EAAAH,EAAAA,EAAAjkF,MACA,IAAAgoE,GAAAhgE,EAAAA,IACAi8E,EAAAjkF,KAAAA,MAAAokF,EAAAH,EAAAA,EAAAjkF,KAAAA,MACAjM,EAAAsuF,WAAAr6E,GAEA,IAAAggE,GAAArwD,GAAA3P,EAAArO,KAAA,GAAA+jD,GAAA3pD,EAAAm+C,IAAAv6B,GAAA3P,EAAArO,KAAA,EAAA,KACA5F,EAAA+4E,aAAA97D,EAAAG,OAAAH,EAAAI,MACArd,EAAAogC,QACAslB,GAAAlnD,EAVA,CAYAwxF,GAfA,IAiBAxuF,GAAAiwD,EAAA+H,SAAA,cAAAw2B,GAIAxuF,GAAAiwD,EAAA+H,SAAA,UAAA,WACA/H,EAAA+H,SAAAv8B,eACAyqC,GAAA1nE,EAAAyxD,EAAA+H,SAAAl9B,WACA0rC,GAAAhoE,EAAAyxD,EAAA+H,SAAAn9B,YAAA,GACAlC,GAAAn6B,EAAA,SAAAA,GAJA,IASAwB,GAAAiwD,EAAA+H,SAAA,cAAA,SAAAh7D,GAAA,OAAAw0E,GAAAhzE,EAAAxB,EAAA,IACAgD,GAAAiwD,EAAA+H,SAAA,kBAAA,SAAAh7D,GAAA,OAAAw0E,GAAAhzE,EAAAxB,EAAA,IAGAgD,GAAAiwD,EAAAvS,QAAA,UAAA,WAAA,OAAAuS,EAAAvS,QAAA5iB,UAAAm1B,EAAAvS,QAAA7iB,WAAA,CAAA,IAEAo1B,EAAA09B,cAAA,CACAE,MAAA,SAAA7wF,GAAAumD,GAAA/kD,EAAAxB,IAAAunD,GAAAvnD,EAAA,EACA8wF,KAAA,SAAA9wF,GAAAumD,GAAA/kD,EAAAxB,KAt5CA,SAAAwB,EAAAxB,GACA,IAAAyV,EAAAusD,GAAAxgE,EAAAxB,GACA,GAAAyV,EAAA,CACA,IAAAu8E,EAAA3xE,SAAAiD,yBACAygD,GAAAviE,EAAAiU,EAAAu8E,GACAxwF,EAAAu9B,QAAAkmD,aACAzjF,EAAAu9B,QAAAkmD,WAAAnlE,EAAA,MAAA,KAAA,6CACAte,EAAAu9B,QAAA07B,UAAAzC,aAAAx2D,EAAAu9B,QAAAkmD,WAAAzjF,EAAAu9B,QAAAynC,YAEAtnB,EAAA19C,EAAAu9B,QAAAkmD,WAAA+M,EAPA,CAFA,CAs5CAC,CAAAzwF,EAAAxB,GAAAunD,GAAAvnD,GAAA,EACA2U,MAAA,SAAA3U,GAAA,OA96CA,SAAAwB,EAAAxB,GACA,GAAAw9C,KAAAh8C,EAAA+D,MAAAwhE,eAAA,IAAAnlB,KAAAkiC,GAAA,KAAAv8B,GAAAvnD,QACA,IAAAumD,GAAA/kD,EAAAxB,KAAAo6D,GAAA54D,EAAAu9B,QAAA/+B,KAEAA,EAAAkkF,aAAAgO,QAAA,OAAA1wF,EAAAi5B,gBACAz6B,EAAAkkF,aAAAiO,cAAA,WAIAnyF,EAAAkkF,aAAAkO,eAAAr0C,GAAA,CACA,IAAA31C,EAAA0X,EAAA,MAAA,KAAA,KAAA,qCACA1X,EAAAq+B,IAAA,6EACAqX,IACA11C,EAAA62B,MAAA72B,EAAAu2B,OAAA,EACAn9B,EAAAu9B,QAAA2hB,QAAAt/B,YAAAhZ,GAEAA,EAAAiqF,KAAAjqF,EAAAo1B,WAEAx9B,EAAAkkF,aAAAkO,aAAAhqF,EAAA,EAAA,GACA01C,GAAA11C,EAAA2X,WAAAC,YAAA5X,EAVA,CATA,CA86CAkqF,CAAA9wF,EAAAxB,EAAA,EACAgxF,KAAA9xE,GAAA1d,EAAAuiF,IACAgN,MAAA,SAAA/wF,GAAAumD,GAAA/kD,EAAAxB,IAAAgkF,GAAAxiF,EAAA,GAGA,IAAA+wF,EAAAt/B,EAAA5qD,MAAAgkF,WACArpF,GAAAuvF,EAAA,SAAA,SAAAvyF,GAAA,OAAAysF,GAAAtsF,KAAAqB,EAAAxB,EAAA,IACAgD,GAAAuvF,EAAA,UAAArzE,GAAA1d,EAAA4qF,KACAppF,GAAAuvF,EAAA,WAAArzE,GAAA1d,EAAAkrF,KACA1pF,GAAAuvF,EAAA,SAAA,SAAAvyF,GAAA,OAAAqhC,GAAA7/B,EAAAxB,EAAA,IACAgD,GAAAuvF,EAAA,QAAA,SAAAvyF,GAAA,OAAAohC,GAAA5/B,EAAAxB,EAAA,GA3GA,CAjCAwyF,CAAAhlF,MACA+3E,KAEAhZ,GAAA/+D,MACAA,KAAAq5C,MAAA+U,aAAA,EACAgc,GAAApqE,KAAAmyC,GAEAx+B,EAAAomB,YAAA+W,GAAA9wC,KAAAm5D,WACAhlD,YAAA,WACA09D,EAAA1Y,aAAA0Y,EAAA95E,MAAA2wC,SAAA7U,GAAAg+C,EADA,GAEA,IAEAj+C,GAAA5zB,MAEAgjF,GAAAA,GAAA3qF,eAAA+oC,IACA4hD,GAAA5hD,GAAAphC,KAAA2T,EAAAytB,GAAApvB,IACAyxD,GAAAzjE,MACA2T,EAAAsxE,YAAAtxE,EAAAsxE,WAAAjlF,MACA,IAAA,IAAA3O,EAAA,EAAAA,EAAA6zF,GAAA5zF,SAAAD,EAAA6zF,GAAA7zF,GAAA2O,MACA0/D,GAAA1/D,MAGAkwC,GAAAv8B,EAAArf,cACA,sBAAA47B,iBAAAqB,EAAAqoC,SAAAurB,gBACA5zD,EAAAqoC,QAAAhkE,MAAAuvF,cAAA,OApEA,CAwEAvxF,GAAA4K,SAAAA,GAEA5K,GAAAovF,eAAAA,GAiHA,IAAAkC,GAAA,GAQA,SAAAx5C,GAAA13C,EAAAf,EAAAmyF,EAAAC,GACA,IAAAttF,EAAAo6C,EAAAn+C,EAAAm+C,IACA,MAAAizC,IAAAA,EAAA,OACA,SAAAA,IAGAjzC,EAAA/9C,KAAAmF,OACAxB,EAAA2nD,GAAA1rD,EAAAf,GAAA8E,MADAqtF,EAAA,QAIA,IAAAzxC,EAAA3/C,EAAA2f,QAAAggC,QACA/5C,EAAAozB,GAAAmlB,EAAAl/C,GAAAqyF,EAAA5xC,EAAA95C,EAAA7D,KAAA,KAAA49C,GACA/5C,EAAAimD,aAAAjmD,EAAAimD,WAAA,MACA,IAAAv+C,EAAAikF,EAAA3rF,EAAA7D,KAAAE,MAAA,QAAA,GACA,GAAAovF,GAAA,KAAAntF,KAAA0B,EAAA7D,OAGA,GAAA,SAAAqvF,KACA9jF,EAAA6wC,EAAA/9C,KAAAmF,OAAAxB,EAAA6B,EAAA7D,KAAAmR,MAAAq+E,EAAAj0F,QAAAsI,EAAA7D,QACA8D,GAAAyH,EAAA,KAAA,CACA,IAAA+jF,EAAA,OACAD,EAAA,MAFA,OAJA9jF,EAAA,EACA8jF,EAAA,MAQA,QAAAA,EACA9jF,EAAArO,EAAAk/C,EAAAld,MAAAye,EAAA1mB,GAAAmlB,EAAAl/C,EAAA,GAAA8C,KAAA,KAAA49C,GACA,EACA,OAAAyxC,EACA9jF,EAAAgkF,EAAAtxF,EAAA2f,QAAApV,WACA,YAAA6mF,EACA9jF,EAAAgkF,EAAAtxF,EAAA2f,QAAApV,WACA,iBAAA6mF,IACA9jF,EAAAgkF,EAAAF,GAEA9jF,EAAA0R,KAAAC,IAAA,EAAA3R,GAEA,IAAAkkF,EAAA,GAAAv9E,EAAA,EACA,GAAAjU,EAAA2f,QAAA8xE,eACA,IAAA,IAAAp0F,EAAA2hB,KAAA+b,MAAAztB,EAAAqyC,GAAAtiD,IAAAA,EAAA4W,GAAA0rC,EAAA6xC,GAAA,KAGA,GAFAv9E,EAAA3G,IAAAkkF,GAAAvwC,EAAA3zC,EAAA2G,IAEAu9E,GAAAD,EAGA,OAFA5wD,GAAAwd,EAAAqzC,EAAA5tE,GAAA3kB,EAAA,GAAA2kB,GAAA3kB,EAAAsyF,EAAAj0F,QAAA,UACAsI,EAAAimD,WAAA,MACA,EAIA,IAAA,IAAA3I,EAAA,EAAAA,EAAA/E,EAAAtgC,IAAAd,OAAAzf,OAAA4lD,IAAA,CACA,IAAAjmC,EAAAkhC,EAAAtgC,IAAAd,OAAAmmC,GACA,GAAAjmC,EAAAI,KAAAzX,MAAA3G,GAAAge,EAAAI,KAAAvS,GAAAymF,EAAAj0F,OAAA,CACA,IAAAo0F,EAAA9tE,GAAA3kB,EAAAsyF,EAAAj0F,QACA47E,GAAA/6B,EAAA+E,EAAA,IAAA+wB,GAAAyd,EAAAA,IACA,KAHA,CAFA,CAhDA,CAPA9xF,GAAA+xF,eAAA,SAAAtyF,GAAA,OAAA6xF,GAAA7iF,KAAAhP,EAAA,EAqEA,IAAAuyF,GAAA,KAEA,SAAAC,GAAAC,GACAF,GAAAE,CADA,CAIA,SAAAC,GAAA/xF,EAAAgyF,EAAAC,EAAAp0E,EAAA8iC,GACA,IAAAxC,EAAAn+C,EAAAm+C,IACAn+C,EAAAu9B,QAAAnJ,OAAA,EACAvW,IAAAA,EAAAsgC,EAAAtgC,KAEA,IAAAq0E,GAAA,IAAA9xC,KAAA,IACA+xC,EAAA,SAAAxxC,GAAA3gD,EAAA+D,MAAA6rF,cAAAsC,EACAE,EAAAvrC,GAAAmrC,GAAAK,EAAA,KAEA,GAAAF,GAAAt0E,EAAAd,OAAAzf,OAAA,EACA,GAAAs0F,IAAAA,GAAA7vF,KAAAmnB,KAAA,OAAA8oE,GACA,GAAAn0E,EAAAd,OAAAzf,OAAAs0F,GAAA7vF,KAAAzE,QAAA,EAAA,CACA+0F,EAAA,GACA,IAAA,IAAAh1F,EAAA,EAAAA,EAAAu0F,GAAA7vF,KAAAzE,OAAAD,IACAg1F,EAAAhkF,KAAA8vC,EAAAs+B,WAAAmV,GAAA7vF,KAAA1E,IAHA,OAKA+0F,EAAA90F,QAAAugB,EAAAd,OAAAzf,QAAA0C,EAAA2f,QAAA2yE,yBACAD,EAAAn+D,GAAAk+D,GAAA,SAAA5yF,GAAA,MAAA,CAAAA,EAAA,KAMA,IAFA,IAAAyrE,EAAAjrE,EAAAqlD,MAAA4lB,YAEA/nB,EAAArlC,EAAAd,OAAAzf,OAAA,EAAA4lD,GAAA,EAAAA,IAAA,CACA,IAAAjmC,EAAAY,EAAAd,OAAAmmC,GACAxgD,EAAAua,EAAAva,OAAAC,EAAAsa,EAAAta,KACAsa,EAAAK,UACA20E,GAAAA,EAAA,EACAvvF,EAAAkhB,GAAAlhB,EAAAkD,KAAAlD,EAAAoI,GAAAmnF,GACAjyF,EAAA+D,MAAA07C,YAAA0yC,EACAxvF,EAAAihB,GAAAjhB,EAAAiD,KAAAoZ,KAAAK,IAAA2Z,GAAAmlB,EAAAx7C,EAAAiD,MAAA7D,KAAAzE,OAAAqF,EAAAmI,GAAAo2C,GAAAkxC,GAAA90F,SACA60F,GAAAP,IAAAA,GAAAW,UAAAX,GAAA7vF,KAAAmnB,KAAA,OAAAkpE,EAAAlpE,KAAA,QACAxmB,EAAAC,EAAAihB,GAAAlhB,EAAAkD,KAAA,KAEA,IAAA4sF,EAAA,CAAA9vF,KAAAA,EAAAC,GAAAA,EAAAZ,KAAAswF,EAAAA,EAAAnvC,EAAAmvC,EAAA/0F,QAAA80F,EACAzxC,OAAAA,IAAAwxC,EAAA,QAAAnyF,EAAA+D,MAAA8rF,YAAAqC,EAAA,MAAA,WACArX,GAAA76E,EAAAm+C,IAAAq0C,GACAl9B,GAAAt1D,EAAA,YAAAA,EAAAwyF,EAdA,CAgBAR,IAAAG,GACA/2C,GAAAp7C,EAAAgyF,GAEA5qB,GAAApnE,GACAA,EAAAqlD,MAAA4lB,YAAA,IAAAjrE,EAAAqlD,MAAA4lB,YAAAA,GACAjrE,EAAAqlD,MAAA6lB,QAAA,EACAlrE,EAAA+D,MAAA6rF,cAAA5vF,EAAA+D,MAAA8rF,aAAA,CA7CA,CAgDA,SAAA4C,GAAAj0F,EAAAwB,GACA,IAAA0yF,EAAAl0F,EAAAm0F,eAAAn0F,EAAAm0F,cAAAnP,QAAA,QACA,GAAAkP,EAIA,OAHAl0F,EAAAwmD,iBACAhlD,EAAA2iF,cAAA3iF,EAAA2f,QAAAizE,eAAA5yF,EAAAmlE,YACAkJ,GAAAruE,GAAA,WAAA,OAAA+xF,GAAA/xF,EAAA0yF,EAAA,EAAA,KAAA,QAAA,KACA,CANA,CAUA,SAAAt3C,GAAAp7C,EAAAgyF,GAEA,GAAAhyF,EAAA2f,QAAAqxB,eAAAhxC,EAAA2f,QAAAkzE,YAGA,IAFA,IAAAh1E,EAAA7d,EAAAm+C,IAAAtgC,IAEAxgB,EAAAwgB,EAAAd,OAAAzf,OAAA,EAAAD,GAAA,EAAAA,IAAA,CACA,IAAA4f,EAAAY,EAAAd,OAAA1f,GACA,KAAA4f,EAAAI,KAAAvS,GAAA,KAAAzN,GAAAwgB,EAAAd,OAAA1f,EAAA,GAAAggB,KAAAzX,MAAAqX,EAAAI,KAAAzX,MAAA,CACA,IAAAxF,EAAAJ,EAAAu7C,UAAAt+B,EAAAI,MACAlR,GAAA,EACA,GAAA/L,EAAA4wC,eACA,IAAA,IAAA/gB,EAAA,EAAAA,EAAA7vB,EAAA4wC,cAAA1zC,OAAA2yB,IACA,GAAA+hE,EAAAn+E,QAAAzT,EAAA4wC,cAAA98B,OAAA+b,KAAA,EAAA,CACA9jB,EAAAurC,GAAA13C,EAAAid,EAAAI,KAAAzX,KAAA,SACA,KAFA,OAIAxF,EAAAwN,eACAxN,EAAAwN,cAAA1J,KAAA80B,GAAAh5B,EAAAm+C,IAAAlhC,EAAAI,KAAAzX,MAAA7D,KAAAmR,MAAA,EAAA+J,EAAAI,KAAAvS,OACAqB,EAAAurC,GAAA13C,EAAAid,EAAAI,KAAAzX,KAAA,UAEAuG,GAAAmpD,GAAAt1D,EAAA,gBAAAA,EAAAid,EAAAI,KAAAzX,KAbA,CAFA,CALA,CAwBA,SAAAktF,GAAA9yF,GAEA,IADA,IAAA+B,EAAA,GAAAgb,EAAA,GACA1f,EAAA,EAAAA,EAAA2C,EAAAm+C,IAAAtgC,IAAAd,OAAAzf,OAAAD,IAAA,CACA,IAAAuI,EAAA5F,EAAAm+C,IAAAtgC,IAAAd,OAAA1f,GAAAggB,KAAAzX,KACAmtF,EAAA,CAAA31E,OAAAwG,GAAAhe,EAAA,GAAAyX,KAAAuG,GAAAhe,EAAA,EAAA,IACAmX,EAAA1O,KAAA0kF,GACAhxF,EAAAsM,KAAArO,EAAAmuC,SAAA4kD,EAAA31E,OAAA21E,EAAA11E,MAJA,CAMA,MAAA,CAAAtb,KAAAA,EAAAgb,OAAAA,EARA,CAWA,SAAAi2E,GAAAC,EAAA1yF,EAAAC,EAAAosC,GACAqmD,EAAA53D,aAAA,cAAA76B,EAAA,KAAA,OACAyyF,EAAA53D,aAAA,iBAAAuR,EAAA,KAAA,OACAqmD,EAAA53D,aAAA,eAAA96B,EAHA,CAMA,SAAA2yF,KACA,IAAAlsC,EAAA1oC,EAAA,WAAA,KAAA,KAAA,yGACA7V,EAAA6V,EAAA,MAAA,CAAA0oC,GAAA,KAAA,kEASA,OAJA9K,EAAA8K,EAAAplD,MAAA67B,MAAA,SACAupB,EAAA3rB,aAAA,OAAA,OAEAshB,IAAAqK,EAAAplD,MAAAuxF,OAAA,mBACA1qF,CAXA,CA8cA,SAAA2qF,GAAAj1C,EAAAlqC,EAAAzL,EAAA2jF,EAAApG,GACA,IAAAhM,EAAA9lE,EACAo/E,EAAA7qF,EACA6oD,EAAAr4B,GAAAmlB,EAAAlqC,EAAArO,MACA0tF,EAAAvN,GAAA,OAAA5nC,EAAA6E,WAAAx6C,EAAAA,EAOA,SAAA+qF,EAAAC,GACA,IAAAzoF,EANAvL,EAOA,GAAA,aAAA2sF,EAAA,CACA,IAAArhF,EAAAumD,EAAAtvD,KAAA8/C,WAAA5tC,EAAAnJ,IAAAtC,EAAA,EAAA,GAAA,IACA,GAAAstC,MAAAhrC,GACAC,EAAA,SACA,CACA,IAAA0oF,EAAAjrF,EAAA,EAAAsC,GAAA,OAAAA,EAAA,MAAAA,GAAA,OAAAA,EAAA,MACAC,EAAA,IAAA6Y,GAAA3P,EAAArO,KAAAoZ,KAAAC,IAAA,EAAAD,KAAAK,IAAAgyC,EAAAtvD,KAAAzE,OAAA2W,EAAAnJ,GAAAtC,GAAAirF,EAAA,EAAA,MAAAjrF,EAFA,CAJA,MASAuC,EADAg7E,EAxxDA,SAAA/lF,EAAA4F,EAAAuN,EAAA3K,GACA,IAAAkrF,EAAArvC,GAAAz+C,EAAA5F,EAAAm+C,IAAA6E,WACA,IAAA0wC,EAAA,OAAA7N,GAAAjgF,EAAAuN,EAAA3K,GACA2K,EAAArI,IAAAlF,EAAA7D,KAAAzE,QACA6V,EAAArI,GAAAlF,EAAA7D,KAAAzE,OACA6V,EAAAovC,OAAA,UACApvC,EAAArI,IAAA,IACAqI,EAAArI,GAAA,EACAqI,EAAAovC,OAAA,SAEA,IAAAgc,EAAAlc,GAAAqxC,EAAAvgF,EAAArI,GAAAqI,EAAAovC,QAAA0R,EAAAy/B,EAAAn1B,GACA,GAAA,OAAAv+D,EAAAm+C,IAAA6E,WAAAiR,EAAAlR,MAAA,GAAA,IAAAv6C,EAAA,EAAAyrD,EAAAtxD,GAAAwQ,EAAArI,GAAAmpD,EAAAvxD,KAAAyQ,EAAArI,IAGA,OAAA+6E,GAAAjgF,EAAAuN,EAAA3K,GAGA,IACAw9E,EADA2N,EAAA,SAAA1/E,EAAAzL,GAAA,OAAAo9E,GAAAhgF,EAAAqO,aAAA2P,GAAA3P,EAAAnJ,GAAAmJ,EAAAzL,EAAA,EAEAorF,EAAA,SAAA9oF,GACA,OAAA9K,EAAA2f,QAAArf,cACA0lF,EAAAA,GAAAhsB,GAAAh6D,EAAA4F,GACAq5D,GAAAj/D,EAAA4F,EAAAogF,EAAAl7E,IAFA,CAAAk0D,MAAA,EAAAtlD,IAAA9T,EAAA7D,KAAAzE,OADA,EAKAyhE,EAAA60B,EAAA,UAAAzgF,EAAAovC,OAAAoxC,EAAAxgF,GAAA,GAAAA,EAAArI,IAEA,GAAA,OAAA9K,EAAAm+C,IAAA6E,WAAA,GAAAiR,EAAAlR,MAAA,CACA,IAAA8wC,EAAA,GAAA5/B,EAAAlR,OAAAv6C,EAAA,EACAsC,EAAA6oF,EAAAxgF,EAAA0gF,EAAA,GAAA,GACA,GAAA,MAAA/oF,IAAA+oF,EAAA/oF,GAAAmpD,EAAAtxD,IAAAmI,GAAAi0D,EAAArlD,IAAA5O,GAAAmpD,EAAAvxD,MAAAoI,GAAAi0D,EAAAC,OAAA,CAEA,IAAAzc,EAAAsxC,EAAA,SAAA,QACA,OAAA,IAAAjwE,GAAAzQ,EAAAvN,KAAAkF,EAAAy3C,EAHA,CAHA,CAaA,IAAAuxC,EAAA,SAAAv1B,EAAA/1D,EAAAu2D,GAKA,IAJA,IAAAg1B,EAAA,SAAAjpF,EAAA+oF,GAAA,OAAAA,EACA,IAAAjwE,GAAAzQ,EAAAvN,KAAA+tF,EAAA7oF,EAAA,GAAA,UACA,IAAA8Y,GAAAzQ,EAAAvN,KAAAkF,EAAA,QAFA,EAIAyzD,GAAA,GAAAA,EAAAm1B,EAAAp2F,OAAAihE,GAAA/1D,EAAA,CACA,IAAAyrD,EAAAy/B,EAAAn1B,GACAs1B,EAAArrF,EAAA,IAAA,GAAAyrD,EAAAlR,OACAj4C,EAAA+oF,EAAA90B,EAAAC,MAAA20B,EAAA50B,EAAArlD,KAAA,GACA,GAAAu6C,EAAAvxD,MAAAoI,GAAAA,EAAAmpD,EAAAtxD,GAAA,OAAAoxF,EAAAjpF,EAAA+oF,GAEA,GADA/oF,EAAA+oF,EAAA5/B,EAAAvxD,KAAAixF,EAAA1/B,EAAAtxD,IAAA,GACAo8D,EAAAC,OAAAl0D,GAAAA,EAAAi0D,EAAArlD,IAAA,OAAAq6E,EAAAjpF,EAAA+oF,EANA,CALA,EAgBAG,EAAAF,EAAAv1B,EAAA/1D,EAAAA,EAAAu2D,GACA,GAAAi1B,EAAA,OAAAA,EAGA,IAAAC,EAAAzrF,EAAA,EAAAu2D,EAAArlD,IAAAi6E,EAAA50B,EAAAC,OAAA,GACA,OAAA,MAAAi1B,GAAAzrF,EAAA,GAAAyrF,GAAAruF,EAAA7D,KAAAzE,UACA02F,EAAAF,EAAAtrF,EAAA,EAAA,EAAAkrF,EAAAp2F,OAAA,EAAAkL,EAAAorF,EAAAK,KAKA,KAJAD,CA9DA,CAyxDAE,CAAA/1C,EAAAn+C,GAAAqxD,EAAAp9C,EAAAzL,GAEAq9E,GAAAx0B,EAAAp9C,EAAAzL,GAEA,GAAA,MAAAuC,EAAA,CACA,GAAAyoF,IArBAh0F,EAAAyU,EAAArO,KAAA0tF,GACAn1C,EAAAld,OAAAzhC,GAAA2+C,EAAAld,MAAAkd,EAAAvV,OACA30B,EAAA,IAAA2P,GAAApkB,EAAAyU,EAAAnJ,GAAAmJ,EAAAsuC,UACA8O,EAAAr4B,GAAAmlB,EAAA3+C,KAqBA,OAAA,EAFAyU,EAAA6xE,GAAAC,EAAA5nC,EAAAn+C,GAAAqxD,EAAAp9C,EAAArO,KAAA0tF,EAFA,MAMAr/E,EAAAlJ,EAEA,OAAA,CAvBA,CA0BA,GAAA,QAAAohF,GAAA,aAAAA,EACAoH,SACA,GAAA,UAAApH,EACAoH,GAAA,QACA,GAAA,QAAApH,GAAA,SAAAA,EAGA,IAFA,IAAAgI,EAAA,KAAAvoB,EAAA,SAAAugB,EACA1qC,EAAAtD,EAAAn+C,IAAAm+C,EAAAn+C,GAAA2jB,UAAA1P,EAAA,aACAgtB,GAAA,IACAz4B,EAAA,IAAA+qF,GAAAtyD,GADAA,GAAA,EAAA,CAEA,IAAAh8B,EAAAosD,EAAAtvD,KAAAmS,OAAAD,EAAAnJ,KAAA,KACAT,EAAA0wC,GAAA91C,EAAAw8C,GAAA,IACAmqB,GAAA,MAAA3mE,EAAA,KACA2mE,GAAA,KAAA1nE,KAAAe,GAAA,KACA,IAEA,IADA2mE,GAAA3qC,GAAA52B,IAAAA,EAAA,KACA8pF,GAAAA,GAAA9pF,EAAA,CACA7B,EAAA,IAAAA,EAAA,EAAA+qF,IAAAt/E,EAAAsuC,OAAA,SACA,KAFA,CAMA,GADAl4C,IAAA8pF,EAAA9pF,GACA7B,EAAA,IAAA+qF,GAAAtyD,GAAA,KAdA,CAiBA,IAAAzqB,EAAAojE,GAAAz7B,EAAAlqC,EAAA8lE,EAAAsZ,GAAA,GAEA,OADA/pC,GAAAywB,EAAAvjE,KAAAA,EAAA49E,SAAA,GACA59E,CA/DA,CAqEA,SAAA69E,GAAAr0F,EAAAiU,EAAAzL,EAAA2jF,GACA,IAAA7qE,EASAnkB,EATAghD,EAAAn+C,EAAAm+C,IAAA/8B,EAAAnN,EAAAmL,KACA,GAAA,QAAA+sE,EAAA,CACA,IAAAmI,EAAAt1E,KAAAK,IAAArf,EAAAu9B,QAAA2hB,QAAAjiB,aAAAoiB,EAAAr/C,GAAA08B,aAAAyhB,EAAAn+C,GAAAw8B,gBAAAS,cACAs3D,EAAAv1E,KAAAC,IAAAq1E,EAAA,GAAAt0B,GAAAhgE,EAAAu9B,SAAA,GACAjc,GAAA9Y,EAAA,EAAAyL,EAAAsN,OAAAtN,EAAA0H,KAAAnT,EAAA+rF,CAHA,KAKA,QAAApI,IACA7qE,EAAA9Y,EAAA,EAAAyL,EAAAsN,OAAA,EAAAtN,EAAA0H,IAAA,GAGA,MACAxe,EAAAukB,GAAA1hB,EAAAohB,EAAAE,IACAq9C,SAFA,CAGA,GAAAn2D,EAAA,EAAA8Y,GAAA,EAAAA,GAAA68B,EAAAhhB,OAAA,CAAAhgC,EAAAi3F,SAAA,EAAA,KAAA,CACA9yE,GAAA,EAAA9Y,CAJA,CAMA,OAAArL,CAjBA,CAsBA,IAAAq3F,GAAA,SAAAx0F,GACAgM,KAAAhM,GAAAA,EACAgM,KAAAyoF,eAAAzoF,KAAA0oF,iBAAA1oF,KAAA2oF,cAAA3oF,KAAA4oF,gBAAA,KACA5oF,KAAA6oF,QAAA,IAAA30C,EACAl0C,KAAA8oF,UAAA,KACA9oF,KAAA+oF,aAAA,EACA/oF,KAAAgpF,eAAA,IANA,EAkYA,SAAAC,GAAAj1F,EAAAiU,GACA,IAAAkhD,EAAA8E,GAAAj6D,EAAAiU,EAAArO,MACA,IAAAuvD,GAAAA,EAAA/oB,OAAA,OAAA,KACA,IAAAxmC,EAAAozB,GAAAh5B,EAAAm+C,IAAAlqC,EAAArO,MACA6O,EAAAmlD,GAAAzE,EAAAvvD,EAAAqO,EAAArO,MAEA08C,EAAA+B,GAAAz+C,EAAA5F,EAAAm+C,IAAA6E,WAAA2gB,EAAA,OACArhB,IAEAqhB,EADAthB,GAAAC,EAAAruC,EAAAnJ,IACA,EAAA,QAAA,QAEA,IAAA0L,EAAA2kD,GAAA1mD,EAAAyf,IAAAjgB,EAAAnJ,GAAA64D,GAEA,OADAntD,EAAAw4C,OAAA,SAAAx4C,EAAAsoC,SAAAtoC,EAAAkD,IAAAlD,EAAArD,MACAqD,CAbA,CAsBA,SAAA0+E,GAAAjhF,EAAAkhF,GAAA,OAAAA,IAAAlhF,EAAAkhF,KAAA,GAAAlhF,CAAA,CAuDA,SAAAmhF,GAAAp1F,EAAA0e,EAAAswC,GACA,IAAAqmC,EACA,GAAA32E,GAAA1e,EAAAu9B,QAAAqoC,QAAA,CAEA,KADAyvB,EAAAr1F,EAAAu9B,QAAAqoC,QAAAplC,WAAAwuB,IACA,OAAAkmC,GAAAl1F,EAAA2pD,QAAA/lC,GAAA5jB,EAAAu9B,QAAAovB,OAAA,KAAA,GACAjuC,EAAA,KAAAswC,EAAA,CAHA,MAKA,IAAAqmC,EAAA32E,GAAA22E,EAAAA,EAAA92E,WAAA,CACA,IAAA82E,GAAAA,GAAAr1F,EAAAu9B,QAAAqoC,QAAA,OAAA,KACA,GAAAyvB,EAAA92E,YAAA82E,EAAA92E,YAAAve,EAAAu9B,QAAAqoC,QAAA,KAFA,CAKA,IAAA,IAAAvoE,EAAA,EAAAA,EAAA2C,EAAAu9B,QAAA43B,KAAA73D,OAAAD,IAAA,CACA,IAAAg1D,EAAAryD,EAAAu9B,QAAA43B,KAAA93D,GACA,GAAAg1D,EAAA3zC,MAAA22E,EACA,OAAAC,GAAAjjC,EAAA3zC,EAAAswC,EAHA,CAZA,CAmBA,SAAAsmC,GAAAjjC,EAAA3zC,EAAAswC,GACA,IAAA9P,EAAAmT,EAAAtwD,KAAA27B,WAAAy3D,GAAA,EACA,IAAAz2E,IAAAo/B,EAAAoB,EAAAxgC,GAAA,OAAAw2E,GAAAtxE,GAAAuwB,GAAAke,EAAAzsD,MAAA,IAAA,GACA,GAAA8Y,GAAAwgC,IACAi2C,GAAA,EACAz2E,EAAAwgC,EAAA1e,WAAAwuB,GACAA,EAAA,GACAtwC,GAAA,CACA,IAAA9Y,EAAAysD,EAAAI,KAAAvR,GAAAmR,EAAAI,MAAAJ,EAAAzsD,KACA,OAAAsvF,GAAAtxE,GAAAuwB,GAAAvuC,GAAAA,EAAA7D,KAAAzE,QAAA63F,EAFA,CAMA,IAAAI,EAAA,GAAA72E,EAAA4B,SAAA5B,EAAA,KAAA82E,EAAA92E,EAKA,IAJA62E,GAAA,GAAA72E,EAAA8hB,WAAAljC,QAAA,GAAAohB,EAAAgf,WAAApd,WACAi1E,EAAA72E,EAAAgf,WACAsxB,IAAAA,EAAAumC,EAAAE,UAAAn4F,SAEAk4F,EAAAj3E,YAAA2gC,GAAAs2C,EAAAA,EAAAj3E,WACA,IAAAioC,EAAA6L,EAAA7L,QAAAuM,EAAAvM,EAAAuM,KAEA,SAAAzxD,EAAAi0F,EAAAC,EAAAxmC,GACA,IAAA,IAAA3xD,GAAA,EAAAA,GAAA01D,EAAAA,EAAAz1D,OAAA,GAAAD,IAEA,IADA,IAAA62B,EAAA72B,EAAA,EAAAmpD,EAAAtyB,IAAA6+B,EAAA11D,GACA4yB,EAAA,EAAAA,EAAAiE,EAAA52B,OAAA2yB,GAAA,EAAA,CACA,IAAAylE,EAAAxhE,EAAAjE,EAAA,GACA,GAAAylE,GAAAH,GAAAG,GAAAF,EAAA,CACA,IAAA5vF,EAAAuuC,GAAA92C,EAAA,EAAAg1D,EAAAzsD,KAAAysD,EAAAI,KAAAp1D,IACAyN,EAAAopB,EAAAjE,GAAA++B,EAEA,OADAA,EAAA,GAAA0mC,GAAAH,KAAAzqF,EAAAopB,EAAAjE,GAAA++B,EAAA,EAAA,KACAprC,GAAAhe,EAAAkF,EAJA,CAFA,CAHA,CAcA,IAAAka,EAAA1jB,EAAAi0F,EAAAC,EAAAxmC,GACA,GAAAhqC,EAAA,OAAAkwE,GAAAlwE,EAAAmwE,GAGA,IAAA,IAAA3mD,EAAAgnD,EAAA73D,YAAAoiC,EAAAw1B,EAAAA,EAAAE,UAAAn4F,OAAA0xD,EAAA,EAAAxgB,EAAAA,EAAAA,EAAA7Q,YAAA,CAEA,GADA3Y,EAAA1jB,EAAAktC,EAAAA,EAAA9Q,WAAA,GAEA,OAAAw3D,GAAAtxE,GAAAoB,EAAApf,KAAAof,EAAAla,GAAAi1D,GAAAo1B,GAEAp1B,GAAAvxB,EAAAmnD,YAAAr4F,MALA,CAOA,IAAA,IAAAqwC,EAAA6nD,EAAAI,gBAAAC,EAAA7mC,EAAArhB,EAAAA,EAAAA,EAAAioD,gBAAA,CAEA,GADA5wE,EAAA1jB,EAAAqsC,EAAAA,EAAAjQ,YAAA,GAEA,OAAAw3D,GAAAtxE,GAAAoB,EAAApf,KAAAof,EAAAla,GAAA+qF,GAAAV,GAEAU,GAAAloD,EAAAgoD,YAAAr4F,MALA,CA9CA,CAzdAk3F,GAAAt2F,UAAA2sB,KAAA,SAAA0S,GACA,IAAAsgD,EAAA7xE,KAEAnF,EAAAmF,KAAAhM,EAAA6G,EAAA7G,GACAyI,EAAA5B,EAAA4B,IAAA80B,EAAAqoC,QAIA,SAAAkwB,EAAAt3F,GACA,IAAA,IAAAL,EAAAK,EAAArB,OAAAgB,EAAAA,EAAAA,EAAAogB,WAAA,CACA,GAAApgB,GAAAsK,EAAA,OAAA,EACA,GAAA,iCAAAvE,KAAA/F,EAAAkZ,WAAA,KAFA,CAIA,OAAA,CALA,CAiCA,SAAA0+E,EAAAv3F,GACA,GAAAs3F,EAAAt3F,KAAAumD,GAAA/kD,EAAAxB,GAAA,CACA,GAAAwB,EAAA+5B,oBACA83D,GAAA,CAAAU,UAAA,EAAAxwF,KAAA/B,EAAAk7C,kBACA,OAAA18C,EAAA6L,MAAArK,EAAAw6C,iBAAA,GAAA,KAAA,WACA,KAAAx6C,EAAA2f,QAAAq2E,gBACA,OAEA,IAAAj5E,EAAA+1E,GAAA9yF,GACA6xF,GAAA,CAAAU,UAAA,EAAAxwF,KAAAgb,EAAAhb,OACA,OAAAvD,EAAA6L,MACArK,EAAA0d,WAAA,WACA1d,EAAAy3C,cAAA16B,EAAAA,OAAA,EAAAyjC,GACAxgD,EAAAw6C,iBAAA,GAAA,KAAA,MAFA,GAJA,CAUA,GAAAh8C,EAAAm0F,cAAA,CACAn0F,EAAAm0F,cAAAsD,YACA,IAAAznF,EAAAojF,GAAA7vF,KAAAmnB,KAAA,MAGA,GADA1qB,EAAAm0F,cAAAjC,QAAA,OAAAliF,GACAhQ,EAAAm0F,cAAAnP,QAAA,SAAAh1E,EAEA,YADAhQ,EAAAwmD,gBANA,CAWA,IAAAkxC,EAAAhD,KAAAlsC,EAAAkvC,EAAAx4D,WACAs1D,GAAAhsC,GACAhnD,EAAAu9B,QAAA07B,UAAAzC,aAAA0/B,EAAAl2F,EAAAu9B,QAAA07B,UAAAv7B,YACAspB,EAAAlwC,MAAA86E,GAAA7vF,KAAAmnB,KAAA,MACA,IAAAitE,EAAAn4C,EAAAC,EAAAx1C,IACAw2C,EAAA+H,GACA7mC,YAAA,WACAngB,EAAAu9B,QAAA07B,UAAAz6C,YAAA03E,GACAC,EAAA/1D,QACA+1D,GAAA1tF,GAAA5B,EAAAuvF,sBAHA,GAIA,GArCA,CADA,CApCA3tF,EAAA4tF,iBAAA,EACArD,GAAAvqF,EAAAzI,EAAA2f,QAAApf,WAAAP,EAAA2f,QAAAnf,YAAAR,EAAA2f,QAAAitB,gBAUAprC,GAAAiH,EAAA,SAAA,SAAAjK,IACAs3F,EAAAt3F,IAAAumD,GAAA/kD,EAAAxB,IAAAi0F,GAAAj0F,EAAAwB,IAEAi8C,GAAA,IAAA97B,WAAAzC,GAAA1d,GAAA,WAAA,OAAA69E,EAAAyY,eAAA,IAAA,GAHA,IAMA90F,GAAAiH,EAAA,oBAAA,SAAAjK,GACAq/E,EAAAiX,UAAA,CAAA9uE,KAAAxnB,EAAAwnB,KAAAuwD,MAAA,EADA,IAGA/0E,GAAAiH,EAAA,qBAAA,SAAAjK,GACAq/E,EAAAiX,YAAAjX,EAAAiX,UAAA,CAAA9uE,KAAAxnB,EAAAwnB,KAAAuwD,MAAA,GADA,IAGA/0E,GAAAiH,EAAA,kBAAA,SAAAjK,GACAq/E,EAAAiX,YACAt2F,EAAAwnB,MAAA63D,EAAAiX,UAAA9uE,MAAA63D,EAAA0Y,kBACA1Y,EAAAiX,UAAAve,MAAA,EAHA,IAOA/0E,GAAAiH,EAAA,cAAA,WAAA,OAAA5B,EAAA2vF,qBAAA,IAEAh1F,GAAAiH,EAAA,SAAA,WACAo1E,EAAAiX,WAAAjX,EAAA0Y,iBADA,IA4CA/0F,GAAAiH,EAAA,OAAAstF,GACAv0F,GAAAiH,EAAA,MAAAstF,EAlFA,EAqFAvB,GAAAt2F,UAAAu4F,yBAAA,SAAA/vD,GAEAA,EACA16B,KAAAvD,IAAA4yB,aAAA,aAAAqL,GAEA16B,KAAAvD,IAAA64B,gBAAA,aALA,EASAkzD,GAAAt2F,UAAA8jE,iBAAA,WACA,IAAAxrD,EAAAwrD,GAAAh2D,KAAAhM,IAAA,GAEA,OADAwW,EAAA4pB,MAAA4d,EAAAC,EAAAjyC,KAAAvD,OAAAuD,KAAAvD,IACA+N,CAHA,EAMAg+E,GAAAt2F,UAAA6jE,cAAA,SAAAttD,EAAAy4D,GACAz4D,GAAAzI,KAAAhM,GAAAu9B,QAAA43B,KAAA73D,UACAmX,EAAA2rB,OAAA8sC,IAAAlhE,KAAAoqF,uBACApqF,KAAA0qF,uBAAAjiF,GAHA,EAMA+/E,GAAAt2F,UAAA+6B,aAAA,WACA,OAAAjtB,KAAAhM,GAAAu9B,QAAA2hB,QAAA3/B,cAAA0Z,cADA,EAIAu7D,GAAAt2F,UAAAk4F,qBAAA,WACA,IAAAv4E,EAAA7R,KAAAitB,eAAAj5B,EAAAgM,KAAAhM,GAAAq0E,EAAAr0E,EAAAm+C,IAAAtgC,IAAA49B,UACA/4C,EAAA2xE,EAAA3xE,OAAAC,EAAA0xE,EAAA1xE,KAEA,GAAA3C,EAAAu9B,QAAAovB,QAAA3sD,EAAAu9B,QAAAmvB,UAAAhqD,EAAAkD,MAAA5F,EAAAu9B,QAAAovB,QAAAhqD,EAAAiD,KAAA5F,EAAAu9B,QAAAmvB,SACA7uC,EAAA+yD,sBADA,CAKA,IAAA+lB,EAAAvB,GAAAp1F,EAAA6d,EAAAoyD,WAAApyD,EAAAsyD,cACAymB,EAAAxB,GAAAp1F,EAAA6d,EAAAuyD,UAAAvyD,EAAAwyD,aACA,IAAAsmB,GAAAA,EAAAxB,MAAAyB,GAAAA,EAAAzB,KACA,GAAA78C,GAAAmR,GAAAktC,EAAAC,GAAAl0F,IACA,GAAA41C,GAAAkR,GAAAmtC,EAAAC,GAAAj0F,GAFA,CAKA,IAAAwyD,EAAAn1D,EAAAu9B,QAAA43B,KACAhiD,EAAAzQ,EAAAkD,MAAA5F,EAAAu9B,QAAAmvB,UAAAuoC,GAAAj1F,EAAA0C,IACA,CAAAgc,KAAAy2C,EAAA,GAAA3O,QAAAtyB,IAAA,GAAA86B,OAAA,GACAt1C,EAAA/W,EAAAiD,KAAA5F,EAAAu9B,QAAAovB,QAAAsoC,GAAAj1F,EAAA2C,GACA,IAAA+W,EAAA,CACA,IAAA8sC,EAAA2O,EAAAA,EAAA73D,OAAA,GAAAkpD,QACAtyB,EAAAsyB,EAAAuM,KAAAvM,EAAAuM,KAAAvM,EAAAuM,KAAAz1D,OAAA,GAAAkpD,EAAAtyB,IACAxa,EAAA,CAAAgF,KAAAwV,EAAAA,EAAA52B,OAAA,GAAA0xD,OAAA96B,EAAAA,EAAA52B,OAAA,GAAA42B,EAAAA,EAAA52B,OAAA,GAHA,CAMA,GAAA6V,GAAAuG,EAAA,CAKA,IAAAm9E,EAAA94E,EAAAF,EAAAi5E,YAAAj5E,EAAAk5E,WAAA,GACA,IAAAF,EAAA55E,EAAA9J,EAAAuL,KAAAvL,EAAA67C,OAAAt1C,EAAAs1C,OAAAt1C,EAAAgF,KAAA,CACA,MAAAlgB,GAAA,CACAq4F,KACAj7C,GAAA57C,EAAA+D,MAAA2wC,SACA72B,EAAAihC,SAAA3rC,EAAAuL,KAAAvL,EAAA67C,QACA6nC,EAAAvmC,YACAzyC,EAAA+yD,kBACA/yD,EAAAgzD,SAAAgmB,MAGAh5E,EAAA+yD,kBACA/yD,EAAAgzD,SAAAgmB,IAEA94E,GAAA,MAAAF,EAAAoyD,WAAApyD,EAAAgzD,SAAA9yD,GACA69B,GAAA5vC,KAAAgrF,oBAEAhrF,KAAAirF,mBAtBA,MACAp5E,EAAA+yD,iBAbA,CAVA,CAJA,EAmDA4jB,GAAAt2F,UAAA84F,iBAAA,WACA,IAAAnZ,EAAA7xE,KAEA6Y,aAAA7Y,KAAA+oF,aACA/oF,KAAA+oF,YAAA50E,YAAA,WACA09D,EAAAkX,aAAA,EACAlX,EAAAxS,oBACAwS,EAAA79E,GAAA0d,WAAA,WAAA,OAAAmgE,EAAA79E,GAAAqlD,MAAAgmB,kBAAA,CAAA,GAHA,GAIA,GARA,EAWAmpB,GAAAt2F,UAAAw4F,uBAAA,SAAAjiF,GACAipC,EAAA1xC,KAAAhM,GAAAu9B,QAAAynC,UAAAvwD,EAAAytD,SACAxkB,EAAA1xC,KAAAhM,GAAAu9B,QAAAwzC,aAAAt8D,EAAAu6B,UAFA,EAKAwlD,GAAAt2F,UAAA+4F,kBAAA,WACA,IAAAp5E,EAAA7R,KAAAitB,eACAjtB,KAAAyoF,eAAA52E,EAAAoyD,WAAAjkE,KAAA0oF,iBAAA72E,EAAAsyD,aACAnkE,KAAA2oF,cAAA92E,EAAAuyD,UAAApkE,KAAA4oF,gBAAA/2E,EAAAwyD,WAHA,EAMAmkB,GAAAt2F,UAAAg5F,kBAAA,WACA,IAAAr5E,EAAA7R,KAAAitB,eACA,IAAApb,EAAAi5E,WAAA,OAAA,EACA,IAAAp4E,EAAAb,EAAAk5E,WAAA,GAAAI,wBACA,OAAAr5C,EAAA9xC,KAAAvD,IAAAiW,EAJA,EAOA81E,GAAAt2F,UAAAkiC,MAAA,WACA,YAAAp0B,KAAAhM,GAAA2f,QAAA9e,WACAmL,KAAAkrF,qBAAAl5C,EAAAC,EAAAjyC,KAAAvD,OAAAuD,KAAAvD,KACAuD,KAAA+1D,cAAA/1D,KAAAg2D,oBAAA,GACAh2D,KAAAvD,IAAA23B,QAJA,EAOAo0D,GAAAt2F,UAAAk5F,KAAA,WAAAprF,KAAAvD,IAAA2uF,MAAA,EACA5C,GAAAt2F,UAAA2sF,SAAA,WAAA,OAAA7+E,KAAAvD,GAAA,EAEA+rF,GAAAt2F,UAAAutF,cAAA,WAAA,OAAA,CAAA,EAEA+I,GAAAt2F,UAAAunE,cAAA,WACA,IAAAoY,EAAA7xE,KAEAnF,EAAAmF,KACAA,KAAAkrF,oBACA/2E,YAAA,WAAA,OAAA09D,EAAAwZ,eAAA,GAAA,IAEAhpB,GAAAriE,KAAAhM,IAAA,WAAA,OAAA6G,EAAA7G,GAAAqlD,MAAAgmB,kBAAA,CAAA,IAQAr/D,KAAA6oF,QAAA9mD,IAAA/hC,KAAAhM,GAAA2f,QAAA23E,cANA,SAAAl3E,IACAvZ,EAAA7G,GAAA+D,MAAA2wC,UACA7tC,EAAAwwF,gBACAxwF,EAAAguF,QAAA9mD,IAAAlnC,EAAA7G,GAAA2f,QAAA23E,aAAAl3E,GAHA,GATA,EAkBAo0E,GAAAt2F,UAAAmtE,iBAAA,WACA,IAAAxtD,EAAA7R,KAAAitB,eACA,OAAApb,EAAAoyD,YAAAjkE,KAAAyoF,gBAAA52E,EAAAsyD,cAAAnkE,KAAA0oF,kBACA72E,EAAAuyD,WAAApkE,KAAA2oF,eAAA92E,EAAAwyD,aAAArkE,KAAA4oF,eAHA,EAMAJ,GAAAt2F,UAAAm5F,cAAA,WACA,GAAA,MAAArrF,KAAAgpF,iBAAAhpF,KAAA+oF,aAAA/oF,KAAAq/D,mBAAA,CACA,IAAAxtD,EAAA7R,KAAAitB,eAAAj5B,EAAAgM,KAAAhM,GAOA,GAAA68C,GAAAT,GAAApwC,KAAAhM,GAAAu9B,QAAAg6B,YAAAj6D,QA8JA,SAAAohB,GACA,IAAA,IAAA64E,EAAA74E,EAAA64E,EAAAA,EAAAA,EAAAh5E,WACA,GAAA,4BAAAra,KAAAqzF,EAAAlgF,WAAA,OAAA,EACA,OAAA,CAHA,CA9JAmgF,CAAA35E,EAAAoyD,YAIA,OAHAjkE,KAAAhM,GAAAy3F,iBAAA,CAAAptF,KAAA,UAAA06E,QAAA,EAAA//B,eAAAhmC,KAAAg8C,MACAhvD,KAAAorF,YACAprF,KAAAo0B,QAGA,IAAAp0B,KAAA8oF,UAAA,CACA9oF,KAAAirF,oBACA,IAAA75E,EAAAg4E,GAAAp1F,EAAA6d,EAAAoyD,WAAApyD,EAAAsyD,cACA9yD,EAAA+3E,GAAAp1F,EAAA6d,EAAAuyD,UAAAvyD,EAAAwyD,aACAjzD,GAAAC,GAAAgxD,GAAAruE,GAAA,WACA+4E,GAAA/4E,EAAAm+C,IAAAo2B,GAAAn3D,EAAAC,GAAAmjC,IACApjC,EAAA+3E,KAAA93E,EAAA83E,OAAAn1F,EAAAqlD,MAAAgmB,kBAAA,EAFA,GAJA,CAdA,CADA,EAyBAmpB,GAAAt2F,UAAAw5F,YAAA,WACA,MAAA1rF,KAAAgpF,iBACAnwE,aAAA7Y,KAAAgpF,gBACAhpF,KAAAgpF,eAAA,MAGA,IAQA2C,EAAAlzB,EAAAmzB,EARA53F,EAAAgM,KAAAhM,GAAAu9B,EAAAv9B,EAAAu9B,QAAA1f,EAAA7d,EAAAm+C,IAAAtgC,IAAA49B,UACA/4C,EAAAmb,EAAAnb,OAAAC,EAAAkb,EAAAlb,KAKA,GAJA,GAAAD,EAAAoI,IAAApI,EAAAkD,KAAA5F,EAAAgyC,cACAtvC,EAAAkhB,GAAAlhB,EAAAkD,KAAA,EAAAozB,GAAAh5B,EAAAm+C,IAAAz7C,EAAAkD,KAAA,GAAAtI,SACAqF,EAAAmI,IAAAkuB,GAAAh5B,EAAAm+C,IAAAx7C,EAAAiD,MAAA7D,KAAAzE,QAAAqF,EAAAiD,KAAA5F,EAAAiyC,aACAtvC,EAAAihB,GAAAjhB,EAAAiD,KAAA,EAAA,IACAlD,EAAAkD,KAAA23B,EAAAmvB,UAAA/pD,EAAAiD,KAAA23B,EAAAovB,OAAA,EAAA,OAAA,EAGAjqD,EAAAkD,MAAA23B,EAAAmvB,UAAA,IAAAirC,EAAAz9B,GAAAl6D,EAAA0C,EAAAkD,QACA6+D,EAAAtwB,GAAA5W,EAAA43B,KAAA,GAAAvvD,MACAgyF,EAAAr6D,EAAA43B,KAAA,GAAAz2C,OAEA+lD,EAAAtwB,GAAA5W,EAAA43B,KAAAwiC,GAAA/xF,MACAgyF,EAAAr6D,EAAA43B,KAAAwiC,EAAA,GAAAj5E,KAAAif,aAEA,IACA+mC,EAAAmzB,EADAC,EAAA59B,GAAAl6D,EAAA2C,EAAAiD,MAUA,GARAkyF,GAAAv6D,EAAA43B,KAAA73D,OAAA,GACAonE,EAAAnnC,EAAAovB,OAAA,EACAkrC,EAAAt6D,EAAAqoC,QAAA3S,YAEAyR,EAAAvwB,GAAA5W,EAAA43B,KAAA2iC,EAAA,GAAAlyF,MAAA,EACAiyF,EAAAt6D,EAAA43B,KAAA2iC,EAAA,GAAAp5E,KAAAk3E,kBAGAgC,EAAA,OAAA,EAGA,IAFA,IAAAG,EAAA/3F,EAAAm+C,IAAAs+B,WAqHA,SAAAz8E,EAAA0C,EAAAC,EAAA8hE,EAAAC,GACA,IAAA3iE,EAAA,GAAA+Z,GAAA,EAAAsjE,EAAAp/E,EAAAm+C,IAAA5D,gBAAAy9C,GAAA,EACA,SAAAC,EAAAp0E,GAAA,OAAA,SAAAT,GAAA,OAAAA,EAAAS,IAAAA,CAAA,CAAA,CACA,SAAA3e,IACA4W,IACA/Z,GAAAq9E,EACA4Y,IAAAj2F,GAAAq9E,GACAtjE,EAAAk8E,GAAA,EAJA,CAOA,SAAAE,EAAA7yE,GACAA,IACAngB,IACAnD,GAAAsjB,EAHA,CAMA,SAAA8yE,EAAAz5E,GACA,GAAA,GAAAA,EAAA4B,SAAA,CACA,IAAA83E,EAAA15E,EAAAm6C,aAAA,WACA,GAAAu/B,EAEA,YADAF,EAAAE,GAGA,IAAAn7E,EAAAo7E,EAAA35E,EAAAm6C,aAAA,aACA,GAAAw/B,EAAA,CACA,IAAArzE,EAAAhlB,EAAA++E,UAAAn7D,GAAA6gD,EAAA,GAAA7gD,GAAA8gD,EAAA,EAAA,GAAAuzB,GAAAI,IAGA,YAFArzE,EAAA1nB,SAAA2f,EAAA+H,EAAA,GAAA1jB,KAAA,KACA42F,EAAAxvC,GAAA1oD,EAAAm+C,IAAAlhC,EAAAva,KAAAua,EAAAta,IAAAumB,KAAAk2D,IAHA,CAMA,GAAA,SAAA1gE,EAAAm6C,aAAA,mBAAA,OACA,IAAAy/B,EAAA,6BAAAp0F,KAAAwa,EAAAkc,UACA,IAAA,QAAA12B,KAAAwa,EAAAkc,WAAA,GAAAlc,EAAAi3E,YAAAr4F,OAAA,OAEAg7F,GAAApzF,IACA,IAAA,IAAA7H,EAAA,EAAAA,EAAAqhB,EAAA8hB,WAAAljC,OAAAD,IACA86F,EAAAz5E,EAAA8hB,WAAAnjC,IAEA,aAAA6G,KAAAwa,EAAAkc,YAAAo9D,GAAA,GACAM,IAAAx8E,GAAA,EAtBA,MAuBA,GAAA4C,EAAA4B,UACA43E,EAAAx5E,EAAA+2E,UAAAvoE,QAAA,UAAA,IAAAA,QAAA,UAAA,KAzBA,CA4BA,KACAirE,EAAAz1F,GACAA,GAAAC,GACAD,EAAAA,EAAAi7B,YACAq6D,GAAA,EAEA,OAAAj2F,CAlDA,CArHAw2F,CAAAv4F,EAAA43F,EAAAC,EAAApzB,EAAAC,IACA8zB,EAAA9vC,GAAA1oD,EAAAm+C,IAAAv6B,GAAA6gD,EAAA,GAAA7gD,GAAA8gD,EAAA1rC,GAAAh5B,EAAAm+C,IAAAumB,GAAA3iE,KAAAzE,SACAy6F,EAAAz6F,OAAA,GAAAk7F,EAAAl7F,OAAA,GACA,GAAA4jD,GAAA62C,IAAA72C,GAAAs3C,GAAAT,EAAA7iF,MAAAsjF,EAAAtjF,MAAAwvD,QACA,IAAAqzB,EAAA,IAAAS,EAAA,GACA,MADAT,EAAA3jE,QAAAokE,EAAApkE,QAAAqwC,GACA,CAKA,IAFA,IAAAg0B,EAAA,EAAAC,EAAA,EACA14D,EAAA+3D,EAAA,GAAAY,EAAAH,EAAA,GAAAI,EAAA55E,KAAAK,IAAA2gB,EAAA1iC,OAAAq7F,EAAAr7F,QACAm7F,EAAAG,GAAA54D,EAAA6hB,WAAA42C,IAAAE,EAAA92C,WAAA42C,MACAA,EAIA,IAHA,IAAAI,EAAA33C,GAAA62C,GAAAe,EAAA53C,GAAAs3C,GACAO,EAAA/5E,KAAAK,IAAAw5E,EAAAv7F,QAAA,GAAAy6F,EAAAz6F,OAAAm7F,EAAA,GACAK,EAAAx7F,QAAA,GAAAk7F,EAAAl7F,OAAAm7F,EAAA,IACAC,EAAAK,GACAF,EAAAh3C,WAAAg3C,EAAAv7F,OAAAo7F,EAAA,IAAAI,EAAAj3C,WAAAi3C,EAAAx7F,OAAAo7F,EAAA,MACAA,EAEA,GAAA,GAAAX,EAAAz6F,QAAA,GAAAk7F,EAAAl7F,QAAAmnE,GAAA/hE,EAAAkD,KACA,KAAA6yF,GAAAA,EAAA/1F,EAAAoI,IACA+tF,EAAAh3C,WAAAg3C,EAAAv7F,OAAAo7F,EAAA,IAAAI,EAAAj3C,WAAAi3C,EAAAx7F,OAAAo7F,EAAA,IACAD,IACAC,IAIAX,EAAAA,EAAAz6F,OAAA,GAAAu7F,EAAA3lF,MAAA,EAAA2lF,EAAAv7F,OAAAo7F,GAAAxrE,QAAA,WAAA,IACA6qE,EAAA,GAAAA,EAAA,GAAA7kF,MAAAulF,GAAAvrE,QAAA,WAAA,IAEA,IAAA8rE,EAAAp1E,GAAA6gD,EAAAg0B,GACAQ,EAAAr1E,GAAA8gD,EAAA8zB,EAAAl7F,OAAA4jD,GAAAs3C,GAAAl7F,OAAAo7F,EAAA,GACA,OAAAX,EAAAz6F,OAAA,GAAAy6F,EAAA,IAAAz/C,GAAA0gD,EAAAC,IACAt4D,GAAA3gC,EAAAm+C,IAAA45C,EAAAiB,EAAAC,EAAA,WACA,QAFA,CAjEA,EAuEAzE,GAAAt2F,UAAA8rF,aAAA,WACAh+E,KAAAwqF,qBADA,EAGAhC,GAAAt2F,UAAA25B,MAAA,WACA7rB,KAAAwqF,qBADA,EAGAhC,GAAAt2F,UAAAs4F,oBAAA,WACAxqF,KAAA8oF,YACAjwE,aAAA7Y,KAAAgpF,gBACAhpF,KAAA8oF,UAAA,KACA9oF,KAAAsqF,gBACAtqF,KAAAvD,IAAA2uF,OACAprF,KAAAvD,IAAA23B,QANA,EAQAo0D,GAAAt2F,UAAAq4F,gBAAA,WACA,IAAA1Y,EAAA7xE,KAEA,MAAAA,KAAAgpF,iBACAhpF,KAAAgpF,eAAA70E,YAAA,WAEA,GADA09D,EAAAmX,eAAA,KACAnX,EAAAiX,UAAA,CACA,IAAAjX,EAAAiX,UAAAve,KACA,OADAsH,EAAAiX,UAAA,IADA,CAIAjX,EAAAyY,eANA,GAOA,IAXA,EAcA9B,GAAAt2F,UAAAo4F,cAAA,WACA,IAAAzY,EAAA7xE,MAEAA,KAAAhM,GAAA2iF,cAAA32E,KAAA0rF,eACArpB,GAAAriE,KAAAhM,IAAA,WAAA,OAAA+gE,GAAA8c,EAAA79E,GAAA,GAJA,EAOAw0F,GAAAt2F,UAAAm2D,cAAA,SAAA31C,GACAA,EAAA23E,gBAAA,OADA,EAIA7B,GAAAt2F,UAAAgtF,WAAA,SAAA1sF,GACA,GAAAA,EAAA2sF,UAAAn/E,KAAA8oF,YACAt2F,EAAAwmD,iBACAh5C,KAAAhM,GAAA2iF,cACAjlE,GAAA1R,KAAAhM,GAAA+xF,GAAAr0E,CAAA1R,KAAAhM,GAAA1B,OAAA8lF,aAAA,MAAA5lF,EAAA2sF,SAAA3sF,EAAAumF,QAAAvmF,EAAA2sF,UAAA,GAJA,EAOAqJ,GAAAt2F,UAAAg7F,gBAAA,SAAA/3F,GACA6K,KAAAvD,IAAA4tF,gBAAA/3F,OAAA,YAAA6C,EADA,EAIAqzF,GAAAt2F,UAAAmwF,cAAA,WAAA,EACAmG,GAAAt2F,UAAAi7F,cAAA,WAAA,EAEA3E,GAAAt2F,UAAAk2D,uBAAA,EA2JA,IAAAglC,GAAA,SAAAp5F,GACAgM,KAAAhM,GAAAA,EAEAgM,KAAAqtF,UAAA,GAKArtF,KAAAstF,aAAA,EAEAttF,KAAA6oF,QAAA,IAAA30C,EAEAl0C,KAAA+6C,cAAA,EACA/6C,KAAA8oF,UAAA,KACA9oF,KAAAutF,WAAA,CAdA,EAiBAH,GAAAl7F,UAAA2sB,KAAA,SAAA0S,GACA,IAAAsgD,EAAA7xE,KAEAnF,EAAAmF,KAAAhM,EAAAgM,KAAAhM,GACAgM,KAAAwtF,YAAAj8D,GACA,IAAAypB,EAAAh7C,KAAAm/B,SAmBA,SAAAsuD,EAAAj7F,GACA,IAAAumD,GAAA/kD,EAAAxB,GAAA,CACA,GAAAwB,EAAA+5B,oBACA83D,GAAA,CAAAU,UAAA,EAAAxwF,KAAA/B,EAAAk7C,sBACA,KAAAl7C,EAAA2f,QAAAq2E,gBACA,OAEA,IAAAj5E,EAAA+1E,GAAA9yF,GACA6xF,GAAA,CAAAU,UAAA,EAAAxwF,KAAAgb,EAAAhb,OACA,OAAAvD,EAAA6L,KACArK,EAAAy3C,cAAA16B,EAAAA,OAAA,KAAAyjC,IAEA35C,EAAAwyF,UAAA,GACAryC,EAAAlwC,MAAAiG,EAAAhb,KAAAmnB,KAAA,MACA+1B,EAAA+H,GARA,CAWA,OAAAxoD,EAAA6L,OAAArK,EAAA+D,MAAA8rF,aAAA,IAAAzvC,KAhBA,CADA,CAjBA7iB,EAAA2hB,QAAAsX,aAAAxqD,KAAAkzC,QAAA3hB,EAAA2hB,QAAAxhB,YAGAif,IAAAqK,EAAAplD,MAAA67B,MAAA,OAEAj8B,GAAAwlD,EAAA,SAAA,WACAhL,GAAAC,GAAA,GAAA4hC,EAAA92B,eAAA82B,EAAA92B,aAAA,MACAlgD,EAAAuZ,MAFA,IAKA5e,GAAAwlD,EAAA,SAAA,SAAAxoD,GACAumD,GAAA/kD,EAAAxB,IAAAi0F,GAAAj0F,EAAAwB,KAEAA,EAAA+D,MAAA6rF,eAAA,IAAAxvC,KACAv5C,EAAA6yF,WAJA,IA0BAl4F,GAAAwlD,EAAA,MAAAyyC,GACAj4F,GAAAwlD,EAAA,OAAAyyC,GAEAj4F,GAAA+7B,EAAAi8B,SAAA,SAAA,SAAAh7D,GACA,IAAAo6D,GAAAr7B,EAAA/+B,KAAAumD,GAAA/kD,EAAAxB,GAAA,CACA,IAAAwoD,EAAA2yC,cAGA,OAFA35F,EAAA+D,MAAA6rF,eAAA,IAAAxvC,UACAv5C,EAAAu5B,QAKA,IAAArW,EAAA,IAAA6vE,MAAA,SACA7vE,EAAA4oE,cAAAn0F,EAAAm0F,cACA3rC,EAAA2yC,cAAA5vE,EAVA,CADA,IAeAvoB,GAAA+7B,EAAA07B,UAAA,eAAA,SAAAz6D,GACAo6D,GAAAr7B,EAAA/+B,IAAAknD,GAAAlnD,EADA,IAIAgD,GAAAwlD,EAAA,oBAAA,WACA,IAAA7zC,EAAAnT,EAAA84B,UAAA,QACAjyB,EAAAiuF,WAAAjuF,EAAAiuF,UAAA73E,MAAA8F,QACAlc,EAAAiuF,UAAA,CACA3hF,MAAAA,EACA8J,MAAAjd,EAAA0kB,SAAAvR,EAAAnT,EAAA84B,UAAA,MAAA,CAAAzhB,UAAA,yBALA,IAQA7V,GAAAwlD,EAAA,kBAAA,WACAngD,EAAAiuF,YACAjuF,EAAAuZ,OACAvZ,EAAAiuF,UAAA73E,MAAA8F,QACAlc,EAAAiuF,UAAA,KAJA,GAzEA,EAkFAsE,GAAAl7F,UAAAs7F,YAAA,SAAAK,GAEA7tF,KAAAkzC,QAAAg0C,KAGAlnF,KAAAm/B,SAAAn/B,KAAAkzC,QAAAxhB,WACA,IAAAo8D,EAAA9tF,KAAAhM,GAAA2f,QACAqzE,GAAAhnF,KAAAm/B,SAAA2uD,EAAAv5F,WAAAu5F,EAAAt5F,YAAAs5F,EAAAltD,eAPA,EAUAwsD,GAAAl7F,UAAAu4F,yBAAA,SAAA/vD,GAEAA,EACA16B,KAAAm/B,SAAA9P,aAAA,aAAAqL,GAEA16B,KAAAm/B,SAAA7J,gBAAA,aALA,EASA83D,GAAAl7F,UAAA8jE,iBAAA,WAEA,IAAAhiE,EAAAgM,KAAAhM,GAAAu9B,EAAAv9B,EAAAu9B,QAAA4gB,EAAAn+C,EAAAm+C,IACA3nC,EAAAwrD,GAAAhiE,GAGA,GAAAA,EAAA2f,QAAAo6E,oBAAA,CACA,IAAAC,EAAAp+D,GAAA57B,EAAAm+C,EAAAtgC,IAAA49B,UAAAp+B,KAAA,OACA48E,EAAA18D,EAAA2hB,QAAA/9B,wBAAA+4E,EAAA38D,EAAAqoC,QAAAzkD,wBACA3K,EAAA2jF,MAAAn7E,KAAAC,IAAA,EAAAD,KAAAK,IAAAke,EAAA2hB,QAAAjiB,aAAA,GACA+8D,EAAAr+E,IAAAu+E,EAAAv+E,IAAAs+E,EAAAt+E,MACAnF,EAAA4jF,OAAAp7E,KAAAC,IAAA,EAAAD,KAAAK,IAAAke,EAAA2hB,QAAAyZ,YAAA,GACAqhC,EAAA56E,KAAA86E,EAAA96E,KAAA66E,EAAA76E,MANA,CASA,OAAA5I,CAfA,EAkBA4iF,GAAAl7F,UAAA6jE,cAAA,SAAAs4B,GACA,IAAA98D,EAAAvxB,KAAAhM,GAAAu9B,QACAmgB,EAAAngB,EAAAynC,UAAAq1B,EAAAn4B,SACAxkB,EAAAngB,EAAAwzC,aAAAspB,EAAArrD,WACA,MAAAqrD,EAAAF,QACAnuF,KAAAkzC,QAAAt9C,MAAA+Z,IAAA0+E,EAAAF,MAAA,KACAnuF,KAAAkzC,QAAAt9C,MAAAwd,KAAAi7E,EAAAD,OAAA,KANA,EAYAhB,GAAAl7F,UAAA25B,MAAA,SAAAqzC,GACA,KAAAl/D,KAAAsuF,oBAAAtuF,KAAA8oF,WAAA5pB,GAAA,CACA,IAAAlrE,EAAAgM,KAAAhM,GAEA,GADAgM,KAAAutF,WAAA,EACAv5F,EAAA+5B,oBAAA,CACA/tB,KAAAqtF,UAAA,GACA,IAAA7qF,EAAAxO,EAAAi5B,eACAjtB,KAAAm/B,SAAAr0B,MAAAtI,EACAxO,EAAA+D,MAAA2wC,SAAAuK,EAAAjzC,KAAAm/B,UACA6Q,GAAAC,GAAA,IAAAjwC,KAAA+6C,aAAAv4C,EALA,MAMA08D,IACAl/D,KAAAqtF,UAAArtF,KAAAm/B,SAAAr0B,MAAA,GACAklC,GAAAC,GAAA,IAAAjwC,KAAA+6C,aAAA,OAEA/6C,KAAAutF,WAAA,CAbA,CADA,EAiBAH,GAAAl7F,UAAA2sF,SAAA,WAAA,OAAA7+E,KAAAm/B,QAAA,EAEAiuD,GAAAl7F,UAAAutF,cAAA,WAAA,OAAA,CAAA,EAEA2N,GAAAl7F,UAAAkiC,MAAA,WACA,GAAA,YAAAp0B,KAAAhM,GAAA2f,QAAA9e,YAAAi8C,GAAAkB,EAAAC,EAAAjyC,KAAAm/B,YAAAn/B,KAAAm/B,UACA,IAAAn/B,KAAAm/B,SAAA/K,OAAA,CACA,MAAA5hC,GAAA,CAHA,EAOA46F,GAAAl7F,UAAAk5F,KAAA,WAAAprF,KAAAm/B,SAAAisD,MAAA,EAEAgC,GAAAl7F,UAAAi7F,cAAA,WACAntF,KAAAkzC,QAAAt9C,MAAA+Z,IAAA3P,KAAAkzC,QAAAt9C,MAAAwd,KAAA,CADA,EAIAg6E,GAAAl7F,UAAAunE,cAAA,WAAAz5D,KAAAuuF,UAAA,EAIAnB,GAAAl7F,UAAAq8F,SAAA,WACA,IAAA1c,EAAA7xE,KAEAA,KAAAstF,aACAttF,KAAA6oF,QAAA9mD,IAAA/hC,KAAAhM,GAAA2f,QAAA23E,cAAA,WACAzZ,EAAAz9D,OACAy9D,EAAA79E,GAAA+D,MAAA2wC,SAAAmpC,EAAA0c,UAFA,GAJA,EAaAnB,GAAAl7F,UAAAw7F,SAAA,WACA,IAAAc,GAAA,EAAA3zF,EAAAmF,KACAnF,EAAAyyF,aAAA,EAMAzyF,EAAAguF,QAAA9mD,IAAA,IALA,SAAArmC,IACAb,EAAAuZ,QACAo6E,GACA3zF,EAAAyyF,aAAA,EAAAzyF,EAAA0zF,aADAC,GAAA,EAAA3zF,EAAAguF,QAAA9mD,IAAA,GAAArmC,GAFA,GAHA,EAiBA0xF,GAAAl7F,UAAAkiB,KAAA,WACA,IAAAy9D,EAAA7xE,KAEAhM,EAAAgM,KAAAhM,GAAA6G,EAAAmF,KAAAm/B,SAAAkuD,EAAArtF,KAAAqtF,UAKA,GAAArtF,KAAAsuF,oBAAAtuF,KAAAutF,YAAAv5F,EAAA+D,MAAA2wC,SACAqS,GAAAlgD,KAAAwyF,IAAArtF,KAAA8oF,WACA90F,EAAA2iF,cAAA3iF,EAAA2f,QAAAizE,cAAA5yF,EAAA+D,MAAAsmF,OACA,OAAA,EAEA,IAAAtoF,EAAA8E,EAAAiQ,MAEA,GAAA/U,GAAAs3F,IAAAr5F,EAAA+5B,oBAAA,OAAA,EAIA,GAAAiiB,GAAAC,GAAA,GAAAjwC,KAAA+6C,eAAAhlD,GACAg7C,GAAA,kBAAA74C,KAAAnC,GAEA,OADA/B,EAAAu9B,QAAA12B,MAAAgxB,SACA,EAGA,GAAA73B,EAAAm+C,IAAAtgC,KAAA7d,EAAAu9B,QAAAioC,kBAAA,CACA,IAAAvkC,EAAAl/B,EAAA8/C,WAAA,GAEA,GADA,MAAA5gB,GAAAo4D,IAAAA,EAAA,KACA,MAAAp4D,EAAA,OAAAj1B,KAAA6rB,QAAA7rB,KAAAhM,GAAAm2C,YAAA,OAHA,CAOA,IADA,IAAAskD,EAAA,EAAAj7F,EAAAwf,KAAAK,IAAAg6E,EAAA/7F,OAAAyE,EAAAzE,QACAm9F,EAAAj7F,GAAA65F,EAAAx3C,WAAA44C,IAAA14F,EAAA8/C,WAAA44C,MAAAA,EAgBA,OAdApsB,GAAAruE,GAAA,WACA+xF,GAAA/xF,EAAA+B,EAAAmR,MAAAunF,GAAApB,EAAA/7F,OAAAm9F,EACA,KAAA5c,EAAAiX,UAAA,WAAA,MAGA/yF,EAAAzE,OAAA,KAAAyE,EAAA8R,QAAA,OAAA,EAAAhN,EAAAiQ,MAAA+mE,EAAAwb,UAAA,GACAxb,EAAAwb,UAAAt3F,EAEA87E,EAAAiX,YACAjX,EAAAiX,UAAA73E,MAAA8F,QACA86D,EAAAiX,UAAA73E,MAAAjd,EAAA0kB,SAAAm5D,EAAAiX,UAAA3hF,MAAAnT,EAAA84B,UAAA,MACA,CAAAzhB,UAAA,yBAXA,KAcA,CAhDA,EAmDA+hF,GAAAl7F,UAAA8rF,aAAA,WACAh+E,KAAAstF,aAAAttF,KAAAoU,SAAApU,KAAAstF,aAAA,EADA,EAIAF,GAAAl7F,UAAAgtF,WAAA,WACAlvC,GAAAC,GAAA,IAAAjwC,KAAA+6C,aAAA,MACA/6C,KAAA0tF,UAFA,EAKAN,GAAAl7F,UAAAmwF,cAAA,SAAA7vF,GACA,IAAAqI,EAAAmF,KAAAhM,EAAA6G,EAAA7G,GAAAu9B,EAAAv9B,EAAAu9B,QAAAypB,EAAAngD,EAAAskC,SACAtkC,EAAAyzF,oBAAAzzF,EAAAyzF,qBACA,IAAArmF,EAAAusD,GAAAxgE,EAAAxB,GAAAkvE,EAAAnwC,EAAAi8B,SAAAl9B,UACA,GAAAroB,IAAAqoC,EAAA,CAIAt8C,EAAA2f,QAAA+6E,8BACA,GAAA16F,EAAAm+C,IAAAtgC,IAAAigC,SAAA7pC,IACAyJ,GAAA1d,EAAA+4E,GAAAr7D,CAAA1d,EAAAm+C,IAAAo2B,GAAAtgE,GAAAusC,GAEA,IAIAm6C,EAJAC,EAAA5zC,EAAAplD,MAAAg8C,QAAAi9C,EAAAh0F,EAAAq4C,QAAAt9C,MAAAg8C,QACAk9C,EAAAj0F,EAAAq4C,QAAAjjB,aAAA9a,wBACAta,EAAAq4C,QAAAt9C,MAAAg8C,QAAA,mBACAoJ,EAAAplD,MAAAg8C,QAAA,+DAAAp/C,EAAA0gB,QAAA47E,EAAAn/E,IAAA,GAAA,cAAAnd,EAAA8gB,QAAAw7E,EAAA17E,KAAA,GAAA,0CAAA48B,EAAA,2BAAA,eAAA,oHAEAE,IAAAy+C,EAAA3zC,EAAAznC,cAAAC,YAAAu7E,SACAx9D,EAAA12B,MAAAu5B,QACA8b,GAAA8K,EAAAznC,cAAAC,YAAAw7E,SAAA,KAAAL,GACAp9D,EAAA12B,MAAAgxB,QAEA73B,EAAA+5B,sBAAAitB,EAAAlwC,MAAAjQ,EAAAwyF,UAAA,KACAxyF,EAAAyzF,mBAAAW,EACA19D,EAAAioC,kBAAAxlE,EAAAm+C,IAAAtgC,IACAgH,aAAA0Y,EAAA29D,oBA2CAl/C,GAAAC,GAAA,GAAAk/C,IACA/9C,GACA2I,GAAAvnD,GAKAgD,GAAAV,OAAA,WAJA,SAAAs6F,IACAn9E,GAAAnd,OAAA,UAAAs6F,GACAj7E,WAAA86E,EAAA,GAFA,KAMA96E,WAAA86E,EAAA,GAzEA,CA0BA,SAAAE,IACA,GAAA,MAAAn0C,EAAAjH,eAAA,CACA,IAAA7V,EAAAlqC,EAAA+5B,oBACAshE,EAAA,KAAAnxD,EAAA8c,EAAAlwC,MAAA,IACAkwC,EAAAlwC,MAAA,IACAkwC,EAAAlwC,MAAAukF,EACAx0F,EAAAwyF,UAAAnvD,EAAA,GAAA,IACA8c,EAAAjH,eAAA,EAAAiH,EAAAhH,aAAAq7C,EAAA/9F,OAGAigC,EAAAioC,kBAAAxlE,EAAAm+C,IAAAtgC,GATA,CADA,CAaA,SAAAo9E,IACA,GAAAp0F,EAAAyzF,oBAAAW,IACAp0F,EAAAyzF,oBAAA,EACAzzF,EAAAq4C,QAAAt9C,MAAAg8C,QAAAi9C,EACA7zC,EAAAplD,MAAAg8C,QAAAg9C,EACA5+C,GAAAC,EAAA,GAAA1e,EAAAwqC,WAAAH,aAAArqC,EAAAi8B,SAAAl9B,UAAAoxC,GAGA,MAAA1mB,EAAAjH,gBAAA,GACA/D,GAAAA,GAAAC,EAAA,IAAAk/C,IACA,IAAA99F,EAAA,EAWAkgC,EAAA29D,mBAAA/6E,YAXA,SAAAC,IACAmd,EAAAioC,mBAAAxlE,EAAAm+C,IAAAtgC,KAAA,GAAAmpC,EAAAjH,gBACAiH,EAAAhH,aAAA,GAAA,KAAAn5C,EAAAwyF,UACA37E,GAAA1d,EAAAy6E,GAAA/8D,CAAA1d,GACA3C,IAAA,GACAkgC,EAAA29D,mBAAA/6E,WAAAC,EAAA,MAEAmd,EAAAioC,kBAAA,KACAjoC,EAAA12B,MAAAgxB,QARA,GAWA,IAbA,CARA,CA3CA,EAiFAuhE,GAAAl7F,UAAAg7F,gBAAA,SAAA/3F,GACAA,GAAA6K,KAAA6rB,QACA7rB,KAAAm/B,SAAAnF,SAAA,YAAA7kC,EACA6K,KAAAm/B,SAAAtqC,WAAAM,CAHA,EAMAi4F,GAAAl7F,UAAAm2D,cAAA,WAAA,EAEA+kC,GAAAl7F,UAAAk2D,uBAAA,EA18DA,SAAAx0D,GACA,IAAAovF,EAAApvF,EAAAovF,eAEA,SAAAvnF,EAAApE,EAAAi4C,EAAAvd,EAAAu9D,GACA17F,EAAA4K,SAAAnH,GAAAi4C,EACAvd,IAAAixD,EAAA3rF,GACAi4F,EAAA,SAAAt7F,EAAAmB,EAAA4c,GAAAA,GAAAC,IAAA+f,EAAA/9B,EAAAmB,EAAA4c,EAAA,EAAAggB,EAHA,CAMAn+B,EAAAke,aAAArW,EAGA7H,EAAAoe,KAAAA,GAIAvW,EAAA,QAAA,IAAA,SAAAzH,EAAAmB,GAAA,OAAAnB,EAAAs/E,SAAAn+E,EAAA,IAAA,GACAsG,EAAA,OAAA,MAAA,SAAAzH,EAAAmB,GACAnB,EAAAm+C,IAAA02B,WAAA1zE,EACAyzE,GAAA50E,EAFA,IAGA,GAEAyH,EAAA,aAAA,EAAAmtE,IAAA,GACAntE,EAAA,kBAAA,GACAA,EAAA,eAAA,GACAA,EAAA,UAAA,GAAA,SAAAzH,GACA80E,GAAA90E,GACAk9D,GAAAl9D,GACA+gE,GAAA/gE,EAHA,IAIA,GAEAyH,EAAA,gBAAA,MAAA,SAAAzH,EAAAmB,GAEA,GADAnB,EAAAm+C,IAAAihC,QAAAj+E,EACAA,EAAA,CACA,IAAAo6F,EAAA,GAAApnD,EAAAn0C,EAAAm+C,IAAAld,MACAjhC,EAAAm+C,IAAAxF,MAAA,SAAA/yC,GACA,IAAA,IAAAqO,EAAA,IAAA,CACA,IAAA+Q,EAAApf,EAAA7D,KAAA8R,QAAA1S,EAAA8S,GACA,IAAA,GAAA+Q,EAAA,MACA/Q,EAAA+Q,EAAA7jB,EAAA7D,OACAi+F,EAAAltF,KAAAuV,GAAAuwB,EAAAnvB,GAJA,CAMAmvB,GAPA,IASA,IAAA,IAAA92C,EAAAk+F,EAAAj+F,OAAA,EAAAD,GAAA,EAAAA,IACAsjC,GAAA3gC,EAAAm+C,IAAAh9C,EAAAo6F,EAAAl+F,GAAAumB,GAAA23E,EAAAl+F,GAAAuI,KAAA21F,EAAAl+F,GAAAyN,GAAA3J,EAAA7D,QAZA,CAFA,IAgBAmK,EAAA,eAAA,4HAAA,SAAAzH,EAAAmB,EAAA4c,GACA/d,EAAA+D,MAAA4vD,aAAA,IAAAxxD,OAAAhB,EAAA2B,QAAA3B,EAAA+C,KAAA,MAAA,GAAA,OAAA,KACA6Z,GAAAC,IAAAhe,EAAAw7F,SAFA,IAIA/zF,EAAA,yBAAA0rD,IAAA,SAAAnzD,GAAA,OAAAA,EAAAw7F,SAAA,IAAA,GACA/zF,EAAA,iBAAA,GACAA,EAAA,aAAAq1C,EAAA,kBAAA,YAAA,WACA,MAAA,IAAAx9C,MAAA,0DADA,IAEA,GACAmI,EAAA,cAAA,GAAA,SAAAzH,EAAAmB,GAAA,OAAAnB,EAAAk7B,gBAAA36B,WAAAY,CAAA,IAAA,GACAsG,EAAA,eAAA,GAAA,SAAAzH,EAAAmB,GAAA,OAAAnB,EAAAk7B,gBAAA16B,YAAAW,CAAA,IAAA,GACAsG,EAAA,kBAAA,GAAA,SAAAzH,EAAAmB,GAAA,OAAAnB,EAAAk7B,gBAAA0R,eAAAzrC,CAAA,IAAA,GACAsG,EAAA,mBAAAw1C,GACAx1C,EAAA,yBAAA,GAEAA,EAAA,QAAA,WAAA,SAAAzH,GACA+uF,GAAA/uF,GACA6xE,GAAA7xE,EAFA,IAGA,GACAyH,EAAA,SAAA,WAAA,SAAAzH,EAAAmB,EAAA4c,GACA,IAAAhT,EAAA65E,GAAAzjF,GACA8K,EAAA8R,GAAAC,IAAA4mE,GAAA7mE,GACA9R,GAAAA,EAAAwvF,QAAAxvF,EAAAwvF,OAAAz7F,EAAA+K,GACAA,EAAA2wF,QAAA3wF,EAAA2wF,OAAA17F,EAAAiM,GAAA,KAJA,IAMAxE,EAAA,YAAA,MACAA,EAAA,iBAAA,MAEAA,EAAA,gBAAA,EAAAgoF,IAAA,GACAhoF,EAAA,UAAA,IAAA,SAAAzH,EAAAmB,GACAnB,EAAAu9B,QAAAg6B,YAAAia,GAAArwE,EAAAnB,EAAA2f,QAAAtf,aACAwxE,GAAA7xE,EAFA,IAGA,GACAyH,EAAA,eAAA,GAAA,SAAAzH,EAAAmB,GACAnB,EAAAu9B,QAAAt8B,QAAAW,MAAAwd,KAAAje,EAAA++D,GAAAlgE,EAAAu9B,SAAA,KAAA,IACAv9B,EAAAw7F,SAFA,IAGA,GACA/zF,EAAA,8BAAA,GAAA,SAAAzH,GAAA,OAAA+pE,GAAA/pE,EAAA,IAAA,GACAyH,EAAA,iBAAA,UAAA,SAAAzH,GACA2qE,GAAA3qE,GACA+pE,GAAA/pE,GACAA,EAAAu9B,QAAAwqC,WAAAH,aAAA5nE,EAAAm+C,IAAA7hB,WACAt8B,EAAAu9B,QAAAwqC,WAAAC,cAAAhoE,EAAAm+C,IAAA9hB,WAJA,IAKA,GACA50B,EAAA,eAAA,GAAA,SAAAzH,EAAAmB,GACAnB,EAAAu9B,QAAAg6B,YAAAia,GAAAxxE,EAAA2f,QAAA1e,QAAAE,GACA0wE,GAAA7xE,EAFA,IAGA,GACAyH,EAAA,kBAAA,EAAAoqE,IAAA,GACApqE,EAAA,uBAAA,SAAAk0F,GAAA,OAAAA,CAAA,GAAA9pB,IAAA,GACApqE,EAAA,2BAAA,EAAAq6D,IAAA,GAEAr6D,EAAA,+BAAA,GACAA,EAAA,mBAAA,GACAA,EAAA,0BAAA,GACAA,EAAA,sBAAA,GAEAA,EAAA,YAAA,GAAA,SAAAzH,EAAAmB,GACA,YAAAA,IACAy+B,GAAA5/B,GACAA,EAAAu9B,QAAA12B,MAAAuwF,QAEAp3F,EAAAu9B,QAAA12B,MAAAqyF,gBAAA/3F,EALA,IAQAsG,EAAA,oBAAA,MAAA,SAAAzH,EAAAmB,GACAA,EAAA,KAAAA,EAAA,KAAAA,EACAnB,EAAAu9B,QAAA12B,MAAA4vF,yBAAAt1F,EAFA,IAKAsG,EAAA,gBAAA,GAAA,SAAAzH,EAAAmB,GAAAA,GAAAnB,EAAAu9B,QAAA12B,MAAAgxB,OAAA,IAAA,GACApwB,EAAA,YAAA,EAAAwnF,IACAxnF,EAAA,qBAAA,MAEAA,EAAA,kBAAA,KACAA,EAAA,qBAAA,GACAA,EAAA,eAAA,EAAAq6D,IAAA,GACAr6D,EAAA,6BAAA,EAAAq6D,IAAA,GACAr6D,EAAA,WAAA,KACAA,EAAA,YAAA,KACAA,EAAA,gBAAA,EAAAqtE,IAAA,GACArtE,EAAA,gBAAA,EAAAqtE,IAAA,GACArtE,EAAA,eAAA,KACAA,EAAA,YAAA,KAAA,SAAAzH,EAAAmB,GAAA,OAAAnB,EAAAm+C,IAAAu5B,QAAAjB,UAAAt1E,CAAA,IACAsG,EAAA,oBAAA,MACAA,EAAA,iBAAA,IAAA,SAAAzH,GAAA,OAAAA,EAAAw7F,SAAA,IAAA,GACA/zF,EAAA,qBAAA,IAAAqtE,IAAA,GACArtE,EAAA,uBAAA,GAAA,SAAAzH,EAAAmB,GACAA,GAAAnB,EAAAu9B,QAAA12B,MAAAsyF,eADA,IAIA1xF,EAAA,WAAA,MAAA,SAAAzH,EAAAmB,GAAA,OAAAnB,EAAAu9B,QAAA12B,MAAAgkF,WAAA/hB,SAAA3nE,GAAA,EAAA,IACAsG,EAAA,YAAA,MACAA,EAAA,YAAA,OAAA,SAAAzH,EAAAmB,GAAA,OAAAnB,EAAAm+C,IAAAkkC,aAAAlhF,EAAA,IAAA,GACAsG,EAAA,UAAA,KA7IA,CAmjEAm0F,CAAAh8F,IApgDA,SAAAA,GACA,IAAAovF,EAAApvF,EAAAovF,eAEAntD,EAAAjiC,EAAAiiC,QAAA,CAAA,EAEAjiC,EAAA1B,UAAA,CACAa,YAAAa,EACAwgC,MAAA,WAAAif,EAAArzC,MAAAo0B,QAAAp0B,KAAAuxB,QAAA12B,MAAAu5B,OAAA,EAEAy7D,UAAA,SAAAp0F,EAAAqP,GACA,IAAA6I,EAAA3T,KAAA2T,QAAA5B,EAAA4B,EAAAlY,GACAkY,EAAAlY,IAAAqP,GAAA,QAAArP,IACAkY,EAAAlY,GAAAqP,EACAk4E,EAAA3qF,eAAAoD,IACAiW,GAAA1R,KAAAgjF,EAAAvnF,GAAAiW,CAAA1R,KAAA8K,EAAAiH,GACAoc,GAAAnuB,KAAA,eAAAA,KAAAvE,GANA,EASAyV,UAAA,SAAAzV,GAAA,OAAAuE,KAAA2T,QAAAlY,EAAA,EACAq0F,OAAA,WAAA,OAAA9vF,KAAAmyC,GAAA,EAEAtgB,UAAA,SAAA3J,EAAA3S,GACAvV,KAAAjI,MAAAwmF,QAAAhpE,EAAA,OAAA,WAAAqjE,GAAA1wD,GADA,EAGAmN,aAAA,SAAAnN,GAEA,IADA,IAAA6+B,EAAA/mD,KAAAjI,MAAAwmF,QACAltF,EAAA,EAAAA,EAAA01D,EAAAz1D,SAAAD,EACA,GAAA01D,EAAA11D,IAAA62B,GAAA6+B,EAAA11D,GAAAgG,MAAA6wB,EAEA,OADA6+B,EAAAjpC,OAAAzsB,EAAA,IACA,CALA,EASA80C,WAAAm8B,IAAA,SAAA5pE,EAAAib,GACA,IAAAvf,EAAAsE,EAAAV,MAAAU,EAAA9E,EAAAwD,QAAA4I,KAAA2T,QAAAjb,GACA,GAAAtE,EAAAkF,WAAA,MAAA,IAAAhG,MAAA,kCAx4PA,SAAAswC,EAAA94B,EAAAilF,GAEA,IADA,IAAA9nF,EAAA,EAAA+nF,EAAAD,EAAAjlF,GACA7C,EAAA27B,EAAAtyC,QAAAy+F,EAAAnsD,EAAA37B,KAAA+nF,GAAA/nF,IACA27B,EAAA9lB,OAAA7V,EAAA,EAAA6C,EAHA,CAy4PAmlF,CAAAjwF,KAAAjI,MAAAknD,SACA,CAAA7qD,KAAAA,EAAAmE,SAAAG,EAAAymD,OAAAxrC,GAAAA,EAAAwrC,OACA6wC,SAAAr8E,GAAAA,EAAAq8E,UAAA,IACA,SAAAhxC,GAAA,OAAAA,EAAAgxC,QAAA,IACAhwF,KAAAjI,MAAA8mD,UACAkW,GAAA/0D,KARA,IAUAkmC,cAAAo8B,IAAA,SAAA5pE,GAEA,IADA,IAAAumD,EAAAj/C,KAAAjI,MAAAknD,SACA5tD,EAAA,EAAAA,EAAA4tD,EAAA3tD,SAAAD,EAAA,CACA,IAAA4H,EAAAgmD,EAAA5tD,GAAAkH,SACA,GAAAU,GAAAP,GAAA,iBAAAA,GAAAO,EAAA5B,MAAAqB,EAIA,OAHAumD,EAAAnhC,OAAAzsB,EAAA,GACA2O,KAAAjI,MAAA8mD,eACAkW,GAAA/0D,KALA,CAFA,IAaA0rC,WAAA42B,IAAA,SAAArvE,EAAAuJ,EAAA6oF,GACA,iBAAA7oF,GAAA,iBAAAA,IACAA,EAAA,MAAAA,EAAAwD,KAAA2T,QAAAkzE,YAAA,QAAA,OACArqF,EAAA,MAAA,YAEA0gD,GAAAl9C,KAAAmyC,IAAAl/C,IAAAy4C,GAAA1rC,KAAA/M,EAAAuJ,EAAA6oF,EALA,IAOApI,gBAAA3a,IAAA,SAAA8iB,GAEA,IADA,IAAAr0E,EAAA/Q,KAAAmyC,IAAAtgC,IAAAd,OAAArD,GAAA,EACArc,EAAA,EAAAA,EAAA0f,EAAAzf,OAAAD,IAAA,CACA,IAAA4f,EAAAF,EAAA1f,GACA,GAAA4f,EAAAK,QASAL,EAAAI,KAAAzX,KAAA8T,IACAg+B,GAAA1rC,KAAAiR,EAAAI,KAAAzX,KAAAwrF,GAAA,GACA13E,EAAAuD,EAAAI,KAAAzX,KACAvI,GAAA2O,KAAAmyC,IAAAtgC,IAAAykD,WAAA8E,GAAAp7D,WAZA,CACA,IAAAtJ,EAAAua,EAAAva,OAAAC,EAAAsa,EAAAta,KACAwQ,EAAA6L,KAAAC,IAAAvF,EAAAhX,EAAAkD,MACA8T,EAAAsF,KAAAK,IAAArT,KAAAimC,WAAAtvC,EAAAiD,MAAAjD,EAAAmI,GAAA,EAAA,IAAA,EACA,IAAA,IAAAmlB,EAAA9c,EAAA8c,EAAAvW,IAAAuW,EACAynB,GAAA1rC,KAAAikB,EAAAmhE,GACA,IAAA51C,EAAAxvC,KAAAmyC,IAAAtgC,IAAAd,OACA,GAAAra,EAAAoI,IAAAiS,EAAAzf,QAAAk+C,EAAAl+C,QAAAk+C,EAAAn+C,GAAAqF,OAAAoI,GAAA,GACAouE,GAAAltE,KAAAmyC,IAAA9gD,EAAA,IAAA42E,GAAAvxE,EAAA84C,EAAAn+C,GAAAsF,MAAA69C,EARA,CAFA,CAFA,IAuBAle,WAAA,SAAAruB,EAAAi4C,GACA,OAAAgB,GAAAlhD,KAAAiI,EAAAi4C,EADA,EAIAgwC,cAAA,SAAAt2F,EAAAsmD,GACA,OAAAgB,GAAAlhD,KAAA4X,GAAAhe,GAAAsmD,GAAA,EADA,EAIAtY,eAAA,SAAA3/B,GACAA,EAAA01C,GAAA39C,KAAAmyC,IAAAlqC,GACA,IAEA5J,EAFA+gD,EAAAI,GAAAx/C,KAAAgtB,GAAAhtB,KAAAmyC,IAAAlqC,EAAArO,OACA+nC,EAAA,EAAAa,GAAA4c,EAAA9tD,OAAA,GAAA,EAAAwN,EAAAmJ,EAAAnJ,GAEA,GAAA,GAAAA,EAAAT,EAAA+gD,EAAA,QACA,OAAA,CACA,IAAAlJ,EAAAvU,EAAAa,GAAA,EACA,IAAA0T,EAAAkJ,EAAA,EAAAlJ,EAAA,GAAA,IAAAp3C,EAAA0jC,EAAA0T,MACA,MAAAkJ,EAAA,EAAAlJ,EAAA,GAAAp3C,GACA,CAAAT,EAAA+gD,EAAA,EAAAlJ,EAAA,GAAA,KAAA,CADAvU,EAAAuU,EAAA,CACA,CAJA,CAMA,IAAAkf,EAAA/2D,EAAAA,EAAAwJ,QAAA,aAAA,EACA,OAAAutD,EAAA,EAAA/2D,EAAA,GAAA+2D,EAAA,KAAA/2D,EAAA6I,MAAA,EAAAkuD,EAAA,EAbA,EAgBA7lB,UAAA,SAAAtnC,GACA,IAAA7T,EAAA4L,KAAAmyC,IAAA/9C,KACA,OAAAA,EAAA0F,UACAlG,EAAAkG,UAAA1F,EAAA4L,KAAAs2B,WAAAruB,GAAAlQ,OAAA3D,KADAA,CAFA,EAMAujB,UAAA,SAAA1P,EAAA5J,GACA,OAAA2B,KAAA81B,WAAA7tB,EAAA5J,GAAA,EADA,EAIAy3B,WAAA,SAAA7tB,EAAA5J,GACA,IAAA2a,EAAA,GACA,IAAA6c,EAAAx9B,eAAAgG,GAAA,OAAA2a,EACA,IAAAm3E,EAAAt6D,EAAAx3B,GAAAjK,EAAA4L,KAAAuvC,UAAAtnC,GACA,GAAA,iBAAA7T,EAAAiK,GACA8xF,EAAA/7F,EAAAiK,KAAA2a,EAAA3W,KAAA8tF,EAAA/7F,EAAAiK,UACA,GAAAjK,EAAAiK,GACA,IAAA,IAAAhN,EAAA,EAAAA,EAAA+C,EAAAiK,GAAA/M,OAAAD,IAAA,CACA,IAAA8D,EAAAg7F,EAAA/7F,EAAAiK,GAAAhN,IACA8D,GAAA6jB,EAAA3W,KAAAlN,EAFA,MAIAf,EAAA4N,YAAAmuF,EAAA/7F,EAAA4N,YACAgX,EAAA3W,KAAA8tF,EAAA/7F,EAAA4N,aACAmuF,EAAA/7F,EAAAiD,OACA2hB,EAAA3W,KAAA8tF,EAAA/7F,EAAAiD,OAEA,IAAA,IAAA6/C,EAAA,EAAAA,EAAAi5C,EAAAC,QAAA9+F,OAAA4lD,IAAA,CACA,IAAAj+C,EAAAk3F,EAAAC,QAAAl5C,GACAj+C,EAAA+8C,KAAA5hD,EAAA4L,QAAA,GAAA6H,EAAAmR,EAAA/f,EAAA9D,MACA6jB,EAAA3W,KAAApJ,EAAA9D,IAHA,CAKA,OAAA6jB,CArBA,EAwBAkxB,cAAA,SAAAtwC,EAAAsmD,GACA,IAAA/N,EAAAnyC,KAAAmyC,IAEA,OAAAuN,GAAA1/C,MADApG,EAAA8jD,GAAAvL,EAAA,MAAAv4C,EAAAu4C,EAAAld,MAAAkd,EAAAvV,KAAA,EAAAhjC,IACA,EAAAsmD,GAAAnoD,KAHA,EAMA63B,aAAA,SAAAzoB,EAAA/S,GACA,IAAA6c,EAAAjR,KAAAmyC,IAAAtgC,IAAA49B,UAIA,OAAA7f,GAAA5vB,KAHA,MAAAmH,EAAA8J,EAAAI,KACA,UAAAhf,QAAA8U,GAAAw2C,GAAA39C,KAAAmyC,IAAAhrC,GACAA,EAAA8J,EAAAva,OAAAua,EAAAta,KACAvC,GAAA,OALA,EAQAg+D,WAAA,SAAAnqD,EAAA7T,GACA,OAAAg+D,GAAApyD,KAAA29C,GAAA39C,KAAAmyC,IAAAlqC,GAAA7T,GAAA,OADA,EAIAshB,WAAA,SAAAojB,EAAA1kC,GAEA,OAAAshB,GAAA1V,MADA84B,EAAAm5B,GAAAjyD,KAAA84B,EAAA1kC,GAAA,SACAgf,KAAA0lB,EAAAnpB,IAFA,EAKAotC,aAAA,SAAA5rB,EAAA/8B,GAEA,OADA+8B,EAAA8gC,GAAAjyD,KAAA,CAAA2P,IAAAwhB,EAAA/d,KAAA,GAAAhf,GAAA,QAAAub,IACAotC,GAAA/8C,KAAAmyC,IAAAhhB,EAAAnxB,KAAAuxB,QAAAugC,WAFA,EAIA1M,aAAA,SAAAxrD,EAAAxF,EAAAw9D,GACA,IAAAvM,EAAA33C,GAAA,EACA,GAAA,iBAAA9T,EAAA,CACA,IAAAgkD,EAAA59C,KAAAmyC,IAAAld,MAAAj1B,KAAAmyC,IAAAvV,KAAA,EACAhjC,EAAAoG,KAAAmyC,IAAAld,MAAAr7B,EAAAoG,KAAAmyC,IAAAld,MACAr7B,EAAAgkD,IAAAhkD,EAAAgkD,EAAAlwC,GAAA,GACA23C,EAAAr4B,GAAAhtB,KAAAmyC,IAAAv4C,EAJA,MAMAyrD,EAAAzrD,EAEA,OAAA+3D,GAAA3xD,KAAAqlD,EAAA,CAAA11C,IAAA,EAAAyD,KAAA,GAAAhf,GAAA,OAAAw9D,GAAAlkD,GAAAiC,KACAjC,EAAA1N,KAAAmyC,IAAAhhB,OAAAi0B,GAAAC,GAAA,EAXA,EAcAgrC,kBAAA,WAAA,OAAAr8B,GAAAh0D,KAAAuxB,QAAA,EACAslC,iBAAA,WAAA,OAAA1G,GAAAnwD,KAAAuxB,QAAA,EAEAiV,YAAA,WAAA,MAAA,CAAA9vC,KAAAsJ,KAAAuxB,QAAAmvB,SAAA/pD,GAAAqJ,KAAAuxB,QAAAovB,OAAA,EAEA2vC,UAAA,SAAAroF,EAAAyK,EAAA+hC,EAAAmoB,EAAAC,GACA,IAv3JA7oE,EAAAu6D,EACAmT,EAs3JAnwC,EAAAvxB,KAAAuxB,QAEA5hB,GADA1H,EAAA2nB,GAAA5vB,KAAA29C,GAAA39C,KAAAmyC,IAAAlqC,KACAsN,OAAAnC,EAAAnL,EAAAmL,KAKA,GAJAV,EAAA9c,MAAAmd,SAAA,WACAL,EAAA2c,aAAA,mBAAA,QACArvB,KAAAuxB,QAAA12B,MAAAwtD,cAAA31C,GACA6e,EAAAu7B,MAAAl5C,YAAAlB,GACA,QAAAkqD,EACAjtD,EAAA1H,EAAA0H,SACA,GAAA,SAAAitD,GAAA,QAAAA,EAAA,CACA,IAAA2zB,EAAAv9E,KAAAC,IAAAse,EAAA2hB,QAAAjiB,aAAAjxB,KAAAmyC,IAAAhhB,QACAq/D,EAAAx9E,KAAAC,IAAAse,EAAAu7B,MAAAH,YAAAp7B,EAAA07B,UAAAN,cAEA,SAAAiQ,GAAA30D,EAAAsN,OAAA7C,EAAAS,aAAAo9E,IAAAtoF,EAAA0H,IAAA+C,EAAAS,aACAxD,EAAA1H,EAAA0H,IAAA+C,EAAAS,aACAlL,EAAAsN,OAAA7C,EAAAS,cAAAo9E,IACA5gF,EAAA1H,EAAAsN,QACAnC,EAAAV,EAAAgB,YAAA88E,IACAp9E,EAAAo9E,EAAA99E,EAAAgB,YATA,CAWAhB,EAAA9c,MAAA+Z,IAAAA,EAAA,KACA+C,EAAA9c,MAAAwd,KAAAV,EAAA9c,MAAAyf,MAAA,GACA,SAAAwnD,GACAzpD,EAAAme,EAAAu7B,MAAAH,YAAAj6C,EAAAgB,YACAhB,EAAA9c,MAAAyf,MAAA,QAEA,QAAAwnD,EAAAzpD,EAAA,EACA,UAAAypD,IAAAzpD,GAAAme,EAAAu7B,MAAAH,YAAAj6C,EAAAgB,aAAA,GACAhB,EAAA9c,MAAAwd,KAAAA,EAAA,MAEAqhC,IAr5JAzgD,EAs5JAgM,KAt5JAuuD,EAs5JA,CAAAn7C,KAAAA,EAAAzD,IAAAA,EAAA0F,MAAAjC,EAAAV,EAAAgB,YAAA6B,OAAA5F,EAAA+C,EAAAS,cAp5JA,OADAuuD,EAAAlH,GAAAxmE,EAAAu6D,IACAj+B,WAAAorC,GAAA1nE,EAAA0tE,EAAApxC,WACA,MAAAoxC,EAAArxC,YAAA2rC,GAAAhoE,EAAA0tE,EAAArxC,YAm3JA,EAmCAo7D,iBAAAnpB,GAAAsc,IACA6R,kBAAAnuB,GAAA4c,IACAwR,eAAAzR,GACA0R,mBAAAruB,GAAAkd,IAEAr1C,YAAA,SAAAouC,GACA,GAAAhiD,GAAAl+B,eAAAkgF,GACA,OAAAhiD,GAAAgiD,GAAA5lF,KAAA,KAAAqN,KAFA,EAKAovC,gBAAAkzB,IAAA,SAAAvsE,GAAAq5C,GAAApvC,KAAAjK,EAAA,IAEAqxF,SAAA,SAAA1wF,EAAAk6F,EAAAzQ,EAAApG,GACA,IAAAv9E,EAAA,EACAo0F,EAAA,IAAAp0F,GAAA,EAAAo0F,GAAAA,GAEA,IADA,IAAA33F,EAAA0kD,GAAA39C,KAAAmyC,IAAAz7C,GACArF,EAAA,EAAAA,EAAAu/F,KACA33F,EAAAmuF,GAAApnF,KAAAmyC,IAAAl5C,EAAAuD,EAAA2jF,EAAApG,IACAqO,UAFA/2F,GAIA,OAAA4H,CARA,EAWAgjF,MAAA3Z,IAAA,SAAA9lE,EAAA2jF,GACA,IAAAtO,EAAA7xE,KAEAA,KAAAyzE,oBAAA,SAAAxiE,GACA,OAAA4gE,EAAAtgD,QAAAnJ,OAAAypD,EAAA1/B,IAAA+xB,QAAAjzD,EAAAK,QACA81E,GAAAvV,EAAA1/B,IAAAlhC,EAAAI,KAAA7U,EAAA2jF,EAAAtO,EAAAl+D,QAAAk9E,iBAEAr0F,EAAA,EAAAyU,EAAAva,OAAAua,EAAAta,IAJA,GAKAi+C,EARA,IAWA8nC,QAAApa,IAAA,SAAA9lE,EAAA2jF,GACA,IAAAtuE,EAAA7R,KAAAmyC,IAAAtgC,IAAAsgC,EAAAnyC,KAAAmyC,IACAtgC,EAAAkc,oBACAokB,EAAA3D,iBAAA,GAAA,KAAA,WAEA+qC,GAAAv5E,MAAA,SAAAiR,GACA,IAAA41B,EAAAugD,GAAAj1C,EAAAlhC,EAAAI,KAAA7U,EAAA2jF,GAAA,GACA,OAAA3jF,EAAA,EAAA,CAAA9F,KAAAmwC,EAAAlwC,GAAAsa,EAAAI,MAAA,CAAA3a,KAAAua,EAAAI,KAAA1a,GAAAkwC,EAFA,GALA,IAWAwhD,SAAA,SAAA3xF,EAAAk6F,EAAAzQ,EAAA2Q,GACA,IAAAt0F,EAAA,EAAA4Y,EAAA07E,EACAF,EAAA,IAAAp0F,GAAA,EAAAo0F,GAAAA,GAEA,IADA,IAAA33F,EAAA0kD,GAAA39C,KAAAmyC,IAAAz7C,GACArF,EAAA,EAAAA,EAAAu/F,IAAAv/F,EAAA,CACA,IAAAynC,EAAAlJ,GAAA5vB,KAAA/G,EAAA,OAIA,GAHA,MAAAmc,EAAAA,EAAA0jB,EAAA1lB,KACA0lB,EAAA1lB,KAAAgC,GACAnc,EAAAovF,GAAAroF,KAAA84B,EAAAt8B,EAAA2jF,IACAiI,QAAA,KALA,CAOA,OAAAnvF,CAXA,EAcA2iF,MAAAtZ,IAAA,SAAA9lE,EAAA2jF,GACA,IAAAtO,EAAA7xE,KAEAmyC,EAAAnyC,KAAAmyC,IAAA4+C,EAAA,GACAj+C,GAAA9yC,KAAAuxB,QAAAnJ,QAAA+pB,EAAA+xB,QAAA/xB,EAAAtgC,IAAAkc,oBAYA,GAXAokB,EAAAshC,oBAAA,SAAAxiE,GACA,GAAA6hC,EACA,OAAAt2C,EAAA,EAAAyU,EAAAva,OAAAua,EAAAta,KACA,IAAAq3F,EAAAp+D,GAAAiiD,EAAA5gE,EAAAI,KAAA,OACA,MAAAJ,EAAA6/E,aAAA9C,EAAA56E,KAAAnC,EAAA6/E,YACAC,EAAA1uF,KAAA2rF,EAAA56E,MACA,IAAAnL,EAAAogF,GAAAxW,EAAAmc,EAAAxxF,EAAA2jF,GAGA,MAFA,QAAAA,GAAAlvE,GAAAkhC,EAAAtgC,IAAA49B,WACAyrB,GAAA2W,EAAAzf,GAAAyf,EAAA5pE,EAAA,OAAA0H,IAAAq+E,EAAAr+E,KACA1H,CATA,GAUA2sC,GACAm8C,EAAAz/F,OAAA,IAAA,IAAAD,EAAA,EAAAA,EAAA8gD,EAAAtgC,IAAAd,OAAAzf,OAAAD,IACA8gD,EAAAtgC,IAAAd,OAAA1f,GAAAy/F,WAAAC,EAAA1/F,EAjBA,IAqBAixF,WAAA,SAAAr6E,GACA,IAAArO,EAAAozB,GAAAhtB,KAAAmyC,IAAAlqC,EAAArO,MAAA7D,KACAoR,EAAAc,EAAAnJ,GAAA4O,EAAAzF,EAAAnJ,GACA,GAAAlF,EAAA,CACA,IAAA67C,EAAAz1C,KAAA2X,UAAA1P,EAAA,aACA,UAAAA,EAAAsuC,QAAA7oC,GAAA9T,EAAAtI,SAAA6V,IAAAuG,IAAAvG,EAMA,IALA,IAAA6pF,EAAAp3F,EAAAsO,OAAAf,GACA8pF,EAAAliD,GAAAiiD,EAAAv7C,GACA,SAAA32C,GAAA,OAAAiwC,GAAAjwC,EAAA22C,EAAA,EACA,KAAAv9C,KAAA84F,GAAA,SAAAlyF,GAAA,MAAA,KAAA5G,KAAA4G,EAAA,EACA,SAAAA,GAAA,OAAA,KAAA5G,KAAA4G,KAAAiwC,GAAAjwC,EAAA,EACAqI,EAAA,GAAA8pF,EAAAr3F,EAAAsO,OAAAf,EAAA,OAAAA,EACA,KAAAuG,EAAA9T,EAAAtI,QAAA2/F,EAAAr3F,EAAAsO,OAAAwF,OAAAA,CATA,CAWA,OAAA,IAAAu6D,GAAArwD,GAAA3P,EAAArO,KAAAuN,GAAAyQ,GAAA3P,EAAArO,KAAA8T,GAdA,EAiBAiwE,gBAAA,SAAA7yE,GACA,MAAAA,GAAAA,GAAA9K,KAAAjI,MAAA07C,aACAzzC,KAAAjI,MAAA07C,WAAAzzC,KAAAjI,MAAA07C,WACApB,EAAAryC,KAAAuxB,QAAAynC,UAAA,wBAEAznB,EAAAvxC,KAAAuxB,QAAAynC,UAAA,wBAEA7qC,GAAAnuB,KAAA,kBAAAA,KAAAA,KAAAjI,MAAA07C,WAPA,EASA0lB,SAAA,WAAA,OAAAn5D,KAAAuxB,QAAA12B,MAAAgkF,YAAA7sC,EAAAjP,EAAA/iC,MAAA,EACA22E,WAAA,WAAA,SAAA32E,KAAA2T,QAAA9e,WAAAmL,KAAAmyC,IAAAq8B,SAAA,EAEAwgB,SAAA1sB,IAAA,SAAAltD,EAAAE,GAAAimD,GAAAv7D,KAAAoV,EAAAE,EAAA,IACA4b,cAAA,WACA,IAAAs8B,EAAAxtD,KAAAuxB,QAAAi8B,SACA,MAAA,CAAAp6C,KAAAo6C,EAAAn9B,WAAA1gB,IAAA69C,EAAAl9B,UACAa,OAAAq8B,EAAAx8B,aAAAs8B,GAAAttD,MAAAA,KAAAuxB,QAAAo8B,UACAl8B,MAAA+7B,EAAA0O,YAAA5O,GAAAttD,MAAAA,KAAAuxB,QAAAk8B,SACAx8B,aAAAy8B,GAAA1tD,MAAA2sD,YAAAY,GAAAvtD,MALA,EAQA40B,eAAA0tC,IAAA,SAAArxD,EAAAykB,GACA,MAAAzkB,GACAA,EAAA,CAAAva,KAAAsJ,KAAAmyC,IAAAtgC,IAAA49B,UAAAp+B,KAAA1a,GAAA,MACA,MAAA++B,IAAAA,EAAA11B,KAAA2T,QAAA2nD,qBACA,iBAAArqD,EACAA,EAAA,CAAAva,KAAAkhB,GAAA3G,EAAA,GAAAta,GAAA,MACA,MAAAsa,EAAAva,OACAua,EAAA,CAAAva,KAAAua,EAAAta,GAAA,OAEAsa,EAAAta,KAAAsa,EAAAta,GAAAsa,EAAAva,MACAua,EAAAykB,OAAAA,GAAA,EAEA,MAAAzkB,EAAAva,KAAAkD,KA99JA,SAAA5F,EAAAid,GACAkqD,GAAAnnE,GACAA,EAAAqlD,MAAAgiB,YAAApqD,CAFA,CA+9JAigF,CAAAlxF,KAAAiR,GAEAuqD,GAAAx7D,KAAAiR,EAAAva,KAAAua,EAAAta,GAAAsa,EAAAykB,OAfA,IAmBAwiD,QAAA5V,IAAA,SAAA7wC,EAAAN,GACA,IAAA0gD,EAAA7xE,KAEAmxF,EAAA,SAAAh8F,GAAA,MAAA,iBAAAA,GAAA,QAAA+C,KAAA5F,OAAA6C,IAAAA,EAAA,KAAAA,CAAA,EACA,MAAAs8B,IAAAzxB,KAAAuxB,QAAA2hB,QAAAt9C,MAAA67B,MAAA0/D,EAAA1/D,IACA,MAAAN,IAAAnxB,KAAAuxB,QAAA2hB,QAAAt9C,MAAAu7B,OAAAggE,EAAAhgE,IACAnxB,KAAA2T,QAAArf,cAAA08D,GAAAhxD,MACA,IAAAmoC,EAAAnoC,KAAAuxB,QAAAmvB,SACA1gD,KAAAmyC,IAAAxF,KAAAxE,EAAAnoC,KAAAuxB,QAAAovB,QAAA,SAAA/mD,GACA,GAAAA,EAAAmyD,QAAA,IAAA,IAAA16D,EAAA,EAAAA,EAAAuI,EAAAmyD,QAAAz6D,OAAAD,IACA,GAAAuI,EAAAmyD,QAAA16D,GAAA+6D,UAAA,CAAAqJ,GAAAoc,EAAA1pC,EAAA,UAAA,KAAA,GACAA,CAHA,IAKAnoC,KAAAq5C,MAAA+U,aAAA,EACAjgC,GAAAnuB,KAAA,UAAAA,KAdA,IAiBA0R,UAAA,SAAAre,GAAA,OAAAgvE,GAAAriE,KAAA3M,EAAA,EACA0rE,eAAA,WAAA,OAAAA,GAAA/+D,KAAA,EACA0/D,aAAA,WAAA,OAAAA,GAAA1/D,KAAA,EAEAwvF,QAAAltB,IAAA,WACA,IAAAxI,EAAA95D,KAAAuxB,QAAA6/B,iBACA2D,GAAA/0D,MACAA,KAAAq5C,MAAA+U,aAAA,EACA8C,GAAAlxD,MACAu7D,GAAAv7D,KAAAA,KAAAmyC,IAAA9hB,WAAArwB,KAAAmyC,IAAA7hB,WACA40C,GAAAllE,KAAAuxB,UACA,MAAAuoC,GAAA9mD,KAAAg8C,IAAA8K,EAAA9F,GAAAh0D,KAAAuxB,UAAA,IAAAvxB,KAAA2T,QAAArf,eACA+/D,GAAAr0D,MACAmuB,GAAAnuB,KAAA,UAAAA,KATA,IAYAoxF,QAAA9uB,IAAA,SAAAnwB,GACA,IAAApgC,EAAA/R,KAAAmyC,IAUA,OATApgC,EAAA/d,GAAA,KAEAgM,KAAAjI,MAAAgoF,eAAA//E,KAAAjI,MAAAgoF,gBACA3V,GAAApqE,KAAAmyC,GACA+e,GAAAlxD,MACAA,KAAAuxB,QAAA12B,MAAAgxB,QACA0vC,GAAAv7D,KAAAmyC,EAAA9hB,WAAA8hB,EAAA7hB,WACAtwB,KAAAq5C,MAAAyiB,aAAA,EACAxS,GAAAtpD,KAAA,UAAAA,KAAA+R,GACAA,CAXA,IAcAs/E,OAAA,SAAAC,GACA,IAAAC,EAAAvxF,KAAA2T,QAAA49E,QACA,OAAAA,GAAA5/F,OAAAO,UAAAmG,eAAA1F,KAAA4+F,EAAAD,GAAAC,EAAAD,GAAAA,CAFA,EAKApiE,cAAA,WAAA,OAAAlvB,KAAAuxB,QAAA12B,MAAAgkF,UAAA,EACA9qE,kBAAA,WAAA,OAAA/T,KAAAuxB,QAAA2hB,OAAA,EACAs+C,mBAAA,WAAA,OAAAxxF,KAAAuxB,QAAAi8B,QAAA,EACAikC,iBAAA,WAAA,OAAAzxF,KAAAuxB,QAAAt8B,OAAA,GAEAukD,GAAA5lD,GAEAA,EAAA2c,eAAA,SAAAlS,EAAAhH,EAAAyT,GACA+qB,EAAAx9B,eAAAgG,KAAAw3B,EAAAx3B,GAAAzK,EAAAyK,GAAA,CAAA+xF,QAAA,KACAv6D,EAAAx3B,GAAAhH,GAAAyT,CAFA,EAIAlX,EAAA89F,qBAAA,SAAArzF,EAAAhH,EAAAs6F,EAAA7mF,GACAlX,EAAA2c,eAAAlS,EAAAhH,EAAAyT,GACA+qB,EAAAx3B,GAAA+xF,QAAA/tF,KAAA,CAAA2zC,KAAA27C,EAAAx8F,IAAA2V,GAFA,CAzaA,CAsgDA8mF,CAAAh+F,IAGA,IAAAi+F,GAAA,gDAAA91E,MAAA,KACA,IAAA,IAAAtd,MAAA00E,GAAAjhF,UAAAihF,GAAAjhF,UAAAmG,eAAAoG,KAAAoJ,EAAAgqF,GAAApzF,IAAA,IACA7K,GAAA1B,UAAAuM,IAAA,SAAAq9B,GACA,OAAA,WAAA,OAAAA,EAAAtyB,MAAAxJ,KAAAmyC,IAAA5oC,UAAA,CADA,CAAA,CAEA4pE,GAAAjhF,UAAAuM,MAkCA,OAhCA+6C,GAAA25B,IACAv/E,GAAA8vF,YAAA,CAAAvkD,SAAAiuD,GAAAptD,gBAAAwoD,IAKA50F,GAAAoD,WAAA,SAAAK,GACAzD,GAAA4K,SAAApK,MAAA,QAAAiD,IAAAzD,GAAA4K,SAAApK,KAAAiD,GACAL,GAAAwS,MAAAxJ,KAAAuJ,UAFA,EAKA3V,GAAAmG,WAp6RA,SAAA+3F,EAAAp5F,GACA6J,GAAAuvF,GAAAp5F,CADA,EAu6RA9E,GAAAoD,WAAA,QAAA,WAAA,MAAA,CAAAgB,MAAA,SAAAF,GAAA,OAAAA,EAAA8O,WAAA,EAAA,IACAhT,GAAAmG,WAAA,aAAA,QAIAnG,GAAAmlB,gBAAA,SAAA1hB,EAAA06F,GACAn+F,GAAA1B,UAAAmF,GAAA06F,CADA,EAGAn+F,GAAAo+F,mBAAA,SAAA36F,EAAA06F,GACA5e,GAAAjhF,UAAAmF,GAAA06F,CADA,EAIAn+F,GAAAK,aA5IA,SAAAkrC,EAAAxrB,GASA,IARAA,EAAAA,EAAA6/B,EAAA7/B,GAAA,CAAA,GACA7I,MAAAq0B,EAAAr0B,OACA6I,EAAAktB,UAAA1B,EAAA29B,WACAnpD,EAAAktB,SAAA1B,EAAA29B,WACAnpD,EAAAgpB,aAAAwC,EAAAxC,cACAhpB,EAAAgpB,YAAAwC,EAAAxC,aAGA,MAAAhpB,EAAAomB,UAAA,CACA,IAAAo/B,EAAAnnB,EAAAC,EAAA9S,IACAxrB,EAAAomB,UAAAo/B,GAAAh6B,GACA,MAAAA,EAAA0tB,aAAA,cAAAsM,GAAAtmD,SAAA3G,IAHA,CAMA,SAAA4zC,IAAA3gB,EAAAr0B,MAAA9W,EAAAoB,UAAA,CAEA,IAAA68F,EACA,GAAA9yD,EAAAtiC,OACArH,GAAA2pC,EAAAtiC,KAAA,SAAAijD,IAEAnsC,EAAAu+E,wBAAA,CACA,IAAAr1F,EAAAsiC,EAAAtiC,KACAo1F,EAAAp1F,EAAAs1F,OACA,IACA,IAAAC,EAAAv1F,EAAAs1F,OAAA,WACAryC,IACAjjD,EAAAs1F,OAAAF,EACAp1F,EAAAs1F,SACAt1F,EAAAs1F,OAAAC,CAJA,CADA,CAOA,MAAA5/F,GAAA,CAVA,CAcAmhB,EAAAsxE,WAAA,SAAAjxF,GACAA,EAAA8rD,KAAAA,EACA9rD,EAAAq+F,YAAA,WAAA,OAAAlzD,CAAA,EACAnrC,EAAAs+F,WAAA,WACAt+F,EAAAs+F,WAAAxoD,MACAgW,IACA3gB,EAAA5sB,WAAAC,YAAAxe,EAAA+f,qBACAorB,EAAAvpC,MAAA27B,QAAA,GACA4N,EAAAtiC,OACAoV,GAAAktB,EAAAtiC,KAAA,SAAAijD,GACAnsC,EAAAu+E,wBAAA,mBAAA/yD,EAAAtiC,KAAAs1F,SACAhzD,EAAAtiC,KAAAs1F,OAAAF,GARA,CAHA,EAgBA9yD,EAAAvpC,MAAA27B,QAAA,OACA,IAAAv9B,EAAAJ,IAAA,SAAA8e,GAAA,OAAAysB,EAAA5sB,WAAAi4C,aAAA93C,EAAAysB,EAAAxN,YAAA,GACAhe,GACA,OAAA3f,CAtDA,EAyDA,SAAAJ,GACAA,EAAAqe,IAAAA,GACAre,EAAA4B,GAAAA,GACA5B,EAAAkzE,iBAAAA,GACAlzE,EAAAu/E,IAAAA,GACAv/E,EAAA68E,WAAA51B,GACAjnD,EAAA8/C,YAAAA,EACA9/C,EAAAihD,WAAAA,EACAjhD,EAAAm7C,WAAAyG,GACA5hD,EAAAiG,KAAAA,EACAjG,EAAAu6B,OAAAA,GACAv6B,EAAAiyD,KAAAA,GACAjyD,EAAA40E,UAAAA,GACA50E,EAAA6qE,eAAAA,GACA7qE,EAAAgkB,IAAAA,GACAhkB,EAAA+7C,OAAArD,GACA14C,EAAA0nD,MAAAA,GACA1nD,EAAA2O,UAAAA,GACA3O,EAAAuvC,YAAAA,GACAvvC,EAAAwD,QAAAA,GACAxD,EAAA8nD,eAAAA,GACA9nD,EAAAkoD,WAAAA,GACAloD,EAAA6F,UAAAA,GACA7F,EAAA0F,WAAAA,GACA1F,EAAAkG,UAAAA,GACAlG,EAAA2iC,SAAAA,GACA3iC,EAAAk+B,OAAAA,GACAl+B,EAAAylF,QAAAA,GACAzlF,EAAAklF,cAAAA,GACAllF,EAAA+kF,UAAAA,GACA/kF,EAAA4kF,gBAAAA,GACA5kF,EAAA0c,aAAAA,GACA1c,EAAAs+E,iBAAAA,GACAt+E,EAAAo+E,WAAAA,GACAp+E,EAAA+9E,WAAAA,GACA/9E,EAAA8lD,iBAAAA,GACA9lD,EAAAgmD,kBAAAA,GACAhmD,EAAAmmD,OAAAA,GACAnmD,EAAAy+C,SAAAA,EACAz+C,EAAAk+C,SAAAA,EACAl+C,EAAA29C,QAAAA,EACA39C,EAAAukF,SAAAA,EAzCA,CAqFAoa,CAAA3+F,IAEAA,GAAA4+F,QAAA,UAEA5+F,EA5oTA,EAHA,WAAAvB,QAAAoB,SAAA,IAAAC,EAAAA,EAAAD,QAAA2nB,IACA,mBAAAphB,QAAAA,OAAAC,IAAAD,OAAAohB,IACAD,EAAAA,GAAAoR,MAAA34B,WAAAwnB,G3Bu9mBQ,EACA,CAAC,ICp+mBT,CAAA,EAAA,CAAA","file":"advanced-settings.js","sourcesContent":["require = function e(t, n, r) {\n    function s(o, u) {\n        if (!n[o]) {\n            if (!t[o]) {\n                var a = typeof require == 'function' && require;\n                if (!u && a)\n                    return a(o, !0);\n                if (i)\n                    return i(o, !0);\n                var f = new Error('Cannot find module \\'' + o + '\\'');\n                throw f.code = 'MODULE_NOT_FOUND', f;\n            }\n            var l = n[o] = { exports: {} };\n            t[o][0].call(l.exports, function (e) {\n                var n = t[o][1][e];\n                return s(n ? n : e);\n            }, l, l.exports, e, t, n, r);\n        }\n        return n[o].exports;\n    }\n    var i = typeof require == 'function' && require;\n    for (var o = 0; o < r.length; o++)\n        s(r[o]);\n    return s;\n}({\n    1: [\n        function (require, module, exports) {\n            const $ = require(131);\n            const CodeMirror = require(79);\n            require(60);\n            require(61);\n            require(62);\n            require(63);\n            require(64);\n            require(65);\n            require(67);\n            require(68);\n            require(69);\n            require(70);\n            require(71);\n            require(77);\n            require(74);\n            require(73);\n            require(75);\n            require(76);\n            require(78);\n            require(82);\n            require(80);\n            require(81);\n            const debounce = require(5);\n            const $preview = $('#custom-verification-preview');\n            const $editor = $('#textarea-custom-verification-html');\n            const cm = CodeMirror.fromTextArea($editor.get(0), {\n                theme: 'material',\n                mode: 'htmlmixed',\n                lineNumbers: true,\n                lineWrapping: true,\n                spellcheck: true,\n                autocorrect: true,\n                showTrailingSpace: true,\n                styleActiveLine: true,\n                continueComments: true,\n                autoRefresh: true,\n                readOnly: window.IS_CUSTOM_VERIFICATION_DISABLED === true,\n                lint: true,\n                gutters: ['CodeMirror-lint-markers']\n            });\n            function change() {\n                const val = cm.getValue();\n                $preview.contents().find('html').html(val);\n            }\n            change();\n            cm.on('change', debounce(change, 300));\n        },\n        {\n            '131': 131,\n            '5': 5,\n            '60': 60,\n            '61': 61,\n            '62': 62,\n            '63': 63,\n            '64': 64,\n            '65': 65,\n            '67': 67,\n            '68': 68,\n            '69': 69,\n            '70': 70,\n            '71': 71,\n            '73': 73,\n            '74': 74,\n            '75': 75,\n            '76': 76,\n            '77': 77,\n            '78': 78,\n            '79': 79,\n            '80': 80,\n            '81': 81,\n            '82': 82\n        }\n    ],\n    81: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79), require(83), require(82), require(80));\n                else if (typeof define == 'function' && define.amd)\n                    define([\n                        '../../lib/codemirror',\n                        '../xml/xml',\n                        '../javascript/javascript',\n                        '../css/css'\n                    ], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                var defaultTags = {\n                    script: [\n                        [\n                            'lang',\n                            /(javascript|babel)/i,\n                            'javascript'\n                        ],\n                        [\n                            'type',\n                            /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^module$|^$/i,\n                            'javascript'\n                        ],\n                        [\n                            'type',\n                            /./,\n                            'text/plain'\n                        ],\n                        [\n                            null,\n                            null,\n                            'javascript'\n                        ]\n                    ],\n                    style: [\n                        [\n                            'lang',\n                            /^css$/i,\n                            'css'\n                        ],\n                        [\n                            'type',\n                            /^(text\\/)?(x-)?(stylesheet|css)$/i,\n                            'css'\n                        ],\n                        [\n                            'type',\n                            /./,\n                            'text/plain'\n                        ],\n                        [\n                            null,\n                            null,\n                            'css'\n                        ]\n                    ]\n                };\n                function maybeBackup(stream, pat, style) {\n                    var cur = stream.current(), close = cur.search(pat);\n                    if (close > -1) {\n                        stream.backUp(cur.length - close);\n                    } else if (cur.match(/<\\/?$/)) {\n                        stream.backUp(cur.length);\n                        if (!stream.match(pat, false))\n                            stream.match(cur);\n                    }\n                    return style;\n                }\n                var attrRegexpCache = {};\n                function getAttrRegexp(attr) {\n                    var regexp = attrRegexpCache[attr];\n                    if (regexp)\n                        return regexp;\n                    return attrRegexpCache[attr] = new RegExp('\\\\s+' + attr + '\\\\s*=\\\\s*(\\'|\")?([^\\'\"]+)(\\'|\")?\\\\s*');\n                }\n                function getAttrValue(text, attr) {\n                    var match = text.match(getAttrRegexp(attr));\n                    return match ? /^\\s*(.*?)\\s*$/.exec(match[2])[1] : '';\n                }\n                function getTagRegexp(tagName, anchored) {\n                    return new RegExp((anchored ? '^' : '') + '</\\\\s*' + tagName + '\\\\s*>', 'i');\n                }\n                function addTags(from, to) {\n                    for (var tag in from) {\n                        var dest = to[tag] || (to[tag] = []);\n                        var source = from[tag];\n                        for (var i = source.length - 1; i >= 0; i--)\n                            dest.unshift(source[i]);\n                    }\n                }\n                function findMatchingMode(tagInfo, tagText) {\n                    for (var i = 0; i < tagInfo.length; i++) {\n                        var spec = tagInfo[i];\n                        if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0])))\n                            return spec[2];\n                    }\n                }\n                CodeMirror.defineMode('htmlmixed', function (config, parserConfig) {\n                    var htmlMode = CodeMirror.getMode(config, {\n                        name: 'xml',\n                        htmlMode: true,\n                        multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,\n                        multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag,\n                        allowMissingTagName: parserConfig.allowMissingTagName\n                    });\n                    var tags = {};\n                    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;\n                    addTags(defaultTags, tags);\n                    if (configTags)\n                        addTags(configTags, tags);\n                    if (configScript)\n                        for (var i = configScript.length - 1; i >= 0; i--)\n                            tags.script.unshift([\n                                'type',\n                                configScript[i].matches,\n                                configScript[i].mode\n                            ]);\n                    function html(stream, state) {\n                        var style = htmlMode.token(stream, state.htmlState), tag = /\\btag\\b/.test(style), tagName;\n                        if (tag && !/[<>\\s\\/]/.test(stream.current()) && (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) && tags.hasOwnProperty(tagName)) {\n                            state.inTag = tagName + ' ';\n                        } else if (state.inTag && tag && />$/.test(stream.current())) {\n                            var inTag = /^([\\S]+) (.*)/.exec(state.inTag);\n                            state.inTag = null;\n                            var modeSpec = stream.current() == '>' && findMatchingMode(tags[inTag[1]], inTag[2]);\n                            var mode = CodeMirror.getMode(config, modeSpec);\n                            var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);\n                            state.token = function (stream, state) {\n                                if (stream.match(endTagA, false)) {\n                                    state.token = html;\n                                    state.localState = state.localMode = null;\n                                    return null;\n                                }\n                                return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));\n                            };\n                            state.localMode = mode;\n                            state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, '', ''));\n                        } else if (state.inTag) {\n                            state.inTag += stream.current();\n                            if (stream.eol())\n                                state.inTag += ' ';\n                        }\n                        return style;\n                    }\n                    ;\n                    return {\n                        startState: function () {\n                            var state = CodeMirror.startState(htmlMode);\n                            return {\n                                token: html,\n                                inTag: null,\n                                localMode: null,\n                                localState: null,\n                                htmlState: state\n                            };\n                        },\n                        copyState: function (state) {\n                            var local;\n                            if (state.localState) {\n                                local = CodeMirror.copyState(state.localMode, state.localState);\n                            }\n                            return {\n                                token: state.token,\n                                inTag: state.inTag,\n                                localMode: state.localMode,\n                                localState: local,\n                                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)\n                            };\n                        },\n                        token: function (stream, state) {\n                            return state.token(stream, state);\n                        },\n                        indent: function (state, textAfter, line) {\n                            if (!state.localMode || /^\\s*<\\//.test(textAfter))\n                                return htmlMode.indent(state.htmlState, textAfter, line);\n                            else if (state.localMode.indent)\n                                return state.localMode.indent(state.localState, textAfter, line);\n                            else\n                                return CodeMirror.Pass;\n                        },\n                        innerMode: function (state) {\n                            return {\n                                state: state.localState || state.htmlState,\n                                mode: state.localMode || htmlMode\n                            };\n                        }\n                    };\n                }, 'xml', 'javascript', 'css');\n                CodeMirror.defineMIME('text/html', 'htmlmixed');\n            }));\n        },\n        {\n            '79': 79,\n            '80': 80,\n            '82': 82,\n            '83': 83\n        }\n    ],\n    83: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                var htmlConfig = {\n                    autoSelfClosers: {\n                        'area': true,\n                        'base': true,\n                        'br': true,\n                        'col': true,\n                        'command': true,\n                        'embed': true,\n                        'frame': true,\n                        'hr': true,\n                        'img': true,\n                        'input': true,\n                        'keygen': true,\n                        'link': true,\n                        'meta': true,\n                        'param': true,\n                        'source': true,\n                        'track': true,\n                        'wbr': true,\n                        'menuitem': true\n                    },\n                    implicitlyClosed: {\n                        'dd': true,\n                        'li': true,\n                        'optgroup': true,\n                        'option': true,\n                        'p': true,\n                        'rp': true,\n                        'rt': true,\n                        'tbody': true,\n                        'td': true,\n                        'tfoot': true,\n                        'th': true,\n                        'tr': true\n                    },\n                    contextGrabbers: {\n                        'dd': {\n                            'dd': true,\n                            'dt': true\n                        },\n                        'dt': {\n                            'dd': true,\n                            'dt': true\n                        },\n                        'li': { 'li': true },\n                        'option': {\n                            'option': true,\n                            'optgroup': true\n                        },\n                        'optgroup': { 'optgroup': true },\n                        'p': {\n                            'address': true,\n                            'article': true,\n                            'aside': true,\n                            'blockquote': true,\n                            'dir': true,\n                            'div': true,\n                            'dl': true,\n                            'fieldset': true,\n                            'footer': true,\n                            'form': true,\n                            'h1': true,\n                            'h2': true,\n                            'h3': true,\n                            'h4': true,\n                            'h5': true,\n                            'h6': true,\n                            'header': true,\n                            'hgroup': true,\n                            'hr': true,\n                            'menu': true,\n                            'nav': true,\n                            'ol': true,\n                            'p': true,\n                            'pre': true,\n                            'section': true,\n                            'table': true,\n                            'ul': true\n                        },\n                        'rp': {\n                            'rp': true,\n                            'rt': true\n                        },\n                        'rt': {\n                            'rp': true,\n                            'rt': true\n                        },\n                        'tbody': {\n                            'tbody': true,\n                            'tfoot': true\n                        },\n                        'td': {\n                            'td': true,\n                            'th': true\n                        },\n                        'tfoot': { 'tbody': true },\n                        'th': {\n                            'td': true,\n                            'th': true\n                        },\n                        'thead': {\n                            'tbody': true,\n                            'tfoot': true\n                        },\n                        'tr': { 'tr': true }\n                    },\n                    doNotIndent: { 'pre': true },\n                    allowUnquoted: true,\n                    allowMissing: true,\n                    caseFold: true\n                };\n                var xmlConfig = {\n                    autoSelfClosers: {},\n                    implicitlyClosed: {},\n                    contextGrabbers: {},\n                    doNotIndent: {},\n                    allowUnquoted: false,\n                    allowMissing: false,\n                    allowMissingTagName: false,\n                    caseFold: false\n                };\n                CodeMirror.defineMode('xml', function (editorConf, config_) {\n                    var indentUnit = editorConf.indentUnit;\n                    var config = {};\n                    var defaults = config_.htmlMode ? htmlConfig : xmlConfig;\n                    for (var prop in defaults)\n                        config[prop] = defaults[prop];\n                    for (var prop in config_)\n                        config[prop] = config_[prop];\n                    var type, setStyle;\n                    function inText(stream, state) {\n                        function chain(parser) {\n                            state.tokenize = parser;\n                            return parser(stream, state);\n                        }\n                        var ch = stream.next();\n                        if (ch == '<') {\n                            if (stream.eat('!')) {\n                                if (stream.eat('[')) {\n                                    if (stream.match('CDATA['))\n                                        return chain(inBlock('atom', ']]>'));\n                                    else\n                                        return null;\n                                } else if (stream.match('--')) {\n                                    return chain(inBlock('comment', '-->'));\n                                } else if (stream.match('DOCTYPE', true, true)) {\n                                    stream.eatWhile(/[\\w\\._\\-]/);\n                                    return chain(doctype(1));\n                                } else {\n                                    return null;\n                                }\n                            } else if (stream.eat('?')) {\n                                stream.eatWhile(/[\\w\\._\\-]/);\n                                state.tokenize = inBlock('meta', '?>');\n                                return 'meta';\n                            } else {\n                                type = stream.eat('/') ? 'closeTag' : 'openTag';\n                                state.tokenize = inTag;\n                                return 'tag bracket';\n                            }\n                        } else if (ch == '&') {\n                            var ok;\n                            if (stream.eat('#')) {\n                                if (stream.eat('x')) {\n                                    ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(';');\n                                } else {\n                                    ok = stream.eatWhile(/[\\d]/) && stream.eat(';');\n                                }\n                            } else {\n                                ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(';');\n                            }\n                            return ok ? 'atom' : 'error';\n                        } else {\n                            stream.eatWhile(/[^&<]/);\n                            return null;\n                        }\n                    }\n                    inText.isInText = true;\n                    function inTag(stream, state) {\n                        var ch = stream.next();\n                        if (ch == '>' || ch == '/' && stream.eat('>')) {\n                            state.tokenize = inText;\n                            type = ch == '>' ? 'endTag' : 'selfcloseTag';\n                            return 'tag bracket';\n                        } else if (ch == '=') {\n                            type = 'equals';\n                            return null;\n                        } else if (ch == '<') {\n                            state.tokenize = inText;\n                            state.state = baseState;\n                            state.tagName = state.tagStart = null;\n                            var next = state.tokenize(stream, state);\n                            return next ? next + ' tag error' : 'tag error';\n                        } else if (/[\\'\\\"]/.test(ch)) {\n                            state.tokenize = inAttribute(ch);\n                            state.stringStartCol = stream.column();\n                            return state.tokenize(stream, state);\n                        } else {\n                            stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n                            return 'word';\n                        }\n                    }\n                    function inAttribute(quote) {\n                        var closure = function (stream, state) {\n                            while (!stream.eol()) {\n                                if (stream.next() == quote) {\n                                    state.tokenize = inTag;\n                                    break;\n                                }\n                            }\n                            return 'string';\n                        };\n                        closure.isInAttribute = true;\n                        return closure;\n                    }\n                    function inBlock(style, terminator) {\n                        return function (stream, state) {\n                            while (!stream.eol()) {\n                                if (stream.match(terminator)) {\n                                    state.tokenize = inText;\n                                    break;\n                                }\n                                stream.next();\n                            }\n                            return style;\n                        };\n                    }\n                    function doctype(depth) {\n                        return function (stream, state) {\n                            var ch;\n                            while ((ch = stream.next()) != null) {\n                                if (ch == '<') {\n                                    state.tokenize = doctype(depth + 1);\n                                    return state.tokenize(stream, state);\n                                } else if (ch == '>') {\n                                    if (depth == 1) {\n                                        state.tokenize = inText;\n                                        break;\n                                    } else {\n                                        state.tokenize = doctype(depth - 1);\n                                        return state.tokenize(stream, state);\n                                    }\n                                }\n                            }\n                            return 'meta';\n                        };\n                    }\n                    function lower(tagName) {\n                        return tagName && tagName.toLowerCase();\n                    }\n                    function Context(state, tagName, startOfLine) {\n                        this.prev = state.context;\n                        this.tagName = tagName || '';\n                        this.indent = state.indented;\n                        this.startOfLine = startOfLine;\n                        if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent)\n                            this.noIndent = true;\n                    }\n                    function popContext(state) {\n                        if (state.context)\n                            state.context = state.context.prev;\n                    }\n                    function maybePopContext(state, nextTagName) {\n                        var parentTagName;\n                        while (true) {\n                            if (!state.context) {\n                                return;\n                            }\n                            parentTagName = state.context.tagName;\n                            if (!config.contextGrabbers.hasOwnProperty(lower(parentTagName)) || !config.contextGrabbers[lower(parentTagName)].hasOwnProperty(lower(nextTagName))) {\n                                return;\n                            }\n                            popContext(state);\n                        }\n                    }\n                    function baseState(type, stream, state) {\n                        if (type == 'openTag') {\n                            state.tagStart = stream.column();\n                            return tagNameState;\n                        } else if (type == 'closeTag') {\n                            return closeTagNameState;\n                        } else {\n                            return baseState;\n                        }\n                    }\n                    function tagNameState(type, stream, state) {\n                        if (type == 'word') {\n                            state.tagName = stream.current();\n                            setStyle = 'tag';\n                            return attrState;\n                        } else if (config.allowMissingTagName && type == 'endTag') {\n                            setStyle = 'tag bracket';\n                            return attrState(type, stream, state);\n                        } else {\n                            setStyle = 'error';\n                            return tagNameState;\n                        }\n                    }\n                    function closeTagNameState(type, stream, state) {\n                        if (type == 'word') {\n                            var tagName = stream.current();\n                            if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(lower(state.context.tagName)))\n                                popContext(state);\n                            if (state.context && state.context.tagName == tagName || config.matchClosing === false) {\n                                setStyle = 'tag';\n                                return closeState;\n                            } else {\n                                setStyle = 'tag error';\n                                return closeStateErr;\n                            }\n                        } else if (config.allowMissingTagName && type == 'endTag') {\n                            setStyle = 'tag bracket';\n                            return closeState(type, stream, state);\n                        } else {\n                            setStyle = 'error';\n                            return closeStateErr;\n                        }\n                    }\n                    function closeState(type, _stream, state) {\n                        if (type != 'endTag') {\n                            setStyle = 'error';\n                            return closeState;\n                        }\n                        popContext(state);\n                        return baseState;\n                    }\n                    function closeStateErr(type, stream, state) {\n                        setStyle = 'error';\n                        return closeState(type, stream, state);\n                    }\n                    function attrState(type, _stream, state) {\n                        if (type == 'word') {\n                            setStyle = 'attribute';\n                            return attrEqState;\n                        } else if (type == 'endTag' || type == 'selfcloseTag') {\n                            var tagName = state.tagName, tagStart = state.tagStart;\n                            state.tagName = state.tagStart = null;\n                            if (type == 'selfcloseTag' || config.autoSelfClosers.hasOwnProperty(lower(tagName))) {\n                                maybePopContext(state, tagName);\n                            } else {\n                                maybePopContext(state, tagName);\n                                state.context = new Context(state, tagName, tagStart == state.indented);\n                            }\n                            return baseState;\n                        }\n                        setStyle = 'error';\n                        return attrState;\n                    }\n                    function attrEqState(type, stream, state) {\n                        if (type == 'equals')\n                            return attrValueState;\n                        if (!config.allowMissing)\n                            setStyle = 'error';\n                        return attrState(type, stream, state);\n                    }\n                    function attrValueState(type, stream, state) {\n                        if (type == 'string')\n                            return attrContinuedState;\n                        if (type == 'word' && config.allowUnquoted) {\n                            setStyle = 'string';\n                            return attrState;\n                        }\n                        setStyle = 'error';\n                        return attrState(type, stream, state);\n                    }\n                    function attrContinuedState(type, stream, state) {\n                        if (type == 'string')\n                            return attrContinuedState;\n                        return attrState(type, stream, state);\n                    }\n                    return {\n                        startState: function (baseIndent) {\n                            var state = {\n                                tokenize: inText,\n                                state: baseState,\n                                indented: baseIndent || 0,\n                                tagName: null,\n                                tagStart: null,\n                                context: null\n                            };\n                            if (baseIndent != null)\n                                state.baseIndent = baseIndent;\n                            return state;\n                        },\n                        token: function (stream, state) {\n                            if (!state.tagName && stream.sol())\n                                state.indented = stream.indentation();\n                            if (stream.eatSpace())\n                                return null;\n                            type = null;\n                            var style = state.tokenize(stream, state);\n                            if ((style || type) && style != 'comment') {\n                                setStyle = null;\n                                state.state = state.state(type || style, stream, state);\n                                if (setStyle)\n                                    style = setStyle == 'error' ? style + ' error' : setStyle;\n                            }\n                            return style;\n                        },\n                        indent: function (state, textAfter, fullLine) {\n                            var context = state.context;\n                            if (state.tokenize.isInAttribute) {\n                                if (state.tagStart == state.indented)\n                                    return state.stringStartCol + 1;\n                                else\n                                    return state.indented + indentUnit;\n                            }\n                            if (context && context.noIndent)\n                                return CodeMirror.Pass;\n                            if (state.tokenize != inTag && state.tokenize != inText)\n                                return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n                            if (state.tagName) {\n                                if (config.multilineTagIndentPastTag !== false)\n                                    return state.tagStart + state.tagName.length + 2;\n                                else\n                                    return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n                            }\n                            if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter))\n                                return 0;\n                            var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n                            if (tagAfter && tagAfter[1]) {\n                                while (context) {\n                                    if (context.tagName == tagAfter[2]) {\n                                        context = context.prev;\n                                        break;\n                                    } else if (config.implicitlyClosed.hasOwnProperty(lower(context.tagName))) {\n                                        context = context.prev;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (tagAfter) {\n                                while (context) {\n                                    var grabbers = config.contextGrabbers[lower(context.tagName)];\n                                    if (grabbers && grabbers.hasOwnProperty(lower(tagAfter[2])))\n                                        context = context.prev;\n                                    else\n                                        break;\n                                }\n                            }\n                            while (context && context.prev && !context.startOfLine)\n                                context = context.prev;\n                            if (context)\n                                return context.indent + indentUnit;\n                            else\n                                return state.baseIndent || 0;\n                        },\n                        electricInput: /<\\/[\\s\\w:]+>$/,\n                        blockCommentStart: '<!--',\n                        blockCommentEnd: '-->',\n                        configuration: config.htmlMode ? 'html' : 'xml',\n                        helperType: config.htmlMode ? 'html' : 'xml',\n                        skipAttribute: function (state) {\n                            if (state.state == attrValueState)\n                                state.state = attrState;\n                        },\n                        xmlCurrentTag: function (state) {\n                            return state.tagName ? {\n                                name: state.tagName,\n                                close: state.type == 'closeTag'\n                            } : null;\n                        },\n                        xmlCurrentContext: function (state) {\n                            var context = [];\n                            for (var cx = state.context; cx; cx = cx.prev)\n                                context.push(cx.tagName);\n                            return context.reverse();\n                        }\n                    };\n                });\n                CodeMirror.defineMIME('text/xml', 'xml');\n                CodeMirror.defineMIME('application/xml', 'xml');\n                if (!CodeMirror.mimeModes.hasOwnProperty('text/html'))\n                    CodeMirror.defineMIME('text/html', {\n                        name: 'xml',\n                        htmlMode: true\n                    });\n            }));\n        },\n        { '79': 79 }\n    ],\n    82: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                CodeMirror.defineMode('javascript', function (config, parserConfig) {\n                    var indentUnit = config.indentUnit;\n                    var statementIndent = parserConfig.statementIndent;\n                    var jsonldMode = parserConfig.jsonld;\n                    var jsonMode = parserConfig.json || jsonldMode;\n                    var trackScope = parserConfig.trackScope !== false;\n                    var isTS = parserConfig.typescript;\n                    var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n                    var keywords = function () {\n                        function kw(type) {\n                            return {\n                                type: type,\n                                style: 'keyword'\n                            };\n                        }\n                        var A = kw('keyword a'), B = kw('keyword b'), C = kw('keyword c'), D = kw('keyword d');\n                        var operator = kw('operator'), atom = {\n                                type: 'atom',\n                                style: 'atom'\n                            };\n                        return {\n                            'if': kw('if'),\n                            'while': A,\n                            'with': A,\n                            'else': B,\n                            'do': B,\n                            'try': B,\n                            'finally': B,\n                            'return': D,\n                            'break': D,\n                            'continue': D,\n                            'new': kw('new'),\n                            'delete': C,\n                            'void': C,\n                            'throw': C,\n                            'debugger': kw('debugger'),\n                            'var': kw('var'),\n                            'const': kw('var'),\n                            'let': kw('var'),\n                            'function': kw('function'),\n                            'catch': kw('catch'),\n                            'for': kw('for'),\n                            'switch': kw('switch'),\n                            'case': kw('case'),\n                            'default': kw('default'),\n                            'in': operator,\n                            'typeof': operator,\n                            'instanceof': operator,\n                            'true': atom,\n                            'false': atom,\n                            'null': atom,\n                            'undefined': atom,\n                            'NaN': atom,\n                            'Infinity': atom,\n                            'this': kw('this'),\n                            'class': kw('class'),\n                            'super': kw('atom'),\n                            'yield': C,\n                            'export': kw('export'),\n                            'import': kw('import'),\n                            'extends': C,\n                            'await': C\n                        };\n                    }();\n                    var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n                    var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n                    function readRegexp(stream) {\n                        var escaped = false, next, inSet = false;\n                        while ((next = stream.next()) != null) {\n                            if (!escaped) {\n                                if (next == '/' && !inSet)\n                                    return;\n                                if (next == '[')\n                                    inSet = true;\n                                else if (inSet && next == ']')\n                                    inSet = false;\n                            }\n                            escaped = !escaped && next == '\\\\';\n                        }\n                    }\n                    var type, content;\n                    function ret(tp, style, cont) {\n                        type = tp;\n                        content = cont;\n                        return style;\n                    }\n                    function tokenBase(stream, state) {\n                        var ch = stream.next();\n                        if (ch == '\"' || ch == '\\'') {\n                            state.tokenize = tokenString(ch);\n                            return state.tokenize(stream, state);\n                        } else if (ch == '.' && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n                            return ret('number', 'number');\n                        } else if (ch == '.' && stream.match('..')) {\n                            return ret('spread', 'meta');\n                        } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n                            return ret(ch);\n                        } else if (ch == '=' && stream.eat('>')) {\n                            return ret('=>', 'operator');\n                        } else if (ch == '0' && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n                            return ret('number', 'number');\n                        } else if (/\\d/.test(ch)) {\n                            stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n                            return ret('number', 'number');\n                        } else if (ch == '/') {\n                            if (stream.eat('*')) {\n                                state.tokenize = tokenComment;\n                                return tokenComment(stream, state);\n                            } else if (stream.eat('/')) {\n                                stream.skipToEnd();\n                                return ret('comment', 'comment');\n                            } else if (expressionAllowed(stream, state, 1)) {\n                                readRegexp(stream);\n                                stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n                                return ret('regexp', 'string-2');\n                            } else {\n                                stream.eat('=');\n                                return ret('operator', 'operator', stream.current());\n                            }\n                        } else if (ch == '`') {\n                            state.tokenize = tokenQuasi;\n                            return tokenQuasi(stream, state);\n                        } else if (ch == '#' && stream.peek() == '!') {\n                            stream.skipToEnd();\n                            return ret('meta', 'meta');\n                        } else if (ch == '#' && stream.eatWhile(wordRE)) {\n                            return ret('variable', 'property');\n                        } else if (ch == '<' && stream.match('!--') || ch == '-' && stream.match('->') && !/\\S/.test(stream.string.slice(0, stream.start))) {\n                            stream.skipToEnd();\n                            return ret('comment', 'comment');\n                        } else if (isOperatorChar.test(ch)) {\n                            if (ch != '>' || !state.lexical || state.lexical.type != '>') {\n                                if (stream.eat('=')) {\n                                    if (ch == '!' || ch == '=')\n                                        stream.eat('=');\n                                } else if (/[<>*+\\-|&?]/.test(ch)) {\n                                    stream.eat(ch);\n                                    if (ch == '>')\n                                        stream.eat(ch);\n                                }\n                            }\n                            if (ch == '?' && stream.eat('.'))\n                                return ret('.');\n                            return ret('operator', 'operator', stream.current());\n                        } else if (wordRE.test(ch)) {\n                            stream.eatWhile(wordRE);\n                            var word = stream.current();\n                            if (state.lastType != '.') {\n                                if (keywords.propertyIsEnumerable(word)) {\n                                    var kw = keywords[word];\n                                    return ret(kw.type, kw.style, word);\n                                }\n                                if (word == 'async' && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n                                    return ret('async', 'keyword', word);\n                            }\n                            return ret('variable', 'variable', word);\n                        }\n                    }\n                    function tokenString(quote) {\n                        return function (stream, state) {\n                            var escaped = false, next;\n                            if (jsonldMode && stream.peek() == '@' && stream.match(isJsonldKeyword)) {\n                                state.tokenize = tokenBase;\n                                return ret('jsonld-keyword', 'meta');\n                            }\n                            while ((next = stream.next()) != null) {\n                                if (next == quote && !escaped)\n                                    break;\n                                escaped = !escaped && next == '\\\\';\n                            }\n                            if (!escaped)\n                                state.tokenize = tokenBase;\n                            return ret('string', 'string');\n                        };\n                    }\n                    function tokenComment(stream, state) {\n                        var maybeEnd = false, ch;\n                        while (ch = stream.next()) {\n                            if (ch == '/' && maybeEnd) {\n                                state.tokenize = tokenBase;\n                                break;\n                            }\n                            maybeEnd = ch == '*';\n                        }\n                        return ret('comment', 'comment');\n                    }\n                    function tokenQuasi(stream, state) {\n                        var escaped = false, next;\n                        while ((next = stream.next()) != null) {\n                            if (!escaped && (next == '`' || next == '$' && stream.eat('{'))) {\n                                state.tokenize = tokenBase;\n                                break;\n                            }\n                            escaped = !escaped && next == '\\\\';\n                        }\n                        return ret('quasi', 'string-2', stream.current());\n                    }\n                    var brackets = '([{}])';\n                    function findFatArrow(stream, state) {\n                        if (state.fatArrowAt)\n                            state.fatArrowAt = null;\n                        var arrow = stream.string.indexOf('=>', stream.start);\n                        if (arrow < 0)\n                            return;\n                        if (isTS) {\n                            var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow));\n                            if (m)\n                                arrow = m.index;\n                        }\n                        var depth = 0, sawSomething = false;\n                        for (var pos = arrow - 1; pos >= 0; --pos) {\n                            var ch = stream.string.charAt(pos);\n                            var bracket = brackets.indexOf(ch);\n                            if (bracket >= 0 && bracket < 3) {\n                                if (!depth) {\n                                    ++pos;\n                                    break;\n                                }\n                                if (--depth == 0) {\n                                    if (ch == '(')\n                                        sawSomething = true;\n                                    break;\n                                }\n                            } else if (bracket >= 3 && bracket < 6) {\n                                ++depth;\n                            } else if (wordRE.test(ch)) {\n                                sawSomething = true;\n                            } else if (/[\"'\\/`]/.test(ch)) {\n                                for (;; --pos) {\n                                    if (pos == 0)\n                                        return;\n                                    var next = stream.string.charAt(pos - 1);\n                                    if (next == ch && stream.string.charAt(pos - 2) != '\\\\') {\n                                        pos--;\n                                        break;\n                                    }\n                                }\n                            } else if (sawSomething && !depth) {\n                                ++pos;\n                                break;\n                            }\n                        }\n                        if (sawSomething && !depth)\n                            state.fatArrowAt = pos;\n                    }\n                    var atomicTypes = {\n                        'atom': true,\n                        'number': true,\n                        'variable': true,\n                        'string': true,\n                        'regexp': true,\n                        'this': true,\n                        'import': true,\n                        'jsonld-keyword': true\n                    };\n                    function JSLexical(indented, column, type, align, prev, info) {\n                        this.indented = indented;\n                        this.column = column;\n                        this.type = type;\n                        this.prev = prev;\n                        this.info = info;\n                        if (align != null)\n                            this.align = align;\n                    }\n                    function inScope(state, varname) {\n                        if (!trackScope)\n                            return false;\n                        for (var v = state.localVars; v; v = v.next)\n                            if (v.name == varname)\n                                return true;\n                        for (var cx = state.context; cx; cx = cx.prev) {\n                            for (var v = cx.vars; v; v = v.next)\n                                if (v.name == varname)\n                                    return true;\n                        }\n                    }\n                    function parseJS(state, style, type, content, stream) {\n                        var cc = state.cc;\n                        cx.state = state;\n                        cx.stream = stream;\n                        cx.marked = null, cx.cc = cc;\n                        cx.style = style;\n                        if (!state.lexical.hasOwnProperty('align'))\n                            state.lexical.align = true;\n                        while (true) {\n                            var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n                            if (combinator(type, content)) {\n                                while (cc.length && cc[cc.length - 1].lex)\n                                    cc.pop()();\n                                if (cx.marked)\n                                    return cx.marked;\n                                if (type == 'variable' && inScope(state, content))\n                                    return 'variable-2';\n                                return style;\n                            }\n                        }\n                    }\n                    var cx = {\n                        state: null,\n                        column: null,\n                        marked: null,\n                        cc: null\n                    };\n                    function pass() {\n                        for (var i = arguments.length - 1; i >= 0; i--)\n                            cx.cc.push(arguments[i]);\n                    }\n                    function cont() {\n                        pass.apply(null, arguments);\n                        return true;\n                    }\n                    function inList(name, list) {\n                        for (var v = list; v; v = v.next)\n                            if (v.name == name)\n                                return true;\n                        return false;\n                    }\n                    function register(varname) {\n                        var state = cx.state;\n                        cx.marked = 'def';\n                        if (!trackScope)\n                            return;\n                        if (state.context) {\n                            if (state.lexical.info == 'var' && state.context && state.context.block) {\n                                var newContext = registerVarScoped(varname, state.context);\n                                if (newContext != null) {\n                                    state.context = newContext;\n                                    return;\n                                }\n                            } else if (!inList(varname, state.localVars)) {\n                                state.localVars = new Var(varname, state.localVars);\n                                return;\n                            }\n                        }\n                        if (parserConfig.globalVars && !inList(varname, state.globalVars))\n                            state.globalVars = new Var(varname, state.globalVars);\n                    }\n                    function registerVarScoped(varname, context) {\n                        if (!context) {\n                            return null;\n                        } else if (context.block) {\n                            var inner = registerVarScoped(varname, context.prev);\n                            if (!inner)\n                                return null;\n                            if (inner == context.prev)\n                                return context;\n                            return new Context(inner, context.vars, true);\n                        } else if (inList(varname, context.vars)) {\n                            return context;\n                        } else {\n                            return new Context(context.prev, new Var(varname, context.vars), false);\n                        }\n                    }\n                    function isModifier(name) {\n                        return name == 'public' || name == 'private' || name == 'protected' || name == 'abstract' || name == 'readonly';\n                    }\n                    function Context(prev, vars, block) {\n                        this.prev = prev;\n                        this.vars = vars;\n                        this.block = block;\n                    }\n                    function Var(name, next) {\n                        this.name = name;\n                        this.next = next;\n                    }\n                    var defaultVars = new Var('this', new Var('arguments', null));\n                    function pushcontext() {\n                        cx.state.context = new Context(cx.state.context, cx.state.localVars, false);\n                        cx.state.localVars = defaultVars;\n                    }\n                    function pushblockcontext() {\n                        cx.state.context = new Context(cx.state.context, cx.state.localVars, true);\n                        cx.state.localVars = null;\n                    }\n                    pushcontext.lex = pushblockcontext.lex = true;\n                    function popcontext() {\n                        cx.state.localVars = cx.state.context.vars;\n                        cx.state.context = cx.state.context.prev;\n                    }\n                    popcontext.lex = true;\n                    function pushlex(type, info) {\n                        var result = function () {\n                            var state = cx.state, indent = state.indented;\n                            if (state.lexical.type == 'stat')\n                                indent = state.lexical.indented;\n                            else\n                                for (var outer = state.lexical; outer && outer.type == ')' && outer.align; outer = outer.prev)\n                                    indent = outer.indented;\n                            state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n                        };\n                        result.lex = true;\n                        return result;\n                    }\n                    function poplex() {\n                        var state = cx.state;\n                        if (state.lexical.prev) {\n                            if (state.lexical.type == ')')\n                                state.indented = state.lexical.indented;\n                            state.lexical = state.lexical.prev;\n                        }\n                    }\n                    poplex.lex = true;\n                    function expect(wanted) {\n                        function exp(type) {\n                            if (type == wanted)\n                                return cont();\n                            else if (wanted == ';' || type == '}' || type == ')' || type == ']')\n                                return pass();\n                            else\n                                return cont(exp);\n                        }\n                        ;\n                        return exp;\n                    }\n                    function statement(type, value) {\n                        if (type == 'var')\n                            return cont(pushlex('vardef', value), vardef, expect(';'), poplex);\n                        if (type == 'keyword a')\n                            return cont(pushlex('form'), parenExpr, statement, poplex);\n                        if (type == 'keyword b')\n                            return cont(pushlex('form'), statement, poplex);\n                        if (type == 'keyword d')\n                            return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex('stat'), maybeexpression, expect(';'), poplex);\n                        if (type == 'debugger')\n                            return cont(expect(';'));\n                        if (type == '{')\n                            return cont(pushlex('}'), pushblockcontext, block, poplex, popcontext);\n                        if (type == ';')\n                            return cont();\n                        if (type == 'if') {\n                            if (cx.state.lexical.info == 'else' && cx.state.cc[cx.state.cc.length - 1] == poplex)\n                                cx.state.cc.pop()();\n                            return cont(pushlex('form'), parenExpr, statement, poplex, maybeelse);\n                        }\n                        if (type == 'function')\n                            return cont(functiondef);\n                        if (type == 'for')\n                            return cont(pushlex('form'), pushblockcontext, forspec, statement, popcontext, poplex);\n                        if (type == 'class' || isTS && value == 'interface') {\n                            cx.marked = 'keyword';\n                            return cont(pushlex('form', type == 'class' ? type : value), className, poplex);\n                        }\n                        if (type == 'variable') {\n                            if (isTS && value == 'declare') {\n                                cx.marked = 'keyword';\n                                return cont(statement);\n                            } else if (isTS && (value == 'module' || value == 'enum' || value == 'type') && cx.stream.match(/^\\s*\\w/, false)) {\n                                cx.marked = 'keyword';\n                                if (value == 'enum')\n                                    return cont(enumdef);\n                                else if (value == 'type')\n                                    return cont(typename, expect('operator'), typeexpr, expect(';'));\n                                else\n                                    return cont(pushlex('form'), pattern, expect('{'), pushlex('}'), block, poplex, poplex);\n                            } else if (isTS && value == 'namespace') {\n                                cx.marked = 'keyword';\n                                return cont(pushlex('form'), expression, statement, poplex);\n                            } else if (isTS && value == 'abstract') {\n                                cx.marked = 'keyword';\n                                return cont(statement);\n                            } else {\n                                return cont(pushlex('stat'), maybelabel);\n                            }\n                        }\n                        if (type == 'switch')\n                            return cont(pushlex('form'), parenExpr, expect('{'), pushlex('}', 'switch'), pushblockcontext, block, poplex, poplex, popcontext);\n                        if (type == 'case')\n                            return cont(expression, expect(':'));\n                        if (type == 'default')\n                            return cont(expect(':'));\n                        if (type == 'catch')\n                            return cont(pushlex('form'), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n                        if (type == 'export')\n                            return cont(pushlex('stat'), afterExport, poplex);\n                        if (type == 'import')\n                            return cont(pushlex('stat'), afterImport, poplex);\n                        if (type == 'async')\n                            return cont(statement);\n                        if (value == '@')\n                            return cont(expression, statement);\n                        return pass(pushlex('stat'), expression, expect(';'), poplex);\n                    }\n                    function maybeCatchBinding(type) {\n                        if (type == '(')\n                            return cont(funarg, expect(')'));\n                    }\n                    function expression(type, value) {\n                        return expressionInner(type, value, false);\n                    }\n                    function expressionNoComma(type, value) {\n                        return expressionInner(type, value, true);\n                    }\n                    function parenExpr(type) {\n                        if (type != '(')\n                            return pass();\n                        return cont(pushlex(')'), maybeexpression, expect(')'), poplex);\n                    }\n                    function expressionInner(type, value, noComma) {\n                        if (cx.state.fatArrowAt == cx.stream.start) {\n                            var body = noComma ? arrowBodyNoComma : arrowBody;\n                            if (type == '(')\n                                return cont(pushcontext, pushlex(')'), commasep(funarg, ')'), poplex, expect('=>'), body, popcontext);\n                            else if (type == 'variable')\n                                return pass(pushcontext, pattern, expect('=>'), body, popcontext);\n                        }\n                        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n                        if (atomicTypes.hasOwnProperty(type))\n                            return cont(maybeop);\n                        if (type == 'function')\n                            return cont(functiondef, maybeop);\n                        if (type == 'class' || isTS && value == 'interface') {\n                            cx.marked = 'keyword';\n                            return cont(pushlex('form'), classExpression, poplex);\n                        }\n                        if (type == 'keyword c' || type == 'async')\n                            return cont(noComma ? expressionNoComma : expression);\n                        if (type == '(')\n                            return cont(pushlex(')'), maybeexpression, expect(')'), poplex, maybeop);\n                        if (type == 'operator' || type == 'spread')\n                            return cont(noComma ? expressionNoComma : expression);\n                        if (type == '[')\n                            return cont(pushlex(']'), arrayLiteral, poplex, maybeop);\n                        if (type == '{')\n                            return contCommasep(objprop, '}', null, maybeop);\n                        if (type == 'quasi')\n                            return pass(quasi, maybeop);\n                        if (type == 'new')\n                            return cont(maybeTarget(noComma));\n                        return cont();\n                    }\n                    function maybeexpression(type) {\n                        if (type.match(/[;\\}\\)\\],]/))\n                            return pass();\n                        return pass(expression);\n                    }\n                    function maybeoperatorComma(type, value) {\n                        if (type == ',')\n                            return cont(maybeexpression);\n                        return maybeoperatorNoComma(type, value, false);\n                    }\n                    function maybeoperatorNoComma(type, value, noComma) {\n                        var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n                        var expr = noComma == false ? expression : expressionNoComma;\n                        if (type == '=>')\n                            return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n                        if (type == 'operator') {\n                            if (/\\+\\+|--/.test(value) || isTS && value == '!')\n                                return cont(me);\n                            if (isTS && value == '<' && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n                                return cont(pushlex('>'), commasep(typeexpr, '>'), poplex, me);\n                            if (value == '?')\n                                return cont(expression, expect(':'), expr);\n                            return cont(expr);\n                        }\n                        if (type == 'quasi') {\n                            return pass(quasi, me);\n                        }\n                        if (type == ';')\n                            return;\n                        if (type == '(')\n                            return contCommasep(expressionNoComma, ')', 'call', me);\n                        if (type == '.')\n                            return cont(property, me);\n                        if (type == '[')\n                            return cont(pushlex(']'), maybeexpression, expect(']'), poplex, me);\n                        if (isTS && value == 'as') {\n                            cx.marked = 'keyword';\n                            return cont(typeexpr, me);\n                        }\n                        if (type == 'regexp') {\n                            cx.state.lastType = cx.marked = 'operator';\n                            cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);\n                            return cont(expr);\n                        }\n                    }\n                    function quasi(type, value) {\n                        if (type != 'quasi')\n                            return pass();\n                        if (value.slice(value.length - 2) != '${')\n                            return cont(quasi);\n                        return cont(maybeexpression, continueQuasi);\n                    }\n                    function continueQuasi(type) {\n                        if (type == '}') {\n                            cx.marked = 'string-2';\n                            cx.state.tokenize = tokenQuasi;\n                            return cont(quasi);\n                        }\n                    }\n                    function arrowBody(type) {\n                        findFatArrow(cx.stream, cx.state);\n                        return pass(type == '{' ? statement : expression);\n                    }\n                    function arrowBodyNoComma(type) {\n                        findFatArrow(cx.stream, cx.state);\n                        return pass(type == '{' ? statement : expressionNoComma);\n                    }\n                    function maybeTarget(noComma) {\n                        return function (type) {\n                            if (type == '.')\n                                return cont(noComma ? targetNoComma : target);\n                            else if (type == 'variable' && isTS)\n                                return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);\n                            else\n                                return pass(noComma ? expressionNoComma : expression);\n                        };\n                    }\n                    function target(_, value) {\n                        if (value == 'target') {\n                            cx.marked = 'keyword';\n                            return cont(maybeoperatorComma);\n                        }\n                    }\n                    function targetNoComma(_, value) {\n                        if (value == 'target') {\n                            cx.marked = 'keyword';\n                            return cont(maybeoperatorNoComma);\n                        }\n                    }\n                    function maybelabel(type) {\n                        if (type == ':')\n                            return cont(poplex, statement);\n                        return pass(maybeoperatorComma, expect(';'), poplex);\n                    }\n                    function property(type) {\n                        if (type == 'variable') {\n                            cx.marked = 'property';\n                            return cont();\n                        }\n                    }\n                    function objprop(type, value) {\n                        if (type == 'async') {\n                            cx.marked = 'property';\n                            return cont(objprop);\n                        } else if (type == 'variable' || cx.style == 'keyword') {\n                            cx.marked = 'property';\n                            if (value == 'get' || value == 'set')\n                                return cont(getterSetter);\n                            var m;\n                            if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n                                cx.state.fatArrowAt = cx.stream.pos + m[0].length;\n                            return cont(afterprop);\n                        } else if (type == 'number' || type == 'string') {\n                            cx.marked = jsonldMode ? 'property' : cx.style + ' property';\n                            return cont(afterprop);\n                        } else if (type == 'jsonld-keyword') {\n                            return cont(afterprop);\n                        } else if (isTS && isModifier(value)) {\n                            cx.marked = 'keyword';\n                            return cont(objprop);\n                        } else if (type == '[') {\n                            return cont(expression, maybetype, expect(']'), afterprop);\n                        } else if (type == 'spread') {\n                            return cont(expressionNoComma, afterprop);\n                        } else if (value == '*') {\n                            cx.marked = 'keyword';\n                            return cont(objprop);\n                        } else if (type == ':') {\n                            return pass(afterprop);\n                        }\n                    }\n                    function getterSetter(type) {\n                        if (type != 'variable')\n                            return pass(afterprop);\n                        cx.marked = 'property';\n                        return cont(functiondef);\n                    }\n                    function afterprop(type) {\n                        if (type == ':')\n                            return cont(expressionNoComma);\n                        if (type == '(')\n                            return pass(functiondef);\n                    }\n                    function commasep(what, end, sep) {\n                        function proceed(type, value) {\n                            if (sep ? sep.indexOf(type) > -1 : type == ',') {\n                                var lex = cx.state.lexical;\n                                if (lex.info == 'call')\n                                    lex.pos = (lex.pos || 0) + 1;\n                                return cont(function (type, value) {\n                                    if (type == end || value == end)\n                                        return pass();\n                                    return pass(what);\n                                }, proceed);\n                            }\n                            if (type == end || value == end)\n                                return cont();\n                            if (sep && sep.indexOf(';') > -1)\n                                return pass(what);\n                            return cont(expect(end));\n                        }\n                        return function (type, value) {\n                            if (type == end || value == end)\n                                return cont();\n                            return pass(what, proceed);\n                        };\n                    }\n                    function contCommasep(what, end, info) {\n                        for (var i = 3; i < arguments.length; i++)\n                            cx.cc.push(arguments[i]);\n                        return cont(pushlex(end, info), commasep(what, end), poplex);\n                    }\n                    function block(type) {\n                        if (type == '}')\n                            return cont();\n                        return pass(statement, block);\n                    }\n                    function maybetype(type, value) {\n                        if (isTS) {\n                            if (type == ':')\n                                return cont(typeexpr);\n                            if (value == '?')\n                                return cont(maybetype);\n                        }\n                    }\n                    function maybetypeOrIn(type, value) {\n                        if (isTS && (type == ':' || value == 'in'))\n                            return cont(typeexpr);\n                    }\n                    function mayberettype(type) {\n                        if (isTS && type == ':') {\n                            if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false))\n                                return cont(expression, isKW, typeexpr);\n                            else\n                                return cont(typeexpr);\n                        }\n                    }\n                    function isKW(_, value) {\n                        if (value == 'is') {\n                            cx.marked = 'keyword';\n                            return cont();\n                        }\n                    }\n                    function typeexpr(type, value) {\n                        if (value == 'keyof' || value == 'typeof' || value == 'infer' || value == 'readonly') {\n                            cx.marked = 'keyword';\n                            return cont(value == 'typeof' ? expressionNoComma : typeexpr);\n                        }\n                        if (type == 'variable' || value == 'void') {\n                            cx.marked = 'type';\n                            return cont(afterType);\n                        }\n                        if (value == '|' || value == '&')\n                            return cont(typeexpr);\n                        if (type == 'string' || type == 'number' || type == 'atom')\n                            return cont(afterType);\n                        if (type == '[')\n                            return cont(pushlex(']'), commasep(typeexpr, ']', ','), poplex, afterType);\n                        if (type == '{')\n                            return cont(pushlex('}'), typeprops, poplex, afterType);\n                        if (type == '(')\n                            return cont(commasep(typearg, ')'), maybeReturnType, afterType);\n                        if (type == '<')\n                            return cont(commasep(typeexpr, '>'), typeexpr);\n                        if (type == 'quasi') {\n                            return pass(quasiType, afterType);\n                        }\n                    }\n                    function maybeReturnType(type) {\n                        if (type == '=>')\n                            return cont(typeexpr);\n                    }\n                    function typeprops(type) {\n                        if (type.match(/[\\}\\)\\]]/))\n                            return cont();\n                        if (type == ',' || type == ';')\n                            return cont(typeprops);\n                        return pass(typeprop, typeprops);\n                    }\n                    function typeprop(type, value) {\n                        if (type == 'variable' || cx.style == 'keyword') {\n                            cx.marked = 'property';\n                            return cont(typeprop);\n                        } else if (value == '?' || type == 'number' || type == 'string') {\n                            return cont(typeprop);\n                        } else if (type == ':') {\n                            return cont(typeexpr);\n                        } else if (type == '[') {\n                            return cont(expect('variable'), maybetypeOrIn, expect(']'), typeprop);\n                        } else if (type == '(') {\n                            return pass(functiondecl, typeprop);\n                        } else if (!type.match(/[;\\}\\)\\],]/)) {\n                            return cont();\n                        }\n                    }\n                    function quasiType(type, value) {\n                        if (type != 'quasi')\n                            return pass();\n                        if (value.slice(value.length - 2) != '${')\n                            return cont(quasiType);\n                        return cont(typeexpr, continueQuasiType);\n                    }\n                    function continueQuasiType(type) {\n                        if (type == '}') {\n                            cx.marked = 'string-2';\n                            cx.state.tokenize = tokenQuasi;\n                            return cont(quasiType);\n                        }\n                    }\n                    function typearg(type, value) {\n                        if (type == 'variable' && cx.stream.match(/^\\s*[?:]/, false) || value == '?')\n                            return cont(typearg);\n                        if (type == ':')\n                            return cont(typeexpr);\n                        if (type == 'spread')\n                            return cont(typearg);\n                        return pass(typeexpr);\n                    }\n                    function afterType(type, value) {\n                        if (value == '<')\n                            return cont(pushlex('>'), commasep(typeexpr, '>'), poplex, afterType);\n                        if (value == '|' || type == '.' || value == '&')\n                            return cont(typeexpr);\n                        if (type == '[')\n                            return cont(typeexpr, expect(']'), afterType);\n                        if (value == 'extends' || value == 'implements') {\n                            cx.marked = 'keyword';\n                            return cont(typeexpr);\n                        }\n                        if (value == '?')\n                            return cont(typeexpr, expect(':'), typeexpr);\n                    }\n                    function maybeTypeArgs(_, value) {\n                        if (value == '<')\n                            return cont(pushlex('>'), commasep(typeexpr, '>'), poplex, afterType);\n                    }\n                    function typeparam() {\n                        return pass(typeexpr, maybeTypeDefault);\n                    }\n                    function maybeTypeDefault(_, value) {\n                        if (value == '=')\n                            return cont(typeexpr);\n                    }\n                    function vardef(_, value) {\n                        if (value == 'enum') {\n                            cx.marked = 'keyword';\n                            return cont(enumdef);\n                        }\n                        return pass(pattern, maybetype, maybeAssign, vardefCont);\n                    }\n                    function pattern(type, value) {\n                        if (isTS && isModifier(value)) {\n                            cx.marked = 'keyword';\n                            return cont(pattern);\n                        }\n                        if (type == 'variable') {\n                            register(value);\n                            return cont();\n                        }\n                        if (type == 'spread')\n                            return cont(pattern);\n                        if (type == '[')\n                            return contCommasep(eltpattern, ']');\n                        if (type == '{')\n                            return contCommasep(proppattern, '}');\n                    }\n                    function proppattern(type, value) {\n                        if (type == 'variable' && !cx.stream.match(/^\\s*:/, false)) {\n                            register(value);\n                            return cont(maybeAssign);\n                        }\n                        if (type == 'variable')\n                            cx.marked = 'property';\n                        if (type == 'spread')\n                            return cont(pattern);\n                        if (type == '}')\n                            return pass();\n                        if (type == '[')\n                            return cont(expression, expect(']'), expect(':'), proppattern);\n                        return cont(expect(':'), pattern, maybeAssign);\n                    }\n                    function eltpattern() {\n                        return pass(pattern, maybeAssign);\n                    }\n                    function maybeAssign(_type, value) {\n                        if (value == '=')\n                            return cont(expressionNoComma);\n                    }\n                    function vardefCont(type) {\n                        if (type == ',')\n                            return cont(vardef);\n                    }\n                    function maybeelse(type, value) {\n                        if (type == 'keyword b' && value == 'else')\n                            return cont(pushlex('form', 'else'), statement, poplex);\n                    }\n                    function forspec(type, value) {\n                        if (value == 'await')\n                            return cont(forspec);\n                        if (type == '(')\n                            return cont(pushlex(')'), forspec1, poplex);\n                    }\n                    function forspec1(type) {\n                        if (type == 'var')\n                            return cont(vardef, forspec2);\n                        if (type == 'variable')\n                            return cont(forspec2);\n                        return pass(forspec2);\n                    }\n                    function forspec2(type, value) {\n                        if (type == ')')\n                            return cont();\n                        if (type == ';')\n                            return cont(forspec2);\n                        if (value == 'in' || value == 'of') {\n                            cx.marked = 'keyword';\n                            return cont(expression, forspec2);\n                        }\n                        return pass(expression, forspec2);\n                    }\n                    function functiondef(type, value) {\n                        if (value == '*') {\n                            cx.marked = 'keyword';\n                            return cont(functiondef);\n                        }\n                        if (type == 'variable') {\n                            register(value);\n                            return cont(functiondef);\n                        }\n                        if (type == '(')\n                            return cont(pushcontext, pushlex(')'), commasep(funarg, ')'), poplex, mayberettype, statement, popcontext);\n                        if (isTS && value == '<')\n                            return cont(pushlex('>'), commasep(typeparam, '>'), poplex, functiondef);\n                    }\n                    function functiondecl(type, value) {\n                        if (value == '*') {\n                            cx.marked = 'keyword';\n                            return cont(functiondecl);\n                        }\n                        if (type == 'variable') {\n                            register(value);\n                            return cont(functiondecl);\n                        }\n                        if (type == '(')\n                            return cont(pushcontext, pushlex(')'), commasep(funarg, ')'), poplex, mayberettype, popcontext);\n                        if (isTS && value == '<')\n                            return cont(pushlex('>'), commasep(typeparam, '>'), poplex, functiondecl);\n                    }\n                    function typename(type, value) {\n                        if (type == 'keyword' || type == 'variable') {\n                            cx.marked = 'type';\n                            return cont(typename);\n                        } else if (value == '<') {\n                            return cont(pushlex('>'), commasep(typeparam, '>'), poplex);\n                        }\n                    }\n                    function funarg(type, value) {\n                        if (value == '@')\n                            cont(expression, funarg);\n                        if (type == 'spread')\n                            return cont(funarg);\n                        if (isTS && isModifier(value)) {\n                            cx.marked = 'keyword';\n                            return cont(funarg);\n                        }\n                        if (isTS && type == 'this')\n                            return cont(maybetype, maybeAssign);\n                        return pass(pattern, maybetype, maybeAssign);\n                    }\n                    function classExpression(type, value) {\n                        if (type == 'variable')\n                            return className(type, value);\n                        return classNameAfter(type, value);\n                    }\n                    function className(type, value) {\n                        if (type == 'variable') {\n                            register(value);\n                            return cont(classNameAfter);\n                        }\n                    }\n                    function classNameAfter(type, value) {\n                        if (value == '<')\n                            return cont(pushlex('>'), commasep(typeparam, '>'), poplex, classNameAfter);\n                        if (value == 'extends' || value == 'implements' || isTS && type == ',') {\n                            if (value == 'implements')\n                                cx.marked = 'keyword';\n                            return cont(isTS ? typeexpr : expression, classNameAfter);\n                        }\n                        if (type == '{')\n                            return cont(pushlex('}'), classBody, poplex);\n                    }\n                    function classBody(type, value) {\n                        if (type == 'async' || type == 'variable' && (value == 'static' || value == 'get' || value == 'set' || isTS && isModifier(value)) && cx.stream.match(/^\\s+#?[\\w$\\xa1-\\uffff]/, false)) {\n                            cx.marked = 'keyword';\n                            return cont(classBody);\n                        }\n                        if (type == 'variable' || cx.style == 'keyword') {\n                            cx.marked = 'property';\n                            return cont(classfield, classBody);\n                        }\n                        if (type == 'number' || type == 'string')\n                            return cont(classfield, classBody);\n                        if (type == '[')\n                            return cont(expression, maybetype, expect(']'), classfield, classBody);\n                        if (value == '*') {\n                            cx.marked = 'keyword';\n                            return cont(classBody);\n                        }\n                        if (isTS && type == '(')\n                            return pass(functiondecl, classBody);\n                        if (type == ';' || type == ',')\n                            return cont(classBody);\n                        if (type == '}')\n                            return cont();\n                        if (value == '@')\n                            return cont(expression, classBody);\n                    }\n                    function classfield(type, value) {\n                        if (value == '!')\n                            return cont(classfield);\n                        if (value == '?')\n                            return cont(classfield);\n                        if (type == ':')\n                            return cont(typeexpr, maybeAssign);\n                        if (value == '=')\n                            return cont(expressionNoComma);\n                        var context = cx.state.lexical.prev, isInterface = context && context.info == 'interface';\n                        return pass(isInterface ? functiondecl : functiondef);\n                    }\n                    function afterExport(type, value) {\n                        if (value == '*') {\n                            cx.marked = 'keyword';\n                            return cont(maybeFrom, expect(';'));\n                        }\n                        if (value == 'default') {\n                            cx.marked = 'keyword';\n                            return cont(expression, expect(';'));\n                        }\n                        if (type == '{')\n                            return cont(commasep(exportField, '}'), maybeFrom, expect(';'));\n                        return pass(statement);\n                    }\n                    function exportField(type, value) {\n                        if (value == 'as') {\n                            cx.marked = 'keyword';\n                            return cont(expect('variable'));\n                        }\n                        if (type == 'variable')\n                            return pass(expressionNoComma, exportField);\n                    }\n                    function afterImport(type) {\n                        if (type == 'string')\n                            return cont();\n                        if (type == '(')\n                            return pass(expression);\n                        if (type == '.')\n                            return pass(maybeoperatorComma);\n                        return pass(importSpec, maybeMoreImports, maybeFrom);\n                    }\n                    function importSpec(type, value) {\n                        if (type == '{')\n                            return contCommasep(importSpec, '}');\n                        if (type == 'variable')\n                            register(value);\n                        if (value == '*')\n                            cx.marked = 'keyword';\n                        return cont(maybeAs);\n                    }\n                    function maybeMoreImports(type) {\n                        if (type == ',')\n                            return cont(importSpec, maybeMoreImports);\n                    }\n                    function maybeAs(_type, value) {\n                        if (value == 'as') {\n                            cx.marked = 'keyword';\n                            return cont(importSpec);\n                        }\n                    }\n                    function maybeFrom(_type, value) {\n                        if (value == 'from') {\n                            cx.marked = 'keyword';\n                            return cont(expression);\n                        }\n                    }\n                    function arrayLiteral(type) {\n                        if (type == ']')\n                            return cont();\n                        return pass(commasep(expressionNoComma, ']'));\n                    }\n                    function enumdef() {\n                        return pass(pushlex('form'), pattern, expect('{'), pushlex('}'), commasep(enummember, '}'), poplex, poplex);\n                    }\n                    function enummember() {\n                        return pass(pattern, maybeAssign);\n                    }\n                    function isContinuedStatement(state, textAfter) {\n                        return state.lastType == 'operator' || state.lastType == ',' || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));\n                    }\n                    function expressionAllowed(stream, state, backUp) {\n                        return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) || state.lastType == 'quasi' && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));\n                    }\n                    return {\n                        startState: function (basecolumn) {\n                            var state = {\n                                tokenize: tokenBase,\n                                lastType: 'sof',\n                                cc: [],\n                                lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, 'block', false),\n                                localVars: parserConfig.localVars,\n                                context: parserConfig.localVars && new Context(null, null, false),\n                                indented: basecolumn || 0\n                            };\n                            if (parserConfig.globalVars && typeof parserConfig.globalVars == 'object')\n                                state.globalVars = parserConfig.globalVars;\n                            return state;\n                        },\n                        token: function (stream, state) {\n                            if (stream.sol()) {\n                                if (!state.lexical.hasOwnProperty('align'))\n                                    state.lexical.align = false;\n                                state.indented = stream.indentation();\n                                findFatArrow(stream, state);\n                            }\n                            if (state.tokenize != tokenComment && stream.eatSpace())\n                                return null;\n                            var style = state.tokenize(stream, state);\n                            if (type == 'comment')\n                                return style;\n                            state.lastType = type == 'operator' && (content == '++' || content == '--') ? 'incdec' : type;\n                            return parseJS(state, style, type, content, stream);\n                        },\n                        indent: function (state, textAfter) {\n                            if (state.tokenize == tokenComment || state.tokenize == tokenQuasi)\n                                return CodeMirror.Pass;\n                            if (state.tokenize != tokenBase)\n                                return 0;\n                            var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;\n                            if (!/^\\s*else\\b/.test(textAfter))\n                                for (var i = state.cc.length - 1; i >= 0; --i) {\n                                    var c = state.cc[i];\n                                    if (c == poplex)\n                                        lexical = lexical.prev;\n                                    else if (c != maybeelse && c != popcontext)\n                                        break;\n                                }\n                            while ((lexical.type == 'stat' || lexical.type == 'form') && (firstChar == '}' || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\\.=+\\-*:?[\\(]/.test(textAfter)))\n                                lexical = lexical.prev;\n                            if (statementIndent && lexical.type == ')' && lexical.prev.type == 'stat')\n                                lexical = lexical.prev;\n                            var type = lexical.type, closing = firstChar == type;\n                            if (type == 'vardef')\n                                return lexical.indented + (state.lastType == 'operator' || state.lastType == ',' ? lexical.info.length + 1 : 0);\n                            else if (type == 'form' && firstChar == '{')\n                                return lexical.indented;\n                            else if (type == 'form')\n                                return lexical.indented + indentUnit;\n                            else if (type == 'stat')\n                                return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n                            else if (lexical.info == 'switch' && !closing && parserConfig.doubleIndentSwitch != false)\n                                return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n                            else if (lexical.align)\n                                return lexical.column + (closing ? 0 : 1);\n                            else\n                                return lexical.indented + (closing ? 0 : indentUnit);\n                        },\n                        electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n                        blockCommentStart: jsonMode ? null : '/*',\n                        blockCommentEnd: jsonMode ? null : '*/',\n                        blockCommentContinue: jsonMode ? null : ' * ',\n                        lineComment: jsonMode ? null : '//',\n                        fold: 'brace',\n                        closeBrackets: '()[]{}\\'\\'\"\"``',\n                        helperType: jsonMode ? 'json' : 'javascript',\n                        jsonldMode: jsonldMode,\n                        jsonMode: jsonMode,\n                        expressionAllowed: expressionAllowed,\n                        skipExpression: function (state) {\n                            parseJS(state, 'atom', 'atom', 'true', new CodeMirror.StringStream('', 2, null));\n                        }\n                    };\n                });\n                CodeMirror.registerHelper('wordChars', 'javascript', /[\\w$]/);\n                CodeMirror.defineMIME('text/javascript', 'javascript');\n                CodeMirror.defineMIME('text/ecmascript', 'javascript');\n                CodeMirror.defineMIME('application/javascript', 'javascript');\n                CodeMirror.defineMIME('application/x-javascript', 'javascript');\n                CodeMirror.defineMIME('application/ecmascript', 'javascript');\n                CodeMirror.defineMIME('application/json', {\n                    name: 'javascript',\n                    json: true\n                });\n                CodeMirror.defineMIME('application/x-json', {\n                    name: 'javascript',\n                    json: true\n                });\n                CodeMirror.defineMIME('application/manifest+json', {\n                    name: 'javascript',\n                    json: true\n                });\n                CodeMirror.defineMIME('application/ld+json', {\n                    name: 'javascript',\n                    jsonld: true\n                });\n                CodeMirror.defineMIME('text/typescript', {\n                    name: 'javascript',\n                    typescript: true\n                });\n                CodeMirror.defineMIME('application/typescript', {\n                    name: 'javascript',\n                    typescript: true\n                });\n            }));\n        },\n        { '79': 79 }\n    ],\n    78: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                var WRAP_CLASS = 'CodeMirror-activeline';\n                var BACK_CLASS = 'CodeMirror-activeline-background';\n                var GUTT_CLASS = 'CodeMirror-activeline-gutter';\n                CodeMirror.defineOption('styleActiveLine', false, function (cm, val, old) {\n                    var prev = old == CodeMirror.Init ? false : old;\n                    if (val == prev)\n                        return;\n                    if (prev) {\n                        cm.off('beforeSelectionChange', selectionChange);\n                        clearActiveLines(cm);\n                        delete cm.state.activeLines;\n                    }\n                    if (val) {\n                        cm.state.activeLines = [];\n                        updateActiveLines(cm, cm.listSelections());\n                        cm.on('beforeSelectionChange', selectionChange);\n                    }\n                });\n                function clearActiveLines(cm) {\n                    for (var i = 0; i < cm.state.activeLines.length; i++) {\n                        cm.removeLineClass(cm.state.activeLines[i], 'wrap', WRAP_CLASS);\n                        cm.removeLineClass(cm.state.activeLines[i], 'background', BACK_CLASS);\n                        cm.removeLineClass(cm.state.activeLines[i], 'gutter', GUTT_CLASS);\n                    }\n                }\n                function sameArray(a, b) {\n                    if (a.length != b.length)\n                        return false;\n                    for (var i = 0; i < a.length; i++)\n                        if (a[i] != b[i])\n                            return false;\n                    return true;\n                }\n                function updateActiveLines(cm, ranges) {\n                    var active = [];\n                    for (var i = 0; i < ranges.length; i++) {\n                        var range = ranges[i];\n                        var option = cm.getOption('styleActiveLine');\n                        if (typeof option == 'object' && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())\n                            continue;\n                        var line = cm.getLineHandleVisualStart(range.head.line);\n                        if (active[active.length - 1] != line)\n                            active.push(line);\n                    }\n                    if (sameArray(cm.state.activeLines, active))\n                        return;\n                    cm.operation(function () {\n                        clearActiveLines(cm);\n                        for (var i = 0; i < active.length; i++) {\n                            cm.addLineClass(active[i], 'wrap', WRAP_CLASS);\n                            cm.addLineClass(active[i], 'background', BACK_CLASS);\n                            cm.addLineClass(active[i], 'gutter', GUTT_CLASS);\n                        }\n                        cm.state.activeLines = active;\n                    });\n                }\n                function selectionChange(cm, sel) {\n                    updateActiveLines(cm, sel.ranges);\n                }\n            }));\n        },\n        { '79': 79 }\n    ],\n    77: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                var GUTTER_ID = 'CodeMirror-lint-markers';\n                var LINT_LINE_ID = 'CodeMirror-lint-line-';\n                function showTooltip(cm, e, content) {\n                    var tt = document.createElement('div');\n                    tt.className = 'CodeMirror-lint-tooltip cm-s-' + cm.options.theme;\n                    tt.appendChild(content.cloneNode(true));\n                    if (cm.state.lint.options.selfContain)\n                        cm.getWrapperElement().appendChild(tt);\n                    else\n                        document.body.appendChild(tt);\n                    function position(e) {\n                        if (!tt.parentNode)\n                            return CodeMirror.off(document, 'mousemove', position);\n                        var top = Math.max(0, e.clientY - tt.offsetHeight - 5);\n                        var left = Math.max(0, Math.min(e.clientX + 5, tt.ownerDocument.defaultView.innerWidth - tt.offsetWidth));\n                        tt.style.top = top + 'px';\n                        tt.style.left = left + 'px';\n                    }\n                    CodeMirror.on(document, 'mousemove', position);\n                    position(e);\n                    if (tt.style.opacity != null)\n                        tt.style.opacity = 1;\n                    return tt;\n                }\n                function rm(elt) {\n                    if (elt.parentNode)\n                        elt.parentNode.removeChild(elt);\n                }\n                function hideTooltip(tt) {\n                    if (!tt.parentNode)\n                        return;\n                    if (tt.style.opacity == null)\n                        rm(tt);\n                    tt.style.opacity = 0;\n                    setTimeout(function () {\n                        rm(tt);\n                    }, 600);\n                }\n                function showTooltipFor(cm, e, content, node) {\n                    var tooltip = showTooltip(cm, e, content);\n                    function hide() {\n                        CodeMirror.off(node, 'mouseout', hide);\n                        if (tooltip) {\n                            hideTooltip(tooltip);\n                            tooltip = null;\n                        }\n                    }\n                    var poll = setInterval(function () {\n                        if (tooltip)\n                            for (var n = node;; n = n.parentNode) {\n                                if (n && n.nodeType == 11)\n                                    n = n.host;\n                                if (n == document.body)\n                                    return;\n                                if (!n) {\n                                    hide();\n                                    break;\n                                }\n                            }\n                        if (!tooltip)\n                            return clearInterval(poll);\n                    }, 400);\n                    CodeMirror.on(node, 'mouseout', hide);\n                }\n                function LintState(cm, conf, hasGutter) {\n                    this.marked = [];\n                    if (conf instanceof Function)\n                        conf = { getAnnotations: conf };\n                    if (!conf || conf === true)\n                        conf = {};\n                    this.options = {};\n                    this.linterOptions = conf.options || {};\n                    for (var prop in defaults)\n                        this.options[prop] = defaults[prop];\n                    for (var prop in conf) {\n                        if (defaults.hasOwnProperty(prop)) {\n                            if (conf[prop] != null)\n                                this.options[prop] = conf[prop];\n                        } else if (!conf.options) {\n                            this.linterOptions[prop] = conf[prop];\n                        }\n                    }\n                    this.timeout = null;\n                    this.hasGutter = hasGutter;\n                    this.onMouseOver = function (e) {\n                        onMouseOver(cm, e);\n                    };\n                    this.waitingFor = 0;\n                }\n                var defaults = {\n                    highlightLines: false,\n                    tooltips: true,\n                    delay: 500,\n                    lintOnChange: true,\n                    getAnnotations: null,\n                    async: false,\n                    selfContain: null,\n                    formatAnnotation: null,\n                    onUpdateLinting: null\n                };\n                function clearMarks(cm) {\n                    var state = cm.state.lint;\n                    if (state.hasGutter)\n                        cm.clearGutter(GUTTER_ID);\n                    if (state.options.highlightLines)\n                        clearErrorLines(cm);\n                    for (var i = 0; i < state.marked.length; ++i)\n                        state.marked[i].clear();\n                    state.marked.length = 0;\n                }\n                function clearErrorLines(cm) {\n                    cm.eachLine(function (line) {\n                        var has = line.wrapClass && /\\bCodeMirror-lint-line-\\w+\\b/.exec(line.wrapClass);\n                        if (has)\n                            cm.removeLineClass(line, 'wrap', has[0]);\n                    });\n                }\n                function makeMarker(cm, labels, severity, multiple, tooltips) {\n                    var marker = document.createElement('div'), inner = marker;\n                    marker.className = 'CodeMirror-lint-marker CodeMirror-lint-marker-' + severity;\n                    if (multiple) {\n                        inner = marker.appendChild(document.createElement('div'));\n                        inner.className = 'CodeMirror-lint-marker CodeMirror-lint-marker-multiple';\n                    }\n                    if (tooltips != false)\n                        CodeMirror.on(inner, 'mouseover', function (e) {\n                            showTooltipFor(cm, e, labels, inner);\n                        });\n                    return marker;\n                }\n                function getMaxSeverity(a, b) {\n                    if (a == 'error')\n                        return a;\n                    else\n                        return b;\n                }\n                function groupByLine(annotations) {\n                    var lines = [];\n                    for (var i = 0; i < annotations.length; ++i) {\n                        var ann = annotations[i], line = ann.from.line;\n                        (lines[line] || (lines[line] = [])).push(ann);\n                    }\n                    return lines;\n                }\n                function annotationTooltip(ann) {\n                    var severity = ann.severity;\n                    if (!severity)\n                        severity = 'error';\n                    var tip = document.createElement('div');\n                    tip.className = 'CodeMirror-lint-message CodeMirror-lint-message-' + severity;\n                    if (typeof ann.messageHTML != 'undefined') {\n                        tip.innerHTML = ann.messageHTML;\n                    } else {\n                        tip.appendChild(document.createTextNode(ann.message));\n                    }\n                    return tip;\n                }\n                function lintAsync(cm, getAnnotations) {\n                    var state = cm.state.lint;\n                    var id = ++state.waitingFor;\n                    function abort() {\n                        id = -1;\n                        cm.off('change', abort);\n                    }\n                    cm.on('change', abort);\n                    getAnnotations(cm.getValue(), function (annotations, arg2) {\n                        cm.off('change', abort);\n                        if (state.waitingFor != id)\n                            return;\n                        if (arg2 && annotations instanceof CodeMirror)\n                            annotations = arg2;\n                        cm.operation(function () {\n                            updateLinting(cm, annotations);\n                        });\n                    }, state.linterOptions, cm);\n                }\n                function startLinting(cm) {\n                    var state = cm.state.lint;\n                    if (!state)\n                        return;\n                    var options = state.options;\n                    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), 'lint');\n                    if (!getAnnotations)\n                        return;\n                    if (options.async || getAnnotations.async) {\n                        lintAsync(cm, getAnnotations);\n                    } else {\n                        var annotations = getAnnotations(cm.getValue(), state.linterOptions, cm);\n                        if (!annotations)\n                            return;\n                        if (annotations.then)\n                            annotations.then(function (issues) {\n                                cm.operation(function () {\n                                    updateLinting(cm, issues);\n                                });\n                            });\n                        else\n                            cm.operation(function () {\n                                updateLinting(cm, annotations);\n                            });\n                    }\n                }\n                function updateLinting(cm, annotationsNotSorted) {\n                    var state = cm.state.lint;\n                    if (!state)\n                        return;\n                    var options = state.options;\n                    clearMarks(cm);\n                    var annotations = groupByLine(annotationsNotSorted);\n                    for (var line = 0; line < annotations.length; ++line) {\n                        var anns = annotations[line];\n                        if (!anns)\n                            continue;\n                        var maxSeverity = null;\n                        var tipLabel = state.hasGutter && document.createDocumentFragment();\n                        for (var i = 0; i < anns.length; ++i) {\n                            var ann = anns[i];\n                            var severity = ann.severity;\n                            if (!severity)\n                                severity = 'error';\n                            maxSeverity = getMaxSeverity(maxSeverity, severity);\n                            if (options.formatAnnotation)\n                                ann = options.formatAnnotation(ann);\n                            if (state.hasGutter)\n                                tipLabel.appendChild(annotationTooltip(ann));\n                            if (ann.to)\n                                state.marked.push(cm.markText(ann.from, ann.to, {\n                                    className: 'CodeMirror-lint-mark CodeMirror-lint-mark-' + severity,\n                                    __annotation: ann\n                                }));\n                        }\n                        if (state.hasGutter)\n                            cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, anns.length > 1, options.tooltips));\n                        if (options.highlightLines)\n                            cm.addLineClass(line, 'wrap', LINT_LINE_ID + maxSeverity);\n                    }\n                    if (options.onUpdateLinting)\n                        options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n                }\n                function onChange(cm) {\n                    var state = cm.state.lint;\n                    if (!state)\n                        return;\n                    clearTimeout(state.timeout);\n                    state.timeout = setTimeout(function () {\n                        startLinting(cm);\n                    }, state.options.delay);\n                }\n                function popupTooltips(cm, annotations, e) {\n                    var target = e.target || e.srcElement;\n                    var tooltip = document.createDocumentFragment();\n                    for (var i = 0; i < annotations.length; i++) {\n                        var ann = annotations[i];\n                        tooltip.appendChild(annotationTooltip(ann));\n                    }\n                    showTooltipFor(cm, e, tooltip, target);\n                }\n                function onMouseOver(cm, e) {\n                    var target = e.target || e.srcElement;\n                    if (!/\\bCodeMirror-lint-mark-/.test(target.className))\n                        return;\n                    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n                    var spans = cm.findMarksAt(cm.coordsChar({\n                        left: x,\n                        top: y\n                    }, 'client'));\n                    var annotations = [];\n                    for (var i = 0; i < spans.length; ++i) {\n                        var ann = spans[i].__annotation;\n                        if (ann)\n                            annotations.push(ann);\n                    }\n                    if (annotations.length)\n                        popupTooltips(cm, annotations, e);\n                }\n                CodeMirror.defineOption('lint', false, function (cm, val, old) {\n                    if (old && old != CodeMirror.Init) {\n                        clearMarks(cm);\n                        if (cm.state.lint.options.lintOnChange !== false)\n                            cm.off('change', onChange);\n                        CodeMirror.off(cm.getWrapperElement(), 'mouseover', cm.state.lint.onMouseOver);\n                        clearTimeout(cm.state.lint.timeout);\n                        delete cm.state.lint;\n                    }\n                    if (val) {\n                        var gutters = cm.getOption('gutters'), hasLintGutter = false;\n                        for (var i = 0; i < gutters.length; ++i)\n                            if (gutters[i] == GUTTER_ID)\n                                hasLintGutter = true;\n                        var state = cm.state.lint = new LintState(cm, val, hasLintGutter);\n                        if (state.options.lintOnChange)\n                            cm.on('change', onChange);\n                        if (state.options.tooltips != false && state.options.tooltips != 'gutter')\n                            CodeMirror.on(cm.getWrapperElement(), 'mouseover', state.onMouseOver);\n                        startLinting(cm);\n                    }\n                });\n                CodeMirror.defineExtension('performLint', function () {\n                    startLinting(this);\n                });\n            }));\n        },\n        { '79': 79 }\n    ],\n    76: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                CodeMirror.registerHelper('lint', 'json', function (text) {\n                    var found = [];\n                    if (!window.jsonlint) {\n                        if (window.console) {\n                            window.console.error('Error: window.jsonlint not defined, CodeMirror JSON linting cannot run.');\n                        }\n                        return found;\n                    }\n                    var jsonlint = window.jsonlint.parser || window.jsonlint;\n                    jsonlint.parseError = function (str, hash) {\n                        var loc = hash.loc;\n                        found.push({\n                            from: CodeMirror.Pos(loc.first_line - 1, loc.first_column),\n                            to: CodeMirror.Pos(loc.last_line - 1, loc.last_column),\n                            message: str\n                        });\n                    };\n                    try {\n                        jsonlint.parse(text);\n                    } catch (e) {\n                    }\n                    return found;\n                });\n            }));\n        },\n        { '79': 79 }\n    ],\n    75: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                function validator(text, options) {\n                    if (!window.JSHINT) {\n                        if (window.console) {\n                            window.console.error('Error: window.JSHINT not defined, CodeMirror JavaScript linting cannot run.');\n                        }\n                        return [];\n                    }\n                    if (!options.indent)\n                        options.indent = 1;\n                    JSHINT(text, options, options.globals);\n                    var errors = JSHINT.data().errors, result = [];\n                    if (errors)\n                        parseErrors(errors, result);\n                    return result;\n                }\n                CodeMirror.registerHelper('lint', 'javascript', validator);\n                function parseErrors(errors, output) {\n                    for (var i = 0; i < errors.length; i++) {\n                        var error = errors[i];\n                        if (error) {\n                            if (error.line <= 0) {\n                                if (window.console) {\n                                    window.console.warn('Cannot display JSHint error (invalid line ' + error.line + ')', error);\n                                }\n                                continue;\n                            }\n                            var start = error.character - 1, end = start + 1;\n                            if (error.evidence) {\n                                var index = error.evidence.substring(start).search(/.\\b/);\n                                if (index > -1) {\n                                    end += index;\n                                }\n                            }\n                            var hint = {\n                                message: error.reason,\n                                severity: error.code ? error.code.startsWith('W') ? 'warning' : 'error' : 'error',\n                                from: CodeMirror.Pos(error.line - 1, start),\n                                to: CodeMirror.Pos(error.line - 1, end)\n                            };\n                            output.push(hint);\n                        }\n                    }\n                }\n            }));\n        },\n        { '79': 79 }\n    ],\n    74: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79), require(122));\n                else if (typeof define == 'function' && define.amd)\n                    define([\n                        '../../lib/codemirror',\n                        'htmlhint'\n                    ], mod);\n                else\n                    mod(CodeMirror, window.HTMLHint);\n            }(function (CodeMirror, HTMLHint) {\n                'use strict';\n                var defaultRules = {\n                    'tagname-lowercase': true,\n                    'attr-lowercase': true,\n                    'attr-value-double-quotes': true,\n                    'doctype-first': false,\n                    'tag-pair': true,\n                    'spec-char-escape': true,\n                    'id-unique': true,\n                    'src-not-empty': true,\n                    'attr-no-duplication': true\n                };\n                CodeMirror.registerHelper('lint', 'html', function (text, options) {\n                    var found = [];\n                    if (HTMLHint && !HTMLHint.verify) {\n                        if (typeof HTMLHint.default !== 'undefined') {\n                            HTMLHint = HTMLHint.default;\n                        } else {\n                            HTMLHint = HTMLHint.HTMLHint;\n                        }\n                    }\n                    if (!HTMLHint)\n                        HTMLHint = window.HTMLHint;\n                    if (!HTMLHint) {\n                        if (window.console) {\n                            window.console.error('Error: HTMLHint not found, not defined on window, or not available through define/require, CodeMirror HTML linting cannot run.');\n                        }\n                        return found;\n                    }\n                    var messages = HTMLHint.verify(text, options && options.rules || defaultRules);\n                    for (var i = 0; i < messages.length; i++) {\n                        var message = messages[i];\n                        var startLine = message.line - 1, endLine = message.line - 1, startCol = message.col - 1, endCol = message.col;\n                        found.push({\n                            from: CodeMirror.Pos(startLine, startCol),\n                            to: CodeMirror.Pos(endLine, endCol),\n                            message: message.message,\n                            severity: message.type\n                        });\n                    }\n                    return found;\n                });\n            }));\n        },\n        {\n            '122': 122,\n            '79': 79\n        }\n    ],\n    122: [\n        function (require, module, exports) {\n            (function (global, factory) {\n                typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.HTMLHint = factory());\n            }(this, function () {\n                'use strict';\n                function getDefaultExportFromCjs(x) {\n                    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n                }\n                var core$1 = {};\n                var htmlparser = {};\n                Object.defineProperty(htmlparser, '__esModule', { value: true });\n                class HTMLParser {\n                    constructor() {\n                        this._listeners = {};\n                        this._mapCdataTags = this.makeMap('script,style');\n                        this._arrBlocks = [];\n                        this.lastEvent = null;\n                    }\n                    makeMap(str) {\n                        const obj = {};\n                        const items = str.split(',');\n                        for (let i = 0; i < items.length; i++) {\n                            obj[items[i]] = true;\n                        }\n                        return obj;\n                    }\n                    parse(html) {\n                        const mapCdataTags = this._mapCdataTags;\n                        const regTag = /<(?:\\/([^\\s>]+)\\s*|!--([\\s\\S]*?)--|!([^>]*?)|([\\w\\-:]+)((?:\\s+[^\\s\"'>\\/=\\x00-\\x0F\\x7F\\x80-\\x9F]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'>]*))?)*?)\\s*(\\/?))>/g;\n                        const regAttr = /\\s*([^\\s\"'>\\/=\\x00-\\x0F\\x7F\\x80-\\x9F]+)(?:\\s*=\\s*(?:(\")([^\"]*)\"|(')([^']*)'|([^\\s\"'>]*)))?/g;\n                        const regLine = /\\r?\\n/g;\n                        let match;\n                        let matchIndex;\n                        let lastIndex = 0;\n                        let tagName;\n                        let arrAttrs;\n                        let tagCDATA = null;\n                        let attrsCDATA;\n                        let arrCDATA = [];\n                        let lastCDATAIndex = 0;\n                        let text;\n                        let lastLineIndex = 0;\n                        let line = 1;\n                        const arrBlocks = this._arrBlocks;\n                        this.fire('start', {\n                            pos: 0,\n                            line: 1,\n                            col: 1\n                        });\n                        const isMapCdataTagsRequired = () => {\n                            const attrType = arrAttrs.find(attr => attr.name === 'type') || { value: '' };\n                            return mapCdataTags[tagName] && attrType.value.indexOf('text/ng-template') === -1;\n                        };\n                        const saveBlock = (type, raw, pos, data) => {\n                            const col = pos - lastLineIndex + 1;\n                            if (data === undefined) {\n                                data = {};\n                            }\n                            data.raw = raw;\n                            data.pos = pos;\n                            data.line = line;\n                            data.col = col;\n                            arrBlocks.push(data);\n                            this.fire(type, data);\n                            while (regLine.exec(raw)) {\n                                line++;\n                                lastLineIndex = pos + regLine.lastIndex;\n                            }\n                        };\n                        while (match = regTag.exec(html)) {\n                            matchIndex = match.index;\n                            if (matchIndex > lastIndex) {\n                                text = html.substring(lastIndex, matchIndex);\n                                if (tagCDATA) {\n                                    arrCDATA.push(text);\n                                } else {\n                                    saveBlock('text', text, lastIndex);\n                                }\n                            }\n                            lastIndex = regTag.lastIndex;\n                            if (tagName = match[1]) {\n                                if (tagCDATA && tagName === tagCDATA) {\n                                    text = arrCDATA.join('');\n                                    saveBlock('cdata', text, lastCDATAIndex, {\n                                        tagName: tagCDATA,\n                                        attrs: attrsCDATA\n                                    });\n                                    tagCDATA = null;\n                                    attrsCDATA = undefined;\n                                    arrCDATA = [];\n                                }\n                                if (!tagCDATA) {\n                                    saveBlock('tagend', match[0], matchIndex, { tagName: tagName });\n                                    continue;\n                                }\n                            }\n                            if (tagCDATA) {\n                                arrCDATA.push(match[0]);\n                            } else {\n                                if (tagName = match[4]) {\n                                    arrAttrs = [];\n                                    const attrs = match[5];\n                                    let attrMatch;\n                                    let attrMatchCount = 0;\n                                    while (attrMatch = regAttr.exec(attrs)) {\n                                        const name = attrMatch[1];\n                                        const quote = attrMatch[2] ? attrMatch[2] : attrMatch[4] ? attrMatch[4] : '';\n                                        const value = attrMatch[3] ? attrMatch[3] : attrMatch[5] ? attrMatch[5] : attrMatch[6] ? attrMatch[6] : '';\n                                        arrAttrs.push({\n                                            name: name,\n                                            value: value,\n                                            quote: quote,\n                                            index: attrMatch.index,\n                                            raw: attrMatch[0]\n                                        });\n                                        attrMatchCount += attrMatch[0].length;\n                                    }\n                                    if (attrMatchCount === attrs.length) {\n                                        saveBlock('tagstart', match[0], matchIndex, {\n                                            tagName: tagName,\n                                            attrs: arrAttrs,\n                                            close: match[6]\n                                        });\n                                        if (isMapCdataTagsRequired()) {\n                                            tagCDATA = tagName;\n                                            attrsCDATA = arrAttrs.concat();\n                                            arrCDATA = [];\n                                            lastCDATAIndex = lastIndex;\n                                        }\n                                    } else {\n                                        saveBlock('text', match[0], matchIndex);\n                                    }\n                                } else if (match[2] || match[3]) {\n                                    saveBlock('comment', match[0], matchIndex, {\n                                        content: match[2] || match[3],\n                                        long: match[2] ? true : false\n                                    });\n                                }\n                            }\n                        }\n                        if (html.length > lastIndex) {\n                            text = html.substring(lastIndex, html.length);\n                            saveBlock('text', text, lastIndex);\n                        }\n                        this.fire('end', {\n                            pos: lastIndex,\n                            line: line,\n                            col: html.length - lastLineIndex + 1\n                        });\n                    }\n                    addListener(types, listener) {\n                        const _listeners = this._listeners;\n                        const arrTypes = types.split(/[,\\s]/);\n                        let type;\n                        for (let i = 0, l = arrTypes.length; i < l; i++) {\n                            type = arrTypes[i];\n                            if (_listeners[type] === undefined) {\n                                _listeners[type] = [];\n                            }\n                            _listeners[type].push(listener);\n                        }\n                    }\n                    fire(type, data) {\n                        if (data === undefined) {\n                            data = {};\n                        }\n                        data.type = type;\n                        let listeners = [];\n                        const listenersType = this._listeners[type];\n                        const listenersAll = this._listeners['all'];\n                        if (listenersType !== undefined) {\n                            listeners = listeners.concat(listenersType);\n                        }\n                        if (listenersAll !== undefined) {\n                            listeners = listeners.concat(listenersAll);\n                        }\n                        const lastEvent = this.lastEvent;\n                        if (lastEvent !== null) {\n                            delete lastEvent['lastEvent'];\n                            data.lastEvent = lastEvent;\n                        }\n                        this.lastEvent = data;\n                        for (let i = 0, l = listeners.length; i < l; i++) {\n                            listeners[i].call(this, data);\n                        }\n                    }\n                    removeListener(type, listener) {\n                        const listenersType = this._listeners[type];\n                        if (listenersType !== undefined) {\n                            for (let i = 0, l = listenersType.length; i < l; i++) {\n                                if (listenersType[i] === listener) {\n                                    listenersType.splice(i, 1);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    fixPos(event, index) {\n                        const text = event.raw.substr(0, index);\n                        const arrLines = text.split(/\\r?\\n/);\n                        const lineCount = arrLines.length - 1;\n                        let line = event.line;\n                        let col;\n                        if (lineCount > 0) {\n                            line += lineCount;\n                            col = arrLines[lineCount].length + 1;\n                        } else {\n                            col = event.col + index;\n                        }\n                        return {\n                            line: line,\n                            col: col\n                        };\n                    }\n                    getMapAttrs(arrAttrs) {\n                        const mapAttrs = {};\n                        let attr;\n                        for (let i = 0, l = arrAttrs.length; i < l; i++) {\n                            attr = arrAttrs[i];\n                            mapAttrs[attr.name] = attr.value;\n                        }\n                        return mapAttrs;\n                    }\n                }\n                htmlparser.default = HTMLParser;\n                var reporter = {};\n                Object.defineProperty(reporter, '__esModule', { value: true });\n                class Reporter {\n                    constructor(html, ruleset) {\n                        this.html = html;\n                        this.lines = html.split(/\\r?\\n/);\n                        const match = /\\r?\\n/.exec(html);\n                        this.brLen = match !== null ? match[0].length : 0;\n                        this.ruleset = ruleset;\n                        this.messages = [];\n                    }\n                    info(message, line, col, rule, raw) {\n                        this.report('info', message, line, col, rule, raw);\n                    }\n                    warn(message, line, col, rule, raw) {\n                        this.report('warning', message, line, col, rule, raw);\n                    }\n                    error(message, line, col, rule, raw) {\n                        this.report('error', message, line, col, rule, raw);\n                    }\n                    report(type, message, line, col, rule, raw) {\n                        const lines = this.lines;\n                        const brLen = this.brLen;\n                        let evidence = '';\n                        let evidenceLen = 0;\n                        for (let i = line - 1, lineCount = lines.length; i < lineCount; i++) {\n                            evidence = lines[i];\n                            evidenceLen = evidence.length;\n                            if (col > evidenceLen && line < lineCount) {\n                                line++;\n                                col -= evidenceLen;\n                                if (col !== 1) {\n                                    col -= brLen;\n                                }\n                            } else {\n                                break;\n                            }\n                        }\n                        this.messages.push({\n                            type: type,\n                            message: message,\n                            raw: raw,\n                            evidence: evidence,\n                            line: line,\n                            col: col,\n                            rule: {\n                                id: rule.id,\n                                description: rule.description,\n                                link: `https://htmlhint.com/docs/user-guide/rules/${ rule.id }`\n                            }\n                        });\n                    }\n                }\n                reporter.default = Reporter;\n                var rules = {};\n                var altRequire = {};\n                Object.defineProperty(altRequire, '__esModule', { value: true });\n                altRequire.default = {\n                    id: 'alt-require',\n                    description: 'The alt attribute of an <img> element must be present and alt attribute of area[href] and input[type=image] must have a value.',\n                    init(parser, reporter) {\n                        parser.addListener('tagstart', event => {\n                            const tagName = event.tagName.toLowerCase();\n                            const mapAttrs = parser.getMapAttrs(event.attrs);\n                            const col = event.col + tagName.length + 1;\n                            let selector;\n                            if (tagName === 'img' && !('alt' in mapAttrs)) {\n                                reporter.warn('An alt attribute must be present on <img> elements.', event.line, col, this, event.raw);\n                            } else if (tagName === 'area' && 'href' in mapAttrs || tagName === 'input' && mapAttrs['type'] === 'image') {\n                                if (!('alt' in mapAttrs) || mapAttrs['alt'] === '') {\n                                    selector = tagName === 'area' ? 'area[href]' : 'input[type=image]';\n                                    reporter.warn(`The alt attribute of ${ selector } must have a value.`, event.line, col, this, event.raw);\n                                }\n                            }\n                        });\n                    }\n                };\n                var attrLowercase = {};\n                Object.defineProperty(attrLowercase, '__esModule', { value: true });\n                const svgIgnores = [\n                    'allowReorder',\n                    'attributeName',\n                    'attributeType',\n                    'autoReverse',\n                    'baseFrequency',\n                    'baseProfile',\n                    'calcMode',\n                    'clipPath',\n                    'clipPathUnits',\n                    'contentScriptType',\n                    'contentStyleType',\n                    'diffuseConstant',\n                    'edgeMode',\n                    'externalResourcesRequired',\n                    'filterRes',\n                    'filterUnits',\n                    'glyphRef',\n                    'gradientTransform',\n                    'gradientUnits',\n                    'kernelMatrix',\n                    'kernelUnitLength',\n                    'keyPoints',\n                    'keySplines',\n                    'keyTimes',\n                    'lengthAdjust',\n                    'limitingConeAngle',\n                    'markerHeight',\n                    'markerUnits',\n                    'markerWidth',\n                    'maskContentUnits',\n                    'maskUnits',\n                    'numOctaves',\n                    'onBlur',\n                    'onChange',\n                    'onClick',\n                    'onFocus',\n                    'onKeyUp',\n                    'onLoad',\n                    'pathLength',\n                    'patternContentUnits',\n                    'patternTransform',\n                    'patternUnits',\n                    'pointsAtX',\n                    'pointsAtY',\n                    'pointsAtZ',\n                    'preserveAlpha',\n                    'preserveAspectRatio',\n                    'primitiveUnits',\n                    'refX',\n                    'refY',\n                    'repeatCount',\n                    'repeatDur',\n                    'requiredExtensions',\n                    'requiredFeatures',\n                    'specularConstant',\n                    'specularExponent',\n                    'spreadMethod',\n                    'startOffset',\n                    'stdDeviation',\n                    'stitchTiles',\n                    'surfaceScale',\n                    'systemLanguage',\n                    'tableValues',\n                    'targetX',\n                    'targetY',\n                    'textLength',\n                    'viewBox',\n                    'viewTarget',\n                    'xChannelSelector',\n                    'yChannelSelector',\n                    'zoomAndPan'\n                ];\n                function testAgainstStringOrRegExp(value, comparison) {\n                    if (comparison instanceof RegExp) {\n                        return comparison.test(value) ? {\n                            match: value,\n                            pattern: comparison\n                        } : false;\n                    }\n                    const firstComparisonChar = comparison[0];\n                    const lastComparisonChar = comparison[comparison.length - 1];\n                    const secondToLastComparisonChar = comparison[comparison.length - 2];\n                    const comparisonIsRegex = firstComparisonChar === '/' && (lastComparisonChar === '/' || secondToLastComparisonChar === '/' && lastComparisonChar === 'i');\n                    const hasCaseInsensitiveFlag = comparisonIsRegex && lastComparisonChar === 'i';\n                    if (comparisonIsRegex) {\n                        const valueMatches = hasCaseInsensitiveFlag ? new RegExp(comparison.slice(1, -2), 'i').test(value) : new RegExp(comparison.slice(1, -1)).test(value);\n                        return valueMatches;\n                    }\n                    return value === comparison;\n                }\n                attrLowercase.default = {\n                    id: 'attr-lowercase',\n                    description: 'All attribute names must be in lowercase.',\n                    init(parser, reporter, options) {\n                        const exceptions = (Array.isArray(options) ? options : []).concat(svgIgnores);\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            let attr;\n                            const col = event.col + event.tagName.length + 1;\n                            for (let i = 0, l = attrs.length; i < l; i++) {\n                                attr = attrs[i];\n                                const attrName = attr.name;\n                                if (!exceptions.find(exp => testAgainstStringOrRegExp(attrName, exp)) && attrName !== attrName.toLowerCase()) {\n                                    reporter.error(`The attribute name of [ ${ attrName } ] must be in lowercase.`, event.line, col + attr.index, this, attr.raw);\n                                }\n                            }\n                        });\n                    }\n                };\n                var attrSorted = {};\n                Object.defineProperty(attrSorted, '__esModule', { value: true });\n                attrSorted.default = {\n                    id: 'attr-sorted',\n                    description: 'Attribute tags must be in proper order.',\n                    init(parser, reporter) {\n                        const orderMap = {};\n                        const sortOrder = [\n                            'class',\n                            'id',\n                            'name',\n                            'src',\n                            'for',\n                            'type',\n                            'href',\n                            'value',\n                            'title',\n                            'alt',\n                            'role'\n                        ];\n                        for (let i = 0; i < sortOrder.length; i++) {\n                            orderMap[sortOrder[i]] = i;\n                        }\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            const listOfAttributes = [];\n                            for (let i = 0; i < attrs.length; i++) {\n                                listOfAttributes.push(attrs[i].name);\n                            }\n                            const originalAttrs = JSON.stringify(listOfAttributes);\n                            listOfAttributes.sort((a, b) => {\n                                if (orderMap[a] == undefined && orderMap[b] == undefined) {\n                                    return 0;\n                                }\n                                if (orderMap[a] == undefined) {\n                                    return 1;\n                                } else if (orderMap[b] == undefined) {\n                                    return -1;\n                                }\n                                return orderMap[a] - orderMap[b] || a.localeCompare(b);\n                            });\n                            if (originalAttrs !== JSON.stringify(listOfAttributes)) {\n                                reporter.error(`Inaccurate order ${ originalAttrs } should be in hierarchy ${ JSON.stringify(listOfAttributes) } `, event.line, event.col, this, event.raw);\n                            }\n                        });\n                    }\n                };\n                var attrNoDuplication = {};\n                Object.defineProperty(attrNoDuplication, '__esModule', { value: true });\n                attrNoDuplication.default = {\n                    id: 'attr-no-duplication',\n                    description: 'Elements cannot have duplicate attributes.',\n                    init(parser, reporter) {\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            let attr;\n                            let attrName;\n                            const col = event.col + event.tagName.length + 1;\n                            const mapAttrName = {};\n                            for (let i = 0, l = attrs.length; i < l; i++) {\n                                attr = attrs[i];\n                                attrName = attr.name;\n                                if (mapAttrName[attrName] === true) {\n                                    reporter.error(`Duplicate of attribute name [ ${ attr.name } ] was found.`, event.line, col + attr.index, this, attr.raw);\n                                }\n                                mapAttrName[attrName] = true;\n                            }\n                        });\n                    }\n                };\n                var attrUnsafeChars = {};\n                Object.defineProperty(attrUnsafeChars, '__esModule', { value: true });\n                attrUnsafeChars.default = {\n                    id: 'attr-unsafe-chars',\n                    description: 'Attribute values cannot contain unsafe chars.',\n                    init(parser, reporter) {\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            let attr;\n                            const col = event.col + event.tagName.length + 1;\n                            const regUnsafe = /[\\u0000-\\u0008\\u000b\\u000c\\u000e-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/;\n                            let match;\n                            for (let i = 0, l = attrs.length; i < l; i++) {\n                                attr = attrs[i];\n                                match = regUnsafe.exec(attr.value);\n                                if (match !== null) {\n                                    const unsafeCode = escape(match[0]).replace(/%u/, '\\\\u').replace(/%/, '\\\\x');\n                                    reporter.warn(`The value of attribute [ ${ attr.name } ] cannot contain an unsafe char [ ${ unsafeCode } ].`, event.line, col + attr.index, this, attr.raw);\n                                }\n                            }\n                        });\n                    }\n                };\n                var attrValueDoubleQuotes = {};\n                Object.defineProperty(attrValueDoubleQuotes, '__esModule', { value: true });\n                attrValueDoubleQuotes.default = {\n                    id: 'attr-value-double-quotes',\n                    description: 'Attribute values must be in double quotes.',\n                    init(parser, reporter) {\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            let attr;\n                            const col = event.col + event.tagName.length + 1;\n                            for (let i = 0, l = attrs.length; i < l; i++) {\n                                attr = attrs[i];\n                                if (attr.value !== '' && attr.quote !== '\"' || attr.value === '' && attr.quote === '\\'') {\n                                    reporter.error(`The value of attribute [ ${ attr.name } ] must be in double quotes.`, event.line, col + attr.index, this, attr.raw);\n                                }\n                            }\n                        });\n                    }\n                };\n                var attrValueNotEmpty = {};\n                Object.defineProperty(attrValueNotEmpty, '__esModule', { value: true });\n                attrValueNotEmpty.default = {\n                    id: 'attr-value-not-empty',\n                    description: 'All attributes must have values.',\n                    init(parser, reporter) {\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            let attr;\n                            const col = event.col + event.tagName.length + 1;\n                            for (let i = 0, l = attrs.length; i < l; i++) {\n                                attr = attrs[i];\n                                if (attr.quote === '' && attr.value === '') {\n                                    reporter.warn(`The attribute [ ${ attr.name } ] must have a value.`, event.line, col + attr.index, this, attr.raw);\n                                }\n                            }\n                        });\n                    }\n                };\n                var attrValueSingleQuotes = {};\n                Object.defineProperty(attrValueSingleQuotes, '__esModule', { value: true });\n                attrValueSingleQuotes.default = {\n                    id: 'attr-value-single-quotes',\n                    description: 'Attribute values must be in single quotes.',\n                    init(parser, reporter) {\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            let attr;\n                            const col = event.col + event.tagName.length + 1;\n                            for (let i = 0, l = attrs.length; i < l; i++) {\n                                attr = attrs[i];\n                                if (attr.value !== '' && attr.quote !== '\\'' || attr.value === '' && attr.quote === '\"') {\n                                    reporter.error(`The value of attribute [ ${ attr.name } ] must be in single quotes.`, event.line, col + attr.index, this, attr.raw);\n                                }\n                            }\n                        });\n                    }\n                };\n                var attrWhitespace = {};\n                Object.defineProperty(attrWhitespace, '__esModule', { value: true });\n                attrWhitespace.default = {\n                    id: 'attr-whitespace',\n                    description: 'All attributes should be separated by only one space and not have leading/trailing whitespace.',\n                    init(parser, reporter, options) {\n                        const exceptions = Array.isArray(options) ? options : [];\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            let attr;\n                            const col = event.col + event.tagName.length + 1;\n                            attrs.forEach(elem => {\n                                attr = elem;\n                                const attrName = elem.name;\n                                if (exceptions.indexOf(attrName) !== -1) {\n                                    return;\n                                }\n                                if (elem.value.trim() !== elem.value) {\n                                    reporter.error(`The attributes of [ ${ attrName } ] must not have leading or trailing whitespace.`, event.line, col + attr.index, this, attr.raw);\n                                }\n                                if (elem.value.replace(/ +(?= )/g, '') !== elem.value) {\n                                    reporter.error(`The attributes of [ ${ attrName } ] must be separated by only one space.`, event.line, col + attr.index, this, attr.raw);\n                                }\n                            });\n                        });\n                    }\n                };\n                var doctypeFirst = {};\n                Object.defineProperty(doctypeFirst, '__esModule', { value: true });\n                doctypeFirst.default = {\n                    id: 'doctype-first',\n                    description: 'Doctype must be declared first.',\n                    init(parser, reporter) {\n                        const allEvent = event => {\n                            if (event.type === 'start' || event.type === 'text' && /^\\s*$/.test(event.raw)) {\n                                return;\n                            }\n                            if (event.type !== 'comment' && event.long === false || /^DOCTYPE\\s+/i.test(event.content) === false) {\n                                reporter.error('Doctype must be declared first.', event.line, event.col, this, event.raw);\n                            }\n                            parser.removeListener('all', allEvent);\n                        };\n                        parser.addListener('all', allEvent);\n                    }\n                };\n                var doctypeHtml5 = {};\n                Object.defineProperty(doctypeHtml5, '__esModule', { value: true });\n                doctypeHtml5.default = {\n                    id: 'doctype-html5',\n                    description: 'Invalid doctype. Use: \"<!DOCTYPE html>\"',\n                    init(parser, reporter) {\n                        const onComment = event => {\n                            if (event.long === false && event.content.toLowerCase() !== 'doctype html') {\n                                reporter.warn('Invalid doctype. Use: \"<!DOCTYPE html>\"', event.line, event.col, this, event.raw);\n                            }\n                        };\n                        const onTagStart = () => {\n                            parser.removeListener('comment', onComment);\n                            parser.removeListener('tagstart', onTagStart);\n                        };\n                        parser.addListener('all', onComment);\n                        parser.addListener('tagstart', onTagStart);\n                    }\n                };\n                var headScriptDisabled = {};\n                Object.defineProperty(headScriptDisabled, '__esModule', { value: true });\n                headScriptDisabled.default = {\n                    id: 'head-script-disabled',\n                    description: 'The <script> tag cannot be used in a <head> tag.',\n                    init(parser, reporter) {\n                        const reScript = /^(text\\/javascript|application\\/javascript)$/i;\n                        let isInHead = false;\n                        const onTagStart = event => {\n                            const mapAttrs = parser.getMapAttrs(event.attrs);\n                            const type = mapAttrs.type;\n                            const tagName = event.tagName.toLowerCase();\n                            if (tagName === 'head') {\n                                isInHead = true;\n                            }\n                            if (isInHead === true && tagName === 'script' && (!type || reScript.test(type) === true)) {\n                                reporter.warn('The <script> tag cannot be used in a <head> tag.', event.line, event.col, this, event.raw);\n                            }\n                        };\n                        const onTagEnd = event => {\n                            if (event.tagName.toLowerCase() === 'head') {\n                                parser.removeListener('tagstart', onTagStart);\n                                parser.removeListener('tagend', onTagEnd);\n                            }\n                        };\n                        parser.addListener('tagstart', onTagStart);\n                        parser.addListener('tagend', onTagEnd);\n                    }\n                };\n                var hrefAbsOrRel = {};\n                Object.defineProperty(hrefAbsOrRel, '__esModule', { value: true });\n                hrefAbsOrRel.default = {\n                    id: 'href-abs-or-rel',\n                    description: 'An href attribute must be either absolute or relative.',\n                    init(parser, reporter, options) {\n                        const hrefMode = options === 'abs' ? 'absolute' : 'relative';\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            let attr;\n                            const col = event.col + event.tagName.length + 1;\n                            for (let i = 0, l = attrs.length; i < l; i++) {\n                                attr = attrs[i];\n                                if (attr.name === 'href') {\n                                    if (hrefMode === 'absolute' && /^\\w+?:/.test(attr.value) === false || hrefMode === 'relative' && /^https?:\\/\\//.test(attr.value) === true) {\n                                        reporter.warn(`The value of the href attribute [ ${ attr.value } ] must be ${ hrefMode }.`, event.line, col + attr.index, this, attr.raw);\n                                    }\n                                    break;\n                                }\n                            }\n                        });\n                    }\n                };\n                var htmlLangRequire = {};\n                Object.defineProperty(htmlLangRequire, '__esModule', { value: true });\n                const regular = '(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)';\n                const irregular = '(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)';\n                const grandfathered = `(?<grandfathered>${ irregular }|${ regular })`;\n                const privateUse = '(?<privateUse>x(-[A-Za-z0-9]{1,8})+)';\n                const privateUse2 = '(?<privateUse2>x(-[A-Za-z0-9]{1,8})+)';\n                const singleton = '[0-9A-WY-Za-wy-z]';\n                const extension = `(?<extension>${ singleton }(-[A-Za-z0-9]{2,8})+)`;\n                const variant = '(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3})';\n                const region = '(?<region>[A-Za-z]{2}|[0-9]{3})';\n                const script = '(?<script>[A-Za-z]{4})';\n                const extlang = '(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2})';\n                const language = `(?<language>([A-Za-z]{2,3}(-${ extlang })?)|[A-Za-z]{4}|[A-Za-z]{5,8})`;\n                const langtag = `(${ language }(-${ script })?` + `(-${ region })?` + `(-${ variant })*` + `(-${ extension })*` + `(-${ privateUse })?` + ')';\n                const languageTag = `(${ grandfathered }|${ langtag }|${ privateUse2 })`;\n                htmlLangRequire.default = {\n                    id: 'html-lang-require',\n                    description: 'The lang attribute of an <html> element must be present and should be valid.',\n                    init(parser, reporter) {\n                        parser.addListener('tagstart', event => {\n                            const tagName = event.tagName.toLowerCase();\n                            const mapAttrs = parser.getMapAttrs(event.attrs);\n                            const col = event.col + tagName.length + 1;\n                            const langValidityPattern = new RegExp(languageTag, 'g');\n                            if (tagName === 'html') {\n                                if ('lang' in mapAttrs) {\n                                    if (!mapAttrs['lang']) {\n                                        reporter.warn('The lang attribute of <html> element must have a value.', event.line, col, this, event.raw);\n                                    } else if (!langValidityPattern.test(mapAttrs['lang'])) {\n                                        reporter.warn('The lang attribute value of <html> element must be a valid BCP47.', event.line, col, this, event.raw);\n                                    }\n                                } else {\n                                    reporter.warn('An lang attribute must be present on <html> elements.', event.line, col, this, event.raw);\n                                }\n                            }\n                        });\n                    }\n                };\n                var idClassAdDisabled = {};\n                Object.defineProperty(idClassAdDisabled, '__esModule', { value: true });\n                idClassAdDisabled.default = {\n                    id: 'id-class-ad-disabled',\n                    description: 'The id and class attributes cannot use the ad keyword, it will be blocked by adblock software.',\n                    init(parser, reporter) {\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            let attr;\n                            let attrName;\n                            const col = event.col + event.tagName.length + 1;\n                            for (let i = 0, l = attrs.length; i < l; i++) {\n                                attr = attrs[i];\n                                attrName = attr.name;\n                                if (/^(id|class)$/i.test(attrName)) {\n                                    if (/(^|[-_])ad([-_]|$)/i.test(attr.value)) {\n                                        reporter.warn(`The value of attribute ${ attrName } cannot use the ad keyword.`, event.line, col + attr.index, this, attr.raw);\n                                    }\n                                }\n                            }\n                        });\n                    }\n                };\n                var idClassValue = {};\n                Object.defineProperty(idClassValue, '__esModule', { value: true });\n                idClassValue.default = {\n                    id: 'id-class-value',\n                    description: 'The id and class attribute values must meet the specified rules.',\n                    init(parser, reporter, options) {\n                        const arrRules = {\n                            underline: {\n                                regId: /^[a-z\\d]+(_[a-z\\d]+)*$/,\n                                message: 'The id and class attribute values must be in lowercase and split by an underscore.'\n                            },\n                            dash: {\n                                regId: /^[a-z\\d]+(-[a-z\\d]+)*$/,\n                                message: 'The id and class attribute values must be in lowercase and split by a dash.'\n                            },\n                            hump: {\n                                regId: /^[a-z][a-zA-Z\\d]*([A-Z][a-zA-Z\\d]*)*$/,\n                                message: 'The id and class attribute values must meet the camelCase style.'\n                            }\n                        };\n                        let rule;\n                        if (typeof options === 'string') {\n                            rule = arrRules[options];\n                        } else {\n                            rule = options;\n                        }\n                        if (typeof rule === 'object' && rule.regId) {\n                            let regId = rule.regId;\n                            const message = rule.message;\n                            if (!(regId instanceof RegExp)) {\n                                regId = new RegExp(regId);\n                            }\n                            parser.addListener('tagstart', event => {\n                                const attrs = event.attrs;\n                                let attr;\n                                const col = event.col + event.tagName.length + 1;\n                                for (let i = 0, l1 = attrs.length; i < l1; i++) {\n                                    attr = attrs[i];\n                                    if (attr.name.toLowerCase() === 'id') {\n                                        if (regId.test(attr.value) === false) {\n                                            reporter.warn(message, event.line, col + attr.index, this, attr.raw);\n                                        }\n                                    }\n                                    if (attr.name.toLowerCase() === 'class') {\n                                        const arrClass = attr.value.split(/\\s+/g);\n                                        let classValue;\n                                        for (let j = 0, l2 = arrClass.length; j < l2; j++) {\n                                            classValue = arrClass[j];\n                                            if (classValue && regId.test(classValue) === false) {\n                                                reporter.warn(message, event.line, col + attr.index, this, classValue);\n                                            }\n                                        }\n                                    }\n                                }\n                            });\n                        }\n                    }\n                };\n                var idUnique = {};\n                Object.defineProperty(idUnique, '__esModule', { value: true });\n                idUnique.default = {\n                    id: 'id-unique',\n                    description: 'The value of id attributes must be unique.',\n                    init(parser, reporter) {\n                        const mapIdCount = {};\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            let attr;\n                            let id;\n                            const col = event.col + event.tagName.length + 1;\n                            for (let i = 0, l = attrs.length; i < l; i++) {\n                                attr = attrs[i];\n                                if (attr.name.toLowerCase() === 'id') {\n                                    id = attr.value;\n                                    if (id) {\n                                        if (mapIdCount[id] === undefined) {\n                                            mapIdCount[id] = 1;\n                                        } else {\n                                            mapIdCount[id]++;\n                                        }\n                                        if (mapIdCount[id] > 1) {\n                                            reporter.error(`The id value [ ${ id } ] must be unique.`, event.line, col + attr.index, this, attr.raw);\n                                        }\n                                    }\n                                    break;\n                                }\n                            }\n                        });\n                    }\n                };\n                var inlineScriptDisabled = {};\n                Object.defineProperty(inlineScriptDisabled, '__esModule', { value: true });\n                inlineScriptDisabled.default = {\n                    id: 'inline-script-disabled',\n                    description: 'Inline script cannot be used.',\n                    init(parser, reporter) {\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            let attr;\n                            const col = event.col + event.tagName.length + 1;\n                            let attrName;\n                            const reEvent = /^on(unload|message|submit|select|scroll|resize|mouseover|mouseout|mousemove|mouseleave|mouseenter|mousedown|load|keyup|keypress|keydown|focus|dblclick|click|change|blur|error)$/i;\n                            for (let i = 0, l = attrs.length; i < l; i++) {\n                                attr = attrs[i];\n                                attrName = attr.name.toLowerCase();\n                                if (reEvent.test(attrName) === true) {\n                                    reporter.warn(`Inline script [ ${ attr.raw } ] cannot be used.`, event.line, col + attr.index, this, attr.raw);\n                                } else if (attrName === 'src' || attrName === 'href') {\n                                    if (/^\\s*javascript:/i.test(attr.value)) {\n                                        reporter.warn(`Inline script [ ${ attr.raw } ] cannot be used.`, event.line, col + attr.index, this, attr.raw);\n                                    }\n                                }\n                            }\n                        });\n                    }\n                };\n                var inlineStyleDisabled = {};\n                Object.defineProperty(inlineStyleDisabled, '__esModule', { value: true });\n                inlineStyleDisabled.default = {\n                    id: 'inline-style-disabled',\n                    description: 'Inline style cannot be used.',\n                    init(parser, reporter) {\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            let attr;\n                            const col = event.col + event.tagName.length + 1;\n                            for (let i = 0, l = attrs.length; i < l; i++) {\n                                attr = attrs[i];\n                                if (attr.name.toLowerCase() === 'style') {\n                                    reporter.warn(`Inline style [ ${ attr.raw } ] cannot be used.`, event.line, col + attr.index, this, attr.raw);\n                                }\n                            }\n                        });\n                    }\n                };\n                var inputRequiresLabel = {};\n                Object.defineProperty(inputRequiresLabel, '__esModule', { value: true });\n                inputRequiresLabel.default = {\n                    id: 'input-requires-label',\n                    description: 'All [ input ] tags must have a corresponding [ label ] tag. ',\n                    init(parser, reporter) {\n                        const labelTags = [];\n                        const inputTags = [];\n                        parser.addListener('tagstart', event => {\n                            const tagName = event.tagName.toLowerCase();\n                            const mapAttrs = parser.getMapAttrs(event.attrs);\n                            const col = event.col + tagName.length + 1;\n                            if (tagName === 'input') {\n                                if (mapAttrs['type'] !== 'hidden') {\n                                    inputTags.push({\n                                        event: event,\n                                        col: col,\n                                        id: mapAttrs['id']\n                                    });\n                                }\n                            }\n                            if (tagName === 'label') {\n                                if ('for' in mapAttrs && mapAttrs['for'] !== '') {\n                                    labelTags.push({\n                                        event: event,\n                                        col: col,\n                                        forValue: mapAttrs['for']\n                                    });\n                                }\n                            }\n                        });\n                        parser.addListener('end', () => {\n                            inputTags.forEach(inputTag => {\n                                if (!hasMatchingLabelTag(inputTag)) {\n                                    reporter.warn('No matching [ label ] tag found.', inputTag.event.line, inputTag.col, this, inputTag.event.raw);\n                                }\n                            });\n                        });\n                        function hasMatchingLabelTag(inputTag) {\n                            let found = false;\n                            labelTags.forEach(labelTag => {\n                                if (inputTag.id && inputTag.id === labelTag.forValue) {\n                                    found = true;\n                                }\n                            });\n                            return found;\n                        }\n                    }\n                };\n                var scriptDisabled = {};\n                Object.defineProperty(scriptDisabled, '__esModule', { value: true });\n                scriptDisabled.default = {\n                    id: 'script-disabled',\n                    description: 'The <script> tag cannot be used.',\n                    init(parser, reporter) {\n                        parser.addListener('tagstart', event => {\n                            if (event.tagName.toLowerCase() === 'script') {\n                                reporter.error('The <script> tag cannot be used.', event.line, event.col, this, event.raw);\n                            }\n                        });\n                    }\n                };\n                var spaceTabMixedDisabled = {};\n                Object.defineProperty(spaceTabMixedDisabled, '__esModule', { value: true });\n                spaceTabMixedDisabled.default = {\n                    id: 'space-tab-mixed-disabled',\n                    description: 'Do not mix tabs and spaces for indentation.',\n                    init(parser, reporter, options) {\n                        let indentMode = 'nomix';\n                        let spaceLengthRequire = null;\n                        if (typeof options === 'string') {\n                            const match = /^([a-z]+)(\\d+)?/.exec(options);\n                            if (match) {\n                                indentMode = match[1];\n                                spaceLengthRequire = match[2] && parseInt(match[2], 10);\n                            }\n                        }\n                        parser.addListener('text', event => {\n                            const raw = event.raw;\n                            const reMixed = /(^|\\r?\\n)([ \\t]+)/g;\n                            let match;\n                            while (match = reMixed.exec(raw)) {\n                                const fixedPos = parser.fixPos(event, match.index + match[1].length);\n                                if (fixedPos.col !== 1) {\n                                    continue;\n                                }\n                                const whiteSpace = match[2];\n                                if (indentMode === 'space') {\n                                    if (spaceLengthRequire) {\n                                        if (/^ +$/.test(whiteSpace) === false || whiteSpace.length % spaceLengthRequire !== 0) {\n                                            reporter.warn(`Please use space for indentation and keep ${ spaceLengthRequire } length.`, fixedPos.line, 1, this, event.raw);\n                                        }\n                                    } else {\n                                        if (/^ +$/.test(whiteSpace) === false) {\n                                            reporter.warn('Please use space for indentation.', fixedPos.line, 1, this, event.raw);\n                                        }\n                                    }\n                                } else if (indentMode === 'tab' && /^\\t+$/.test(whiteSpace) === false) {\n                                    reporter.warn('Please use tab for indentation.', fixedPos.line, 1, this, event.raw);\n                                } else if (/ +\\t|\\t+ /.test(whiteSpace) === true) {\n                                    reporter.warn('Do not mix tabs and spaces for indentation.', fixedPos.line, 1, this, event.raw);\n                                }\n                            }\n                        });\n                    }\n                };\n                var specCharEscape = {};\n                Object.defineProperty(specCharEscape, '__esModule', { value: true });\n                specCharEscape.default = {\n                    id: 'spec-char-escape',\n                    description: 'Special characters must be escaped.',\n                    init(parser, reporter) {\n                        parser.addListener('text', event => {\n                            const raw = event.raw;\n                            const reSpecChar = /([<>])|( \\& )/g;\n                            let match;\n                            while (match = reSpecChar.exec(raw)) {\n                                const fixedPos = parser.fixPos(event, match.index);\n                                reporter.error(`Special characters must be escaped : [ ${ match[0] } ].`, fixedPos.line, fixedPos.col, this, event.raw);\n                            }\n                        });\n                    }\n                };\n                var srcNotEmpty = {};\n                Object.defineProperty(srcNotEmpty, '__esModule', { value: true });\n                srcNotEmpty.default = {\n                    id: 'src-not-empty',\n                    description: 'The src attribute of an img(script,link) must have a value.',\n                    init(parser, reporter) {\n                        parser.addListener('tagstart', event => {\n                            const tagName = event.tagName;\n                            const attrs = event.attrs;\n                            let attr;\n                            const col = event.col + tagName.length + 1;\n                            for (let i = 0, l = attrs.length; i < l; i++) {\n                                attr = attrs[i];\n                                if ((/^(img|script|embed|bgsound|iframe)$/.test(tagName) === true && attr.name === 'src' || tagName === 'link' && attr.name === 'href' || tagName === 'object' && attr.name === 'data') && attr.value === '') {\n                                    reporter.error(`The attribute [ ${ attr.name } ] of the tag [ ${ tagName } ] must have a value.`, event.line, col + attr.index, this, attr.raw);\n                                }\n                            }\n                        });\n                    }\n                };\n                var styleDisabled = {};\n                Object.defineProperty(styleDisabled, '__esModule', { value: true });\n                styleDisabled.default = {\n                    id: 'style-disabled',\n                    description: '<style> tags cannot be used.',\n                    init(parser, reporter) {\n                        parser.addListener('tagstart', event => {\n                            if (event.tagName.toLowerCase() === 'style') {\n                                reporter.warn('The <style> tag cannot be used.', event.line, event.col, this, event.raw);\n                            }\n                        });\n                    }\n                };\n                var tagPair = {};\n                Object.defineProperty(tagPair, '__esModule', { value: true });\n                tagPair.default = {\n                    id: 'tag-pair',\n                    description: 'Tag must be paired.',\n                    init(parser, reporter) {\n                        const stack = [];\n                        const mapEmptyTags = parser.makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,track,command,source,keygen,wbr');\n                        parser.addListener('tagstart', event => {\n                            const tagName = event.tagName.toLowerCase();\n                            if (mapEmptyTags[tagName] === undefined && !event.close) {\n                                stack.push({\n                                    tagName: tagName,\n                                    line: event.line,\n                                    raw: event.raw\n                                });\n                            }\n                        });\n                        parser.addListener('tagend', event => {\n                            const tagName = event.tagName.toLowerCase();\n                            let pos;\n                            for (pos = stack.length - 1; pos >= 0; pos--) {\n                                if (stack[pos].tagName === tagName) {\n                                    break;\n                                }\n                            }\n                            if (pos >= 0) {\n                                const arrTags = [];\n                                for (let i = stack.length - 1; i > pos; i--) {\n                                    arrTags.push(`</${ stack[i].tagName }>`);\n                                }\n                                if (arrTags.length > 0) {\n                                    const lastEvent = stack[stack.length - 1];\n                                    reporter.error(`Tag must be paired, missing: [ ${ arrTags.join('') } ], start tag match failed [ ${ lastEvent.raw } ] on line ${ lastEvent.line }.`, event.line, event.col, this, event.raw);\n                                }\n                                stack.length = pos;\n                            } else {\n                                reporter.error(`Tag must be paired, no start tag: [ ${ event.raw } ]`, event.line, event.col, this, event.raw);\n                            }\n                        });\n                        parser.addListener('end', event => {\n                            const arrTags = [];\n                            for (let i = stack.length - 1; i >= 0; i--) {\n                                arrTags.push(`</${ stack[i].tagName }>`);\n                            }\n                            if (arrTags.length > 0) {\n                                const lastEvent = stack[stack.length - 1];\n                                reporter.error(`Tag must be paired, missing: [ ${ arrTags.join('') } ], open tag match failed [ ${ lastEvent.raw } ] on line ${ lastEvent.line }.`, event.line, event.col, this, '');\n                            }\n                        });\n                    }\n                };\n                var tagSelfClose = {};\n                Object.defineProperty(tagSelfClose, '__esModule', { value: true });\n                tagSelfClose.default = {\n                    id: 'tag-self-close',\n                    description: 'Empty tags must be self closed.',\n                    init(parser, reporter) {\n                        const mapEmptyTags = parser.makeMap('area,base,basefont,bgsound,br,col,frame,hr,img,input,isindex,link,meta,param,embed,track,command,source,keygen,wbr');\n                        parser.addListener('tagstart', event => {\n                            const tagName = event.tagName.toLowerCase();\n                            if (mapEmptyTags[tagName] !== undefined) {\n                                if (!event.close) {\n                                    reporter.warn(`The empty tag : [ ${ tagName } ] must be self closed.`, event.line, event.col, this, event.raw);\n                                }\n                            }\n                        });\n                    }\n                };\n                var emptyTagNotSelfClosed = {};\n                Object.defineProperty(emptyTagNotSelfClosed, '__esModule', { value: true });\n                emptyTagNotSelfClosed.default = {\n                    id: 'empty-tag-not-self-closed',\n                    description: 'Empty tags must not use self closed syntax.',\n                    init(parser, reporter) {\n                        const mapEmptyTags = parser.makeMap('area,base,basefont,bgsound,br,col,frame,hr,img,input,isindex,link,meta,param,embed,track,command,source,keygen,wbr');\n                        parser.addListener('tagstart', event => {\n                            const tagName = event.tagName.toLowerCase();\n                            if (mapEmptyTags[tagName] !== undefined) {\n                                if (event.close) {\n                                    reporter.error(`The empty tag : [ ${ tagName } ] must not use self closed syntax.`, event.line, event.col, this, event.raw);\n                                }\n                            }\n                        });\n                    }\n                };\n                var tagnameLowercase = {};\n                Object.defineProperty(tagnameLowercase, '__esModule', { value: true });\n                tagnameLowercase.default = {\n                    id: 'tagname-lowercase',\n                    description: 'All html element names must be in lowercase.',\n                    init(parser, reporter, options) {\n                        const exceptions = Array.isArray(options) ? options : [];\n                        parser.addListener('tagstart,tagend', event => {\n                            const tagName = event.tagName;\n                            if (exceptions.indexOf(tagName) === -1 && tagName !== tagName.toLowerCase()) {\n                                reporter.error(`The html element name of [ ${ tagName } ] must be in lowercase.`, event.line, event.col, this, event.raw);\n                            }\n                        });\n                    }\n                };\n                var tagnameSpecialchars = {};\n                Object.defineProperty(tagnameSpecialchars, '__esModule', { value: true });\n                tagnameSpecialchars.default = {\n                    id: 'tagname-specialchars',\n                    description: 'All special characters must be escaped.',\n                    init(parser, reporter) {\n                        const specialchars = /[^a-zA-Z0-9\\-:_]/;\n                        parser.addListener('tagstart,tagend', event => {\n                            const tagName = event.tagName;\n                            if (specialchars.test(tagName)) {\n                                reporter.error(`The html element name of [ ${ tagName } ] contains special character.`, event.line, event.col, this, event.raw);\n                            }\n                        });\n                    }\n                };\n                var titleRequire = {};\n                Object.defineProperty(titleRequire, '__esModule', { value: true });\n                titleRequire.default = {\n                    id: 'title-require',\n                    description: '<title> must be present in <head> tag.',\n                    init(parser, reporter) {\n                        let headBegin = false;\n                        let hasTitle = false;\n                        const onTagStart = event => {\n                            const tagName = event.tagName.toLowerCase();\n                            if (tagName === 'head') {\n                                headBegin = true;\n                            } else if (tagName === 'title' && headBegin) {\n                                hasTitle = true;\n                            }\n                        };\n                        const onTagEnd = event => {\n                            const tagName = event.tagName.toLowerCase();\n                            if (hasTitle && tagName === 'title') {\n                                const lastEvent = event.lastEvent;\n                                if (lastEvent.type !== 'text' || lastEvent.type === 'text' && /^\\s*$/.test(lastEvent.raw) === true) {\n                                    reporter.error('<title></title> must not be empty.', event.line, event.col, this, event.raw);\n                                }\n                            } else if (tagName === 'head') {\n                                if (hasTitle === false) {\n                                    reporter.error('<title> must be present in <head> tag.', event.line, event.col, this, event.raw);\n                                }\n                                parser.removeListener('tagstart', onTagStart);\n                                parser.removeListener('tagend', onTagEnd);\n                            }\n                        };\n                        parser.addListener('tagstart', onTagStart);\n                        parser.addListener('tagend', onTagEnd);\n                    }\n                };\n                var tagsCheck = {};\n                Object.defineProperty(tagsCheck, '__esModule', { value: true });\n                let tagsTypings = {\n                    a: {\n                        selfclosing: false,\n                        attrsRequired: [\n                            'href',\n                            'title'\n                        ],\n                        redundantAttrs: ['alt']\n                    },\n                    div: { selfclosing: false },\n                    main: {\n                        selfclosing: false,\n                        redundantAttrs: ['role']\n                    },\n                    nav: {\n                        selfclosing: false,\n                        redundantAttrs: ['role']\n                    },\n                    script: {\n                        attrsOptional: [\n                            [\n                                'async',\n                                'async'\n                            ],\n                            [\n                                'defer',\n                                'defer'\n                            ]\n                        ]\n                    },\n                    img: {\n                        selfclosing: true,\n                        attrsRequired: [\n                            'src',\n                            'alt',\n                            'title'\n                        ]\n                    }\n                };\n                tagsCheck.default = {\n                    id: 'tags-check',\n                    description: 'Checks html tags.',\n                    init(parser, reporter, options) {\n                        tagsTypings = Object.assign(Object.assign({}, tagsTypings), options);\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            const col = event.col + event.tagName.length + 1;\n                            const tagName = event.tagName.toLowerCase();\n                            if (tagsTypings[tagName]) {\n                                const currentTagType = tagsTypings[tagName];\n                                if (currentTagType.selfclosing === true && !event.close) {\n                                    reporter.warn(`The <${ tagName }> tag must be selfclosing.`, event.line, event.col, this, event.raw);\n                                } else if (currentTagType.selfclosing === false && event.close) {\n                                    reporter.warn(`The <${ tagName }> tag must not be selfclosing.`, event.line, event.col, this, event.raw);\n                                }\n                                if (Array.isArray(currentTagType.attrsRequired)) {\n                                    const attrsRequired = currentTagType.attrsRequired;\n                                    attrsRequired.forEach(id => {\n                                        if (Array.isArray(id)) {\n                                            const copyOfId = id.map(a => a);\n                                            const realID = copyOfId.shift();\n                                            const values = copyOfId;\n                                            if (attrs.some(attr => attr.name === realID)) {\n                                                attrs.forEach(attr => {\n                                                    if (attr.name === realID && values.indexOf(attr.value) === -1) {\n                                                        reporter.error(`The <${ tagName }> tag must have attr '${ realID }' with one value of '${ values.join('\\' or \\'') }'.`, event.line, col, this, event.raw);\n                                                    }\n                                                });\n                                            } else {\n                                                reporter.error(`The <${ tagName }> tag must have attr '${ realID }'.`, event.line, col, this, event.raw);\n                                            }\n                                        } else if (!attrs.some(attr => id.split('|').indexOf(attr.name) !== -1)) {\n                                            reporter.error(`The <${ tagName }> tag must have attr '${ id }'.`, event.line, col, this, event.raw);\n                                        }\n                                    });\n                                }\n                                if (Array.isArray(currentTagType.attrsOptional)) {\n                                    const attrsOptional = currentTagType.attrsOptional;\n                                    attrsOptional.forEach(id => {\n                                        if (Array.isArray(id)) {\n                                            const copyOfId = id.map(a => a);\n                                            const realID = copyOfId.shift();\n                                            const values = copyOfId;\n                                            if (attrs.some(attr => attr.name === realID)) {\n                                                attrs.forEach(attr => {\n                                                    if (attr.name === realID && values.indexOf(attr.value) === -1) {\n                                                        reporter.error(`The <${ tagName }> tag must have optional attr '${ realID }' with one value of '${ values.join('\\' or \\'') }'.`, event.line, col, this, event.raw);\n                                                    }\n                                                });\n                                            }\n                                        }\n                                    });\n                                }\n                                if (Array.isArray(currentTagType.redundantAttrs)) {\n                                    const redundantAttrs = currentTagType.redundantAttrs;\n                                    redundantAttrs.forEach(attrName => {\n                                        if (attrs.some(attr => attr.name === attrName)) {\n                                            reporter.error(`The attr '${ attrName }' is redundant for <${ tagName }> and should be omitted.`, event.line, col, this, event.raw);\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    }\n                };\n                var attrNoUnnecessaryWhitespace = {};\n                Object.defineProperty(attrNoUnnecessaryWhitespace, '__esModule', { value: true });\n                attrNoUnnecessaryWhitespace.default = {\n                    id: 'attr-no-unnecessary-whitespace',\n                    description: 'No spaces between attribute names and values.',\n                    init(parser, reporter, options) {\n                        const exceptions = Array.isArray(options) ? options : [];\n                        parser.addListener('tagstart', event => {\n                            const attrs = event.attrs;\n                            const col = event.col + event.tagName.length + 1;\n                            for (let i = 0; i < attrs.length; i++) {\n                                if (exceptions.indexOf(attrs[i].name) === -1) {\n                                    const match = /(\\s*)=(\\s*)/.exec(attrs[i].raw.trim());\n                                    if (match && (match[1].length !== 0 || match[2].length !== 0)) {\n                                        reporter.error(`The attribute '${ attrs[i].name }' must not have spaces between the name and value.`, event.line, col + attrs[i].index, this, attrs[i].raw);\n                                    }\n                                }\n                            }\n                        });\n                    }\n                };\n                (function (exports) {\n                    Object.defineProperty(exports, '__esModule', { value: true });\n                    exports.attrNoUnnecessaryWhitespace = exports.tagsCheck = exports.titleRequire = exports.tagnameSpecialChars = exports.tagnameLowercase = exports.emptyTagNotSelfClosed = exports.tagSelfClose = exports.tagPair = exports.styleDisabled = exports.srcNotEmpty = exports.specCharEscape = exports.spaceTabMixedDisabled = exports.scriptDisabled = exports.inputRequiresLabel = exports.inlineStyleDisabled = exports.inlineScriptDisabled = exports.idUnique = exports.idClassValue = exports.idClsasAdDisabled = exports.htmlLangRequire = exports.hrefAbsOrRel = exports.headScriptDisabled = exports.doctypeHTML5 = exports.doctypeFirst = exports.attrWhitespace = exports.attrValueSingleQuotes = exports.attrValueNotEmpty = exports.attrValueDoubleQuotes = exports.attrUnsafeChars = exports.attrNoDuplication = exports.attrSort = exports.attrLowercase = exports.altRequire = void 0;\n                    var alt_require_1 = altRequire;\n                    Object.defineProperty(exports, 'altRequire', {\n                        enumerable: true,\n                        get: function () {\n                            return alt_require_1.default;\n                        }\n                    });\n                    var attr_lowercase_1 = attrLowercase;\n                    Object.defineProperty(exports, 'attrLowercase', {\n                        enumerable: true,\n                        get: function () {\n                            return attr_lowercase_1.default;\n                        }\n                    });\n                    var attr_sorted_1 = attrSorted;\n                    Object.defineProperty(exports, 'attrSort', {\n                        enumerable: true,\n                        get: function () {\n                            return attr_sorted_1.default;\n                        }\n                    });\n                    var attr_no_duplication_1 = attrNoDuplication;\n                    Object.defineProperty(exports, 'attrNoDuplication', {\n                        enumerable: true,\n                        get: function () {\n                            return attr_no_duplication_1.default;\n                        }\n                    });\n                    var attr_unsafe_chars_1 = attrUnsafeChars;\n                    Object.defineProperty(exports, 'attrUnsafeChars', {\n                        enumerable: true,\n                        get: function () {\n                            return attr_unsafe_chars_1.default;\n                        }\n                    });\n                    var attr_value_double_quotes_1 = attrValueDoubleQuotes;\n                    Object.defineProperty(exports, 'attrValueDoubleQuotes', {\n                        enumerable: true,\n                        get: function () {\n                            return attr_value_double_quotes_1.default;\n                        }\n                    });\n                    var attr_value_not_empty_1 = attrValueNotEmpty;\n                    Object.defineProperty(exports, 'attrValueNotEmpty', {\n                        enumerable: true,\n                        get: function () {\n                            return attr_value_not_empty_1.default;\n                        }\n                    });\n                    var attr_value_single_quotes_1 = attrValueSingleQuotes;\n                    Object.defineProperty(exports, 'attrValueSingleQuotes', {\n                        enumerable: true,\n                        get: function () {\n                            return attr_value_single_quotes_1.default;\n                        }\n                    });\n                    var attr_whitespace_1 = attrWhitespace;\n                    Object.defineProperty(exports, 'attrWhitespace', {\n                        enumerable: true,\n                        get: function () {\n                            return attr_whitespace_1.default;\n                        }\n                    });\n                    var doctype_first_1 = doctypeFirst;\n                    Object.defineProperty(exports, 'doctypeFirst', {\n                        enumerable: true,\n                        get: function () {\n                            return doctype_first_1.default;\n                        }\n                    });\n                    var doctype_html5_1 = doctypeHtml5;\n                    Object.defineProperty(exports, 'doctypeHTML5', {\n                        enumerable: true,\n                        get: function () {\n                            return doctype_html5_1.default;\n                        }\n                    });\n                    var head_script_disabled_1 = headScriptDisabled;\n                    Object.defineProperty(exports, 'headScriptDisabled', {\n                        enumerable: true,\n                        get: function () {\n                            return head_script_disabled_1.default;\n                        }\n                    });\n                    var href_abs_or_rel_1 = hrefAbsOrRel;\n                    Object.defineProperty(exports, 'hrefAbsOrRel', {\n                        enumerable: true,\n                        get: function () {\n                            return href_abs_or_rel_1.default;\n                        }\n                    });\n                    var html_lang_require_1 = htmlLangRequire;\n                    Object.defineProperty(exports, 'htmlLangRequire', {\n                        enumerable: true,\n                        get: function () {\n                            return html_lang_require_1.default;\n                        }\n                    });\n                    var id_class_ad_disabled_1 = idClassAdDisabled;\n                    Object.defineProperty(exports, 'idClsasAdDisabled', {\n                        enumerable: true,\n                        get: function () {\n                            return id_class_ad_disabled_1.default;\n                        }\n                    });\n                    var id_class_value_1 = idClassValue;\n                    Object.defineProperty(exports, 'idClassValue', {\n                        enumerable: true,\n                        get: function () {\n                            return id_class_value_1.default;\n                        }\n                    });\n                    var id_unique_1 = idUnique;\n                    Object.defineProperty(exports, 'idUnique', {\n                        enumerable: true,\n                        get: function () {\n                            return id_unique_1.default;\n                        }\n                    });\n                    var inline_script_disabled_1 = inlineScriptDisabled;\n                    Object.defineProperty(exports, 'inlineScriptDisabled', {\n                        enumerable: true,\n                        get: function () {\n                            return inline_script_disabled_1.default;\n                        }\n                    });\n                    var inline_style_disabled_1 = inlineStyleDisabled;\n                    Object.defineProperty(exports, 'inlineStyleDisabled', {\n                        enumerable: true,\n                        get: function () {\n                            return inline_style_disabled_1.default;\n                        }\n                    });\n                    var input_requires_label_1 = inputRequiresLabel;\n                    Object.defineProperty(exports, 'inputRequiresLabel', {\n                        enumerable: true,\n                        get: function () {\n                            return input_requires_label_1.default;\n                        }\n                    });\n                    var script_disabled_1 = scriptDisabled;\n                    Object.defineProperty(exports, 'scriptDisabled', {\n                        enumerable: true,\n                        get: function () {\n                            return script_disabled_1.default;\n                        }\n                    });\n                    var space_tab_mixed_disabled_1 = spaceTabMixedDisabled;\n                    Object.defineProperty(exports, 'spaceTabMixedDisabled', {\n                        enumerable: true,\n                        get: function () {\n                            return space_tab_mixed_disabled_1.default;\n                        }\n                    });\n                    var spec_char_escape_1 = specCharEscape;\n                    Object.defineProperty(exports, 'specCharEscape', {\n                        enumerable: true,\n                        get: function () {\n                            return spec_char_escape_1.default;\n                        }\n                    });\n                    var src_not_empty_1 = srcNotEmpty;\n                    Object.defineProperty(exports, 'srcNotEmpty', {\n                        enumerable: true,\n                        get: function () {\n                            return src_not_empty_1.default;\n                        }\n                    });\n                    var style_disabled_1 = styleDisabled;\n                    Object.defineProperty(exports, 'styleDisabled', {\n                        enumerable: true,\n                        get: function () {\n                            return style_disabled_1.default;\n                        }\n                    });\n                    var tag_pair_1 = tagPair;\n                    Object.defineProperty(exports, 'tagPair', {\n                        enumerable: true,\n                        get: function () {\n                            return tag_pair_1.default;\n                        }\n                    });\n                    var tag_self_close_1 = tagSelfClose;\n                    Object.defineProperty(exports, 'tagSelfClose', {\n                        enumerable: true,\n                        get: function () {\n                            return tag_self_close_1.default;\n                        }\n                    });\n                    var empty_tag_not_self_closed_1 = emptyTagNotSelfClosed;\n                    Object.defineProperty(exports, 'emptyTagNotSelfClosed', {\n                        enumerable: true,\n                        get: function () {\n                            return empty_tag_not_self_closed_1.default;\n                        }\n                    });\n                    var tagname_lowercase_1 = tagnameLowercase;\n                    Object.defineProperty(exports, 'tagnameLowercase', {\n                        enumerable: true,\n                        get: function () {\n                            return tagname_lowercase_1.default;\n                        }\n                    });\n                    var tagname_specialchars_1 = tagnameSpecialchars;\n                    Object.defineProperty(exports, 'tagnameSpecialChars', {\n                        enumerable: true,\n                        get: function () {\n                            return tagname_specialchars_1.default;\n                        }\n                    });\n                    var title_require_1 = titleRequire;\n                    Object.defineProperty(exports, 'titleRequire', {\n                        enumerable: true,\n                        get: function () {\n                            return title_require_1.default;\n                        }\n                    });\n                    var tags_check_1 = tagsCheck;\n                    Object.defineProperty(exports, 'tagsCheck', {\n                        enumerable: true,\n                        get: function () {\n                            return tags_check_1.default;\n                        }\n                    });\n                    var attr_no_unnecessary_whitespace_1 = attrNoUnnecessaryWhitespace;\n                    Object.defineProperty(exports, 'attrNoUnnecessaryWhitespace', {\n                        enumerable: true,\n                        get: function () {\n                            return attr_no_unnecessary_whitespace_1.default;\n                        }\n                    });\n                }(rules));\n                (function (exports) {\n                    Object.defineProperty(exports, '__esModule', { value: true });\n                    exports.HTMLParser = exports.Reporter = exports.HTMLRules = exports.HTMLHint = void 0;\n                    const htmlparser_1 = htmlparser;\n                    exports.HTMLParser = htmlparser_1.default;\n                    const reporter_1 = reporter;\n                    exports.Reporter = reporter_1.default;\n                    const HTMLRules = rules;\n                    exports.HTMLRules = HTMLRules;\n                    class HTMLHintCore {\n                        constructor() {\n                            this.rules = {};\n                            this.defaultRuleset = {\n                                'tagname-lowercase': true,\n                                'attr-lowercase': true,\n                                'attr-value-double-quotes': true,\n                                'doctype-first': true,\n                                'tag-pair': true,\n                                'spec-char-escape': true,\n                                'id-unique': true,\n                                'src-not-empty': true,\n                                'attr-no-duplication': true,\n                                'title-require': true\n                            };\n                        }\n                        addRule(rule) {\n                            this.rules[rule.id] = rule;\n                        }\n                        verify(html, ruleset = this.defaultRuleset) {\n                            if (Object.keys(ruleset).length === 0) {\n                                ruleset = this.defaultRuleset;\n                            }\n                            html = html.replace(/^\\s*<!--\\s*htmlhint\\s+([^\\r\\n]+?)\\s*-->/i, (all, strRuleset) => {\n                                strRuleset.replace(/(?:^|,)\\s*([^:,]+)\\s*(?:\\:\\s*([^,\\s]+))?/g, (all, ruleId, value) => {\n                                    ruleset[ruleId] = value !== undefined && value.length > 0 ? JSON.parse(value) : true;\n                                    return '';\n                                });\n                                return '';\n                            });\n                            const parser = new htmlparser_1.default();\n                            const reporter = new reporter_1.default(html, ruleset);\n                            const rules = this.rules;\n                            let rule;\n                            for (const id in ruleset) {\n                                rule = rules[id];\n                                if (rule !== undefined && ruleset[id] !== false) {\n                                    rule.init(parser, reporter, ruleset[id]);\n                                }\n                            }\n                            parser.parse(html);\n                            return reporter.messages;\n                        }\n                        format(arrMessages, options = {}) {\n                            const arrLogs = [];\n                            const colors = {\n                                white: '',\n                                grey: '',\n                                red: '',\n                                reset: ''\n                            };\n                            if (options.colors) {\n                                colors.white = '\\x1B[37m';\n                                colors.grey = '\\x1B[90m';\n                                colors.red = '\\x1B[31m';\n                                colors.reset = '\\x1B[39m';\n                            }\n                            const indent = options.indent || 0;\n                            arrMessages.forEach(hint => {\n                                const leftWindow = 40;\n                                const rightWindow = leftWindow + 20;\n                                let evidence = hint.evidence;\n                                const line = hint.line;\n                                const col = hint.col;\n                                const evidenceCount = evidence.length;\n                                let leftCol = col > leftWindow + 1 ? col - leftWindow : 1;\n                                let rightCol = evidence.length > col + rightWindow ? col + rightWindow : evidenceCount;\n                                if (col < leftWindow + 1) {\n                                    rightCol += leftWindow - col + 1;\n                                }\n                                evidence = evidence.replace(/\\t/g, ' ').substring(leftCol - 1, rightCol);\n                                if (leftCol > 1) {\n                                    evidence = `...${ evidence }`;\n                                    leftCol -= 3;\n                                }\n                                if (rightCol < evidenceCount) {\n                                    evidence += '...';\n                                }\n                                arrLogs.push(`${ colors.white + repeatStr(indent) }L${ line } |${ colors.grey }${ evidence }${ colors.reset }`);\n                                let pointCol = col - leftCol;\n                                const match = evidence.substring(0, pointCol).match(/[^\\u0000-\\u00ff]/g);\n                                if (match !== null) {\n                                    pointCol += match.length;\n                                }\n                                arrLogs.push(`${ colors.white + repeatStr(indent) + repeatStr(String(line).length + 3 + pointCol) }^ ${ colors.red }${ hint.message } (${ hint.rule.id })${ colors.reset }`);\n                            });\n                            return arrLogs;\n                        }\n                    }\n                    function repeatStr(n, str) {\n                        return new Array(n + 1).join(str || ' ');\n                    }\n                    exports.HTMLHint = new HTMLHintCore();\n                    Object.keys(HTMLRules).forEach(key => {\n                        exports.HTMLHint.addRule(HTMLRules[key]);\n                    });\n                }(core$1));\n                var core = getDefaultExportFromCjs(core$1);\n                return core;\n            }));\n        },\n        {}\n    ],\n    73: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                CodeMirror.registerHelper('lint', 'css', function (text, options) {\n                    var found = [];\n                    if (!window.CSSLint) {\n                        if (window.console) {\n                            window.console.error('Error: window.CSSLint not defined, CodeMirror CSS linting cannot run.');\n                        }\n                        return found;\n                    }\n                    var results = CSSLint.verify(text, options), messages = results.messages, message = null;\n                    for (var i = 0; i < messages.length; i++) {\n                        message = messages[i];\n                        var startLine = message.line - 1, endLine = message.line - 1, startCol = message.col - 1, endCol = message.col;\n                        found.push({\n                            from: CodeMirror.Pos(startLine, startCol),\n                            to: CodeMirror.Pos(endLine, endCol),\n                            message: message.message,\n                            severity: message.type\n                        });\n                    }\n                    return found;\n                });\n            }));\n        },\n        { '79': 79 }\n    ],\n    71: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                var HINT_ELEMENT_CLASS = 'CodeMirror-hint';\n                var ACTIVE_HINT_ELEMENT_CLASS = 'CodeMirror-hint-active';\n                CodeMirror.showHint = function (cm, getHints, options) {\n                    if (!getHints)\n                        return cm.showHint(options);\n                    if (options && options.async)\n                        getHints.async = true;\n                    var newOpts = { hint: getHints };\n                    if (options)\n                        for (var prop in options)\n                            newOpts[prop] = options[prop];\n                    return cm.showHint(newOpts);\n                };\n                CodeMirror.defineExtension('showHint', function (options) {\n                    options = parseOptions(this, this.getCursor('start'), options);\n                    var selections = this.listSelections();\n                    if (selections.length > 1)\n                        return;\n                    if (this.somethingSelected()) {\n                        if (!options.hint.supportsSelection)\n                            return;\n                        for (var i = 0; i < selections.length; i++)\n                            if (selections[i].head.line != selections[i].anchor.line)\n                                return;\n                    }\n                    if (this.state.completionActive)\n                        this.state.completionActive.close();\n                    var completion = this.state.completionActive = new Completion(this, options);\n                    if (!completion.options.hint)\n                        return;\n                    CodeMirror.signal(this, 'startCompletion', this);\n                    completion.update(true);\n                });\n                CodeMirror.defineExtension('closeHint', function () {\n                    if (this.state.completionActive)\n                        this.state.completionActive.close();\n                });\n                function Completion(cm, options) {\n                    this.cm = cm;\n                    this.options = options;\n                    this.widget = null;\n                    this.debounce = 0;\n                    this.tick = 0;\n                    this.startPos = this.cm.getCursor('start');\n                    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n                    if (this.options.updateOnCursorActivity) {\n                        var self = this;\n                        cm.on('cursorActivity', this.activityFunc = function () {\n                            self.cursorActivity();\n                        });\n                    }\n                }\n                var requestAnimationFrame = window.requestAnimationFrame || function (fn) {\n                    return setTimeout(fn, 1000 / 60);\n                };\n                var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n                Completion.prototype = {\n                    close: function () {\n                        if (!this.active())\n                            return;\n                        this.cm.state.completionActive = null;\n                        this.tick = null;\n                        if (this.options.updateOnCursorActivity) {\n                            this.cm.off('cursorActivity', this.activityFunc);\n                        }\n                        if (this.widget && this.data)\n                            CodeMirror.signal(this.data, 'close');\n                        if (this.widget)\n                            this.widget.close();\n                        CodeMirror.signal(this.cm, 'endCompletion', this.cm);\n                    },\n                    active: function () {\n                        return this.cm.state.completionActive == this;\n                    },\n                    pick: function (data, i) {\n                        var completion = data.list[i], self = this;\n                        this.cm.operation(function () {\n                            if (completion.hint)\n                                completion.hint(self.cm, data, completion);\n                            else\n                                self.cm.replaceRange(getText(completion), completion.from || data.from, completion.to || data.to, 'complete');\n                            CodeMirror.signal(data, 'pick', completion);\n                            self.cm.scrollIntoView();\n                        });\n                        if (this.options.closeOnPick) {\n                            this.close();\n                        }\n                    },\n                    cursorActivity: function () {\n                        if (this.debounce) {\n                            cancelAnimationFrame(this.debounce);\n                            this.debounce = 0;\n                        }\n                        var identStart = this.startPos;\n                        if (this.data) {\n                            identStart = this.data.from;\n                        }\n                        var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n                        if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < identStart.ch || this.cm.somethingSelected() || (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n                            this.close();\n                        } else {\n                            var self = this;\n                            this.debounce = requestAnimationFrame(function () {\n                                self.update();\n                            });\n                            if (this.widget)\n                                this.widget.disable();\n                        }\n                    },\n                    update: function (first) {\n                        if (this.tick == null)\n                            return;\n                        var self = this, myTick = ++this.tick;\n                        fetchHints(this.options.hint, this.cm, this.options, function (data) {\n                            if (self.tick == myTick)\n                                self.finishUpdate(data, first);\n                        });\n                    },\n                    finishUpdate: function (data, first) {\n                        if (this.data)\n                            CodeMirror.signal(this.data, 'update');\n                        var picked = this.widget && this.widget.picked || first && this.options.completeSingle;\n                        if (this.widget)\n                            this.widget.close();\n                        this.data = data;\n                        if (data && data.list.length) {\n                            if (picked && data.list.length == 1) {\n                                this.pick(data, 0);\n                            } else {\n                                this.widget = new Widget(this, data);\n                                CodeMirror.signal(data, 'shown');\n                            }\n                        }\n                    }\n                };\n                function parseOptions(cm, pos, options) {\n                    var editor = cm.options.hintOptions;\n                    var out = {};\n                    for (var prop in defaultOptions)\n                        out[prop] = defaultOptions[prop];\n                    if (editor)\n                        for (var prop in editor)\n                            if (editor[prop] !== undefined)\n                                out[prop] = editor[prop];\n                    if (options)\n                        for (var prop in options)\n                            if (options[prop] !== undefined)\n                                out[prop] = options[prop];\n                    if (out.hint.resolve)\n                        out.hint = out.hint.resolve(cm, pos);\n                    return out;\n                }\n                function getText(completion) {\n                    if (typeof completion == 'string')\n                        return completion;\n                    else\n                        return completion.text;\n                }\n                function buildKeyMap(completion, handle) {\n                    var baseMap = {\n                        Up: function () {\n                            handle.moveFocus(-1);\n                        },\n                        Down: function () {\n                            handle.moveFocus(1);\n                        },\n                        PageUp: function () {\n                            handle.moveFocus(-handle.menuSize() + 1, true);\n                        },\n                        PageDown: function () {\n                            handle.moveFocus(handle.menuSize() - 1, true);\n                        },\n                        Home: function () {\n                            handle.setFocus(0);\n                        },\n                        End: function () {\n                            handle.setFocus(handle.length - 1);\n                        },\n                        Enter: handle.pick,\n                        Tab: handle.pick,\n                        Esc: handle.close\n                    };\n                    var mac = /Mac/.test(navigator.platform);\n                    if (mac) {\n                        baseMap['Ctrl-P'] = function () {\n                            handle.moveFocus(-1);\n                        };\n                        baseMap['Ctrl-N'] = function () {\n                            handle.moveFocus(1);\n                        };\n                    }\n                    var custom = completion.options.customKeys;\n                    var ourMap = custom ? {} : baseMap;\n                    function addBinding(key, val) {\n                        var bound;\n                        if (typeof val != 'string')\n                            bound = function (cm) {\n                                return val(cm, handle);\n                            };\n                        else if (baseMap.hasOwnProperty(val))\n                            bound = baseMap[val];\n                        else\n                            bound = val;\n                        ourMap[key] = bound;\n                    }\n                    if (custom)\n                        for (var key in custom)\n                            if (custom.hasOwnProperty(key))\n                                addBinding(key, custom[key]);\n                    var extra = completion.options.extraKeys;\n                    if (extra)\n                        for (var key in extra)\n                            if (extra.hasOwnProperty(key))\n                                addBinding(key, extra[key]);\n                    return ourMap;\n                }\n                function getHintElement(hintsElement, el) {\n                    while (el && el != hintsElement) {\n                        if (el.nodeName.toUpperCase() === 'LI' && el.parentNode == hintsElement)\n                            return el;\n                        el = el.parentNode;\n                    }\n                }\n                function Widget(completion, data) {\n                    this.id = 'cm-complete-' + Math.floor(Math.random(1000000));\n                    this.completion = completion;\n                    this.data = data;\n                    this.picked = false;\n                    var widget = this, cm = completion.cm;\n                    var ownerDocument = cm.getInputField().ownerDocument;\n                    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;\n                    var hints = this.hints = ownerDocument.createElement('ul');\n                    hints.setAttribute('role', 'listbox');\n                    hints.setAttribute('aria-expanded', 'true');\n                    hints.id = this.id;\n                    var theme = completion.cm.options.theme;\n                    hints.className = 'CodeMirror-hints ' + theme;\n                    this.selectedHint = data.selectedHint || 0;\n                    var completions = data.list;\n                    for (var i = 0; i < completions.length; ++i) {\n                        var elt = hints.appendChild(ownerDocument.createElement('li')), cur = completions[i];\n                        var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? '' : ' ' + ACTIVE_HINT_ELEMENT_CLASS);\n                        if (cur.className != null)\n                            className = cur.className + ' ' + className;\n                        elt.className = className;\n                        if (i == this.selectedHint)\n                            elt.setAttribute('aria-selected', 'true');\n                        elt.id = this.id + '-' + i;\n                        elt.setAttribute('role', 'option');\n                        if (cur.render)\n                            cur.render(elt, data, cur);\n                        else\n                            elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));\n                        elt.hintId = i;\n                    }\n                    var container = completion.options.container || ownerDocument.body;\n                    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n                    var left = pos.left, top = pos.bottom, below = true;\n                    var offsetLeft = 0, offsetTop = 0;\n                    if (container !== ownerDocument.body) {\n                        var isContainerPositioned = [\n                            'absolute',\n                            'relative',\n                            'fixed'\n                        ].indexOf(parentWindow.getComputedStyle(container).position) !== -1;\n                        var offsetParent = isContainerPositioned ? container : container.offsetParent;\n                        var offsetParentPosition = offsetParent.getBoundingClientRect();\n                        var bodyPosition = ownerDocument.body.getBoundingClientRect();\n                        offsetLeft = offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft;\n                        offsetTop = offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop;\n                    }\n                    hints.style.left = left - offsetLeft + 'px';\n                    hints.style.top = top - offsetTop + 'px';\n                    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);\n                    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);\n                    container.appendChild(hints);\n                    cm.getInputField().setAttribute('aria-autocomplete', 'list');\n                    cm.getInputField().setAttribute('aria-owns', this.id);\n                    cm.getInputField().setAttribute('aria-activedescendant', this.id + '-' + this.selectedHint);\n                    var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();\n                    var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;\n                    var startScroll;\n                    setTimeout(function () {\n                        startScroll = cm.getScrollInfo();\n                    });\n                    var overlapY = box.bottom - winH;\n                    if (overlapY > 0) {\n                        var height = box.bottom - box.top, spaceAbove = box.top - (pos.bottom - pos.top) - 2;\n                        if (winH - box.top < spaceAbove) {\n                            if (height > spaceAbove)\n                                hints.style.height = (height = spaceAbove) + 'px';\n                            hints.style.top = (top = pos.top - height) + offsetTop + 'px';\n                            below = false;\n                        } else {\n                            hints.style.height = winH - box.top - 2 + 'px';\n                        }\n                    }\n                    var overlapX = box.right - winW;\n                    if (scrolls)\n                        overlapX += cm.display.nativeBarWidth;\n                    if (overlapX > 0) {\n                        if (box.right - box.left > winW) {\n                            hints.style.width = winW - 5 + 'px';\n                            overlapX -= box.right - box.left - winW;\n                        }\n                        hints.style.left = (left = Math.max(pos.left - overlapX - offsetLeft, 0)) + 'px';\n                    }\n                    if (scrolls)\n                        for (var node = hints.firstChild; node; node = node.nextSibling)\n                            node.style.paddingRight = cm.display.nativeBarWidth + 'px';\n                    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n                        moveFocus: function (n, avoidWrap) {\n                            widget.changeActive(widget.selectedHint + n, avoidWrap);\n                        },\n                        setFocus: function (n) {\n                            widget.changeActive(n);\n                        },\n                        menuSize: function () {\n                            return widget.screenAmount();\n                        },\n                        length: completions.length,\n                        close: function () {\n                            completion.close();\n                        },\n                        pick: function () {\n                            widget.pick();\n                        },\n                        data: data\n                    }));\n                    if (completion.options.closeOnUnfocus) {\n                        var closingOnBlur;\n                        cm.on('blur', this.onBlur = function () {\n                            closingOnBlur = setTimeout(function () {\n                                completion.close();\n                            }, 100);\n                        });\n                        cm.on('focus', this.onFocus = function () {\n                            clearTimeout(closingOnBlur);\n                        });\n                    }\n                    cm.on('scroll', this.onScroll = function () {\n                        var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n                        if (!startScroll)\n                            startScroll = cm.getScrollInfo();\n                        var newTop = top + startScroll.top - curScroll.top;\n                        var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);\n                        if (!below)\n                            point += hints.offsetHeight;\n                        if (point <= editor.top || point >= editor.bottom)\n                            return completion.close();\n                        hints.style.top = newTop + 'px';\n                        hints.style.left = left + startScroll.left - curScroll.left + 'px';\n                    });\n                    CodeMirror.on(hints, 'dblclick', function (e) {\n                        var t = getHintElement(hints, e.target || e.srcElement);\n                        if (t && t.hintId != null) {\n                            widget.changeActive(t.hintId);\n                            widget.pick();\n                        }\n                    });\n                    CodeMirror.on(hints, 'click', function (e) {\n                        var t = getHintElement(hints, e.target || e.srcElement);\n                        if (t && t.hintId != null) {\n                            widget.changeActive(t.hintId);\n                            if (completion.options.completeOnSingleClick)\n                                widget.pick();\n                        }\n                    });\n                    CodeMirror.on(hints, 'mousedown', function () {\n                        setTimeout(function () {\n                            cm.focus();\n                        }, 20);\n                    });\n                    var selectedHintRange = this.getSelectedHintRange();\n                    if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {\n                        this.scrollToActive();\n                    }\n                    CodeMirror.signal(data, 'select', completions[this.selectedHint], hints.childNodes[this.selectedHint]);\n                    return true;\n                }\n                Widget.prototype = {\n                    close: function () {\n                        if (this.completion.widget != this)\n                            return;\n                        this.completion.widget = null;\n                        if (this.hints.parentNode)\n                            this.hints.parentNode.removeChild(this.hints);\n                        this.completion.cm.removeKeyMap(this.keyMap);\n                        var input = this.completion.cm.getInputField();\n                        input.removeAttribute('aria-activedescendant');\n                        input.removeAttribute('aria-owns');\n                        var cm = this.completion.cm;\n                        if (this.completion.options.closeOnUnfocus) {\n                            cm.off('blur', this.onBlur);\n                            cm.off('focus', this.onFocus);\n                        }\n                        cm.off('scroll', this.onScroll);\n                    },\n                    disable: function () {\n                        this.completion.cm.removeKeyMap(this.keyMap);\n                        var widget = this;\n                        this.keyMap = {\n                            Enter: function () {\n                                widget.picked = true;\n                            }\n                        };\n                        this.completion.cm.addKeyMap(this.keyMap);\n                    },\n                    pick: function () {\n                        this.completion.pick(this.data, this.selectedHint);\n                    },\n                    changeActive: function (i, avoidWrap) {\n                        if (i >= this.data.list.length)\n                            i = avoidWrap ? this.data.list.length - 1 : 0;\n                        else if (i < 0)\n                            i = avoidWrap ? 0 : this.data.list.length - 1;\n                        if (this.selectedHint == i)\n                            return;\n                        var node = this.hints.childNodes[this.selectedHint];\n                        if (node) {\n                            node.className = node.className.replace(' ' + ACTIVE_HINT_ELEMENT_CLASS, '');\n                            node.removeAttribute('aria-selected');\n                        }\n                        node = this.hints.childNodes[this.selectedHint = i];\n                        node.className += ' ' + ACTIVE_HINT_ELEMENT_CLASS;\n                        node.setAttribute('aria-selected', 'true');\n                        this.completion.cm.getInputField().setAttribute('aria-activedescendant', node.id);\n                        this.scrollToActive();\n                        CodeMirror.signal(this.data, 'select', this.data.list[this.selectedHint], node);\n                    },\n                    scrollToActive: function () {\n                        var selectedHintRange = this.getSelectedHintRange();\n                        var node1 = this.hints.childNodes[selectedHintRange.from];\n                        var node2 = this.hints.childNodes[selectedHintRange.to];\n                        var firstNode = this.hints.firstChild;\n                        if (node1.offsetTop < this.hints.scrollTop)\n                            this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;\n                        else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n                            this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;\n                    },\n                    screenAmount: function () {\n                        return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n                    },\n                    getSelectedHintRange: function () {\n                        var margin = this.completion.options.scrollMargin || 0;\n                        return {\n                            from: Math.max(0, this.selectedHint - margin),\n                            to: Math.min(this.data.list.length - 1, this.selectedHint + margin)\n                        };\n                    }\n                };\n                function applicableHelpers(cm, helpers) {\n                    if (!cm.somethingSelected())\n                        return helpers;\n                    var result = [];\n                    for (var i = 0; i < helpers.length; i++)\n                        if (helpers[i].supportsSelection)\n                            result.push(helpers[i]);\n                    return result;\n                }\n                function fetchHints(hint, cm, options, callback) {\n                    if (hint.async) {\n                        hint(cm, callback, options);\n                    } else {\n                        var result = hint(cm, options);\n                        if (result && result.then)\n                            result.then(callback);\n                        else\n                            callback(result);\n                    }\n                }\n                function resolveAutoHints(cm, pos) {\n                    var helpers = cm.getHelpers(pos, 'hint'), words;\n                    if (helpers.length) {\n                        var resolved = function (cm, callback, options) {\n                            var app = applicableHelpers(cm, helpers);\n                            function run(i) {\n                                if (i == app.length)\n                                    return callback(null);\n                                fetchHints(app[i], cm, options, function (result) {\n                                    if (result && result.list.length > 0)\n                                        callback(result);\n                                    else\n                                        run(i + 1);\n                                });\n                            }\n                            run(0);\n                        };\n                        resolved.async = true;\n                        resolved.supportsSelection = true;\n                        return resolved;\n                    } else if (words = cm.getHelper(cm.getCursor(), 'hintWords')) {\n                        return function (cm) {\n                            return CodeMirror.hint.fromList(cm, { words: words });\n                        };\n                    } else if (CodeMirror.hint.anyword) {\n                        return function (cm, options) {\n                            return CodeMirror.hint.anyword(cm, options);\n                        };\n                    } else {\n                        return function () {\n                        };\n                    }\n                }\n                CodeMirror.registerHelper('hint', 'auto', { resolve: resolveAutoHints });\n                CodeMirror.registerHelper('hint', 'fromList', function (cm, options) {\n                    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n                    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur;\n                    if (token.start < cur.ch && /\\w/.test(token.string.charAt(cur.ch - token.start - 1))) {\n                        term = token.string.substr(0, cur.ch - token.start);\n                    } else {\n                        term = '';\n                        from = cur;\n                    }\n                    var found = [];\n                    for (var i = 0; i < options.words.length; i++) {\n                        var word = options.words[i];\n                        if (word.slice(0, term.length) == term)\n                            found.push(word);\n                    }\n                    if (found.length)\n                        return {\n                            list: found,\n                            from: from,\n                            to: to\n                        };\n                });\n                CodeMirror.commands.autocomplete = CodeMirror.showHint;\n                var defaultOptions = {\n                    hint: CodeMirror.hint.auto,\n                    completeSingle: true,\n                    alignWithWord: true,\n                    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n                    closeOnPick: true,\n                    closeOnUnfocus: true,\n                    updateOnCursorActivity: true,\n                    completeOnSingleClick: true,\n                    container: null,\n                    customKeys: null,\n                    extraKeys: null,\n                    paddingForScrollbar: true,\n                    moveOnOverlap: true\n                };\n                CodeMirror.defineOption('hintOptions', null);\n            }));\n        },\n        { '79': 79 }\n    ],\n    70: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                var Pos = CodeMirror.Pos;\n                function forEach(arr, f) {\n                    for (var i = 0, e = arr.length; i < e; ++i)\n                        f(arr[i]);\n                }\n                function arrayContains(arr, item) {\n                    if (!Array.prototype.indexOf) {\n                        var i = arr.length;\n                        while (i--) {\n                            if (arr[i] === item) {\n                                return true;\n                            }\n                        }\n                        return false;\n                    }\n                    return arr.indexOf(item) != -1;\n                }\n                function scriptHint(editor, keywords, getToken, options) {\n                    var cur = editor.getCursor(), token = getToken(editor, cur);\n                    if (/\\b(?:string|comment)\\b/.test(token.type))\n                        return;\n                    var innerMode = CodeMirror.innerMode(editor.getMode(), token.state);\n                    if (innerMode.mode.helperType === 'json')\n                        return;\n                    token.state = innerMode.state;\n                    if (!/^[\\w$_]*$/.test(token.string)) {\n                        token = {\n                            start: cur.ch,\n                            end: cur.ch,\n                            string: '',\n                            state: token.state,\n                            type: token.string == '.' ? 'property' : null\n                        };\n                    } else if (token.end > cur.ch) {\n                        token.end = cur.ch;\n                        token.string = token.string.slice(0, cur.ch - token.start);\n                    }\n                    var tprop = token;\n                    while (tprop.type == 'property') {\n                        tprop = getToken(editor, Pos(cur.line, tprop.start));\n                        if (tprop.string != '.')\n                            return;\n                        tprop = getToken(editor, Pos(cur.line, tprop.start));\n                        if (!context)\n                            var context = [];\n                        context.push(tprop);\n                    }\n                    return {\n                        list: getCompletions(token, context, keywords, options),\n                        from: Pos(cur.line, token.start),\n                        to: Pos(cur.line, token.end)\n                    };\n                }\n                function javascriptHint(editor, options) {\n                    return scriptHint(editor, javascriptKeywords, function (e, cur) {\n                        return e.getTokenAt(cur);\n                    }, options);\n                }\n                ;\n                CodeMirror.registerHelper('hint', 'javascript', javascriptHint);\n                function getCoffeeScriptToken(editor, cur) {\n                    var token = editor.getTokenAt(cur);\n                    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\n                        token.end = token.start;\n                        token.string = '.';\n                        token.type = 'property';\n                    } else if (/^\\.[\\w$_]*$/.test(token.string)) {\n                        token.type = 'property';\n                        token.start++;\n                        token.string = token.string.replace(/\\./, '');\n                    }\n                    return token;\n                }\n                function coffeescriptHint(editor, options) {\n                    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\n                }\n                CodeMirror.registerHelper('hint', 'coffeescript', coffeescriptHint);\n                var stringProps = ('charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight ' + 'toUpperCase toLowerCase split concat match replace search').split(' ');\n                var arrayProps = ('length concat join splice push pop shift unshift slice reverse sort indexOf ' + 'lastIndexOf every some filter forEach map reduce reduceRight ').split(' ');\n                var funcProps = 'prototype apply call bind'.split(' ');\n                var javascriptKeywords = ('break case catch class const continue debugger default delete do else export extends false finally for function ' + 'if in import instanceof new null return super switch this throw true try typeof var void while with yield').split(' ');\n                var coffeescriptKeywords = ('and break catch class continue delete do else extends false finally for ' + 'if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes').split(' ');\n                function forAllProps(obj, callback) {\n                    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n                        for (var name in obj)\n                            callback(name);\n                    } else {\n                        for (var o = obj; o; o = Object.getPrototypeOf(o))\n                            Object.getOwnPropertyNames(o).forEach(callback);\n                    }\n                }\n                function getCompletions(token, context, keywords, options) {\n                    var found = [], start = token.string, global = options && options.globalScope || window;\n                    function maybeAdd(str) {\n                        if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str))\n                            found.push(str);\n                    }\n                    function gatherCompletions(obj) {\n                        if (typeof obj == 'string')\n                            forEach(stringProps, maybeAdd);\n                        else if (obj instanceof Array)\n                            forEach(arrayProps, maybeAdd);\n                        else if (obj instanceof Function)\n                            forEach(funcProps, maybeAdd);\n                        forAllProps(obj, maybeAdd);\n                    }\n                    if (context && context.length) {\n                        var obj = context.pop(), base;\n                        if (obj.type && obj.type.indexOf('variable') === 0) {\n                            if (options && options.additionalContext)\n                                base = options.additionalContext[obj.string];\n                            if (!options || options.useGlobalScope !== false)\n                                base = base || global[obj.string];\n                        } else if (obj.type == 'string') {\n                            base = '';\n                        } else if (obj.type == 'atom') {\n                            base = 1;\n                        } else if (obj.type == 'function') {\n                            if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') && typeof global.jQuery == 'function')\n                                base = global.jQuery();\n                            else if (global._ != null && obj.string == '_' && typeof global._ == 'function')\n                                base = global._();\n                        }\n                        while (base != null && context.length)\n                            base = base[context.pop().string];\n                        if (base != null)\n                            gatherCompletions(base);\n                    } else {\n                        for (var v = token.state.localVars; v; v = v.next)\n                            maybeAdd(v.name);\n                        for (var c = token.state.context; c; c = c.prev)\n                            for (var v = c.vars; v; v = v.next)\n                                maybeAdd(v.name);\n                        for (var v = token.state.globalVars; v; v = v.next)\n                            maybeAdd(v.name);\n                        if (options && options.additionalContext != null)\n                            for (var key in options.additionalContext)\n                                maybeAdd(key);\n                        if (!options || options.useGlobalScope !== false)\n                            gatherCompletions(global);\n                        forEach(keywords, maybeAdd);\n                    }\n                    return found;\n                }\n            }));\n        },\n        { '79': 79 }\n    ],\n    69: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79), require(72));\n                else if (typeof define == 'function' && define.amd)\n                    define([\n                        '../../lib/codemirror',\n                        './xml-hint'\n                    ], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                var langs = 'ab aa af ak sq am ar an hy as av ae ay az bm ba eu be bn bh bi bs br bg my ca ch ce ny zh cv kw co cr hr cs da dv nl dz en eo et ee fo fj fi fr ff gl ka de el gn gu ht ha he hz hi ho hu ia id ie ga ig ik io is it iu ja jv kl kn kr ks kk km ki rw ky kv kg ko ku kj la lb lg li ln lo lt lu lv gv mk mg ms ml mt mi mr mh mn na nv nb nd ne ng nn no ii nr oc oj cu om or os pa pi fa pl ps pt qu rm rn ro ru sa sc sd se sm sg sr gd sn si sk sl so st es su sw ss sv ta te tg th ti bo tk tl tn to tr ts tt tw ty ug uk ur uz ve vi vo wa cy wo fy xh yi yo za zu'.split(' ');\n                var targets = [\n                    '_blank',\n                    '_self',\n                    '_top',\n                    '_parent'\n                ];\n                var charsets = [\n                    'ascii',\n                    'utf-8',\n                    'utf-16',\n                    'latin1',\n                    'latin1'\n                ];\n                var methods = [\n                    'get',\n                    'post',\n                    'put',\n                    'delete'\n                ];\n                var encs = [\n                    'application/x-www-form-urlencoded',\n                    'multipart/form-data',\n                    'text/plain'\n                ];\n                var media = [\n                    'all',\n                    'screen',\n                    'print',\n                    'embossed',\n                    'braille',\n                    'handheld',\n                    'print',\n                    'projection',\n                    'screen',\n                    'tty',\n                    'tv',\n                    'speech',\n                    '3d-glasses',\n                    'resolution [>][<][=] [X]',\n                    'device-aspect-ratio: X/Y',\n                    'orientation:portrait',\n                    'orientation:landscape',\n                    'device-height: [X]',\n                    'device-width: [X]'\n                ];\n                var s = { attrs: {} };\n                var data = {\n                    a: {\n                        attrs: {\n                            href: null,\n                            ping: null,\n                            type: null,\n                            media: media,\n                            target: targets,\n                            hreflang: langs\n                        }\n                    },\n                    abbr: s,\n                    acronym: s,\n                    address: s,\n                    applet: s,\n                    area: {\n                        attrs: {\n                            alt: null,\n                            coords: null,\n                            href: null,\n                            target: null,\n                            ping: null,\n                            media: media,\n                            hreflang: langs,\n                            type: null,\n                            shape: [\n                                'default',\n                                'rect',\n                                'circle',\n                                'poly'\n                            ]\n                        }\n                    },\n                    article: s,\n                    aside: s,\n                    audio: {\n                        attrs: {\n                            src: null,\n                            mediagroup: null,\n                            crossorigin: [\n                                'anonymous',\n                                'use-credentials'\n                            ],\n                            preload: [\n                                'none',\n                                'metadata',\n                                'auto'\n                            ],\n                            autoplay: [\n                                '',\n                                'autoplay'\n                            ],\n                            loop: [\n                                '',\n                                'loop'\n                            ],\n                            controls: [\n                                '',\n                                'controls'\n                            ]\n                        }\n                    },\n                    b: s,\n                    base: {\n                        attrs: {\n                            href: null,\n                            target: targets\n                        }\n                    },\n                    basefont: s,\n                    bdi: s,\n                    bdo: s,\n                    big: s,\n                    blockquote: { attrs: { cite: null } },\n                    body: s,\n                    br: s,\n                    button: {\n                        attrs: {\n                            form: null,\n                            formaction: null,\n                            name: null,\n                            value: null,\n                            autofocus: [\n                                '',\n                                'autofocus'\n                            ],\n                            disabled: [\n                                '',\n                                'autofocus'\n                            ],\n                            formenctype: encs,\n                            formmethod: methods,\n                            formnovalidate: [\n                                '',\n                                'novalidate'\n                            ],\n                            formtarget: targets,\n                            type: [\n                                'submit',\n                                'reset',\n                                'button'\n                            ]\n                        }\n                    },\n                    canvas: {\n                        attrs: {\n                            width: null,\n                            height: null\n                        }\n                    },\n                    caption: s,\n                    center: s,\n                    cite: s,\n                    code: s,\n                    col: { attrs: { span: null } },\n                    colgroup: { attrs: { span: null } },\n                    command: {\n                        attrs: {\n                            type: [\n                                'command',\n                                'checkbox',\n                                'radio'\n                            ],\n                            label: null,\n                            icon: null,\n                            radiogroup: null,\n                            command: null,\n                            title: null,\n                            disabled: [\n                                '',\n                                'disabled'\n                            ],\n                            checked: [\n                                '',\n                                'checked'\n                            ]\n                        }\n                    },\n                    data: { attrs: { value: null } },\n                    datagrid: {\n                        attrs: {\n                            disabled: [\n                                '',\n                                'disabled'\n                            ],\n                            multiple: [\n                                '',\n                                'multiple'\n                            ]\n                        }\n                    },\n                    datalist: { attrs: { data: null } },\n                    dd: s,\n                    del: {\n                        attrs: {\n                            cite: null,\n                            datetime: null\n                        }\n                    },\n                    details: {\n                        attrs: {\n                            open: [\n                                '',\n                                'open'\n                            ]\n                        }\n                    },\n                    dfn: s,\n                    dir: s,\n                    div: s,\n                    dialog: { attrs: { open: null } },\n                    dl: s,\n                    dt: s,\n                    em: s,\n                    embed: {\n                        attrs: {\n                            src: null,\n                            type: null,\n                            width: null,\n                            height: null\n                        }\n                    },\n                    eventsource: { attrs: { src: null } },\n                    fieldset: {\n                        attrs: {\n                            disabled: [\n                                '',\n                                'disabled'\n                            ],\n                            form: null,\n                            name: null\n                        }\n                    },\n                    figcaption: s,\n                    figure: s,\n                    font: s,\n                    footer: s,\n                    form: {\n                        attrs: {\n                            action: null,\n                            name: null,\n                            'accept-charset': charsets,\n                            autocomplete: [\n                                'on',\n                                'off'\n                            ],\n                            enctype: encs,\n                            method: methods,\n                            novalidate: [\n                                '',\n                                'novalidate'\n                            ],\n                            target: targets\n                        }\n                    },\n                    frame: s,\n                    frameset: s,\n                    h1: s,\n                    h2: s,\n                    h3: s,\n                    h4: s,\n                    h5: s,\n                    h6: s,\n                    head: {\n                        attrs: {},\n                        children: [\n                            'title',\n                            'base',\n                            'link',\n                            'style',\n                            'meta',\n                            'script',\n                            'noscript',\n                            'command'\n                        ]\n                    },\n                    header: s,\n                    hgroup: s,\n                    hr: s,\n                    html: {\n                        attrs: { manifest: null },\n                        children: [\n                            'head',\n                            'body'\n                        ]\n                    },\n                    i: s,\n                    iframe: {\n                        attrs: {\n                            src: null,\n                            srcdoc: null,\n                            name: null,\n                            width: null,\n                            height: null,\n                            sandbox: [\n                                'allow-top-navigation',\n                                'allow-same-origin',\n                                'allow-forms',\n                                'allow-scripts'\n                            ],\n                            seamless: [\n                                '',\n                                'seamless'\n                            ]\n                        }\n                    },\n                    img: {\n                        attrs: {\n                            alt: null,\n                            src: null,\n                            ismap: null,\n                            usemap: null,\n                            width: null,\n                            height: null,\n                            crossorigin: [\n                                'anonymous',\n                                'use-credentials'\n                            ]\n                        }\n                    },\n                    input: {\n                        attrs: {\n                            alt: null,\n                            dirname: null,\n                            form: null,\n                            formaction: null,\n                            height: null,\n                            list: null,\n                            max: null,\n                            maxlength: null,\n                            min: null,\n                            name: null,\n                            pattern: null,\n                            placeholder: null,\n                            size: null,\n                            src: null,\n                            step: null,\n                            value: null,\n                            width: null,\n                            accept: [\n                                'audio/*',\n                                'video/*',\n                                'image/*'\n                            ],\n                            autocomplete: [\n                                'on',\n                                'off'\n                            ],\n                            autofocus: [\n                                '',\n                                'autofocus'\n                            ],\n                            checked: [\n                                '',\n                                'checked'\n                            ],\n                            disabled: [\n                                '',\n                                'disabled'\n                            ],\n                            formenctype: encs,\n                            formmethod: methods,\n                            formnovalidate: [\n                                '',\n                                'novalidate'\n                            ],\n                            formtarget: targets,\n                            multiple: [\n                                '',\n                                'multiple'\n                            ],\n                            readonly: [\n                                '',\n                                'readonly'\n                            ],\n                            required: [\n                                '',\n                                'required'\n                            ],\n                            type: [\n                                'hidden',\n                                'text',\n                                'search',\n                                'tel',\n                                'url',\n                                'email',\n                                'password',\n                                'datetime',\n                                'date',\n                                'month',\n                                'week',\n                                'time',\n                                'datetime-local',\n                                'number',\n                                'range',\n                                'color',\n                                'checkbox',\n                                'radio',\n                                'file',\n                                'submit',\n                                'image',\n                                'reset',\n                                'button'\n                            ]\n                        }\n                    },\n                    ins: {\n                        attrs: {\n                            cite: null,\n                            datetime: null\n                        }\n                    },\n                    kbd: s,\n                    keygen: {\n                        attrs: {\n                            challenge: null,\n                            form: null,\n                            name: null,\n                            autofocus: [\n                                '',\n                                'autofocus'\n                            ],\n                            disabled: [\n                                '',\n                                'disabled'\n                            ],\n                            keytype: ['RSA']\n                        }\n                    },\n                    label: {\n                        attrs: {\n                            'for': null,\n                            form: null\n                        }\n                    },\n                    legend: s,\n                    li: { attrs: { value: null } },\n                    link: {\n                        attrs: {\n                            href: null,\n                            type: null,\n                            hreflang: langs,\n                            media: media,\n                            sizes: [\n                                'all',\n                                '16x16',\n                                '16x16 32x32',\n                                '16x16 32x32 64x64'\n                            ]\n                        }\n                    },\n                    map: { attrs: { name: null } },\n                    mark: s,\n                    menu: {\n                        attrs: {\n                            label: null,\n                            type: [\n                                'list',\n                                'context',\n                                'toolbar'\n                            ]\n                        }\n                    },\n                    meta: {\n                        attrs: {\n                            content: null,\n                            charset: charsets,\n                            name: [\n                                'viewport',\n                                'application-name',\n                                'author',\n                                'description',\n                                'generator',\n                                'keywords'\n                            ],\n                            'http-equiv': [\n                                'content-language',\n                                'content-type',\n                                'default-style',\n                                'refresh'\n                            ]\n                        }\n                    },\n                    meter: {\n                        attrs: {\n                            value: null,\n                            min: null,\n                            low: null,\n                            high: null,\n                            max: null,\n                            optimum: null\n                        }\n                    },\n                    nav: s,\n                    noframes: s,\n                    noscript: s,\n                    object: {\n                        attrs: {\n                            data: null,\n                            type: null,\n                            name: null,\n                            usemap: null,\n                            form: null,\n                            width: null,\n                            height: null,\n                            typemustmatch: [\n                                '',\n                                'typemustmatch'\n                            ]\n                        }\n                    },\n                    ol: {\n                        attrs: {\n                            reversed: [\n                                '',\n                                'reversed'\n                            ],\n                            start: null,\n                            type: [\n                                '1',\n                                'a',\n                                'A',\n                                'i',\n                                'I'\n                            ]\n                        }\n                    },\n                    optgroup: {\n                        attrs: {\n                            disabled: [\n                                '',\n                                'disabled'\n                            ],\n                            label: null\n                        }\n                    },\n                    option: {\n                        attrs: {\n                            disabled: [\n                                '',\n                                'disabled'\n                            ],\n                            label: null,\n                            selected: [\n                                '',\n                                'selected'\n                            ],\n                            value: null\n                        }\n                    },\n                    output: {\n                        attrs: {\n                            'for': null,\n                            form: null,\n                            name: null\n                        }\n                    },\n                    p: s,\n                    param: {\n                        attrs: {\n                            name: null,\n                            value: null\n                        }\n                    },\n                    pre: s,\n                    progress: {\n                        attrs: {\n                            value: null,\n                            max: null\n                        }\n                    },\n                    q: { attrs: { cite: null } },\n                    rp: s,\n                    rt: s,\n                    ruby: s,\n                    s: s,\n                    samp: s,\n                    script: {\n                        attrs: {\n                            type: ['text/javascript'],\n                            src: null,\n                            async: [\n                                '',\n                                'async'\n                            ],\n                            defer: [\n                                '',\n                                'defer'\n                            ],\n                            charset: charsets\n                        }\n                    },\n                    section: s,\n                    select: {\n                        attrs: {\n                            form: null,\n                            name: null,\n                            size: null,\n                            autofocus: [\n                                '',\n                                'autofocus'\n                            ],\n                            disabled: [\n                                '',\n                                'disabled'\n                            ],\n                            multiple: [\n                                '',\n                                'multiple'\n                            ]\n                        }\n                    },\n                    small: s,\n                    source: {\n                        attrs: {\n                            src: null,\n                            type: null,\n                            media: null\n                        }\n                    },\n                    span: s,\n                    strike: s,\n                    strong: s,\n                    style: {\n                        attrs: {\n                            type: ['text/css'],\n                            media: media,\n                            scoped: null\n                        }\n                    },\n                    sub: s,\n                    summary: s,\n                    sup: s,\n                    table: s,\n                    tbody: s,\n                    td: {\n                        attrs: {\n                            colspan: null,\n                            rowspan: null,\n                            headers: null\n                        }\n                    },\n                    textarea: {\n                        attrs: {\n                            dirname: null,\n                            form: null,\n                            maxlength: null,\n                            name: null,\n                            placeholder: null,\n                            rows: null,\n                            cols: null,\n                            autofocus: [\n                                '',\n                                'autofocus'\n                            ],\n                            disabled: [\n                                '',\n                                'disabled'\n                            ],\n                            readonly: [\n                                '',\n                                'readonly'\n                            ],\n                            required: [\n                                '',\n                                'required'\n                            ],\n                            wrap: [\n                                'soft',\n                                'hard'\n                            ]\n                        }\n                    },\n                    tfoot: s,\n                    th: {\n                        attrs: {\n                            colspan: null,\n                            rowspan: null,\n                            headers: null,\n                            scope: [\n                                'row',\n                                'col',\n                                'rowgroup',\n                                'colgroup'\n                            ]\n                        }\n                    },\n                    thead: s,\n                    time: { attrs: { datetime: null } },\n                    title: s,\n                    tr: s,\n                    track: {\n                        attrs: {\n                            src: null,\n                            label: null,\n                            'default': null,\n                            kind: [\n                                'subtitles',\n                                'captions',\n                                'descriptions',\n                                'chapters',\n                                'metadata'\n                            ],\n                            srclang: langs\n                        }\n                    },\n                    tt: s,\n                    u: s,\n                    ul: s,\n                    'var': s,\n                    video: {\n                        attrs: {\n                            src: null,\n                            poster: null,\n                            width: null,\n                            height: null,\n                            crossorigin: [\n                                'anonymous',\n                                'use-credentials'\n                            ],\n                            preload: [\n                                'auto',\n                                'metadata',\n                                'none'\n                            ],\n                            autoplay: [\n                                '',\n                                'autoplay'\n                            ],\n                            mediagroup: ['movie'],\n                            muted: [\n                                '',\n                                'muted'\n                            ],\n                            controls: [\n                                '',\n                                'controls'\n                            ]\n                        }\n                    },\n                    wbr: s\n                };\n                var globalAttrs = {\n                    accesskey: [\n                        'a',\n                        'b',\n                        'c',\n                        'd',\n                        'e',\n                        'f',\n                        'g',\n                        'h',\n                        'i',\n                        'j',\n                        'k',\n                        'l',\n                        'm',\n                        'n',\n                        'o',\n                        'p',\n                        'q',\n                        'r',\n                        's',\n                        't',\n                        'u',\n                        'v',\n                        'w',\n                        'x',\n                        'y',\n                        'z',\n                        '0',\n                        '1',\n                        '2',\n                        '3',\n                        '4',\n                        '5',\n                        '6',\n                        '7',\n                        '8',\n                        '9'\n                    ],\n                    'class': null,\n                    contenteditable: [\n                        'true',\n                        'false'\n                    ],\n                    contextmenu: null,\n                    dir: [\n                        'ltr',\n                        'rtl',\n                        'auto'\n                    ],\n                    draggable: [\n                        'true',\n                        'false',\n                        'auto'\n                    ],\n                    dropzone: [\n                        'copy',\n                        'move',\n                        'link',\n                        'string:',\n                        'file:'\n                    ],\n                    hidden: ['hidden'],\n                    id: null,\n                    inert: ['inert'],\n                    itemid: null,\n                    itemprop: null,\n                    itemref: null,\n                    itemscope: ['itemscope'],\n                    itemtype: null,\n                    lang: [\n                        'en',\n                        'es'\n                    ],\n                    spellcheck: [\n                        'true',\n                        'false'\n                    ],\n                    autocorrect: [\n                        'true',\n                        'false'\n                    ],\n                    autocapitalize: [\n                        'true',\n                        'false'\n                    ],\n                    style: null,\n                    tabindex: [\n                        '1',\n                        '2',\n                        '3',\n                        '4',\n                        '5',\n                        '6',\n                        '7',\n                        '8',\n                        '9'\n                    ],\n                    title: null,\n                    translate: [\n                        'yes',\n                        'no'\n                    ],\n                    onclick: null,\n                    rel: [\n                        'stylesheet',\n                        'alternate',\n                        'author',\n                        'bookmark',\n                        'help',\n                        'license',\n                        'next',\n                        'nofollow',\n                        'noreferrer',\n                        'prefetch',\n                        'prev',\n                        'search',\n                        'tag'\n                    ]\n                };\n                function populate(obj) {\n                    for (var attr in globalAttrs)\n                        if (globalAttrs.hasOwnProperty(attr))\n                            obj.attrs[attr] = globalAttrs[attr];\n                }\n                populate(s);\n                for (var tag in data)\n                    if (data.hasOwnProperty(tag) && data[tag] != s)\n                        populate(data[tag]);\n                CodeMirror.htmlSchema = data;\n                function htmlHint(cm, options) {\n                    var local = { schemaInfo: data };\n                    if (options)\n                        for (var opt in options)\n                            local[opt] = options[opt];\n                    return CodeMirror.hint.xml(cm, local);\n                }\n                CodeMirror.registerHelper('hint', 'html', htmlHint);\n            }));\n        },\n        {\n            '72': 72,\n            '79': 79\n        }\n    ],\n    72: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                var Pos = CodeMirror.Pos;\n                function matches(hint, typed, matchInMiddle) {\n                    if (matchInMiddle)\n                        return hint.indexOf(typed) >= 0;\n                    else\n                        return hint.lastIndexOf(typed, 0) == 0;\n                }\n                function getHints(cm, options) {\n                    var tags = options && options.schemaInfo;\n                    var quote = options && options.quoteChar || '\"';\n                    var matchInMiddle = options && options.matchInMiddle;\n                    if (!tags)\n                        return;\n                    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n                    if (token.end > cur.ch) {\n                        token.end = cur.ch;\n                        token.string = token.string.slice(0, cur.ch - token.start);\n                    }\n                    var inner = CodeMirror.innerMode(cm.getMode(), token.state);\n                    if (!inner.mode.xmlCurrentTag)\n                        return;\n                    var result = [], replaceToken = false, prefix;\n                    var tag = /\\btag\\b/.test(token.type) && !/>$/.test(token.string);\n                    var tagName = tag && /^\\w/.test(token.string), tagStart;\n                    if (tagName) {\n                        var before = cm.getLine(cur.line).slice(Math.max(0, token.start - 2), token.start);\n                        var tagType = /<\\/$/.test(before) ? 'close' : /<$/.test(before) ? 'open' : null;\n                        if (tagType)\n                            tagStart = token.start - (tagType == 'close' ? 2 : 1);\n                    } else if (tag && token.string == '<') {\n                        tagType = 'open';\n                    } else if (tag && token.string == '</') {\n                        tagType = 'close';\n                    }\n                    var tagInfo = inner.mode.xmlCurrentTag(inner.state);\n                    if (!tag && !tagInfo || tagType) {\n                        if (tagName)\n                            prefix = token.string;\n                        replaceToken = tagType;\n                        var context = inner.mode.xmlCurrentContext ? inner.mode.xmlCurrentContext(inner.state) : [];\n                        var inner = context.length && context[context.length - 1];\n                        var curTag = inner && tags[inner];\n                        var childList = inner ? curTag && curTag.children : tags['!top'];\n                        if (childList && tagType != 'close') {\n                            for (var i = 0; i < childList.length; ++i)\n                                if (!prefix || matches(childList[i], prefix, matchInMiddle))\n                                    result.push('<' + childList[i]);\n                        } else if (tagType != 'close') {\n                            for (var name in tags)\n                                if (tags.hasOwnProperty(name) && name != '!top' && name != '!attrs' && (!prefix || matches(name, prefix, matchInMiddle)))\n                                    result.push('<' + name);\n                        }\n                        if (inner && (!prefix || tagType == 'close' && matches(inner, prefix, matchInMiddle)))\n                            result.push('</' + inner + '>');\n                    } else {\n                        var curTag = tagInfo && tags[tagInfo.name], attrs = curTag && curTag.attrs;\n                        var globalAttrs = tags['!attrs'];\n                        if (!attrs && !globalAttrs)\n                            return;\n                        if (!attrs) {\n                            attrs = globalAttrs;\n                        } else if (globalAttrs) {\n                            var set = {};\n                            for (var nm in globalAttrs)\n                                if (globalAttrs.hasOwnProperty(nm))\n                                    set[nm] = globalAttrs[nm];\n                            for (var nm in attrs)\n                                if (attrs.hasOwnProperty(nm))\n                                    set[nm] = attrs[nm];\n                            attrs = set;\n                        }\n                        if (token.type == 'string' || token.string == '=') {\n                            var before = cm.getRange(Pos(cur.line, Math.max(0, cur.ch - 60)), Pos(cur.line, token.type == 'string' ? token.start : token.end));\n                            var atName = before.match(/([^\\s\\u00a0=<>\\\"\\']+)=$/), atValues;\n                            if (!atName || !attrs.hasOwnProperty(atName[1]) || !(atValues = attrs[atName[1]]))\n                                return;\n                            if (typeof atValues == 'function')\n                                atValues = atValues.call(this, cm);\n                            if (token.type == 'string') {\n                                prefix = token.string;\n                                var n = 0;\n                                if (/['\"]/.test(token.string.charAt(0))) {\n                                    quote = token.string.charAt(0);\n                                    prefix = token.string.slice(1);\n                                    n++;\n                                }\n                                var len = token.string.length;\n                                if (/['\"]/.test(token.string.charAt(len - 1))) {\n                                    quote = token.string.charAt(len - 1);\n                                    prefix = token.string.substr(n, len - 2);\n                                }\n                                if (n) {\n                                    var line = cm.getLine(cur.line);\n                                    if (line.length > token.end && line.charAt(token.end) == quote)\n                                        token.end++;\n                                }\n                                replaceToken = true;\n                            }\n                            var returnHintsFromAtValues = function (atValues) {\n                                if (atValues)\n                                    for (var i = 0; i < atValues.length; ++i)\n                                        if (!prefix || matches(atValues[i], prefix, matchInMiddle))\n                                            result.push(quote + atValues[i] + quote);\n                                return returnHints();\n                            };\n                            if (atValues && atValues.then)\n                                return atValues.then(returnHintsFromAtValues);\n                            return returnHintsFromAtValues(atValues);\n                        } else {\n                            if (token.type == 'attribute') {\n                                prefix = token.string;\n                                replaceToken = true;\n                            }\n                            for (var attr in attrs)\n                                if (attrs.hasOwnProperty(attr) && (!prefix || matches(attr, prefix, matchInMiddle)))\n                                    result.push(attr);\n                        }\n                    }\n                    function returnHints() {\n                        return {\n                            list: result,\n                            from: replaceToken ? Pos(cur.line, tagStart == null ? token.start : tagStart) : cur,\n                            to: replaceToken ? Pos(cur.line, token.end) : cur\n                        };\n                    }\n                    return returnHints();\n                }\n                CodeMirror.registerHelper('hint', 'xml', getHints);\n            }));\n        },\n        { '79': 79 }\n    ],\n    68: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79), require(80));\n                else if (typeof define == 'function' && define.amd)\n                    define([\n                        '../../lib/codemirror',\n                        '../../mode/css/css'\n                    ], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                var pseudoClasses = {\n                    'active': 1,\n                    'after': 1,\n                    'before': 1,\n                    'checked': 1,\n                    'default': 1,\n                    'disabled': 1,\n                    'empty': 1,\n                    'enabled': 1,\n                    'first-child': 1,\n                    'first-letter': 1,\n                    'first-line': 1,\n                    'first-of-type': 1,\n                    'focus': 1,\n                    'hover': 1,\n                    'in-range': 1,\n                    'indeterminate': 1,\n                    'invalid': 1,\n                    'lang': 1,\n                    'last-child': 1,\n                    'last-of-type': 1,\n                    'link': 1,\n                    'not': 1,\n                    'nth-child': 1,\n                    'nth-last-child': 1,\n                    'nth-last-of-type': 1,\n                    'nth-of-type': 1,\n                    'only-of-type': 1,\n                    'only-child': 1,\n                    'optional': 1,\n                    'out-of-range': 1,\n                    'placeholder': 1,\n                    'read-only': 1,\n                    'read-write': 1,\n                    'required': 1,\n                    'root': 1,\n                    'selection': 1,\n                    'target': 1,\n                    'valid': 1,\n                    'visited': 1\n                };\n                CodeMirror.registerHelper('hint', 'css', function (cm) {\n                    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n                    var inner = CodeMirror.innerMode(cm.getMode(), token.state);\n                    if (inner.mode.name != 'css')\n                        return;\n                    if (token.type == 'keyword' && '!important'.indexOf(token.string) == 0)\n                        return {\n                            list: ['!important'],\n                            from: CodeMirror.Pos(cur.line, token.start),\n                            to: CodeMirror.Pos(cur.line, token.end)\n                        };\n                    var start = token.start, end = cur.ch, word = token.string.slice(0, end - start);\n                    if (/[^\\w$_-]/.test(word)) {\n                        word = '';\n                        start = end = cur.ch;\n                    }\n                    var spec = CodeMirror.resolveMode('text/css');\n                    var result = [];\n                    function add(keywords) {\n                        for (var name in keywords)\n                            if (!word || name.lastIndexOf(word, 0) == 0)\n                                result.push(name);\n                    }\n                    var st = inner.state.state;\n                    if (st == 'pseudo' || token.type == 'variable-3') {\n                        add(pseudoClasses);\n                    } else if (st == 'block' || st == 'maybeprop') {\n                        add(spec.propertyKeywords);\n                    } else if (st == 'prop' || st == 'parens' || st == 'at' || st == 'params') {\n                        add(spec.valueKeywords);\n                        add(spec.colorKeywords);\n                    } else if (st == 'media' || st == 'media_parens') {\n                        add(spec.mediaTypes);\n                        add(spec.mediaFeatures);\n                    }\n                    if (result.length)\n                        return {\n                            list: result,\n                            from: CodeMirror.Pos(cur.line, start),\n                            to: CodeMirror.Pos(cur.line, end)\n                        };\n                });\n            }));\n        },\n        {\n            '79': 79,\n            '80': 80\n        }\n    ],\n    80: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                CodeMirror.defineMode('css', function (config, parserConfig) {\n                    var inline = parserConfig.inline;\n                    if (!parserConfig.propertyKeywords)\n                        parserConfig = CodeMirror.resolveMode('text/css');\n                    var indentUnit = config.indentUnit, tokenHooks = parserConfig.tokenHooks, documentTypes = parserConfig.documentTypes || {}, mediaTypes = parserConfig.mediaTypes || {}, mediaFeatures = parserConfig.mediaFeatures || {}, mediaValueKeywords = parserConfig.mediaValueKeywords || {}, propertyKeywords = parserConfig.propertyKeywords || {}, nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {}, fontProperties = parserConfig.fontProperties || {}, counterDescriptors = parserConfig.counterDescriptors || {}, colorKeywords = parserConfig.colorKeywords || {}, valueKeywords = parserConfig.valueKeywords || {}, allowNested = parserConfig.allowNested, lineComment = parserConfig.lineComment, supportsAtComponent = parserConfig.supportsAtComponent === true, highlightNonStandardPropertyKeywords = config.highlightNonStandardPropertyKeywords !== false;\n                    var type, override;\n                    function ret(style, tp) {\n                        type = tp;\n                        return style;\n                    }\n                    function tokenBase(stream, state) {\n                        var ch = stream.next();\n                        if (tokenHooks[ch]) {\n                            var result = tokenHooks[ch](stream, state);\n                            if (result !== false)\n                                return result;\n                        }\n                        if (ch == '@') {\n                            stream.eatWhile(/[\\w\\\\\\-]/);\n                            return ret('def', stream.current());\n                        } else if (ch == '=' || (ch == '~' || ch == '|') && stream.eat('=')) {\n                            return ret(null, 'compare');\n                        } else if (ch == '\"' || ch == '\\'') {\n                            state.tokenize = tokenString(ch);\n                            return state.tokenize(stream, state);\n                        } else if (ch == '#') {\n                            stream.eatWhile(/[\\w\\\\\\-]/);\n                            return ret('atom', 'hash');\n                        } else if (ch == '!') {\n                            stream.match(/^\\s*\\w*/);\n                            return ret('keyword', 'important');\n                        } else if (/\\d/.test(ch) || ch == '.' && stream.eat(/\\d/)) {\n                            stream.eatWhile(/[\\w.%]/);\n                            return ret('number', 'unit');\n                        } else if (ch === '-') {\n                            if (/[\\d.]/.test(stream.peek())) {\n                                stream.eatWhile(/[\\w.%]/);\n                                return ret('number', 'unit');\n                            } else if (stream.match(/^-[\\w\\\\\\-]*/)) {\n                                stream.eatWhile(/[\\w\\\\\\-]/);\n                                if (stream.match(/^\\s*:/, false))\n                                    return ret('variable-2', 'variable-definition');\n                                return ret('variable-2', 'variable');\n                            } else if (stream.match(/^\\w+-/)) {\n                                return ret('meta', 'meta');\n                            }\n                        } else if (/[,+>*\\/]/.test(ch)) {\n                            return ret(null, 'select-op');\n                        } else if (ch == '.' && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n                            return ret('qualifier', 'qualifier');\n                        } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n                            return ret(null, ch);\n                        } else if (stream.match(/^[\\w-.]+(?=\\()/)) {\n                            if (/^(url(-prefix)?|domain|regexp)$/i.test(stream.current())) {\n                                state.tokenize = tokenParenthesized;\n                            }\n                            return ret('variable callee', 'variable');\n                        } else if (/[\\w\\\\\\-]/.test(ch)) {\n                            stream.eatWhile(/[\\w\\\\\\-]/);\n                            return ret('property', 'word');\n                        } else {\n                            return ret(null, null);\n                        }\n                    }\n                    function tokenString(quote) {\n                        return function (stream, state) {\n                            var escaped = false, ch;\n                            while ((ch = stream.next()) != null) {\n                                if (ch == quote && !escaped) {\n                                    if (quote == ')')\n                                        stream.backUp(1);\n                                    break;\n                                }\n                                escaped = !escaped && ch == '\\\\';\n                            }\n                            if (ch == quote || !escaped && quote != ')')\n                                state.tokenize = null;\n                            return ret('string', 'string');\n                        };\n                    }\n                    function tokenParenthesized(stream, state) {\n                        stream.next();\n                        if (!stream.match(/^\\s*[\\\"\\')]/, false))\n                            state.tokenize = tokenString(')');\n                        else\n                            state.tokenize = null;\n                        return ret(null, '(');\n                    }\n                    function Context(type, indent, prev) {\n                        this.type = type;\n                        this.indent = indent;\n                        this.prev = prev;\n                    }\n                    function pushContext(state, stream, type, indent) {\n                        state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);\n                        return type;\n                    }\n                    function popContext(state) {\n                        if (state.context.prev)\n                            state.context = state.context.prev;\n                        return state.context.type;\n                    }\n                    function pass(type, stream, state) {\n                        return states[state.context.type](type, stream, state);\n                    }\n                    function popAndPass(type, stream, state, n) {\n                        for (var i = n || 1; i > 0; i--)\n                            state.context = state.context.prev;\n                        return pass(type, stream, state);\n                    }\n                    function wordAsValue(stream) {\n                        var word = stream.current().toLowerCase();\n                        if (valueKeywords.hasOwnProperty(word))\n                            override = 'atom';\n                        else if (colorKeywords.hasOwnProperty(word))\n                            override = 'keyword';\n                        else\n                            override = 'variable';\n                    }\n                    var states = {};\n                    states.top = function (type, stream, state) {\n                        if (type == '{') {\n                            return pushContext(state, stream, 'block');\n                        } else if (type == '}' && state.context.prev) {\n                            return popContext(state);\n                        } else if (supportsAtComponent && /@component/i.test(type)) {\n                            return pushContext(state, stream, 'atComponentBlock');\n                        } else if (/^@(-moz-)?document$/i.test(type)) {\n                            return pushContext(state, stream, 'documentTypes');\n                        } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {\n                            return pushContext(state, stream, 'atBlock');\n                        } else if (/^@(font-face|counter-style)/i.test(type)) {\n                            state.stateArg = type;\n                            return 'restricted_atBlock_before';\n                        } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {\n                            return 'keyframes';\n                        } else if (type && type.charAt(0) == '@') {\n                            return pushContext(state, stream, 'at');\n                        } else if (type == 'hash') {\n                            override = 'builtin';\n                        } else if (type == 'word') {\n                            override = 'tag';\n                        } else if (type == 'variable-definition') {\n                            return 'maybeprop';\n                        } else if (type == 'interpolation') {\n                            return pushContext(state, stream, 'interpolation');\n                        } else if (type == ':') {\n                            return 'pseudo';\n                        } else if (allowNested && type == '(') {\n                            return pushContext(state, stream, 'parens');\n                        }\n                        return state.context.type;\n                    };\n                    states.block = function (type, stream, state) {\n                        if (type == 'word') {\n                            var word = stream.current().toLowerCase();\n                            if (propertyKeywords.hasOwnProperty(word)) {\n                                override = 'property';\n                                return 'maybeprop';\n                            } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {\n                                override = highlightNonStandardPropertyKeywords ? 'string-2' : 'property';\n                                return 'maybeprop';\n                            } else if (allowNested) {\n                                override = stream.match(/^\\s*:(?:\\s|$)/, false) ? 'property' : 'tag';\n                                return 'block';\n                            } else {\n                                override += ' error';\n                                return 'maybeprop';\n                            }\n                        } else if (type == 'meta') {\n                            return 'block';\n                        } else if (!allowNested && (type == 'hash' || type == 'qualifier')) {\n                            override = 'error';\n                            return 'block';\n                        } else {\n                            return states.top(type, stream, state);\n                        }\n                    };\n                    states.maybeprop = function (type, stream, state) {\n                        if (type == ':')\n                            return pushContext(state, stream, 'prop');\n                        return pass(type, stream, state);\n                    };\n                    states.prop = function (type, stream, state) {\n                        if (type == ';')\n                            return popContext(state);\n                        if (type == '{' && allowNested)\n                            return pushContext(state, stream, 'propBlock');\n                        if (type == '}' || type == '{')\n                            return popAndPass(type, stream, state);\n                        if (type == '(')\n                            return pushContext(state, stream, 'parens');\n                        if (type == 'hash' && !/^#([0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/.test(stream.current())) {\n                            override += ' error';\n                        } else if (type == 'word') {\n                            wordAsValue(stream);\n                        } else if (type == 'interpolation') {\n                            return pushContext(state, stream, 'interpolation');\n                        }\n                        return 'prop';\n                    };\n                    states.propBlock = function (type, _stream, state) {\n                        if (type == '}')\n                            return popContext(state);\n                        if (type == 'word') {\n                            override = 'property';\n                            return 'maybeprop';\n                        }\n                        return state.context.type;\n                    };\n                    states.parens = function (type, stream, state) {\n                        if (type == '{' || type == '}')\n                            return popAndPass(type, stream, state);\n                        if (type == ')')\n                            return popContext(state);\n                        if (type == '(')\n                            return pushContext(state, stream, 'parens');\n                        if (type == 'interpolation')\n                            return pushContext(state, stream, 'interpolation');\n                        if (type == 'word')\n                            wordAsValue(stream);\n                        return 'parens';\n                    };\n                    states.pseudo = function (type, stream, state) {\n                        if (type == 'meta')\n                            return 'pseudo';\n                        if (type == 'word') {\n                            override = 'variable-3';\n                            return state.context.type;\n                        }\n                        return pass(type, stream, state);\n                    };\n                    states.documentTypes = function (type, stream, state) {\n                        if (type == 'word' && documentTypes.hasOwnProperty(stream.current())) {\n                            override = 'tag';\n                            return state.context.type;\n                        } else {\n                            return states.atBlock(type, stream, state);\n                        }\n                    };\n                    states.atBlock = function (type, stream, state) {\n                        if (type == '(')\n                            return pushContext(state, stream, 'atBlock_parens');\n                        if (type == '}' || type == ';')\n                            return popAndPass(type, stream, state);\n                        if (type == '{')\n                            return popContext(state) && pushContext(state, stream, allowNested ? 'block' : 'top');\n                        if (type == 'interpolation')\n                            return pushContext(state, stream, 'interpolation');\n                        if (type == 'word') {\n                            var word = stream.current().toLowerCase();\n                            if (word == 'only' || word == 'not' || word == 'and' || word == 'or')\n                                override = 'keyword';\n                            else if (mediaTypes.hasOwnProperty(word))\n                                override = 'attribute';\n                            else if (mediaFeatures.hasOwnProperty(word))\n                                override = 'property';\n                            else if (mediaValueKeywords.hasOwnProperty(word))\n                                override = 'keyword';\n                            else if (propertyKeywords.hasOwnProperty(word))\n                                override = 'property';\n                            else if (nonStandardPropertyKeywords.hasOwnProperty(word))\n                                override = highlightNonStandardPropertyKeywords ? 'string-2' : 'property';\n                            else if (valueKeywords.hasOwnProperty(word))\n                                override = 'atom';\n                            else if (colorKeywords.hasOwnProperty(word))\n                                override = 'keyword';\n                            else\n                                override = 'error';\n                        }\n                        return state.context.type;\n                    };\n                    states.atComponentBlock = function (type, stream, state) {\n                        if (type == '}')\n                            return popAndPass(type, stream, state);\n                        if (type == '{')\n                            return popContext(state) && pushContext(state, stream, allowNested ? 'block' : 'top', false);\n                        if (type == 'word')\n                            override = 'error';\n                        return state.context.type;\n                    };\n                    states.atBlock_parens = function (type, stream, state) {\n                        if (type == ')')\n                            return popContext(state);\n                        if (type == '{' || type == '}')\n                            return popAndPass(type, stream, state, 2);\n                        return states.atBlock(type, stream, state);\n                    };\n                    states.restricted_atBlock_before = function (type, stream, state) {\n                        if (type == '{')\n                            return pushContext(state, stream, 'restricted_atBlock');\n                        if (type == 'word' && state.stateArg == '@counter-style') {\n                            override = 'variable';\n                            return 'restricted_atBlock_before';\n                        }\n                        return pass(type, stream, state);\n                    };\n                    states.restricted_atBlock = function (type, stream, state) {\n                        if (type == '}') {\n                            state.stateArg = null;\n                            return popContext(state);\n                        }\n                        if (type == 'word') {\n                            if (state.stateArg == '@font-face' && !fontProperties.hasOwnProperty(stream.current().toLowerCase()) || state.stateArg == '@counter-style' && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase()))\n                                override = 'error';\n                            else\n                                override = 'property';\n                            return 'maybeprop';\n                        }\n                        return 'restricted_atBlock';\n                    };\n                    states.keyframes = function (type, stream, state) {\n                        if (type == 'word') {\n                            override = 'variable';\n                            return 'keyframes';\n                        }\n                        if (type == '{')\n                            return pushContext(state, stream, 'top');\n                        return pass(type, stream, state);\n                    };\n                    states.at = function (type, stream, state) {\n                        if (type == ';')\n                            return popContext(state);\n                        if (type == '{' || type == '}')\n                            return popAndPass(type, stream, state);\n                        if (type == 'word')\n                            override = 'tag';\n                        else if (type == 'hash')\n                            override = 'builtin';\n                        return 'at';\n                    };\n                    states.interpolation = function (type, stream, state) {\n                        if (type == '}')\n                            return popContext(state);\n                        if (type == '{' || type == ';')\n                            return popAndPass(type, stream, state);\n                        if (type == 'word')\n                            override = 'variable';\n                        else if (type != 'variable' && type != '(' && type != ')')\n                            override = 'error';\n                        return 'interpolation';\n                    };\n                    return {\n                        startState: function (base) {\n                            return {\n                                tokenize: null,\n                                state: inline ? 'block' : 'top',\n                                stateArg: null,\n                                context: new Context(inline ? 'block' : 'top', base || 0, null)\n                            };\n                        },\n                        token: function (stream, state) {\n                            if (!state.tokenize && stream.eatSpace())\n                                return null;\n                            var style = (state.tokenize || tokenBase)(stream, state);\n                            if (style && typeof style == 'object') {\n                                type = style[1];\n                                style = style[0];\n                            }\n                            override = style;\n                            if (type != 'comment')\n                                state.state = states[state.state](type, stream, state);\n                            return override;\n                        },\n                        indent: function (state, textAfter) {\n                            var cx = state.context, ch = textAfter && textAfter.charAt(0);\n                            var indent = cx.indent;\n                            if (cx.type == 'prop' && (ch == '}' || ch == ')'))\n                                cx = cx.prev;\n                            if (cx.prev) {\n                                if (ch == '}' && (cx.type == 'block' || cx.type == 'top' || cx.type == 'interpolation' || cx.type == 'restricted_atBlock')) {\n                                    cx = cx.prev;\n                                    indent = cx.indent;\n                                } else if (ch == ')' && (cx.type == 'parens' || cx.type == 'atBlock_parens') || ch == '{' && (cx.type == 'at' || cx.type == 'atBlock')) {\n                                    indent = Math.max(0, cx.indent - indentUnit);\n                                }\n                            }\n                            return indent;\n                        },\n                        electricChars: '}',\n                        blockCommentStart: '/*',\n                        blockCommentEnd: '*/',\n                        blockCommentContinue: ' * ',\n                        lineComment: lineComment,\n                        fold: 'brace'\n                    };\n                });\n                function keySet(array) {\n                    var keys = {};\n                    for (var i = 0; i < array.length; ++i) {\n                        keys[array[i].toLowerCase()] = true;\n                    }\n                    return keys;\n                }\n                var documentTypes_ = [\n                        'domain',\n                        'regexp',\n                        'url',\n                        'url-prefix'\n                    ], documentTypes = keySet(documentTypes_);\n                var mediaTypes_ = [\n                        'all',\n                        'aural',\n                        'braille',\n                        'handheld',\n                        'print',\n                        'projection',\n                        'screen',\n                        'tty',\n                        'tv',\n                        'embossed'\n                    ], mediaTypes = keySet(mediaTypes_);\n                var mediaFeatures_ = [\n                        'width',\n                        'min-width',\n                        'max-width',\n                        'height',\n                        'min-height',\n                        'max-height',\n                        'device-width',\n                        'min-device-width',\n                        'max-device-width',\n                        'device-height',\n                        'min-device-height',\n                        'max-device-height',\n                        'aspect-ratio',\n                        'min-aspect-ratio',\n                        'max-aspect-ratio',\n                        'device-aspect-ratio',\n                        'min-device-aspect-ratio',\n                        'max-device-aspect-ratio',\n                        'color',\n                        'min-color',\n                        'max-color',\n                        'color-index',\n                        'min-color-index',\n                        'max-color-index',\n                        'monochrome',\n                        'min-monochrome',\n                        'max-monochrome',\n                        'resolution',\n                        'min-resolution',\n                        'max-resolution',\n                        'scan',\n                        'grid',\n                        'orientation',\n                        'device-pixel-ratio',\n                        'min-device-pixel-ratio',\n                        'max-device-pixel-ratio',\n                        'pointer',\n                        'any-pointer',\n                        'hover',\n                        'any-hover',\n                        'prefers-color-scheme',\n                        'dynamic-range',\n                        'video-dynamic-range'\n                    ], mediaFeatures = keySet(mediaFeatures_);\n                var mediaValueKeywords_ = [\n                        'landscape',\n                        'portrait',\n                        'none',\n                        'coarse',\n                        'fine',\n                        'on-demand',\n                        'hover',\n                        'interlace',\n                        'progressive',\n                        'dark',\n                        'light',\n                        'standard',\n                        'high'\n                    ], mediaValueKeywords = keySet(mediaValueKeywords_);\n                var propertyKeywords_ = [\n                        'align-content',\n                        'align-items',\n                        'align-self',\n                        'alignment-adjust',\n                        'alignment-baseline',\n                        'all',\n                        'anchor-point',\n                        'animation',\n                        'animation-delay',\n                        'animation-direction',\n                        'animation-duration',\n                        'animation-fill-mode',\n                        'animation-iteration-count',\n                        'animation-name',\n                        'animation-play-state',\n                        'animation-timing-function',\n                        'appearance',\n                        'azimuth',\n                        'backdrop-filter',\n                        'backface-visibility',\n                        'background',\n                        'background-attachment',\n                        'background-blend-mode',\n                        'background-clip',\n                        'background-color',\n                        'background-image',\n                        'background-origin',\n                        'background-position',\n                        'background-position-x',\n                        'background-position-y',\n                        'background-repeat',\n                        'background-size',\n                        'baseline-shift',\n                        'binding',\n                        'bleed',\n                        'block-size',\n                        'bookmark-label',\n                        'bookmark-level',\n                        'bookmark-state',\n                        'bookmark-target',\n                        'border',\n                        'border-bottom',\n                        'border-bottom-color',\n                        'border-bottom-left-radius',\n                        'border-bottom-right-radius',\n                        'border-bottom-style',\n                        'border-bottom-width',\n                        'border-collapse',\n                        'border-color',\n                        'border-image',\n                        'border-image-outset',\n                        'border-image-repeat',\n                        'border-image-slice',\n                        'border-image-source',\n                        'border-image-width',\n                        'border-left',\n                        'border-left-color',\n                        'border-left-style',\n                        'border-left-width',\n                        'border-radius',\n                        'border-right',\n                        'border-right-color',\n                        'border-right-style',\n                        'border-right-width',\n                        'border-spacing',\n                        'border-style',\n                        'border-top',\n                        'border-top-color',\n                        'border-top-left-radius',\n                        'border-top-right-radius',\n                        'border-top-style',\n                        'border-top-width',\n                        'border-width',\n                        'bottom',\n                        'box-decoration-break',\n                        'box-shadow',\n                        'box-sizing',\n                        'break-after',\n                        'break-before',\n                        'break-inside',\n                        'caption-side',\n                        'caret-color',\n                        'clear',\n                        'clip',\n                        'color',\n                        'color-profile',\n                        'column-count',\n                        'column-fill',\n                        'column-gap',\n                        'column-rule',\n                        'column-rule-color',\n                        'column-rule-style',\n                        'column-rule-width',\n                        'column-span',\n                        'column-width',\n                        'columns',\n                        'contain',\n                        'content',\n                        'counter-increment',\n                        'counter-reset',\n                        'crop',\n                        'cue',\n                        'cue-after',\n                        'cue-before',\n                        'cursor',\n                        'direction',\n                        'display',\n                        'dominant-baseline',\n                        'drop-initial-after-adjust',\n                        'drop-initial-after-align',\n                        'drop-initial-before-adjust',\n                        'drop-initial-before-align',\n                        'drop-initial-size',\n                        'drop-initial-value',\n                        'elevation',\n                        'empty-cells',\n                        'fit',\n                        'fit-content',\n                        'fit-position',\n                        'flex',\n                        'flex-basis',\n                        'flex-direction',\n                        'flex-flow',\n                        'flex-grow',\n                        'flex-shrink',\n                        'flex-wrap',\n                        'float',\n                        'float-offset',\n                        'flow-from',\n                        'flow-into',\n                        'font',\n                        'font-family',\n                        'font-feature-settings',\n                        'font-kerning',\n                        'font-language-override',\n                        'font-optical-sizing',\n                        'font-size',\n                        'font-size-adjust',\n                        'font-stretch',\n                        'font-style',\n                        'font-synthesis',\n                        'font-variant',\n                        'font-variant-alternates',\n                        'font-variant-caps',\n                        'font-variant-east-asian',\n                        'font-variant-ligatures',\n                        'font-variant-numeric',\n                        'font-variant-position',\n                        'font-variation-settings',\n                        'font-weight',\n                        'gap',\n                        'grid',\n                        'grid-area',\n                        'grid-auto-columns',\n                        'grid-auto-flow',\n                        'grid-auto-rows',\n                        'grid-column',\n                        'grid-column-end',\n                        'grid-column-gap',\n                        'grid-column-start',\n                        'grid-gap',\n                        'grid-row',\n                        'grid-row-end',\n                        'grid-row-gap',\n                        'grid-row-start',\n                        'grid-template',\n                        'grid-template-areas',\n                        'grid-template-columns',\n                        'grid-template-rows',\n                        'hanging-punctuation',\n                        'height',\n                        'hyphens',\n                        'icon',\n                        'image-orientation',\n                        'image-rendering',\n                        'image-resolution',\n                        'inline-box-align',\n                        'inset',\n                        'inset-block',\n                        'inset-block-end',\n                        'inset-block-start',\n                        'inset-inline',\n                        'inset-inline-end',\n                        'inset-inline-start',\n                        'isolation',\n                        'justify-content',\n                        'justify-items',\n                        'justify-self',\n                        'left',\n                        'letter-spacing',\n                        'line-break',\n                        'line-height',\n                        'line-height-step',\n                        'line-stacking',\n                        'line-stacking-ruby',\n                        'line-stacking-shift',\n                        'line-stacking-strategy',\n                        'list-style',\n                        'list-style-image',\n                        'list-style-position',\n                        'list-style-type',\n                        'margin',\n                        'margin-bottom',\n                        'margin-left',\n                        'margin-right',\n                        'margin-top',\n                        'marks',\n                        'marquee-direction',\n                        'marquee-loop',\n                        'marquee-play-count',\n                        'marquee-speed',\n                        'marquee-style',\n                        'mask-clip',\n                        'mask-composite',\n                        'mask-image',\n                        'mask-mode',\n                        'mask-origin',\n                        'mask-position',\n                        'mask-repeat',\n                        'mask-size',\n                        'mask-type',\n                        'max-block-size',\n                        'max-height',\n                        'max-inline-size',\n                        'max-width',\n                        'min-block-size',\n                        'min-height',\n                        'min-inline-size',\n                        'min-width',\n                        'mix-blend-mode',\n                        'move-to',\n                        'nav-down',\n                        'nav-index',\n                        'nav-left',\n                        'nav-right',\n                        'nav-up',\n                        'object-fit',\n                        'object-position',\n                        'offset',\n                        'offset-anchor',\n                        'offset-distance',\n                        'offset-path',\n                        'offset-position',\n                        'offset-rotate',\n                        'opacity',\n                        'order',\n                        'orphans',\n                        'outline',\n                        'outline-color',\n                        'outline-offset',\n                        'outline-style',\n                        'outline-width',\n                        'overflow',\n                        'overflow-style',\n                        'overflow-wrap',\n                        'overflow-x',\n                        'overflow-y',\n                        'padding',\n                        'padding-bottom',\n                        'padding-left',\n                        'padding-right',\n                        'padding-top',\n                        'page',\n                        'page-break-after',\n                        'page-break-before',\n                        'page-break-inside',\n                        'page-policy',\n                        'pause',\n                        'pause-after',\n                        'pause-before',\n                        'perspective',\n                        'perspective-origin',\n                        'pitch',\n                        'pitch-range',\n                        'place-content',\n                        'place-items',\n                        'place-self',\n                        'play-during',\n                        'position',\n                        'presentation-level',\n                        'punctuation-trim',\n                        'quotes',\n                        'region-break-after',\n                        'region-break-before',\n                        'region-break-inside',\n                        'region-fragment',\n                        'rendering-intent',\n                        'resize',\n                        'rest',\n                        'rest-after',\n                        'rest-before',\n                        'richness',\n                        'right',\n                        'rotate',\n                        'rotation',\n                        'rotation-point',\n                        'row-gap',\n                        'ruby-align',\n                        'ruby-overhang',\n                        'ruby-position',\n                        'ruby-span',\n                        'scale',\n                        'scroll-behavior',\n                        'scroll-margin',\n                        'scroll-margin-block',\n                        'scroll-margin-block-end',\n                        'scroll-margin-block-start',\n                        'scroll-margin-bottom',\n                        'scroll-margin-inline',\n                        'scroll-margin-inline-end',\n                        'scroll-margin-inline-start',\n                        'scroll-margin-left',\n                        'scroll-margin-right',\n                        'scroll-margin-top',\n                        'scroll-padding',\n                        'scroll-padding-block',\n                        'scroll-padding-block-end',\n                        'scroll-padding-block-start',\n                        'scroll-padding-bottom',\n                        'scroll-padding-inline',\n                        'scroll-padding-inline-end',\n                        'scroll-padding-inline-start',\n                        'scroll-padding-left',\n                        'scroll-padding-right',\n                        'scroll-padding-top',\n                        'scroll-snap-align',\n                        'scroll-snap-type',\n                        'shape-image-threshold',\n                        'shape-inside',\n                        'shape-margin',\n                        'shape-outside',\n                        'size',\n                        'speak',\n                        'speak-as',\n                        'speak-header',\n                        'speak-numeral',\n                        'speak-punctuation',\n                        'speech-rate',\n                        'stress',\n                        'string-set',\n                        'tab-size',\n                        'table-layout',\n                        'target',\n                        'target-name',\n                        'target-new',\n                        'target-position',\n                        'text-align',\n                        'text-align-last',\n                        'text-combine-upright',\n                        'text-decoration',\n                        'text-decoration-color',\n                        'text-decoration-line',\n                        'text-decoration-skip',\n                        'text-decoration-skip-ink',\n                        'text-decoration-style',\n                        'text-emphasis',\n                        'text-emphasis-color',\n                        'text-emphasis-position',\n                        'text-emphasis-style',\n                        'text-height',\n                        'text-indent',\n                        'text-justify',\n                        'text-orientation',\n                        'text-outline',\n                        'text-overflow',\n                        'text-rendering',\n                        'text-shadow',\n                        'text-size-adjust',\n                        'text-space-collapse',\n                        'text-transform',\n                        'text-underline-position',\n                        'text-wrap',\n                        'top',\n                        'touch-action',\n                        'transform',\n                        'transform-origin',\n                        'transform-style',\n                        'transition',\n                        'transition-delay',\n                        'transition-duration',\n                        'transition-property',\n                        'transition-timing-function',\n                        'translate',\n                        'unicode-bidi',\n                        'user-select',\n                        'vertical-align',\n                        'visibility',\n                        'voice-balance',\n                        'voice-duration',\n                        'voice-family',\n                        'voice-pitch',\n                        'voice-range',\n                        'voice-rate',\n                        'voice-stress',\n                        'voice-volume',\n                        'volume',\n                        'white-space',\n                        'widows',\n                        'width',\n                        'will-change',\n                        'word-break',\n                        'word-spacing',\n                        'word-wrap',\n                        'writing-mode',\n                        'z-index',\n                        'clip-path',\n                        'clip-rule',\n                        'mask',\n                        'enable-background',\n                        'filter',\n                        'flood-color',\n                        'flood-opacity',\n                        'lighting-color',\n                        'stop-color',\n                        'stop-opacity',\n                        'pointer-events',\n                        'color-interpolation',\n                        'color-interpolation-filters',\n                        'color-rendering',\n                        'fill',\n                        'fill-opacity',\n                        'fill-rule',\n                        'image-rendering',\n                        'marker',\n                        'marker-end',\n                        'marker-mid',\n                        'marker-start',\n                        'paint-order',\n                        'shape-rendering',\n                        'stroke',\n                        'stroke-dasharray',\n                        'stroke-dashoffset',\n                        'stroke-linecap',\n                        'stroke-linejoin',\n                        'stroke-miterlimit',\n                        'stroke-opacity',\n                        'stroke-width',\n                        'text-rendering',\n                        'baseline-shift',\n                        'dominant-baseline',\n                        'glyph-orientation-horizontal',\n                        'glyph-orientation-vertical',\n                        'text-anchor',\n                        'writing-mode'\n                    ], propertyKeywords = keySet(propertyKeywords_);\n                var nonStandardPropertyKeywords_ = [\n                        'accent-color',\n                        'aspect-ratio',\n                        'border-block',\n                        'border-block-color',\n                        'border-block-end',\n                        'border-block-end-color',\n                        'border-block-end-style',\n                        'border-block-end-width',\n                        'border-block-start',\n                        'border-block-start-color',\n                        'border-block-start-style',\n                        'border-block-start-width',\n                        'border-block-style',\n                        'border-block-width',\n                        'border-inline',\n                        'border-inline-color',\n                        'border-inline-end',\n                        'border-inline-end-color',\n                        'border-inline-end-style',\n                        'border-inline-end-width',\n                        'border-inline-start',\n                        'border-inline-start-color',\n                        'border-inline-start-style',\n                        'border-inline-start-width',\n                        'border-inline-style',\n                        'border-inline-width',\n                        'content-visibility',\n                        'margin-block',\n                        'margin-block-end',\n                        'margin-block-start',\n                        'margin-inline',\n                        'margin-inline-end',\n                        'margin-inline-start',\n                        'overflow-anchor',\n                        'overscroll-behavior',\n                        'padding-block',\n                        'padding-block-end',\n                        'padding-block-start',\n                        'padding-inline',\n                        'padding-inline-end',\n                        'padding-inline-start',\n                        'scroll-snap-stop',\n                        'scrollbar-3d-light-color',\n                        'scrollbar-arrow-color',\n                        'scrollbar-base-color',\n                        'scrollbar-dark-shadow-color',\n                        'scrollbar-face-color',\n                        'scrollbar-highlight-color',\n                        'scrollbar-shadow-color',\n                        'scrollbar-track-color',\n                        'searchfield-cancel-button',\n                        'searchfield-decoration',\n                        'searchfield-results-button',\n                        'searchfield-results-decoration',\n                        'shape-inside',\n                        'zoom'\n                    ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);\n                var fontProperties_ = [\n                        'font-display',\n                        'font-family',\n                        'src',\n                        'unicode-range',\n                        'font-variant',\n                        'font-feature-settings',\n                        'font-stretch',\n                        'font-weight',\n                        'font-style'\n                    ], fontProperties = keySet(fontProperties_);\n                var counterDescriptors_ = [\n                        'additive-symbols',\n                        'fallback',\n                        'negative',\n                        'pad',\n                        'prefix',\n                        'range',\n                        'speak-as',\n                        'suffix',\n                        'symbols',\n                        'system'\n                    ], counterDescriptors = keySet(counterDescriptors_);\n                var colorKeywords_ = [\n                        'aliceblue',\n                        'antiquewhite',\n                        'aqua',\n                        'aquamarine',\n                        'azure',\n                        'beige',\n                        'bisque',\n                        'black',\n                        'blanchedalmond',\n                        'blue',\n                        'blueviolet',\n                        'brown',\n                        'burlywood',\n                        'cadetblue',\n                        'chartreuse',\n                        'chocolate',\n                        'coral',\n                        'cornflowerblue',\n                        'cornsilk',\n                        'crimson',\n                        'cyan',\n                        'darkblue',\n                        'darkcyan',\n                        'darkgoldenrod',\n                        'darkgray',\n                        'darkgreen',\n                        'darkgrey',\n                        'darkkhaki',\n                        'darkmagenta',\n                        'darkolivegreen',\n                        'darkorange',\n                        'darkorchid',\n                        'darkred',\n                        'darksalmon',\n                        'darkseagreen',\n                        'darkslateblue',\n                        'darkslategray',\n                        'darkslategrey',\n                        'darkturquoise',\n                        'darkviolet',\n                        'deeppink',\n                        'deepskyblue',\n                        'dimgray',\n                        'dimgrey',\n                        'dodgerblue',\n                        'firebrick',\n                        'floralwhite',\n                        'forestgreen',\n                        'fuchsia',\n                        'gainsboro',\n                        'ghostwhite',\n                        'gold',\n                        'goldenrod',\n                        'gray',\n                        'grey',\n                        'green',\n                        'greenyellow',\n                        'honeydew',\n                        'hotpink',\n                        'indianred',\n                        'indigo',\n                        'ivory',\n                        'khaki',\n                        'lavender',\n                        'lavenderblush',\n                        'lawngreen',\n                        'lemonchiffon',\n                        'lightblue',\n                        'lightcoral',\n                        'lightcyan',\n                        'lightgoldenrodyellow',\n                        'lightgray',\n                        'lightgreen',\n                        'lightgrey',\n                        'lightpink',\n                        'lightsalmon',\n                        'lightseagreen',\n                        'lightskyblue',\n                        'lightslategray',\n                        'lightslategrey',\n                        'lightsteelblue',\n                        'lightyellow',\n                        'lime',\n                        'limegreen',\n                        'linen',\n                        'magenta',\n                        'maroon',\n                        'mediumaquamarine',\n                        'mediumblue',\n                        'mediumorchid',\n                        'mediumpurple',\n                        'mediumseagreen',\n                        'mediumslateblue',\n                        'mediumspringgreen',\n                        'mediumturquoise',\n                        'mediumvioletred',\n                        'midnightblue',\n                        'mintcream',\n                        'mistyrose',\n                        'moccasin',\n                        'navajowhite',\n                        'navy',\n                        'oldlace',\n                        'olive',\n                        'olivedrab',\n                        'orange',\n                        'orangered',\n                        'orchid',\n                        'palegoldenrod',\n                        'palegreen',\n                        'paleturquoise',\n                        'palevioletred',\n                        'papayawhip',\n                        'peachpuff',\n                        'peru',\n                        'pink',\n                        'plum',\n                        'powderblue',\n                        'purple',\n                        'rebeccapurple',\n                        'red',\n                        'rosybrown',\n                        'royalblue',\n                        'saddlebrown',\n                        'salmon',\n                        'sandybrown',\n                        'seagreen',\n                        'seashell',\n                        'sienna',\n                        'silver',\n                        'skyblue',\n                        'slateblue',\n                        'slategray',\n                        'slategrey',\n                        'snow',\n                        'springgreen',\n                        'steelblue',\n                        'tan',\n                        'teal',\n                        'thistle',\n                        'tomato',\n                        'turquoise',\n                        'violet',\n                        'wheat',\n                        'white',\n                        'whitesmoke',\n                        'yellow',\n                        'yellowgreen'\n                    ], colorKeywords = keySet(colorKeywords_);\n                var valueKeywords_ = [\n                        'above',\n                        'absolute',\n                        'activeborder',\n                        'additive',\n                        'activecaption',\n                        'afar',\n                        'after-white-space',\n                        'ahead',\n                        'alias',\n                        'all',\n                        'all-scroll',\n                        'alphabetic',\n                        'alternate',\n                        'always',\n                        'amharic',\n                        'amharic-abegede',\n                        'antialiased',\n                        'appworkspace',\n                        'arabic-indic',\n                        'armenian',\n                        'asterisks',\n                        'attr',\n                        'auto',\n                        'auto-flow',\n                        'avoid',\n                        'avoid-column',\n                        'avoid-page',\n                        'avoid-region',\n                        'axis-pan',\n                        'background',\n                        'backwards',\n                        'baseline',\n                        'below',\n                        'bidi-override',\n                        'binary',\n                        'bengali',\n                        'blink',\n                        'block',\n                        'block-axis',\n                        'blur',\n                        'bold',\n                        'bolder',\n                        'border',\n                        'border-box',\n                        'both',\n                        'bottom',\n                        'break',\n                        'break-all',\n                        'break-word',\n                        'brightness',\n                        'bullets',\n                        'button',\n                        'buttonface',\n                        'buttonhighlight',\n                        'buttonshadow',\n                        'buttontext',\n                        'calc',\n                        'cambodian',\n                        'capitalize',\n                        'caps-lock-indicator',\n                        'caption',\n                        'captiontext',\n                        'caret',\n                        'cell',\n                        'center',\n                        'checkbox',\n                        'circle',\n                        'cjk-decimal',\n                        'cjk-earthly-branch',\n                        'cjk-heavenly-stem',\n                        'cjk-ideographic',\n                        'clear',\n                        'clip',\n                        'close-quote',\n                        'col-resize',\n                        'collapse',\n                        'color',\n                        'color-burn',\n                        'color-dodge',\n                        'column',\n                        'column-reverse',\n                        'compact',\n                        'condensed',\n                        'conic-gradient',\n                        'contain',\n                        'content',\n                        'contents',\n                        'content-box',\n                        'context-menu',\n                        'continuous',\n                        'contrast',\n                        'copy',\n                        'counter',\n                        'counters',\n                        'cover',\n                        'crop',\n                        'cross',\n                        'crosshair',\n                        'cubic-bezier',\n                        'currentcolor',\n                        'cursive',\n                        'cyclic',\n                        'darken',\n                        'dashed',\n                        'decimal',\n                        'decimal-leading-zero',\n                        'default',\n                        'default-button',\n                        'dense',\n                        'destination-atop',\n                        'destination-in',\n                        'destination-out',\n                        'destination-over',\n                        'devanagari',\n                        'difference',\n                        'disc',\n                        'discard',\n                        'disclosure-closed',\n                        'disclosure-open',\n                        'document',\n                        'dot-dash',\n                        'dot-dot-dash',\n                        'dotted',\n                        'double',\n                        'down',\n                        'drop-shadow',\n                        'e-resize',\n                        'ease',\n                        'ease-in',\n                        'ease-in-out',\n                        'ease-out',\n                        'element',\n                        'ellipse',\n                        'ellipsis',\n                        'embed',\n                        'end',\n                        'ethiopic',\n                        'ethiopic-abegede',\n                        'ethiopic-abegede-am-et',\n                        'ethiopic-abegede-gez',\n                        'ethiopic-abegede-ti-er',\n                        'ethiopic-abegede-ti-et',\n                        'ethiopic-halehame-aa-er',\n                        'ethiopic-halehame-aa-et',\n                        'ethiopic-halehame-am-et',\n                        'ethiopic-halehame-gez',\n                        'ethiopic-halehame-om-et',\n                        'ethiopic-halehame-sid-et',\n                        'ethiopic-halehame-so-et',\n                        'ethiopic-halehame-ti-er',\n                        'ethiopic-halehame-ti-et',\n                        'ethiopic-halehame-tig',\n                        'ethiopic-numeric',\n                        'ew-resize',\n                        'exclusion',\n                        'expanded',\n                        'extends',\n                        'extra-condensed',\n                        'extra-expanded',\n                        'fantasy',\n                        'fast',\n                        'fill',\n                        'fill-box',\n                        'fixed',\n                        'flat',\n                        'flex',\n                        'flex-end',\n                        'flex-start',\n                        'footnotes',\n                        'forwards',\n                        'from',\n                        'geometricPrecision',\n                        'georgian',\n                        'grayscale',\n                        'graytext',\n                        'grid',\n                        'groove',\n                        'gujarati',\n                        'gurmukhi',\n                        'hand',\n                        'hangul',\n                        'hangul-consonant',\n                        'hard-light',\n                        'hebrew',\n                        'help',\n                        'hidden',\n                        'hide',\n                        'higher',\n                        'highlight',\n                        'highlighttext',\n                        'hiragana',\n                        'hiragana-iroha',\n                        'horizontal',\n                        'hsl',\n                        'hsla',\n                        'hue',\n                        'hue-rotate',\n                        'icon',\n                        'ignore',\n                        'inactiveborder',\n                        'inactivecaption',\n                        'inactivecaptiontext',\n                        'infinite',\n                        'infobackground',\n                        'infotext',\n                        'inherit',\n                        'initial',\n                        'inline',\n                        'inline-axis',\n                        'inline-block',\n                        'inline-flex',\n                        'inline-grid',\n                        'inline-table',\n                        'inset',\n                        'inside',\n                        'intrinsic',\n                        'invert',\n                        'italic',\n                        'japanese-formal',\n                        'japanese-informal',\n                        'justify',\n                        'kannada',\n                        'katakana',\n                        'katakana-iroha',\n                        'keep-all',\n                        'khmer',\n                        'korean-hangul-formal',\n                        'korean-hanja-formal',\n                        'korean-hanja-informal',\n                        'landscape',\n                        'lao',\n                        'large',\n                        'larger',\n                        'left',\n                        'level',\n                        'lighter',\n                        'lighten',\n                        'line-through',\n                        'linear',\n                        'linear-gradient',\n                        'lines',\n                        'list-item',\n                        'listbox',\n                        'listitem',\n                        'local',\n                        'logical',\n                        'loud',\n                        'lower',\n                        'lower-alpha',\n                        'lower-armenian',\n                        'lower-greek',\n                        'lower-hexadecimal',\n                        'lower-latin',\n                        'lower-norwegian',\n                        'lower-roman',\n                        'lowercase',\n                        'ltr',\n                        'luminosity',\n                        'malayalam',\n                        'manipulation',\n                        'match',\n                        'matrix',\n                        'matrix3d',\n                        'media-play-button',\n                        'media-slider',\n                        'media-sliderthumb',\n                        'media-volume-slider',\n                        'media-volume-sliderthumb',\n                        'medium',\n                        'menu',\n                        'menulist',\n                        'menulist-button',\n                        'menutext',\n                        'message-box',\n                        'middle',\n                        'min-intrinsic',\n                        'mix',\n                        'mongolian',\n                        'monospace',\n                        'move',\n                        'multiple',\n                        'multiple_mask_images',\n                        'multiply',\n                        'myanmar',\n                        'n-resize',\n                        'narrower',\n                        'ne-resize',\n                        'nesw-resize',\n                        'no-close-quote',\n                        'no-drop',\n                        'no-open-quote',\n                        'no-repeat',\n                        'none',\n                        'normal',\n                        'not-allowed',\n                        'nowrap',\n                        'ns-resize',\n                        'numbers',\n                        'numeric',\n                        'nw-resize',\n                        'nwse-resize',\n                        'oblique',\n                        'octal',\n                        'opacity',\n                        'open-quote',\n                        'optimizeLegibility',\n                        'optimizeSpeed',\n                        'oriya',\n                        'oromo',\n                        'outset',\n                        'outside',\n                        'outside-shape',\n                        'overlay',\n                        'overline',\n                        'padding',\n                        'padding-box',\n                        'painted',\n                        'page',\n                        'paused',\n                        'persian',\n                        'perspective',\n                        'pinch-zoom',\n                        'plus-darker',\n                        'plus-lighter',\n                        'pointer',\n                        'polygon',\n                        'portrait',\n                        'pre',\n                        'pre-line',\n                        'pre-wrap',\n                        'preserve-3d',\n                        'progress',\n                        'push-button',\n                        'radial-gradient',\n                        'radio',\n                        'read-only',\n                        'read-write',\n                        'read-write-plaintext-only',\n                        'rectangle',\n                        'region',\n                        'relative',\n                        'repeat',\n                        'repeating-linear-gradient',\n                        'repeating-radial-gradient',\n                        'repeating-conic-gradient',\n                        'repeat-x',\n                        'repeat-y',\n                        'reset',\n                        'reverse',\n                        'rgb',\n                        'rgba',\n                        'ridge',\n                        'right',\n                        'rotate',\n                        'rotate3d',\n                        'rotateX',\n                        'rotateY',\n                        'rotateZ',\n                        'round',\n                        'row',\n                        'row-resize',\n                        'row-reverse',\n                        'rtl',\n                        'run-in',\n                        'running',\n                        's-resize',\n                        'sans-serif',\n                        'saturate',\n                        'saturation',\n                        'scale',\n                        'scale3d',\n                        'scaleX',\n                        'scaleY',\n                        'scaleZ',\n                        'screen',\n                        'scroll',\n                        'scrollbar',\n                        'scroll-position',\n                        'se-resize',\n                        'searchfield',\n                        'searchfield-cancel-button',\n                        'searchfield-decoration',\n                        'searchfield-results-button',\n                        'searchfield-results-decoration',\n                        'self-start',\n                        'self-end',\n                        'semi-condensed',\n                        'semi-expanded',\n                        'separate',\n                        'sepia',\n                        'serif',\n                        'show',\n                        'sidama',\n                        'simp-chinese-formal',\n                        'simp-chinese-informal',\n                        'single',\n                        'skew',\n                        'skewX',\n                        'skewY',\n                        'skip-white-space',\n                        'slide',\n                        'slider-horizontal',\n                        'slider-vertical',\n                        'sliderthumb-horizontal',\n                        'sliderthumb-vertical',\n                        'slow',\n                        'small',\n                        'small-caps',\n                        'small-caption',\n                        'smaller',\n                        'soft-light',\n                        'solid',\n                        'somali',\n                        'source-atop',\n                        'source-in',\n                        'source-out',\n                        'source-over',\n                        'space',\n                        'space-around',\n                        'space-between',\n                        'space-evenly',\n                        'spell-out',\n                        'square',\n                        'square-button',\n                        'start',\n                        'static',\n                        'status-bar',\n                        'stretch',\n                        'stroke',\n                        'stroke-box',\n                        'sub',\n                        'subpixel-antialiased',\n                        'svg_masks',\n                        'super',\n                        'sw-resize',\n                        'symbolic',\n                        'symbols',\n                        'system-ui',\n                        'table',\n                        'table-caption',\n                        'table-cell',\n                        'table-column',\n                        'table-column-group',\n                        'table-footer-group',\n                        'table-header-group',\n                        'table-row',\n                        'table-row-group',\n                        'tamil',\n                        'telugu',\n                        'text',\n                        'text-bottom',\n                        'text-top',\n                        'textarea',\n                        'textfield',\n                        'thai',\n                        'thick',\n                        'thin',\n                        'threeddarkshadow',\n                        'threedface',\n                        'threedhighlight',\n                        'threedlightshadow',\n                        'threedshadow',\n                        'tibetan',\n                        'tigre',\n                        'tigrinya-er',\n                        'tigrinya-er-abegede',\n                        'tigrinya-et',\n                        'tigrinya-et-abegede',\n                        'to',\n                        'top',\n                        'trad-chinese-formal',\n                        'trad-chinese-informal',\n                        'transform',\n                        'translate',\n                        'translate3d',\n                        'translateX',\n                        'translateY',\n                        'translateZ',\n                        'transparent',\n                        'ultra-condensed',\n                        'ultra-expanded',\n                        'underline',\n                        'unidirectional-pan',\n                        'unset',\n                        'up',\n                        'upper-alpha',\n                        'upper-armenian',\n                        'upper-greek',\n                        'upper-hexadecimal',\n                        'upper-latin',\n                        'upper-norwegian',\n                        'upper-roman',\n                        'uppercase',\n                        'urdu',\n                        'url',\n                        'var',\n                        'vertical',\n                        'vertical-text',\n                        'view-box',\n                        'visible',\n                        'visibleFill',\n                        'visiblePainted',\n                        'visibleStroke',\n                        'visual',\n                        'w-resize',\n                        'wait',\n                        'wave',\n                        'wider',\n                        'window',\n                        'windowframe',\n                        'windowtext',\n                        'words',\n                        'wrap',\n                        'wrap-reverse',\n                        'x-large',\n                        'x-small',\n                        'xor',\n                        'xx-large',\n                        'xx-small'\n                    ], valueKeywords = keySet(valueKeywords_);\n                var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);\n                CodeMirror.registerHelper('hintWords', 'css', allWords);\n                function tokenCComment(stream, state) {\n                    var maybeEnd = false, ch;\n                    while ((ch = stream.next()) != null) {\n                        if (maybeEnd && ch == '/') {\n                            state.tokenize = null;\n                            break;\n                        }\n                        maybeEnd = ch == '*';\n                    }\n                    return [\n                        'comment',\n                        'comment'\n                    ];\n                }\n                CodeMirror.defineMIME('text/css', {\n                    documentTypes: documentTypes,\n                    mediaTypes: mediaTypes,\n                    mediaFeatures: mediaFeatures,\n                    mediaValueKeywords: mediaValueKeywords,\n                    propertyKeywords: propertyKeywords,\n                    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n                    fontProperties: fontProperties,\n                    counterDescriptors: counterDescriptors,\n                    colorKeywords: colorKeywords,\n                    valueKeywords: valueKeywords,\n                    tokenHooks: {\n                        '/': function (stream, state) {\n                            if (!stream.eat('*'))\n                                return false;\n                            state.tokenize = tokenCComment;\n                            return tokenCComment(stream, state);\n                        }\n                    },\n                    name: 'css'\n                });\n                CodeMirror.defineMIME('text/x-scss', {\n                    mediaTypes: mediaTypes,\n                    mediaFeatures: mediaFeatures,\n                    mediaValueKeywords: mediaValueKeywords,\n                    propertyKeywords: propertyKeywords,\n                    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n                    colorKeywords: colorKeywords,\n                    valueKeywords: valueKeywords,\n                    fontProperties: fontProperties,\n                    allowNested: true,\n                    lineComment: '//',\n                    tokenHooks: {\n                        '/': function (stream, state) {\n                            if (stream.eat('/')) {\n                                stream.skipToEnd();\n                                return [\n                                    'comment',\n                                    'comment'\n                                ];\n                            } else if (stream.eat('*')) {\n                                state.tokenize = tokenCComment;\n                                return tokenCComment(stream, state);\n                            } else {\n                                return [\n                                    'operator',\n                                    'operator'\n                                ];\n                            }\n                        },\n                        ':': function (stream) {\n                            if (stream.match(/^\\s*\\{/, false))\n                                return [\n                                    null,\n                                    null\n                                ];\n                            return false;\n                        },\n                        '$': function (stream) {\n                            stream.match(/^[\\w-]+/);\n                            if (stream.match(/^\\s*:/, false))\n                                return [\n                                    'variable-2',\n                                    'variable-definition'\n                                ];\n                            return [\n                                'variable-2',\n                                'variable'\n                            ];\n                        },\n                        '#': function (stream) {\n                            if (!stream.eat('{'))\n                                return false;\n                            return [\n                                null,\n                                'interpolation'\n                            ];\n                        }\n                    },\n                    name: 'css',\n                    helperType: 'scss'\n                });\n                CodeMirror.defineMIME('text/x-less', {\n                    mediaTypes: mediaTypes,\n                    mediaFeatures: mediaFeatures,\n                    mediaValueKeywords: mediaValueKeywords,\n                    propertyKeywords: propertyKeywords,\n                    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n                    colorKeywords: colorKeywords,\n                    valueKeywords: valueKeywords,\n                    fontProperties: fontProperties,\n                    allowNested: true,\n                    lineComment: '//',\n                    tokenHooks: {\n                        '/': function (stream, state) {\n                            if (stream.eat('/')) {\n                                stream.skipToEnd();\n                                return [\n                                    'comment',\n                                    'comment'\n                                ];\n                            } else if (stream.eat('*')) {\n                                state.tokenize = tokenCComment;\n                                return tokenCComment(stream, state);\n                            } else {\n                                return [\n                                    'operator',\n                                    'operator'\n                                ];\n                            }\n                        },\n                        '@': function (stream) {\n                            if (stream.eat('{'))\n                                return [\n                                    null,\n                                    'interpolation'\n                                ];\n                            if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\\b/i, false))\n                                return false;\n                            stream.eatWhile(/[\\w\\\\\\-]/);\n                            if (stream.match(/^\\s*:/, false))\n                                return [\n                                    'variable-2',\n                                    'variable-definition'\n                                ];\n                            return [\n                                'variable-2',\n                                'variable'\n                            ];\n                        },\n                        '&': function () {\n                            return [\n                                'atom',\n                                'atom'\n                            ];\n                        }\n                    },\n                    name: 'css',\n                    helperType: 'less'\n                });\n                CodeMirror.defineMIME('text/x-gss', {\n                    documentTypes: documentTypes,\n                    mediaTypes: mediaTypes,\n                    mediaFeatures: mediaFeatures,\n                    propertyKeywords: propertyKeywords,\n                    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n                    fontProperties: fontProperties,\n                    counterDescriptors: counterDescriptors,\n                    colorKeywords: colorKeywords,\n                    valueKeywords: valueKeywords,\n                    supportsAtComponent: true,\n                    tokenHooks: {\n                        '/': function (stream, state) {\n                            if (!stream.eat('*'))\n                                return false;\n                            state.tokenize = tokenCComment;\n                            return tokenCComment(stream, state);\n                        }\n                    },\n                    name: 'css',\n                    helperType: 'gss'\n                });\n            }));\n        },\n        { '79': 79 }\n    ],\n    67: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                var WORD = /[\\w$]+/, RANGE = 500;\n                CodeMirror.registerHelper('hint', 'anyword', function (editor, options) {\n                    var word = options && options.word || WORD;\n                    var range = options && options.range || RANGE;\n                    var cur = editor.getCursor(), curLine = editor.getLine(cur.line);\n                    var end = cur.ch, start = end;\n                    while (start && word.test(curLine.charAt(start - 1)))\n                        --start;\n                    var curWord = start != end && curLine.slice(start, end);\n                    var list = options && options.list || [], seen = {};\n                    var re = new RegExp(word.source, 'g');\n                    for (var dir = -1; dir <= 1; dir += 2) {\n                        var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;\n                        for (; line != endLine; line += dir) {\n                            var text = editor.getLine(line), m;\n                            while (m = re.exec(text)) {\n                                if (line == cur.line && m[0] === curWord)\n                                    continue;\n                                if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {\n                                    seen[m[0]] = true;\n                                    list.push(m[0]);\n                                }\n                            }\n                        }\n                    }\n                    return {\n                        list: list,\n                        from: CodeMirror.Pos(cur.line, start),\n                        to: CodeMirror.Pos(cur.line, end)\n                    };\n                });\n            }));\n        },\n        { '79': 79 }\n    ],\n    65: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                CodeMirror.defineOption('showTrailingSpace', false, function (cm, val, prev) {\n                    if (prev == CodeMirror.Init)\n                        prev = false;\n                    if (prev && !val)\n                        cm.removeOverlay('trailingspace');\n                    else if (!prev && val)\n                        cm.addOverlay({\n                            token: function (stream) {\n                                for (var l = stream.string.length, i = l; i && /\\s/.test(stream.string.charAt(i - 1)); --i) {\n                                }\n                                if (i > stream.pos) {\n                                    stream.pos = i;\n                                    return null;\n                                }\n                                stream.pos = l;\n                                return 'trailingspace';\n                            },\n                            name: 'trailingspace'\n                        });\n                });\n            }));\n        },\n        { '79': 79 }\n    ],\n    64: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79), require(66));\n                else if (typeof define == 'function' && define.amd)\n                    define([\n                        '../../lib/codemirror',\n                        '../fold/xml-fold'\n                    ], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                CodeMirror.defineOption('matchTags', false, function (cm, val, old) {\n                    if (old && old != CodeMirror.Init) {\n                        cm.off('cursorActivity', doMatchTags);\n                        cm.off('viewportChange', maybeUpdateMatch);\n                        clear(cm);\n                    }\n                    if (val) {\n                        cm.state.matchBothTags = typeof val == 'object' && val.bothTags;\n                        cm.on('cursorActivity', doMatchTags);\n                        cm.on('viewportChange', maybeUpdateMatch);\n                        doMatchTags(cm);\n                    }\n                });\n                function clear(cm) {\n                    if (cm.state.tagHit)\n                        cm.state.tagHit.clear();\n                    if (cm.state.tagOther)\n                        cm.state.tagOther.clear();\n                    cm.state.tagHit = cm.state.tagOther = null;\n                }\n                function doMatchTags(cm) {\n                    cm.state.failedTagMatch = false;\n                    cm.operation(function () {\n                        clear(cm);\n                        if (cm.somethingSelected())\n                            return;\n                        var cur = cm.getCursor(), range = cm.getViewport();\n                        range.from = Math.min(range.from, cur.line);\n                        range.to = Math.max(cur.line + 1, range.to);\n                        var match = CodeMirror.findMatchingTag(cm, cur, range);\n                        if (!match)\n                            return;\n                        if (cm.state.matchBothTags) {\n                            var hit = match.at == 'open' ? match.open : match.close;\n                            if (hit)\n                                cm.state.tagHit = cm.markText(hit.from, hit.to, { className: 'CodeMirror-matchingtag' });\n                        }\n                        var other = match.at == 'close' ? match.open : match.close;\n                        if (other)\n                            cm.state.tagOther = cm.markText(other.from, other.to, { className: 'CodeMirror-matchingtag' });\n                        else\n                            cm.state.failedTagMatch = true;\n                    });\n                }\n                function maybeUpdateMatch(cm) {\n                    if (cm.state.failedTagMatch)\n                        doMatchTags(cm);\n                }\n                CodeMirror.commands.toMatchingTag = function (cm) {\n                    var found = CodeMirror.findMatchingTag(cm, cm.getCursor());\n                    if (found) {\n                        var other = found.at == 'close' ? found.open : found.close;\n                        if (other)\n                            cm.extendSelection(other.to, other.from);\n                    }\n                };\n            }));\n        },\n        {\n            '66': 66,\n            '79': 79\n        }\n    ],\n    63: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);\n                var Pos = CodeMirror.Pos;\n                var matching = {\n                    '(': ')>',\n                    ')': '(<',\n                    '[': ']>',\n                    ']': '[<',\n                    '{': '}>',\n                    '}': '{<',\n                    '<': '>>',\n                    '>': '<<'\n                };\n                function bracketRegex(config) {\n                    return config && config.bracketRegex || /[(){}[\\]]/;\n                }\n                function findMatchingBracket(cm, where, config) {\n                    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n                    var afterCursor = config && config.afterCursor;\n                    if (afterCursor == null)\n                        afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);\n                    var re = bracketRegex(config);\n                    var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n                    if (!match)\n                        return null;\n                    var dir = match.charAt(1) == '>' ? 1 : -1;\n                    if (config && config.strict && dir > 0 != (pos == where.ch))\n                        return null;\n                    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n                    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);\n                    if (found == null)\n                        return null;\n                    return {\n                        from: Pos(where.line, pos),\n                        to: found && found.pos,\n                        match: found && found.ch == match.charAt(0),\n                        forward: dir > 0\n                    };\n                }\n                function scanForBracket(cm, where, dir, style, config) {\n                    var maxScanLen = config && config.maxScanLineLength || 10000;\n                    var maxScanLines = config && config.maxScanLines || 1000;\n                    var stack = [];\n                    var re = bracketRegex(config);\n                    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n                    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n                        var line = cm.getLine(lineNo);\n                        if (!line)\n                            continue;\n                        var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n                        if (line.length > maxScanLen)\n                            continue;\n                        if (lineNo == where.line)\n                            pos = where.ch - (dir < 0 ? 1 : 0);\n                        for (; pos != end; pos += dir) {\n                            var ch = line.charAt(pos);\n                            if (re.test(ch) && (style === undefined || (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || '') == (style || ''))) {\n                                var match = matching[ch];\n                                if (match && match.charAt(1) == '>' == dir > 0)\n                                    stack.push(ch);\n                                else if (!stack.length)\n                                    return {\n                                        pos: Pos(lineNo, pos),\n                                        ch: ch\n                                    };\n                                else\n                                    stack.pop();\n                            }\n                        }\n                    }\n                    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n                }\n                function matchBrackets(cm, autoclear, config) {\n                    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000, highlightNonMatching = config && config.highlightNonMatching;\n                    var marks = [], ranges = cm.listSelections();\n                    for (var i = 0; i < ranges.length; i++) {\n                        var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n                        if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {\n                            var style = match.match ? 'CodeMirror-matchingbracket' : 'CodeMirror-nonmatchingbracket';\n                            marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), { className: style }));\n                            if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n                                marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), { className: style }));\n                        }\n                    }\n                    if (marks.length) {\n                        if (ie_lt8 && cm.state.focused)\n                            cm.focus();\n                        var clear = function () {\n                            cm.operation(function () {\n                                for (var i = 0; i < marks.length; i++)\n                                    marks[i].clear();\n                            });\n                        };\n                        if (autoclear)\n                            setTimeout(clear, 800);\n                        else\n                            return clear;\n                    }\n                }\n                function doMatchBrackets(cm) {\n                    cm.operation(function () {\n                        if (cm.state.matchBrackets.currentlyHighlighted) {\n                            cm.state.matchBrackets.currentlyHighlighted();\n                            cm.state.matchBrackets.currentlyHighlighted = null;\n                        }\n                        cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n                    });\n                }\n                function clearHighlighted(cm) {\n                    if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n                        cm.state.matchBrackets.currentlyHighlighted();\n                        cm.state.matchBrackets.currentlyHighlighted = null;\n                    }\n                }\n                CodeMirror.defineOption('matchBrackets', false, function (cm, val, old) {\n                    if (old && old != CodeMirror.Init) {\n                        cm.off('cursorActivity', doMatchBrackets);\n                        cm.off('focus', doMatchBrackets);\n                        cm.off('blur', clearHighlighted);\n                        clearHighlighted(cm);\n                    }\n                    if (val) {\n                        cm.state.matchBrackets = typeof val == 'object' ? val : {};\n                        cm.on('cursorActivity', doMatchBrackets);\n                        cm.on('focus', doMatchBrackets);\n                        cm.on('blur', clearHighlighted);\n                    }\n                });\n                CodeMirror.defineExtension('matchBrackets', function () {\n                    matchBrackets(this, true);\n                });\n                CodeMirror.defineExtension('findMatchingBracket', function (pos, config, oldConfig) {\n                    if (oldConfig || typeof config == 'boolean') {\n                        if (!oldConfig) {\n                            config = config ? { strict: true } : null;\n                        } else {\n                            oldConfig.strict = config;\n                            config = oldConfig;\n                        }\n                    }\n                    return findMatchingBracket(this, pos, config);\n                });\n                CodeMirror.defineExtension('scanForBracket', function (pos, dir, style, config) {\n                    return scanForBracket(this, pos, dir, style, config);\n                });\n            }));\n        },\n        { '79': 79 }\n    ],\n    62: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                var listRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]\\s|[*+-]\\s|(\\d+)([.)]))(\\s*)/, emptyListRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]|[*+-]|(\\d+)[.)])(\\s*)$/, unorderedListRE = /[*+-]\\s/;\n                CodeMirror.commands.newlineAndIndentContinueMarkdownList = function (cm) {\n                    if (cm.getOption('disableInput'))\n                        return CodeMirror.Pass;\n                    var ranges = cm.listSelections(), replacements = [];\n                    for (var i = 0; i < ranges.length; i++) {\n                        var pos = ranges[i].head;\n                        var eolState = cm.getStateAfter(pos.line);\n                        var inner = CodeMirror.innerMode(cm.getMode(), eolState);\n                        if (inner.mode.name !== 'markdown' && inner.mode.helperType !== 'markdown') {\n                            cm.execCommand('newlineAndIndent');\n                            return;\n                        } else {\n                            eolState = inner.state;\n                        }\n                        var inList = eolState.list !== false;\n                        var inQuote = eolState.quote !== 0;\n                        var line = cm.getLine(pos.line), match = listRE.exec(line);\n                        var cursorBeforeBullet = /^\\s*$/.test(line.slice(0, pos.ch));\n                        if (!ranges[i].empty() || !inList && !inQuote || !match || cursorBeforeBullet) {\n                            cm.execCommand('newlineAndIndent');\n                            return;\n                        }\n                        if (emptyListRE.test(line)) {\n                            var endOfQuote = inQuote && />\\s*$/.test(line);\n                            var endOfList = !/>\\s*$/.test(line);\n                            if (endOfQuote || endOfList)\n                                cm.replaceRange('', {\n                                    line: pos.line,\n                                    ch: 0\n                                }, {\n                                    line: pos.line,\n                                    ch: pos.ch + 1\n                                });\n                            replacements[i] = '\\n';\n                        } else {\n                            var indent = match[1], after = match[5];\n                            var numbered = !(unorderedListRE.test(match[2]) || match[2].indexOf('>') >= 0);\n                            var bullet = numbered ? parseInt(match[3], 10) + 1 + match[4] : match[2].replace('x', ' ');\n                            replacements[i] = '\\n' + indent + bullet + after;\n                            if (numbered)\n                                incrementRemainingMarkdownListNumbers(cm, pos);\n                        }\n                    }\n                    cm.replaceSelections(replacements);\n                };\n                function incrementRemainingMarkdownListNumbers(cm, pos) {\n                    var startLine = pos.line, lookAhead = 0, skipCount = 0;\n                    var startItem = listRE.exec(cm.getLine(startLine)), startIndent = startItem[1];\n                    do {\n                        lookAhead += 1;\n                        var nextLineNumber = startLine + lookAhead;\n                        var nextLine = cm.getLine(nextLineNumber), nextItem = listRE.exec(nextLine);\n                        if (nextItem) {\n                            var nextIndent = nextItem[1];\n                            var newNumber = parseInt(startItem[3], 10) + lookAhead - skipCount;\n                            var nextNumber = parseInt(nextItem[3], 10), itemNumber = nextNumber;\n                            if (startIndent === nextIndent && !isNaN(nextNumber)) {\n                                if (newNumber === nextNumber)\n                                    itemNumber = nextNumber + 1;\n                                if (newNumber > nextNumber)\n                                    itemNumber = newNumber + 1;\n                                cm.replaceRange(nextLine.replace(listRE, nextIndent + itemNumber + nextItem[4] + nextItem[5]), {\n                                    line: nextLineNumber,\n                                    ch: 0\n                                }, {\n                                    line: nextLineNumber,\n                                    ch: nextLine.length\n                                });\n                            } else {\n                                if (startIndent.length > nextIndent.length)\n                                    return;\n                                if (startIndent.length < nextIndent.length && lookAhead === 1)\n                                    return;\n                                skipCount += 1;\n                            }\n                        }\n                    } while (nextItem);\n                }\n            }));\n        },\n        { '79': 79 }\n    ],\n    61: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79), require(66));\n                else if (typeof define == 'function' && define.amd)\n                    define([\n                        '../../lib/codemirror',\n                        '../fold/xml-fold'\n                    ], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                CodeMirror.defineOption('autoCloseTags', false, function (cm, val, old) {\n                    if (old != CodeMirror.Init && old)\n                        cm.removeKeyMap('autoCloseTags');\n                    if (!val)\n                        return;\n                    var map = { name: 'autoCloseTags' };\n                    if (typeof val != 'object' || val.whenClosing !== false)\n                        map['\\'/\\''] = function (cm) {\n                            return autoCloseSlash(cm);\n                        };\n                    if (typeof val != 'object' || val.whenOpening !== false)\n                        map['\\'>\\''] = function (cm) {\n                            return autoCloseGT(cm);\n                        };\n                    cm.addKeyMap(map);\n                });\n                var htmlDontClose = [\n                    'area',\n                    'base',\n                    'br',\n                    'col',\n                    'command',\n                    'embed',\n                    'hr',\n                    'img',\n                    'input',\n                    'keygen',\n                    'link',\n                    'meta',\n                    'param',\n                    'source',\n                    'track',\n                    'wbr'\n                ];\n                var htmlIndent = [\n                    'applet',\n                    'blockquote',\n                    'body',\n                    'button',\n                    'div',\n                    'dl',\n                    'fieldset',\n                    'form',\n                    'frameset',\n                    'h1',\n                    'h2',\n                    'h3',\n                    'h4',\n                    'h5',\n                    'h6',\n                    'head',\n                    'html',\n                    'iframe',\n                    'layer',\n                    'legend',\n                    'object',\n                    'ol',\n                    'p',\n                    'select',\n                    'table',\n                    'ul'\n                ];\n                function autoCloseGT(cm) {\n                    if (cm.getOption('disableInput'))\n                        return CodeMirror.Pass;\n                    var ranges = cm.listSelections(), replacements = [];\n                    var opt = cm.getOption('autoCloseTags');\n                    for (var i = 0; i < ranges.length; i++) {\n                        if (!ranges[i].empty())\n                            return CodeMirror.Pass;\n                        var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n                        var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n                        var tagInfo = inner.mode.xmlCurrentTag && inner.mode.xmlCurrentTag(state);\n                        var tagName = tagInfo && tagInfo.name;\n                        if (!tagName)\n                            return CodeMirror.Pass;\n                        var html = inner.mode.configuration == 'html';\n                        var dontCloseTags = typeof opt == 'object' && opt.dontCloseTags || html && htmlDontClose;\n                        var indentTags = typeof opt == 'object' && opt.indentTags || html && htmlIndent;\n                        if (tok.end > pos.ch)\n                            tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);\n                        var lowerTagName = tagName.toLowerCase();\n                        if (!tagName || tok.type == 'string' && (tok.end != pos.ch || !/[\\\"\\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) || tok.type == 'tag' && tagInfo.close || tok.string.indexOf('/') == pos.ch - tok.start - 1 || dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 || closingTagExists(cm, inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state) || [], tagName, pos, true))\n                            return CodeMirror.Pass;\n                        var emptyTags = typeof opt == 'object' && opt.emptyTags;\n                        if (emptyTags && indexOf(emptyTags, tagName) > -1) {\n                            replacements[i] = {\n                                text: '/>',\n                                newPos: CodeMirror.Pos(pos.line, pos.ch + 2)\n                            };\n                            continue;\n                        }\n                        var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;\n                        replacements[i] = {\n                            indent: indent,\n                            text: '>' + (indent ? '\\n\\n' : '') + '</' + tagName + '>',\n                            newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1)\n                        };\n                    }\n                    var dontIndentOnAutoClose = typeof opt == 'object' && opt.dontIndentOnAutoClose;\n                    for (var i = ranges.length - 1; i >= 0; i--) {\n                        var info = replacements[i];\n                        cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, '+insert');\n                        var sel = cm.listSelections().slice(0);\n                        sel[i] = {\n                            head: info.newPos,\n                            anchor: info.newPos\n                        };\n                        cm.setSelections(sel);\n                        if (!dontIndentOnAutoClose && info.indent) {\n                            cm.indentLine(info.newPos.line, null, true);\n                            cm.indentLine(info.newPos.line + 1, null, true);\n                        }\n                    }\n                }\n                function autoCloseCurrent(cm, typingSlash) {\n                    var ranges = cm.listSelections(), replacements = [];\n                    var head = typingSlash ? '/' : '</';\n                    var opt = cm.getOption('autoCloseTags');\n                    var dontIndentOnAutoClose = typeof opt == 'object' && opt.dontIndentOnSlash;\n                    for (var i = 0; i < ranges.length; i++) {\n                        if (!ranges[i].empty())\n                            return CodeMirror.Pass;\n                        var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n                        var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n                        if (typingSlash && (tok.type == 'string' || tok.string.charAt(0) != '<' || tok.start != pos.ch - 1))\n                            return CodeMirror.Pass;\n                        var replacement, mixed = inner.mode.name != 'xml' && cm.getMode().name == 'htmlmixed';\n                        if (mixed && inner.mode.name == 'javascript') {\n                            replacement = head + 'script';\n                        } else if (mixed && inner.mode.name == 'css') {\n                            replacement = head + 'style';\n                        } else {\n                            var context = inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state);\n                            var top = context.length ? context[context.length - 1] : '';\n                            if (!context || context.length && closingTagExists(cm, context, top, pos))\n                                return CodeMirror.Pass;\n                            replacement = head + top;\n                        }\n                        if (cm.getLine(pos.line).charAt(tok.end) != '>')\n                            replacement += '>';\n                        replacements[i] = replacement;\n                    }\n                    cm.replaceSelections(replacements);\n                    ranges = cm.listSelections();\n                    if (!dontIndentOnAutoClose) {\n                        for (var i = 0; i < ranges.length; i++)\n                            if (i == ranges.length - 1 || ranges[i].head.line < ranges[i + 1].head.line)\n                                cm.indentLine(ranges[i].head.line);\n                    }\n                }\n                function autoCloseSlash(cm) {\n                    if (cm.getOption('disableInput'))\n                        return CodeMirror.Pass;\n                    return autoCloseCurrent(cm, true);\n                }\n                CodeMirror.commands.closeTag = function (cm) {\n                    return autoCloseCurrent(cm);\n                };\n                function indexOf(collection, elt) {\n                    if (collection.indexOf)\n                        return collection.indexOf(elt);\n                    for (var i = 0, e = collection.length; i < e; ++i)\n                        if (collection[i] == elt)\n                            return i;\n                    return -1;\n                }\n                function closingTagExists(cm, context, tagName, pos, newTag) {\n                    if (!CodeMirror.scanForClosingTag)\n                        return false;\n                    var end = Math.min(cm.lastLine() + 1, pos.line + 500);\n                    var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);\n                    if (!nextClose || nextClose.tag != tagName)\n                        return false;\n                    var onCx = newTag ? 1 : 0;\n                    for (var i = context.length - 1; i >= 0; i--) {\n                        if (context[i] == tagName)\n                            ++onCx;\n                        else\n                            break;\n                    }\n                    pos = nextClose.to;\n                    for (var i = 1; i < onCx; i++) {\n                        var next = CodeMirror.scanForClosingTag(cm, pos, null, end);\n                        if (!next || next.tag != tagName)\n                            return false;\n                        pos = next.to;\n                    }\n                    return true;\n                }\n            }));\n        },\n        {\n            '66': 66,\n            '79': 79\n        }\n    ],\n    66: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                'use strict';\n                var Pos = CodeMirror.Pos;\n                function cmp(a, b) {\n                    return a.line - b.line || a.ch - b.ch;\n                }\n                var nameStartChar = 'A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\n                var nameChar = nameStartChar + '-:.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\n                var xmlTagStart = new RegExp('<(/?)([' + nameStartChar + '][' + nameChar + ']*)', 'g');\n                function Iter(cm, line, ch, range) {\n                    this.line = line;\n                    this.ch = ch;\n                    this.cm = cm;\n                    this.text = cm.getLine(line);\n                    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();\n                    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();\n                }\n                function tagAt(iter, ch) {\n                    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));\n                    return type && /\\btag\\b/.test(type);\n                }\n                function nextLine(iter) {\n                    if (iter.line >= iter.max)\n                        return;\n                    iter.ch = 0;\n                    iter.text = iter.cm.getLine(++iter.line);\n                    return true;\n                }\n                function prevLine(iter) {\n                    if (iter.line <= iter.min)\n                        return;\n                    iter.text = iter.cm.getLine(--iter.line);\n                    iter.ch = iter.text.length;\n                    return true;\n                }\n                function toTagEnd(iter) {\n                    for (;;) {\n                        var gt = iter.text.indexOf('>', iter.ch);\n                        if (gt == -1) {\n                            if (nextLine(iter))\n                                continue;\n                            else\n                                return;\n                        }\n                        if (!tagAt(iter, gt + 1)) {\n                            iter.ch = gt + 1;\n                            continue;\n                        }\n                        var lastSlash = iter.text.lastIndexOf('/', gt);\n                        var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n                        iter.ch = gt + 1;\n                        return selfClose ? 'selfClose' : 'regular';\n                    }\n                }\n                function toTagStart(iter) {\n                    for (;;) {\n                        var lt = iter.ch ? iter.text.lastIndexOf('<', iter.ch - 1) : -1;\n                        if (lt == -1) {\n                            if (prevLine(iter))\n                                continue;\n                            else\n                                return;\n                        }\n                        if (!tagAt(iter, lt + 1)) {\n                            iter.ch = lt;\n                            continue;\n                        }\n                        xmlTagStart.lastIndex = lt;\n                        iter.ch = lt;\n                        var match = xmlTagStart.exec(iter.text);\n                        if (match && match.index == lt)\n                            return match;\n                    }\n                }\n                function toNextTag(iter) {\n                    for (;;) {\n                        xmlTagStart.lastIndex = iter.ch;\n                        var found = xmlTagStart.exec(iter.text);\n                        if (!found) {\n                            if (nextLine(iter))\n                                continue;\n                            else\n                                return;\n                        }\n                        if (!tagAt(iter, found.index + 1)) {\n                            iter.ch = found.index + 1;\n                            continue;\n                        }\n                        iter.ch = found.index + found[0].length;\n                        return found;\n                    }\n                }\n                function toPrevTag(iter) {\n                    for (;;) {\n                        var gt = iter.ch ? iter.text.lastIndexOf('>', iter.ch - 1) : -1;\n                        if (gt == -1) {\n                            if (prevLine(iter))\n                                continue;\n                            else\n                                return;\n                        }\n                        if (!tagAt(iter, gt + 1)) {\n                            iter.ch = gt;\n                            continue;\n                        }\n                        var lastSlash = iter.text.lastIndexOf('/', gt);\n                        var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n                        iter.ch = gt + 1;\n                        return selfClose ? 'selfClose' : 'regular';\n                    }\n                }\n                function findMatchingClose(iter, tag) {\n                    var stack = [];\n                    for (;;) {\n                        var next = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next ? next[0].length : 0);\n                        if (!next || !(end = toTagEnd(iter)))\n                            return;\n                        if (end == 'selfClose')\n                            continue;\n                        if (next[1]) {\n                            for (var i = stack.length - 1; i >= 0; --i)\n                                if (stack[i] == next[2]) {\n                                    stack.length = i;\n                                    break;\n                                }\n                            if (i < 0 && (!tag || tag == next[2]))\n                                return {\n                                    tag: next[2],\n                                    from: Pos(startLine, startCh),\n                                    to: Pos(iter.line, iter.ch)\n                                };\n                        } else {\n                            stack.push(next[2]);\n                        }\n                    }\n                }\n                function findMatchingOpen(iter, tag) {\n                    var stack = [];\n                    for (;;) {\n                        var prev = toPrevTag(iter);\n                        if (!prev)\n                            return;\n                        if (prev == 'selfClose') {\n                            toTagStart(iter);\n                            continue;\n                        }\n                        var endLine = iter.line, endCh = iter.ch;\n                        var start = toTagStart(iter);\n                        if (!start)\n                            return;\n                        if (start[1]) {\n                            stack.push(start[2]);\n                        } else {\n                            for (var i = stack.length - 1; i >= 0; --i)\n                                if (stack[i] == start[2]) {\n                                    stack.length = i;\n                                    break;\n                                }\n                            if (i < 0 && (!tag || tag == start[2]))\n                                return {\n                                    tag: start[2],\n                                    from: Pos(iter.line, iter.ch),\n                                    to: Pos(endLine, endCh)\n                                };\n                        }\n                    }\n                }\n                CodeMirror.registerHelper('fold', 'xml', function (cm, start) {\n                    var iter = new Iter(cm, start.line, 0);\n                    for (;;) {\n                        var openTag = toNextTag(iter);\n                        if (!openTag || iter.line != start.line)\n                            return;\n                        var end = toTagEnd(iter);\n                        if (!end)\n                            return;\n                        if (!openTag[1] && end != 'selfClose') {\n                            var startPos = Pos(iter.line, iter.ch);\n                            var endPos = findMatchingClose(iter, openTag[2]);\n                            return endPos && cmp(endPos.from, startPos) > 0 ? {\n                                from: startPos,\n                                to: endPos.from\n                            } : null;\n                        }\n                    }\n                });\n                CodeMirror.findMatchingTag = function (cm, pos, range) {\n                    var iter = new Iter(cm, pos.line, pos.ch, range);\n                    if (iter.text.indexOf('>') == -1 && iter.text.indexOf('<') == -1)\n                        return;\n                    var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);\n                    var start = end && toTagStart(iter);\n                    if (!end || !start || cmp(iter, pos) > 0)\n                        return;\n                    var here = {\n                        from: Pos(iter.line, iter.ch),\n                        to: to,\n                        tag: start[2]\n                    };\n                    if (end == 'selfClose')\n                        return {\n                            open: here,\n                            close: null,\n                            at: 'open'\n                        };\n                    if (start[1]) {\n                        return {\n                            open: findMatchingOpen(iter, start[2]),\n                            close: here,\n                            at: 'close'\n                        };\n                    } else {\n                        iter = new Iter(cm, to.line, to.ch, range);\n                        return {\n                            open: here,\n                            close: findMatchingClose(iter, start[2]),\n                            at: 'open'\n                        };\n                    }\n                };\n                CodeMirror.findEnclosingTag = function (cm, pos, range, tag) {\n                    var iter = new Iter(cm, pos.line, pos.ch, range);\n                    for (;;) {\n                        var open = findMatchingOpen(iter, tag);\n                        if (!open)\n                            break;\n                        var forward = new Iter(cm, pos.line, pos.ch, range);\n                        var close = findMatchingClose(forward, open.tag);\n                        if (close)\n                            return {\n                                open: open,\n                                close: close\n                            };\n                    }\n                };\n                CodeMirror.scanForClosingTag = function (cm, pos, name, end) {\n                    var iter = new Iter(cm, pos.line, pos.ch, end ? {\n                        from: 0,\n                        to: end\n                    } : null);\n                    return findMatchingClose(iter, name);\n                };\n            }));\n        },\n        { '79': 79 }\n    ],\n    60: [\n        function (require, module, exports) {\n            (function (mod) {\n                if (typeof exports == 'object' && typeof module == 'object')\n                    mod(require(79));\n                else if (typeof define == 'function' && define.amd)\n                    define(['../../lib/codemirror'], mod);\n                else\n                    mod(CodeMirror);\n            }(function (CodeMirror) {\n                var defaults = {\n                    pairs: '()[]{}\\'\\'\"\"',\n                    closeBefore: ')]}\\'\":;>',\n                    triples: '',\n                    explode: '[]{}'\n                };\n                var Pos = CodeMirror.Pos;\n                CodeMirror.defineOption('autoCloseBrackets', false, function (cm, val, old) {\n                    if (old && old != CodeMirror.Init) {\n                        cm.removeKeyMap(keyMap);\n                        cm.state.closeBrackets = null;\n                    }\n                    if (val) {\n                        ensureBound(getOption(val, 'pairs'));\n                        cm.state.closeBrackets = val;\n                        cm.addKeyMap(keyMap);\n                    }\n                });\n                function getOption(conf, name) {\n                    if (name == 'pairs' && typeof conf == 'string')\n                        return conf;\n                    if (typeof conf == 'object' && conf[name] != null)\n                        return conf[name];\n                    return defaults[name];\n                }\n                var keyMap = {\n                    Backspace: handleBackspace,\n                    Enter: handleEnter\n                };\n                function ensureBound(chars) {\n                    for (var i = 0; i < chars.length; i++) {\n                        var ch = chars.charAt(i), key = '\\'' + ch + '\\'';\n                        if (!keyMap[key])\n                            keyMap[key] = handler(ch);\n                    }\n                }\n                ensureBound(defaults.pairs + '`');\n                function handler(ch) {\n                    return function (cm) {\n                        return handleChar(cm, ch);\n                    };\n                }\n                function getConfig(cm) {\n                    var deflt = cm.state.closeBrackets;\n                    if (!deflt || deflt.override)\n                        return deflt;\n                    var mode = cm.getModeAt(cm.getCursor());\n                    return mode.closeBrackets || deflt;\n                }\n                function handleBackspace(cm) {\n                    var conf = getConfig(cm);\n                    if (!conf || cm.getOption('disableInput'))\n                        return CodeMirror.Pass;\n                    var pairs = getOption(conf, 'pairs');\n                    var ranges = cm.listSelections();\n                    for (var i = 0; i < ranges.length; i++) {\n                        if (!ranges[i].empty())\n                            return CodeMirror.Pass;\n                        var around = charsAround(cm, ranges[i].head);\n                        if (!around || pairs.indexOf(around) % 2 != 0)\n                            return CodeMirror.Pass;\n                    }\n                    for (var i = ranges.length - 1; i >= 0; i--) {\n                        var cur = ranges[i].head;\n                        cm.replaceRange('', Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), '+delete');\n                    }\n                }\n                function handleEnter(cm) {\n                    var conf = getConfig(cm);\n                    var explode = conf && getOption(conf, 'explode');\n                    if (!explode || cm.getOption('disableInput'))\n                        return CodeMirror.Pass;\n                    var ranges = cm.listSelections();\n                    for (var i = 0; i < ranges.length; i++) {\n                        if (!ranges[i].empty())\n                            return CodeMirror.Pass;\n                        var around = charsAround(cm, ranges[i].head);\n                        if (!around || explode.indexOf(around) % 2 != 0)\n                            return CodeMirror.Pass;\n                    }\n                    cm.operation(function () {\n                        var linesep = cm.lineSeparator() || '\\n';\n                        cm.replaceSelection(linesep + linesep, null);\n                        moveSel(cm, -1);\n                        ranges = cm.listSelections();\n                        for (var i = 0; i < ranges.length; i++) {\n                            var line = ranges[i].head.line;\n                            cm.indentLine(line, null, true);\n                            cm.indentLine(line + 1, null, true);\n                        }\n                    });\n                }\n                function moveSel(cm, dir) {\n                    var newRanges = [], ranges = cm.listSelections(), primary = 0;\n                    for (var i = 0; i < ranges.length; i++) {\n                        var range = ranges[i];\n                        if (range.head == cm.getCursor())\n                            primary = i;\n                        var pos = range.head.ch || dir > 0 ? {\n                            line: range.head.line,\n                            ch: range.head.ch + dir\n                        } : { line: range.head.line - 1 };\n                        newRanges.push({\n                            anchor: pos,\n                            head: pos\n                        });\n                    }\n                    cm.setSelections(newRanges, primary);\n                }\n                function contractSelection(sel) {\n                    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;\n                    return {\n                        anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),\n                        head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))\n                    };\n                }\n                function handleChar(cm, ch) {\n                    var conf = getConfig(cm);\n                    if (!conf || cm.getOption('disableInput'))\n                        return CodeMirror.Pass;\n                    var pairs = getOption(conf, 'pairs');\n                    var pos = pairs.indexOf(ch);\n                    if (pos == -1)\n                        return CodeMirror.Pass;\n                    var closeBefore = getOption(conf, 'closeBefore');\n                    var triples = getOption(conf, 'triples');\n                    var identical = pairs.charAt(pos + 1) == ch;\n                    var ranges = cm.listSelections();\n                    var opening = pos % 2 == 0;\n                    var type;\n                    for (var i = 0; i < ranges.length; i++) {\n                        var range = ranges[i], cur = range.head, curType;\n                        var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));\n                        if (opening && !range.empty()) {\n                            curType = 'surround';\n                        } else if ((identical || !opening) && next == ch) {\n                            if (identical && stringStartsAfter(cm, cur))\n                                curType = 'both';\n                            else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)\n                                curType = 'skipThree';\n                            else\n                                curType = 'skip';\n                        } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 && cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {\n                            if (cur.ch > 2 && /\\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2))))\n                                return CodeMirror.Pass;\n                            curType = 'addFour';\n                        } else if (identical) {\n                            var prev = cur.ch == 0 ? ' ' : cm.getRange(Pos(cur.line, cur.ch - 1), cur);\n                            if (!CodeMirror.isWordChar(next) && prev != ch && !CodeMirror.isWordChar(prev))\n                                curType = 'both';\n                            else\n                                return CodeMirror.Pass;\n                        } else if (opening && (next.length === 0 || /\\s/.test(next) || closeBefore.indexOf(next) > -1)) {\n                            curType = 'both';\n                        } else {\n                            return CodeMirror.Pass;\n                        }\n                        if (!type)\n                            type = curType;\n                        else if (type != curType)\n                            return CodeMirror.Pass;\n                    }\n                    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;\n                    var right = pos % 2 ? ch : pairs.charAt(pos + 1);\n                    cm.operation(function () {\n                        if (type == 'skip') {\n                            moveSel(cm, 1);\n                        } else if (type == 'skipThree') {\n                            moveSel(cm, 3);\n                        } else if (type == 'surround') {\n                            var sels = cm.getSelections();\n                            for (var i = 0; i < sels.length; i++)\n                                sels[i] = left + sels[i] + right;\n                            cm.replaceSelections(sels, 'around');\n                            sels = cm.listSelections().slice();\n                            for (var i = 0; i < sels.length; i++)\n                                sels[i] = contractSelection(sels[i]);\n                            cm.setSelections(sels);\n                        } else if (type == 'both') {\n                            cm.replaceSelection(left + right, null);\n                            cm.triggerElectric(left + right);\n                            moveSel(cm, -1);\n                        } else if (type == 'addFour') {\n                            cm.replaceSelection(left + left + left + left, 'before');\n                            moveSel(cm, 1);\n                        }\n                    });\n                }\n                function charsAround(cm, pos) {\n                    var str = cm.getRange(Pos(pos.line, pos.ch - 1), Pos(pos.line, pos.ch + 1));\n                    return str.length == 2 ? str : null;\n                }\n                function stringStartsAfter(cm, pos) {\n                    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1));\n                    return /\\bstring/.test(token.type) && token.start == pos.ch && (pos.ch == 0 || !/\\bstring/.test(cm.getTokenTypeAt(pos)));\n                }\n            }));\n        },\n        { '79': 79 }\n    ],\n    79: [\n        function (require, module, exports) {\n            (function (global, factory) {\n                typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.CodeMirror = factory());\n            }(this, function () {\n                'use strict';\n                var userAgent = navigator.userAgent;\n                var platform = navigator.platform;\n                var gecko = /gecko\\/\\d/i.test(userAgent);\n                var ie_upto10 = /MSIE \\d/.test(userAgent);\n                var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n                var edge = /Edge\\/(\\d+)/.exec(userAgent);\n                var ie = ie_upto10 || ie_11up || edge;\n                var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n                var webkit = !edge && /WebKit\\//.test(userAgent);\n                var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n                var chrome = !edge && /Chrome\\/(\\d+)/.exec(userAgent);\n                var chrome_version = chrome && +chrome[1];\n                var presto = /Opera\\//.test(userAgent);\n                var safari = /Apple Computer/.test(navigator.vendor);\n                var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n                var phantom = /PhantomJS/.test(userAgent);\n                var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n                var android = /Android/.test(userAgent);\n                var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n                var mac = ios || /Mac/.test(platform);\n                var chromeOS = /\\bCrOS\\b/.test(userAgent);\n                var windows = /win/i.test(platform);\n                var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n                if (presto_version) {\n                    presto_version = Number(presto_version[1]);\n                }\n                if (presto_version && presto_version >= 15) {\n                    presto = false;\n                    webkit = true;\n                }\n                var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n                var captureRightClick = gecko || ie && ie_version >= 9;\n                function classTest(cls) {\n                    return new RegExp('(^|\\\\s)' + cls + '(?:$|\\\\s)\\\\s*');\n                }\n                var rmClass = function (node, cls) {\n                    var current = node.className;\n                    var match = classTest(cls).exec(current);\n                    if (match) {\n                        var after = current.slice(match.index + match[0].length);\n                        node.className = current.slice(0, match.index) + (after ? match[1] + after : '');\n                    }\n                };\n                function removeChildren(e) {\n                    for (var count = e.childNodes.length; count > 0; --count) {\n                        e.removeChild(e.firstChild);\n                    }\n                    return e;\n                }\n                function removeChildrenAndAdd(parent, e) {\n                    return removeChildren(parent).appendChild(e);\n                }\n                function elt(tag, content, className, style) {\n                    var e = document.createElement(tag);\n                    if (className) {\n                        e.className = className;\n                    }\n                    if (style) {\n                        e.style.cssText = style;\n                    }\n                    if (typeof content == 'string') {\n                        e.appendChild(document.createTextNode(content));\n                    } else if (content) {\n                        for (var i = 0; i < content.length; ++i) {\n                            e.appendChild(content[i]);\n                        }\n                    }\n                    return e;\n                }\n                function eltP(tag, content, className, style) {\n                    var e = elt(tag, content, className, style);\n                    e.setAttribute('role', 'presentation');\n                    return e;\n                }\n                var range;\n                if (document.createRange) {\n                    range = function (node, start, end, endNode) {\n                        var r = document.createRange();\n                        r.setEnd(endNode || node, end);\n                        r.setStart(node, start);\n                        return r;\n                    };\n                } else {\n                    range = function (node, start, end) {\n                        var r = document.body.createTextRange();\n                        try {\n                            r.moveToElementText(node.parentNode);\n                        } catch (e) {\n                            return r;\n                        }\n                        r.collapse(true);\n                        r.moveEnd('character', end);\n                        r.moveStart('character', start);\n                        return r;\n                    };\n                }\n                function contains(parent, child) {\n                    if (child.nodeType == 3) {\n                        child = child.parentNode;\n                    }\n                    if (parent.contains) {\n                        return parent.contains(child);\n                    }\n                    do {\n                        if (child.nodeType == 11) {\n                            child = child.host;\n                        }\n                        if (child == parent) {\n                            return true;\n                        }\n                    } while (child = child.parentNode);\n                }\n                function activeElt(rootNode) {\n                    var doc = rootNode.ownerDocument || rootNode;\n                    var activeElement;\n                    try {\n                        activeElement = rootNode.activeElement;\n                    } catch (e) {\n                        activeElement = doc.body || null;\n                    }\n                    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {\n                        activeElement = activeElement.shadowRoot.activeElement;\n                    }\n                    return activeElement;\n                }\n                function addClass(node, cls) {\n                    var current = node.className;\n                    if (!classTest(cls).test(current)) {\n                        node.className += (current ? ' ' : '') + cls;\n                    }\n                }\n                function joinClasses(a, b) {\n                    var as = a.split(' ');\n                    for (var i = 0; i < as.length; i++) {\n                        if (as[i] && !classTest(as[i]).test(b)) {\n                            b += ' ' + as[i];\n                        }\n                    }\n                    return b;\n                }\n                var selectInput = function (node) {\n                    node.select();\n                };\n                if (ios) {\n                    selectInput = function (node) {\n                        node.selectionStart = 0;\n                        node.selectionEnd = node.value.length;\n                    };\n                } else if (ie) {\n                    selectInput = function (node) {\n                        try {\n                            node.select();\n                        } catch (_e) {\n                        }\n                    };\n                }\n                function doc(cm) {\n                    return cm.display.wrapper.ownerDocument;\n                }\n                function root(cm) {\n                    return rootNode(cm.display.wrapper);\n                }\n                function rootNode(element) {\n                    return element.getRootNode ? element.getRootNode() : element.ownerDocument;\n                }\n                function win(cm) {\n                    return doc(cm).defaultView;\n                }\n                function bind(f) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    return function () {\n                        return f.apply(null, args);\n                    };\n                }\n                function copyObj(obj, target, overwrite) {\n                    if (!target) {\n                        target = {};\n                    }\n                    for (var prop in obj) {\n                        if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {\n                            target[prop] = obj[prop];\n                        }\n                    }\n                    return target;\n                }\n                function countColumn(string, end, tabSize, startIndex, startValue) {\n                    if (end == null) {\n                        end = string.search(/[^\\s\\u00a0]/);\n                        if (end == -1) {\n                            end = string.length;\n                        }\n                    }\n                    for (var i = startIndex || 0, n = startValue || 0;;) {\n                        var nextTab = string.indexOf('\\t', i);\n                        if (nextTab < 0 || nextTab >= end) {\n                            return n + (end - i);\n                        }\n                        n += nextTab - i;\n                        n += tabSize - n % tabSize;\n                        i = nextTab + 1;\n                    }\n                }\n                var Delayed = function () {\n                    this.id = null;\n                    this.f = null;\n                    this.time = 0;\n                    this.handler = bind(this.onTimeout, this);\n                };\n                Delayed.prototype.onTimeout = function (self) {\n                    self.id = 0;\n                    if (self.time <= +new Date()) {\n                        self.f();\n                    } else {\n                        setTimeout(self.handler, self.time - +new Date());\n                    }\n                };\n                Delayed.prototype.set = function (ms, f) {\n                    this.f = f;\n                    var time = +new Date() + ms;\n                    if (!this.id || time < this.time) {\n                        clearTimeout(this.id);\n                        this.id = setTimeout(this.handler, ms);\n                        this.time = time;\n                    }\n                };\n                function indexOf(array, elt) {\n                    for (var i = 0; i < array.length; ++i) {\n                        if (array[i] == elt) {\n                            return i;\n                        }\n                    }\n                    return -1;\n                }\n                var scrollerGap = 50;\n                var Pass = {\n                    toString: function () {\n                        return 'CodeMirror.Pass';\n                    }\n                };\n                var sel_dontScroll = { scroll: false }, sel_mouse = { origin: '*mouse' }, sel_move = { origin: '+move' };\n                function findColumn(string, goal, tabSize) {\n                    for (var pos = 0, col = 0;;) {\n                        var nextTab = string.indexOf('\\t', pos);\n                        if (nextTab == -1) {\n                            nextTab = string.length;\n                        }\n                        var skipped = nextTab - pos;\n                        if (nextTab == string.length || col + skipped >= goal) {\n                            return pos + Math.min(skipped, goal - col);\n                        }\n                        col += nextTab - pos;\n                        col += tabSize - col % tabSize;\n                        pos = nextTab + 1;\n                        if (col >= goal) {\n                            return pos;\n                        }\n                    }\n                }\n                var spaceStrs = [''];\n                function spaceStr(n) {\n                    while (spaceStrs.length <= n) {\n                        spaceStrs.push(lst(spaceStrs) + ' ');\n                    }\n                    return spaceStrs[n];\n                }\n                function lst(arr) {\n                    return arr[arr.length - 1];\n                }\n                function map(array, f) {\n                    var out = [];\n                    for (var i = 0; i < array.length; i++) {\n                        out[i] = f(array[i], i);\n                    }\n                    return out;\n                }\n                function insertSorted(array, value, score) {\n                    var pos = 0, priority = score(value);\n                    while (pos < array.length && score(array[pos]) <= priority) {\n                        pos++;\n                    }\n                    array.splice(pos, 0, value);\n                }\n                function nothing() {\n                }\n                function createObj(base, props) {\n                    var inst;\n                    if (Object.create) {\n                        inst = Object.create(base);\n                    } else {\n                        nothing.prototype = base;\n                        inst = new nothing();\n                    }\n                    if (props) {\n                        copyObj(props, inst);\n                    }\n                    return inst;\n                }\n                var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n                function isWordCharBasic(ch) {\n                    return /\\w/.test(ch) || ch > '\\x80' && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n                }\n                function isWordChar(ch, helper) {\n                    if (!helper) {\n                        return isWordCharBasic(ch);\n                    }\n                    if (helper.source.indexOf('\\\\w') > -1 && isWordCharBasic(ch)) {\n                        return true;\n                    }\n                    return helper.test(ch);\n                }\n                function isEmpty(obj) {\n                    for (var n in obj) {\n                        if (obj.hasOwnProperty(n) && obj[n]) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n                function isExtendingChar(ch) {\n                    return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n                }\n                function skipExtendingChars(str, pos, dir) {\n                    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {\n                        pos += dir;\n                    }\n                    return pos;\n                }\n                function findFirst(pred, from, to) {\n                    var dir = from > to ? -1 : 1;\n                    for (;;) {\n                        if (from == to) {\n                            return from;\n                        }\n                        var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n                        if (mid == from) {\n                            return pred(mid) ? from : to;\n                        }\n                        if (pred(mid)) {\n                            to = mid;\n                        } else {\n                            from = mid + dir;\n                        }\n                    }\n                }\n                function iterateBidiSections(order, from, to, f) {\n                    if (!order) {\n                        return f(from, to, 'ltr', 0);\n                    }\n                    var found = false;\n                    for (var i = 0; i < order.length; ++i) {\n                        var part = order[i];\n                        if (part.from < to && part.to > from || from == to && part.to == from) {\n                            f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? 'rtl' : 'ltr', i);\n                            found = true;\n                        }\n                    }\n                    if (!found) {\n                        f(from, to, 'ltr');\n                    }\n                }\n                var bidiOther = null;\n                function getBidiPartAt(order, ch, sticky) {\n                    var found;\n                    bidiOther = null;\n                    for (var i = 0; i < order.length; ++i) {\n                        var cur = order[i];\n                        if (cur.from < ch && cur.to > ch) {\n                            return i;\n                        }\n                        if (cur.to == ch) {\n                            if (cur.from != cur.to && sticky == 'before') {\n                                found = i;\n                            } else {\n                                bidiOther = i;\n                            }\n                        }\n                        if (cur.from == ch) {\n                            if (cur.from != cur.to && sticky != 'before') {\n                                found = i;\n                            } else {\n                                bidiOther = i;\n                            }\n                        }\n                    }\n                    return found != null ? found : bidiOther;\n                }\n                var bidiOrdering = function () {\n                    var lowTypes = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN';\n                    var arabicTypes = 'nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111';\n                    function charType(code) {\n                        if (code <= 247) {\n                            return lowTypes.charAt(code);\n                        } else if (1424 <= code && code <= 1524) {\n                            return 'R';\n                        } else if (1536 <= code && code <= 1785) {\n                            return arabicTypes.charAt(code - 1536);\n                        } else if (1774 <= code && code <= 2220) {\n                            return 'r';\n                        } else if (8192 <= code && code <= 8203) {\n                            return 'w';\n                        } else if (code == 8204) {\n                            return 'b';\n                        } else {\n                            return 'L';\n                        }\n                    }\n                    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n                    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n                    function BidiSpan(level, from, to) {\n                        this.level = level;\n                        this.from = from;\n                        this.to = to;\n                    }\n                    return function (str, direction) {\n                        var outerType = direction == 'ltr' ? 'L' : 'R';\n                        if (str.length == 0 || direction == 'ltr' && !bidiRE.test(str)) {\n                            return false;\n                        }\n                        var len = str.length, types = [];\n                        for (var i = 0; i < len; ++i) {\n                            types.push(charType(str.charCodeAt(i)));\n                        }\n                        for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n                            var type = types[i$1];\n                            if (type == 'm') {\n                                types[i$1] = prev;\n                            } else {\n                                prev = type;\n                            }\n                        }\n                        for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n                            var type$1 = types[i$2];\n                            if (type$1 == '1' && cur == 'r') {\n                                types[i$2] = 'n';\n                            } else if (isStrong.test(type$1)) {\n                                cur = type$1;\n                                if (type$1 == 'r') {\n                                    types[i$2] = 'R';\n                                }\n                            }\n                        }\n                        for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n                            var type$2 = types[i$3];\n                            if (type$2 == '+' && prev$1 == '1' && types[i$3 + 1] == '1') {\n                                types[i$3] = '1';\n                            } else if (type$2 == ',' && prev$1 == types[i$3 + 1] && (prev$1 == '1' || prev$1 == 'n')) {\n                                types[i$3] = prev$1;\n                            }\n                            prev$1 = type$2;\n                        }\n                        for (var i$4 = 0; i$4 < len; ++i$4) {\n                            var type$3 = types[i$4];\n                            if (type$3 == ',') {\n                                types[i$4] = 'N';\n                            } else if (type$3 == '%') {\n                                var end = void 0;\n                                for (end = i$4 + 1; end < len && types[end] == '%'; ++end) {\n                                }\n                                var replace = i$4 && types[i$4 - 1] == '!' || end < len && types[end] == '1' ? '1' : 'N';\n                                for (var j = i$4; j < end; ++j) {\n                                    types[j] = replace;\n                                }\n                                i$4 = end - 1;\n                            }\n                        }\n                        for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n                            var type$4 = types[i$5];\n                            if (cur$1 == 'L' && type$4 == '1') {\n                                types[i$5] = 'L';\n                            } else if (isStrong.test(type$4)) {\n                                cur$1 = type$4;\n                            }\n                        }\n                        for (var i$6 = 0; i$6 < len; ++i$6) {\n                            if (isNeutral.test(types[i$6])) {\n                                var end$1 = void 0;\n                                for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {\n                                }\n                                var before = (i$6 ? types[i$6 - 1] : outerType) == 'L';\n                                var after = (end$1 < len ? types[end$1] : outerType) == 'L';\n                                var replace$1 = before == after ? before ? 'L' : 'R' : outerType;\n                                for (var j$1 = i$6; j$1 < end$1; ++j$1) {\n                                    types[j$1] = replace$1;\n                                }\n                                i$6 = end$1 - 1;\n                            }\n                        }\n                        var order = [], m;\n                        for (var i$7 = 0; i$7 < len;) {\n                            if (countsAsLeft.test(types[i$7])) {\n                                var start = i$7;\n                                for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {\n                                }\n                                order.push(new BidiSpan(0, start, i$7));\n                            } else {\n                                var pos = i$7, at = order.length, isRTL = direction == 'rtl' ? 1 : 0;\n                                for (++i$7; i$7 < len && types[i$7] != 'L'; ++i$7) {\n                                }\n                                for (var j$2 = pos; j$2 < i$7;) {\n                                    if (countsAsNum.test(types[j$2])) {\n                                        if (pos < j$2) {\n                                            order.splice(at, 0, new BidiSpan(1, pos, j$2));\n                                            at += isRTL;\n                                        }\n                                        var nstart = j$2;\n                                        for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {\n                                        }\n                                        order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n                                        at += isRTL;\n                                        pos = j$2;\n                                    } else {\n                                        ++j$2;\n                                    }\n                                }\n                                if (pos < i$7) {\n                                    order.splice(at, 0, new BidiSpan(1, pos, i$7));\n                                }\n                            }\n                        }\n                        if (direction == 'ltr') {\n                            if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n                                order[0].from = m[0].length;\n                                order.unshift(new BidiSpan(0, 0, m[0].length));\n                            }\n                            if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n                                lst(order).to -= m[0].length;\n                                order.push(new BidiSpan(0, len - m[0].length, len));\n                            }\n                        }\n                        return direction == 'rtl' ? order.reverse() : order;\n                    };\n                }();\n                function getOrder(line, direction) {\n                    var order = line.order;\n                    if (order == null) {\n                        order = line.order = bidiOrdering(line.text, direction);\n                    }\n                    return order;\n                }\n                var noHandlers = [];\n                var on = function (emitter, type, f) {\n                    if (emitter.addEventListener) {\n                        emitter.addEventListener(type, f, false);\n                    } else if (emitter.attachEvent) {\n                        emitter.attachEvent('on' + type, f);\n                    } else {\n                        var map = emitter._handlers || (emitter._handlers = {});\n                        map[type] = (map[type] || noHandlers).concat(f);\n                    }\n                };\n                function getHandlers(emitter, type) {\n                    return emitter._handlers && emitter._handlers[type] || noHandlers;\n                }\n                function off(emitter, type, f) {\n                    if (emitter.removeEventListener) {\n                        emitter.removeEventListener(type, f, false);\n                    } else if (emitter.detachEvent) {\n                        emitter.detachEvent('on' + type, f);\n                    } else {\n                        var map = emitter._handlers, arr = map && map[type];\n                        if (arr) {\n                            var index = indexOf(arr, f);\n                            if (index > -1) {\n                                map[type] = arr.slice(0, index).concat(arr.slice(index + 1));\n                            }\n                        }\n                    }\n                }\n                function signal(emitter, type) {\n                    var handlers = getHandlers(emitter, type);\n                    if (!handlers.length) {\n                        return;\n                    }\n                    var args = Array.prototype.slice.call(arguments, 2);\n                    for (var i = 0; i < handlers.length; ++i) {\n                        handlers[i].apply(null, args);\n                    }\n                }\n                function signalDOMEvent(cm, e, override) {\n                    if (typeof e == 'string') {\n                        e = {\n                            type: e,\n                            preventDefault: function () {\n                                this.defaultPrevented = true;\n                            }\n                        };\n                    }\n                    signal(cm, override || e.type, cm, e);\n                    return e_defaultPrevented(e) || e.codemirrorIgnore;\n                }\n                function signalCursorActivity(cm) {\n                    var arr = cm._handlers && cm._handlers.cursorActivity;\n                    if (!arr) {\n                        return;\n                    }\n                    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n                    for (var i = 0; i < arr.length; ++i) {\n                        if (indexOf(set, arr[i]) == -1) {\n                            set.push(arr[i]);\n                        }\n                    }\n                }\n                function hasHandler(emitter, type) {\n                    return getHandlers(emitter, type).length > 0;\n                }\n                function eventMixin(ctor) {\n                    ctor.prototype.on = function (type, f) {\n                        on(this, type, f);\n                    };\n                    ctor.prototype.off = function (type, f) {\n                        off(this, type, f);\n                    };\n                }\n                function e_preventDefault(e) {\n                    if (e.preventDefault) {\n                        e.preventDefault();\n                    } else {\n                        e.returnValue = false;\n                    }\n                }\n                function e_stopPropagation(e) {\n                    if (e.stopPropagation) {\n                        e.stopPropagation();\n                    } else {\n                        e.cancelBubble = true;\n                    }\n                }\n                function e_defaultPrevented(e) {\n                    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n                }\n                function e_stop(e) {\n                    e_preventDefault(e);\n                    e_stopPropagation(e);\n                }\n                function e_target(e) {\n                    return e.target || e.srcElement;\n                }\n                function e_button(e) {\n                    var b = e.which;\n                    if (b == null) {\n                        if (e.button & 1) {\n                            b = 1;\n                        } else if (e.button & 2) {\n                            b = 3;\n                        } else if (e.button & 4) {\n                            b = 2;\n                        }\n                    }\n                    if (mac && e.ctrlKey && b == 1) {\n                        b = 3;\n                    }\n                    return b;\n                }\n                var dragAndDrop = function () {\n                    if (ie && ie_version < 9) {\n                        return false;\n                    }\n                    var div = elt('div');\n                    return 'draggable' in div || 'dragDrop' in div;\n                }();\n                var zwspSupported;\n                function zeroWidthElement(measure) {\n                    if (zwspSupported == null) {\n                        var test = elt('span', '\\u200B');\n                        removeChildrenAndAdd(measure, elt('span', [\n                            test,\n                            document.createTextNode('x')\n                        ]));\n                        if (measure.firstChild.offsetHeight != 0) {\n                            zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n                        }\n                    }\n                    var node = zwspSupported ? elt('span', '\\u200B') : elt('span', '\\xA0', null, 'display: inline-block; width: 1px; margin-right: -1px');\n                    node.setAttribute('cm-text', '');\n                    return node;\n                }\n                var badBidiRects;\n                function hasBadBidiRects(measure) {\n                    if (badBidiRects != null) {\n                        return badBidiRects;\n                    }\n                    var txt = removeChildrenAndAdd(measure, document.createTextNode('AخA'));\n                    var r0 = range(txt, 0, 1).getBoundingClientRect();\n                    var r1 = range(txt, 1, 2).getBoundingClientRect();\n                    removeChildren(measure);\n                    if (!r0 || r0.left == r0.right) {\n                        return false;\n                    }\n                    return badBidiRects = r1.right - r0.right < 3;\n                }\n                var splitLinesAuto = '\\n\\nb'.split(/\\n/).length != 3 ? function (string) {\n                    var pos = 0, result = [], l = string.length;\n                    while (pos <= l) {\n                        var nl = string.indexOf('\\n', pos);\n                        if (nl == -1) {\n                            nl = string.length;\n                        }\n                        var line = string.slice(pos, string.charAt(nl - 1) == '\\r' ? nl - 1 : nl);\n                        var rt = line.indexOf('\\r');\n                        if (rt != -1) {\n                            result.push(line.slice(0, rt));\n                            pos += rt + 1;\n                        } else {\n                            result.push(line);\n                            pos = nl + 1;\n                        }\n                    }\n                    return result;\n                } : function (string) {\n                    return string.split(/\\r\\n?|\\n/);\n                };\n                var hasSelection = window.getSelection ? function (te) {\n                    try {\n                        return te.selectionStart != te.selectionEnd;\n                    } catch (e) {\n                        return false;\n                    }\n                } : function (te) {\n                    var range;\n                    try {\n                        range = te.ownerDocument.selection.createRange();\n                    } catch (e) {\n                    }\n                    if (!range || range.parentElement() != te) {\n                        return false;\n                    }\n                    return range.compareEndPoints('StartToEnd', range) != 0;\n                };\n                var hasCopyEvent = function () {\n                    var e = elt('div');\n                    if ('oncopy' in e) {\n                        return true;\n                    }\n                    e.setAttribute('oncopy', 'return;');\n                    return typeof e.oncopy == 'function';\n                }();\n                var badZoomedRects = null;\n                function hasBadZoomedRects(measure) {\n                    if (badZoomedRects != null) {\n                        return badZoomedRects;\n                    }\n                    var node = removeChildrenAndAdd(measure, elt('span', 'x'));\n                    var normal = node.getBoundingClientRect();\n                    var fromRange = range(node, 0, 1).getBoundingClientRect();\n                    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n                }\n                var modes = {}, mimeModes = {};\n                function defineMode(name, mode) {\n                    if (arguments.length > 2) {\n                        mode.dependencies = Array.prototype.slice.call(arguments, 2);\n                    }\n                    modes[name] = mode;\n                }\n                function defineMIME(mime, spec) {\n                    mimeModes[mime] = spec;\n                }\n                function resolveMode(spec) {\n                    if (typeof spec == 'string' && mimeModes.hasOwnProperty(spec)) {\n                        spec = mimeModes[spec];\n                    } else if (spec && typeof spec.name == 'string' && mimeModes.hasOwnProperty(spec.name)) {\n                        var found = mimeModes[spec.name];\n                        if (typeof found == 'string') {\n                            found = { name: found };\n                        }\n                        spec = createObj(found, spec);\n                        spec.name = found.name;\n                    } else if (typeof spec == 'string' && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n                        return resolveMode('application/xml');\n                    } else if (typeof spec == 'string' && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n                        return resolveMode('application/json');\n                    }\n                    if (typeof spec == 'string') {\n                        return { name: spec };\n                    } else {\n                        return spec || { name: 'null' };\n                    }\n                }\n                function getMode(options, spec) {\n                    spec = resolveMode(spec);\n                    var mfactory = modes[spec.name];\n                    if (!mfactory) {\n                        return getMode(options, 'text/plain');\n                    }\n                    var modeObj = mfactory(options, spec);\n                    if (modeExtensions.hasOwnProperty(spec.name)) {\n                        var exts = modeExtensions[spec.name];\n                        for (var prop in exts) {\n                            if (!exts.hasOwnProperty(prop)) {\n                                continue;\n                            }\n                            if (modeObj.hasOwnProperty(prop)) {\n                                modeObj['_' + prop] = modeObj[prop];\n                            }\n                            modeObj[prop] = exts[prop];\n                        }\n                    }\n                    modeObj.name = spec.name;\n                    if (spec.helperType) {\n                        modeObj.helperType = spec.helperType;\n                    }\n                    if (spec.modeProps) {\n                        for (var prop$1 in spec.modeProps) {\n                            modeObj[prop$1] = spec.modeProps[prop$1];\n                        }\n                    }\n                    return modeObj;\n                }\n                var modeExtensions = {};\n                function extendMode(mode, properties) {\n                    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};\n                    copyObj(properties, exts);\n                }\n                function copyState(mode, state) {\n                    if (state === true) {\n                        return state;\n                    }\n                    if (mode.copyState) {\n                        return mode.copyState(state);\n                    }\n                    var nstate = {};\n                    for (var n in state) {\n                        var val = state[n];\n                        if (val instanceof Array) {\n                            val = val.concat([]);\n                        }\n                        nstate[n] = val;\n                    }\n                    return nstate;\n                }\n                function innerMode(mode, state) {\n                    var info;\n                    while (mode.innerMode) {\n                        info = mode.innerMode(state);\n                        if (!info || info.mode == mode) {\n                            break;\n                        }\n                        state = info.state;\n                        mode = info.mode;\n                    }\n                    return info || {\n                        mode: mode,\n                        state: state\n                    };\n                }\n                function startState(mode, a1, a2) {\n                    return mode.startState ? mode.startState(a1, a2) : true;\n                }\n                var StringStream = function (string, tabSize, lineOracle) {\n                    this.pos = this.start = 0;\n                    this.string = string;\n                    this.tabSize = tabSize || 8;\n                    this.lastColumnPos = this.lastColumnValue = 0;\n                    this.lineStart = 0;\n                    this.lineOracle = lineOracle;\n                };\n                StringStream.prototype.eol = function () {\n                    return this.pos >= this.string.length;\n                };\n                StringStream.prototype.sol = function () {\n                    return this.pos == this.lineStart;\n                };\n                StringStream.prototype.peek = function () {\n                    return this.string.charAt(this.pos) || undefined;\n                };\n                StringStream.prototype.next = function () {\n                    if (this.pos < this.string.length) {\n                        return this.string.charAt(this.pos++);\n                    }\n                };\n                StringStream.prototype.eat = function (match) {\n                    var ch = this.string.charAt(this.pos);\n                    var ok;\n                    if (typeof match == 'string') {\n                        ok = ch == match;\n                    } else {\n                        ok = ch && (match.test ? match.test(ch) : match(ch));\n                    }\n                    if (ok) {\n                        ++this.pos;\n                        return ch;\n                    }\n                };\n                StringStream.prototype.eatWhile = function (match) {\n                    var start = this.pos;\n                    while (this.eat(match)) {\n                    }\n                    return this.pos > start;\n                };\n                StringStream.prototype.eatSpace = function () {\n                    var start = this.pos;\n                    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {\n                        ++this.pos;\n                    }\n                    return this.pos > start;\n                };\n                StringStream.prototype.skipToEnd = function () {\n                    this.pos = this.string.length;\n                };\n                StringStream.prototype.skipTo = function (ch) {\n                    var found = this.string.indexOf(ch, this.pos);\n                    if (found > -1) {\n                        this.pos = found;\n                        return true;\n                    }\n                };\n                StringStream.prototype.backUp = function (n) {\n                    this.pos -= n;\n                };\n                StringStream.prototype.column = function () {\n                    if (this.lastColumnPos < this.start) {\n                        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n                        this.lastColumnPos = this.start;\n                    }\n                    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n                };\n                StringStream.prototype.indentation = function () {\n                    return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n                };\n                StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n                    if (typeof pattern == 'string') {\n                        var cased = function (str) {\n                            return caseInsensitive ? str.toLowerCase() : str;\n                        };\n                        var substr = this.string.substr(this.pos, pattern.length);\n                        if (cased(substr) == cased(pattern)) {\n                            if (consume !== false) {\n                                this.pos += pattern.length;\n                            }\n                            return true;\n                        }\n                    } else {\n                        var match = this.string.slice(this.pos).match(pattern);\n                        if (match && match.index > 0) {\n                            return null;\n                        }\n                        if (match && consume !== false) {\n                            this.pos += match[0].length;\n                        }\n                        return match;\n                    }\n                };\n                StringStream.prototype.current = function () {\n                    return this.string.slice(this.start, this.pos);\n                };\n                StringStream.prototype.hideFirstChars = function (n, inner) {\n                    this.lineStart += n;\n                    try {\n                        return inner();\n                    } finally {\n                        this.lineStart -= n;\n                    }\n                };\n                StringStream.prototype.lookAhead = function (n) {\n                    var oracle = this.lineOracle;\n                    return oracle && oracle.lookAhead(n);\n                };\n                StringStream.prototype.baseToken = function () {\n                    var oracle = this.lineOracle;\n                    return oracle && oracle.baseToken(this.pos);\n                };\n                function getLine(doc, n) {\n                    n -= doc.first;\n                    if (n < 0 || n >= doc.size) {\n                        throw new Error('There is no line ' + (n + doc.first) + ' in the document.');\n                    }\n                    var chunk = doc;\n                    while (!chunk.lines) {\n                        for (var i = 0;; ++i) {\n                            var child = chunk.children[i], sz = child.chunkSize();\n                            if (n < sz) {\n                                chunk = child;\n                                break;\n                            }\n                            n -= sz;\n                        }\n                    }\n                    return chunk.lines[n];\n                }\n                function getBetween(doc, start, end) {\n                    var out = [], n = start.line;\n                    doc.iter(start.line, end.line + 1, function (line) {\n                        var text = line.text;\n                        if (n == end.line) {\n                            text = text.slice(0, end.ch);\n                        }\n                        if (n == start.line) {\n                            text = text.slice(start.ch);\n                        }\n                        out.push(text);\n                        ++n;\n                    });\n                    return out;\n                }\n                function getLines(doc, from, to) {\n                    var out = [];\n                    doc.iter(from, to, function (line) {\n                        out.push(line.text);\n                    });\n                    return out;\n                }\n                function updateLineHeight(line, height) {\n                    var diff = height - line.height;\n                    if (diff) {\n                        for (var n = line; n; n = n.parent) {\n                            n.height += diff;\n                        }\n                    }\n                }\n                function lineNo(line) {\n                    if (line.parent == null) {\n                        return null;\n                    }\n                    var cur = line.parent, no = indexOf(cur.lines, line);\n                    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n                        for (var i = 0;; ++i) {\n                            if (chunk.children[i] == cur) {\n                                break;\n                            }\n                            no += chunk.children[i].chunkSize();\n                        }\n                    }\n                    return no + cur.first;\n                }\n                function lineAtHeight(chunk, h) {\n                    var n = chunk.first;\n                    outer:\n                        do {\n                            for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n                                var child = chunk.children[i$1], ch = child.height;\n                                if (h < ch) {\n                                    chunk = child;\n                                    continue outer;\n                                }\n                                h -= ch;\n                                n += child.chunkSize();\n                            }\n                            return n;\n                        } while (!chunk.lines);\n                    var i = 0;\n                    for (; i < chunk.lines.length; ++i) {\n                        var line = chunk.lines[i], lh = line.height;\n                        if (h < lh) {\n                            break;\n                        }\n                        h -= lh;\n                    }\n                    return n + i;\n                }\n                function isLine(doc, l) {\n                    return l >= doc.first && l < doc.first + doc.size;\n                }\n                function lineNumberFor(options, i) {\n                    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n                }\n                function Pos(line, ch, sticky) {\n                    if (sticky === void 0)\n                        sticky = null;\n                    if (!(this instanceof Pos)) {\n                        return new Pos(line, ch, sticky);\n                    }\n                    this.line = line;\n                    this.ch = ch;\n                    this.sticky = sticky;\n                }\n                function cmp(a, b) {\n                    return a.line - b.line || a.ch - b.ch;\n                }\n                function equalCursorPos(a, b) {\n                    return a.sticky == b.sticky && cmp(a, b) == 0;\n                }\n                function copyPos(x) {\n                    return Pos(x.line, x.ch);\n                }\n                function maxPos(a, b) {\n                    return cmp(a, b) < 0 ? b : a;\n                }\n                function minPos(a, b) {\n                    return cmp(a, b) < 0 ? a : b;\n                }\n                function clipLine(doc, n) {\n                    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));\n                }\n                function clipPos(doc, pos) {\n                    if (pos.line < doc.first) {\n                        return Pos(doc.first, 0);\n                    }\n                    var last = doc.first + doc.size - 1;\n                    if (pos.line > last) {\n                        return Pos(last, getLine(doc, last).text.length);\n                    }\n                    return clipToLen(pos, getLine(doc, pos.line).text.length);\n                }\n                function clipToLen(pos, linelen) {\n                    var ch = pos.ch;\n                    if (ch == null || ch > linelen) {\n                        return Pos(pos.line, linelen);\n                    } else if (ch < 0) {\n                        return Pos(pos.line, 0);\n                    } else {\n                        return pos;\n                    }\n                }\n                function clipPosArray(doc, array) {\n                    var out = [];\n                    for (var i = 0; i < array.length; i++) {\n                        out[i] = clipPos(doc, array[i]);\n                    }\n                    return out;\n                }\n                var SavedContext = function (state, lookAhead) {\n                    this.state = state;\n                    this.lookAhead = lookAhead;\n                };\n                var Context = function (doc, state, line, lookAhead) {\n                    this.state = state;\n                    this.doc = doc;\n                    this.line = line;\n                    this.maxLookAhead = lookAhead || 0;\n                    this.baseTokens = null;\n                    this.baseTokenPos = 1;\n                };\n                Context.prototype.lookAhead = function (n) {\n                    var line = this.doc.getLine(this.line + n);\n                    if (line != null && n > this.maxLookAhead) {\n                        this.maxLookAhead = n;\n                    }\n                    return line;\n                };\n                Context.prototype.baseToken = function (n) {\n                    if (!this.baseTokens) {\n                        return null;\n                    }\n                    while (this.baseTokens[this.baseTokenPos] <= n) {\n                        this.baseTokenPos += 2;\n                    }\n                    var type = this.baseTokens[this.baseTokenPos + 1];\n                    return {\n                        type: type && type.replace(/( |^)overlay .*/, ''),\n                        size: this.baseTokens[this.baseTokenPos] - n\n                    };\n                };\n                Context.prototype.nextLine = function () {\n                    this.line++;\n                    if (this.maxLookAhead > 0) {\n                        this.maxLookAhead--;\n                    }\n                };\n                Context.fromSaved = function (doc, saved, line) {\n                    if (saved instanceof SavedContext) {\n                        return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);\n                    } else {\n                        return new Context(doc, copyState(doc.mode, saved), line);\n                    }\n                };\n                Context.prototype.save = function (copy) {\n                    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n                    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;\n                };\n                function highlightLine(cm, line, context, forceToEnd) {\n                    var st = [cm.state.modeGen], lineClasses = {};\n                    runMode(cm, line.text, cm.doc.mode, context, function (end, style) {\n                        return st.push(end, style);\n                    }, lineClasses, forceToEnd);\n                    var state = context.state;\n                    var loop = function (o) {\n                        context.baseTokens = st;\n                        var overlay = cm.state.overlays[o], i = 1, at = 0;\n                        context.state = true;\n                        runMode(cm, line.text, overlay.mode, context, function (end, style) {\n                            var start = i;\n                            while (at < end) {\n                                var i_end = st[i];\n                                if (i_end > end) {\n                                    st.splice(i, 1, end, st[i + 1], i_end);\n                                }\n                                i += 2;\n                                at = Math.min(end, i_end);\n                            }\n                            if (!style) {\n                                return;\n                            }\n                            if (overlay.opaque) {\n                                st.splice(start, i - start, end, 'overlay ' + style);\n                                i = start + 2;\n                            } else {\n                                for (; start < i; start += 2) {\n                                    var cur = st[start + 1];\n                                    st[start + 1] = (cur ? cur + ' ' : '') + 'overlay ' + style;\n                                }\n                            }\n                        }, lineClasses);\n                        context.state = state;\n                        context.baseTokens = null;\n                        context.baseTokenPos = 1;\n                    };\n                    for (var o = 0; o < cm.state.overlays.length; ++o)\n                        loop(o);\n                    return {\n                        styles: st,\n                        classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null\n                    };\n                }\n                function getLineStyles(cm, line, updateFrontier) {\n                    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n                        var context = getContextBefore(cm, lineNo(line));\n                        var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n                        var result = highlightLine(cm, line, context);\n                        if (resetState) {\n                            context.state = resetState;\n                        }\n                        line.stateAfter = context.save(!resetState);\n                        line.styles = result.styles;\n                        if (result.classes) {\n                            line.styleClasses = result.classes;\n                        } else if (line.styleClasses) {\n                            line.styleClasses = null;\n                        }\n                        if (updateFrontier === cm.doc.highlightFrontier) {\n                            cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);\n                        }\n                    }\n                    return line.styles;\n                }\n                function getContextBefore(cm, n, precise) {\n                    var doc = cm.doc, display = cm.display;\n                    if (!doc.mode.startState) {\n                        return new Context(doc, true, n);\n                    }\n                    var start = findStartLine(cm, n, precise);\n                    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n                    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n                    doc.iter(start, n, function (line) {\n                        processLine(cm, line.text, context);\n                        var pos = context.line;\n                        line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n                        context.nextLine();\n                    });\n                    if (precise) {\n                        doc.modeFrontier = context.line;\n                    }\n                    return context;\n                }\n                function processLine(cm, text, context, startAt) {\n                    var mode = cm.doc.mode;\n                    var stream = new StringStream(text, cm.options.tabSize, context);\n                    stream.start = stream.pos = startAt || 0;\n                    if (text == '') {\n                        callBlankLine(mode, context.state);\n                    }\n                    while (!stream.eol()) {\n                        readToken(mode, stream, context.state);\n                        stream.start = stream.pos;\n                    }\n                }\n                function callBlankLine(mode, state) {\n                    if (mode.blankLine) {\n                        return mode.blankLine(state);\n                    }\n                    if (!mode.innerMode) {\n                        return;\n                    }\n                    var inner = innerMode(mode, state);\n                    if (inner.mode.blankLine) {\n                        return inner.mode.blankLine(inner.state);\n                    }\n                }\n                function readToken(mode, stream, state, inner) {\n                    for (var i = 0; i < 10; i++) {\n                        if (inner) {\n                            inner[0] = innerMode(mode, state).mode;\n                        }\n                        var style = mode.token(stream, state);\n                        if (stream.pos > stream.start) {\n                            return style;\n                        }\n                    }\n                    throw new Error('Mode ' + mode.name + ' failed to advance stream.');\n                }\n                var Token = function (stream, type, state) {\n                    this.start = stream.start;\n                    this.end = stream.pos;\n                    this.string = stream.current();\n                    this.type = type || null;\n                    this.state = state;\n                };\n                function takeToken(cm, pos, precise, asArray) {\n                    var doc = cm.doc, mode = doc.mode, style;\n                    pos = clipPos(doc, pos);\n                    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n                    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n                    if (asArray) {\n                        tokens = [];\n                    }\n                    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n                        stream.start = stream.pos;\n                        style = readToken(mode, stream, context.state);\n                        if (asArray) {\n                            tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));\n                        }\n                    }\n                    return asArray ? tokens : new Token(stream, style, context.state);\n                }\n                function extractLineClasses(type, output) {\n                    if (type) {\n                        for (;;) {\n                            var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n                            if (!lineClass) {\n                                break;\n                            }\n                            type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n                            var prop = lineClass[1] ? 'bgClass' : 'textClass';\n                            if (output[prop] == null) {\n                                output[prop] = lineClass[2];\n                            } else if (!new RegExp('(?:^|\\\\s)' + lineClass[2] + '(?:$|\\\\s)').test(output[prop])) {\n                                output[prop] += ' ' + lineClass[2];\n                            }\n                        }\n                    }\n                    return type;\n                }\n                function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n                    var flattenSpans = mode.flattenSpans;\n                    if (flattenSpans == null) {\n                        flattenSpans = cm.options.flattenSpans;\n                    }\n                    var curStart = 0, curStyle = null;\n                    var stream = new StringStream(text, cm.options.tabSize, context), style;\n                    var inner = cm.options.addModeClass && [null];\n                    if (text == '') {\n                        extractLineClasses(callBlankLine(mode, context.state), lineClasses);\n                    }\n                    while (!stream.eol()) {\n                        if (stream.pos > cm.options.maxHighlightLength) {\n                            flattenSpans = false;\n                            if (forceToEnd) {\n                                processLine(cm, text, context, stream.pos);\n                            }\n                            stream.pos = text.length;\n                            style = null;\n                        } else {\n                            style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n                        }\n                        if (inner) {\n                            var mName = inner[0].name;\n                            if (mName) {\n                                style = 'm-' + (style ? mName + ' ' + style : mName);\n                            }\n                        }\n                        if (!flattenSpans || curStyle != style) {\n                            while (curStart < stream.start) {\n                                curStart = Math.min(stream.start, curStart + 5000);\n                                f(curStart, curStyle);\n                            }\n                            curStyle = style;\n                        }\n                        stream.start = stream.pos;\n                    }\n                    while (curStart < stream.pos) {\n                        var pos = Math.min(stream.pos, curStart + 5000);\n                        f(pos, curStyle);\n                        curStart = pos;\n                    }\n                }\n                function findStartLine(cm, n, precise) {\n                    var minindent, minline, doc = cm.doc;\n                    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n                    for (var search = n; search > lim; --search) {\n                        if (search <= doc.first) {\n                            return doc.first;\n                        }\n                        var line = getLine(doc, search - 1), after = line.stateAfter;\n                        if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {\n                            return search;\n                        }\n                        var indented = countColumn(line.text, null, cm.options.tabSize);\n                        if (minline == null || minindent > indented) {\n                            minline = search - 1;\n                            minindent = indented;\n                        }\n                    }\n                    return minline;\n                }\n                function retreatFrontier(doc, n) {\n                    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n                    if (doc.highlightFrontier < n - 10) {\n                        return;\n                    }\n                    var start = doc.first;\n                    for (var line = n - 1; line > start; line--) {\n                        var saved = getLine(doc, line).stateAfter;\n                        if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n                            start = line + 1;\n                            break;\n                        }\n                    }\n                    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n                }\n                var sawReadOnlySpans = false, sawCollapsedSpans = false;\n                function seeReadOnlySpans() {\n                    sawReadOnlySpans = true;\n                }\n                function seeCollapsedSpans() {\n                    sawCollapsedSpans = true;\n                }\n                function MarkedSpan(marker, from, to) {\n                    this.marker = marker;\n                    this.from = from;\n                    this.to = to;\n                }\n                function getMarkedSpanFor(spans, marker) {\n                    if (spans) {\n                        for (var i = 0; i < spans.length; ++i) {\n                            var span = spans[i];\n                            if (span.marker == marker) {\n                                return span;\n                            }\n                        }\n                    }\n                }\n                function removeMarkedSpan(spans, span) {\n                    var r;\n                    for (var i = 0; i < spans.length; ++i) {\n                        if (spans[i] != span) {\n                            (r || (r = [])).push(spans[i]);\n                        }\n                    }\n                    return r;\n                }\n                function addMarkedSpan(line, span, op) {\n                    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet()));\n                    if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {\n                        line.markedSpans.push(span);\n                    } else {\n                        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n                        if (inThisOp) {\n                            inThisOp.add(line.markedSpans);\n                        }\n                    }\n                    span.marker.attachLine(line);\n                }\n                function markedSpansBefore(old, startCh, isInsert) {\n                    var nw;\n                    if (old) {\n                        for (var i = 0; i < old.length; ++i) {\n                            var span = old[i], marker = span.marker;\n                            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n                            if (startsBefore || span.from == startCh && marker.type == 'bookmark' && (!isInsert || !span.marker.insertLeft)) {\n                                var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n                                (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n                            }\n                        }\n                    }\n                    return nw;\n                }\n                function markedSpansAfter(old, endCh, isInsert) {\n                    var nw;\n                    if (old) {\n                        for (var i = 0; i < old.length; ++i) {\n                            var span = old[i], marker = span.marker;\n                            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n                            if (endsAfter || span.from == endCh && marker.type == 'bookmark' && (!isInsert || span.marker.insertLeft)) {\n                                var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n                                (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));\n                            }\n                        }\n                    }\n                    return nw;\n                }\n                function stretchSpansOverChange(doc, change) {\n                    if (change.full) {\n                        return null;\n                    }\n                    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n                    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n                    if (!oldFirst && !oldLast) {\n                        return null;\n                    }\n                    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n                    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n                    var last = markedSpansAfter(oldLast, endCh, isInsert);\n                    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n                    if (first) {\n                        for (var i = 0; i < first.length; ++i) {\n                            var span = first[i];\n                            if (span.to == null) {\n                                var found = getMarkedSpanFor(last, span.marker);\n                                if (!found) {\n                                    span.to = startCh;\n                                } else if (sameLine) {\n                                    span.to = found.to == null ? null : found.to + offset;\n                                }\n                            }\n                        }\n                    }\n                    if (last) {\n                        for (var i$1 = 0; i$1 < last.length; ++i$1) {\n                            var span$1 = last[i$1];\n                            if (span$1.to != null) {\n                                span$1.to += offset;\n                            }\n                            if (span$1.from == null) {\n                                var found$1 = getMarkedSpanFor(first, span$1.marker);\n                                if (!found$1) {\n                                    span$1.from = offset;\n                                    if (sameLine) {\n                                        (first || (first = [])).push(span$1);\n                                    }\n                                }\n                            } else {\n                                span$1.from += offset;\n                                if (sameLine) {\n                                    (first || (first = [])).push(span$1);\n                                }\n                            }\n                        }\n                    }\n                    if (first) {\n                        first = clearEmptySpans(first);\n                    }\n                    if (last && last != first) {\n                        last = clearEmptySpans(last);\n                    }\n                    var newMarkers = [first];\n                    if (!sameLine) {\n                        var gap = change.text.length - 2, gapMarkers;\n                        if (gap > 0 && first) {\n                            for (var i$2 = 0; i$2 < first.length; ++i$2) {\n                                if (first[i$2].to == null) {\n                                    (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));\n                                }\n                            }\n                        }\n                        for (var i$3 = 0; i$3 < gap; ++i$3) {\n                            newMarkers.push(gapMarkers);\n                        }\n                        newMarkers.push(last);\n                    }\n                    return newMarkers;\n                }\n                function clearEmptySpans(spans) {\n                    for (var i = 0; i < spans.length; ++i) {\n                        var span = spans[i];\n                        if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {\n                            spans.splice(i--, 1);\n                        }\n                    }\n                    if (!spans.length) {\n                        return null;\n                    }\n                    return spans;\n                }\n                function removeReadOnlyRanges(doc, from, to) {\n                    var markers = null;\n                    doc.iter(from.line, to.line + 1, function (line) {\n                        if (line.markedSpans) {\n                            for (var i = 0; i < line.markedSpans.length; ++i) {\n                                var mark = line.markedSpans[i].marker;\n                                if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {\n                                    (markers || (markers = [])).push(mark);\n                                }\n                            }\n                        }\n                    });\n                    if (!markers) {\n                        return null;\n                    }\n                    var parts = [{\n                            from: from,\n                            to: to\n                        }];\n                    for (var i = 0; i < markers.length; ++i) {\n                        var mk = markers[i], m = mk.find(0);\n                        for (var j = 0; j < parts.length; ++j) {\n                            var p = parts[j];\n                            if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {\n                                continue;\n                            }\n                            var newParts = [\n                                    j,\n                                    1\n                                ], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n                            if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {\n                                newParts.push({\n                                    from: p.from,\n                                    to: m.from\n                                });\n                            }\n                            if (dto > 0 || !mk.inclusiveRight && !dto) {\n                                newParts.push({\n                                    from: m.to,\n                                    to: p.to\n                                });\n                            }\n                            parts.splice.apply(parts, newParts);\n                            j += newParts.length - 3;\n                        }\n                    }\n                    return parts;\n                }\n                function detachMarkedSpans(line) {\n                    var spans = line.markedSpans;\n                    if (!spans) {\n                        return;\n                    }\n                    for (var i = 0; i < spans.length; ++i) {\n                        spans[i].marker.detachLine(line);\n                    }\n                    line.markedSpans = null;\n                }\n                function attachMarkedSpans(line, spans) {\n                    if (!spans) {\n                        return;\n                    }\n                    for (var i = 0; i < spans.length; ++i) {\n                        spans[i].marker.attachLine(line);\n                    }\n                    line.markedSpans = spans;\n                }\n                function extraLeft(marker) {\n                    return marker.inclusiveLeft ? -1 : 0;\n                }\n                function extraRight(marker) {\n                    return marker.inclusiveRight ? 1 : 0;\n                }\n                function compareCollapsedMarkers(a, b) {\n                    var lenDiff = a.lines.length - b.lines.length;\n                    if (lenDiff != 0) {\n                        return lenDiff;\n                    }\n                    var aPos = a.find(), bPos = b.find();\n                    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n                    if (fromCmp) {\n                        return -fromCmp;\n                    }\n                    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n                    if (toCmp) {\n                        return toCmp;\n                    }\n                    return b.id - a.id;\n                }\n                function collapsedSpanAtSide(line, start) {\n                    var sps = sawCollapsedSpans && line.markedSpans, found;\n                    if (sps) {\n                        for (var sp = void 0, i = 0; i < sps.length; ++i) {\n                            sp = sps[i];\n                            if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n                                found = sp.marker;\n                            }\n                        }\n                    }\n                    return found;\n                }\n                function collapsedSpanAtStart(line) {\n                    return collapsedSpanAtSide(line, true);\n                }\n                function collapsedSpanAtEnd(line) {\n                    return collapsedSpanAtSide(line, false);\n                }\n                function collapsedSpanAround(line, ch) {\n                    var sps = sawCollapsedSpans && line.markedSpans, found;\n                    if (sps) {\n                        for (var i = 0; i < sps.length; ++i) {\n                            var sp = sps[i];\n                            if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n                                found = sp.marker;\n                            }\n                        }\n                    }\n                    return found;\n                }\n                function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n                    var line = getLine(doc, lineNo);\n                    var sps = sawCollapsedSpans && line.markedSpans;\n                    if (sps) {\n                        for (var i = 0; i < sps.length; ++i) {\n                            var sp = sps[i];\n                            if (!sp.marker.collapsed) {\n                                continue;\n                            }\n                            var found = sp.marker.find(0);\n                            var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n                            var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n                            if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {\n                                continue;\n                            }\n                            if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n                function visualLine(line) {\n                    var merged;\n                    while (merged = collapsedSpanAtStart(line)) {\n                        line = merged.find(-1, true).line;\n                    }\n                    return line;\n                }\n                function visualLineEnd(line) {\n                    var merged;\n                    while (merged = collapsedSpanAtEnd(line)) {\n                        line = merged.find(1, true).line;\n                    }\n                    return line;\n                }\n                function visualLineContinued(line) {\n                    var merged, lines;\n                    while (merged = collapsedSpanAtEnd(line)) {\n                        line = merged.find(1, true).line;\n                        (lines || (lines = [])).push(line);\n                    }\n                    return lines;\n                }\n                function visualLineNo(doc, lineN) {\n                    var line = getLine(doc, lineN), vis = visualLine(line);\n                    if (line == vis) {\n                        return lineN;\n                    }\n                    return lineNo(vis);\n                }\n                function visualLineEndNo(doc, lineN) {\n                    if (lineN > doc.lastLine()) {\n                        return lineN;\n                    }\n                    var line = getLine(doc, lineN), merged;\n                    if (!lineIsHidden(doc, line)) {\n                        return lineN;\n                    }\n                    while (merged = collapsedSpanAtEnd(line)) {\n                        line = merged.find(1, true).line;\n                    }\n                    return lineNo(line) + 1;\n                }\n                function lineIsHidden(doc, line) {\n                    var sps = sawCollapsedSpans && line.markedSpans;\n                    if (sps) {\n                        for (var sp = void 0, i = 0; i < sps.length; ++i) {\n                            sp = sps[i];\n                            if (!sp.marker.collapsed) {\n                                continue;\n                            }\n                            if (sp.from == null) {\n                                return true;\n                            }\n                            if (sp.marker.widgetNode) {\n                                continue;\n                            }\n                            if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n                function lineIsHiddenInner(doc, line, span) {\n                    if (span.to == null) {\n                        var end = span.marker.find(1, true);\n                        return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n                    }\n                    if (span.marker.inclusiveRight && span.to == line.text.length) {\n                        return true;\n                    }\n                    for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {\n                        sp = line.markedSpans[i];\n                        if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {\n                            return true;\n                        }\n                    }\n                }\n                function heightAtLine(lineObj) {\n                    lineObj = visualLine(lineObj);\n                    var h = 0, chunk = lineObj.parent;\n                    for (var i = 0; i < chunk.lines.length; ++i) {\n                        var line = chunk.lines[i];\n                        if (line == lineObj) {\n                            break;\n                        } else {\n                            h += line.height;\n                        }\n                    }\n                    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n                        for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n                            var cur = p.children[i$1];\n                            if (cur == chunk) {\n                                break;\n                            } else {\n                                h += cur.height;\n                            }\n                        }\n                    }\n                    return h;\n                }\n                function lineLength(line) {\n                    if (line.height == 0) {\n                        return 0;\n                    }\n                    var len = line.text.length, merged, cur = line;\n                    while (merged = collapsedSpanAtStart(cur)) {\n                        var found = merged.find(0, true);\n                        cur = found.from.line;\n                        len += found.from.ch - found.to.ch;\n                    }\n                    cur = line;\n                    while (merged = collapsedSpanAtEnd(cur)) {\n                        var found$1 = merged.find(0, true);\n                        len -= cur.text.length - found$1.from.ch;\n                        cur = found$1.to.line;\n                        len += cur.text.length - found$1.to.ch;\n                    }\n                    return len;\n                }\n                function findMaxLine(cm) {\n                    var d = cm.display, doc = cm.doc;\n                    d.maxLine = getLine(doc, doc.first);\n                    d.maxLineLength = lineLength(d.maxLine);\n                    d.maxLineChanged = true;\n                    doc.iter(function (line) {\n                        var len = lineLength(line);\n                        if (len > d.maxLineLength) {\n                            d.maxLineLength = len;\n                            d.maxLine = line;\n                        }\n                    });\n                }\n                var Line = function (text, markedSpans, estimateHeight) {\n                    this.text = text;\n                    attachMarkedSpans(this, markedSpans);\n                    this.height = estimateHeight ? estimateHeight(this) : 1;\n                };\n                Line.prototype.lineNo = function () {\n                    return lineNo(this);\n                };\n                eventMixin(Line);\n                function updateLine(line, text, markedSpans, estimateHeight) {\n                    line.text = text;\n                    if (line.stateAfter) {\n                        line.stateAfter = null;\n                    }\n                    if (line.styles) {\n                        line.styles = null;\n                    }\n                    if (line.order != null) {\n                        line.order = null;\n                    }\n                    detachMarkedSpans(line);\n                    attachMarkedSpans(line, markedSpans);\n                    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n                    if (estHeight != line.height) {\n                        updateLineHeight(line, estHeight);\n                    }\n                }\n                function cleanUpLine(line) {\n                    line.parent = null;\n                    detachMarkedSpans(line);\n                }\n                var styleToClassCache = {}, styleToClassCacheWithMode = {};\n                function interpretTokenStyle(style, options) {\n                    if (!style || /^\\s*$/.test(style)) {\n                        return null;\n                    }\n                    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n                    return cache[style] || (cache[style] = style.replace(/\\S+/g, 'cm-$&'));\n                }\n                function buildLineContent(cm, lineView) {\n                    var content = eltP('span', null, null, webkit ? 'padding-right: .1px' : null);\n                    var builder = {\n                        pre: eltP('pre', [content], 'CodeMirror-line'),\n                        content: content,\n                        col: 0,\n                        pos: 0,\n                        cm: cm,\n                        trailingSpace: false,\n                        splitSpaces: cm.getOption('lineWrapping')\n                    };\n                    lineView.measure = {};\n                    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n                        var line = i ? lineView.rest[i - 1] : lineView.line, order = void 0;\n                        builder.pos = 0;\n                        builder.addToken = buildToken;\n                        if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {\n                            builder.addToken = buildTokenBadBidi(builder.addToken, order);\n                        }\n                        builder.map = [];\n                        var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n                        insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n                        if (line.styleClasses) {\n                            if (line.styleClasses.bgClass) {\n                                builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || '');\n                            }\n                            if (line.styleClasses.textClass) {\n                                builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || '');\n                            }\n                        }\n                        if (builder.map.length == 0) {\n                            builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n                        }\n                        if (i == 0) {\n                            lineView.measure.map = builder.map;\n                            lineView.measure.cache = {};\n                        } else {\n                            (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n                            (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n                        }\n                    }\n                    if (webkit) {\n                        var last = builder.content.lastChild;\n                        if (/\\bcm-tab\\b/.test(last.className) || last.querySelector && last.querySelector('.cm-tab')) {\n                            builder.content.className = 'cm-tab-wrap-hack';\n                        }\n                    }\n                    signal(cm, 'renderLine', cm, lineView.line, builder.pre);\n                    if (builder.pre.className) {\n                        builder.textClass = joinClasses(builder.pre.className, builder.textClass || '');\n                    }\n                    return builder;\n                }\n                function defaultSpecialCharPlaceholder(ch) {\n                    var token = elt('span', '\\u2022', 'cm-invalidchar');\n                    token.title = '\\\\u' + ch.charCodeAt(0).toString(16);\n                    token.setAttribute('aria-label', token.title);\n                    return token;\n                }\n                function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n                    if (!text) {\n                        return;\n                    }\n                    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n                    var special = builder.cm.state.specialChars, mustWrap = false;\n                    var content;\n                    if (!special.test(text)) {\n                        builder.col += text.length;\n                        content = document.createTextNode(displayText);\n                        builder.map.push(builder.pos, builder.pos + text.length, content);\n                        if (ie && ie_version < 9) {\n                            mustWrap = true;\n                        }\n                        builder.pos += text.length;\n                    } else {\n                        content = document.createDocumentFragment();\n                        var pos = 0;\n                        while (true) {\n                            special.lastIndex = pos;\n                            var m = special.exec(text);\n                            var skipped = m ? m.index - pos : text.length - pos;\n                            if (skipped) {\n                                var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n                                if (ie && ie_version < 9) {\n                                    content.appendChild(elt('span', [txt]));\n                                } else {\n                                    content.appendChild(txt);\n                                }\n                                builder.map.push(builder.pos, builder.pos + skipped, txt);\n                                builder.col += skipped;\n                                builder.pos += skipped;\n                            }\n                            if (!m) {\n                                break;\n                            }\n                            pos += skipped + 1;\n                            var txt$1 = void 0;\n                            if (m[0] == '\\t') {\n                                var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n                                txt$1 = content.appendChild(elt('span', spaceStr(tabWidth), 'cm-tab'));\n                                txt$1.setAttribute('role', 'presentation');\n                                txt$1.setAttribute('cm-text', '\\t');\n                                builder.col += tabWidth;\n                            } else if (m[0] == '\\r' || m[0] == '\\n') {\n                                txt$1 = content.appendChild(elt('span', m[0] == '\\r' ? '\\u240D' : '\\u2424', 'cm-invalidchar'));\n                                txt$1.setAttribute('cm-text', m[0]);\n                                builder.col += 1;\n                            } else {\n                                txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n                                txt$1.setAttribute('cm-text', m[0]);\n                                if (ie && ie_version < 9) {\n                                    content.appendChild(elt('span', [txt$1]));\n                                } else {\n                                    content.appendChild(txt$1);\n                                }\n                                builder.col += 1;\n                            }\n                            builder.map.push(builder.pos, builder.pos + 1, txt$1);\n                            builder.pos++;\n                        }\n                    }\n                    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n                    if (style || startStyle || endStyle || mustWrap || css || attributes) {\n                        var fullStyle = style || '';\n                        if (startStyle) {\n                            fullStyle += startStyle;\n                        }\n                        if (endStyle) {\n                            fullStyle += endStyle;\n                        }\n                        var token = elt('span', [content], fullStyle, css);\n                        if (attributes) {\n                            for (var attr in attributes) {\n                                if (attributes.hasOwnProperty(attr) && attr != 'style' && attr != 'class') {\n                                    token.setAttribute(attr, attributes[attr]);\n                                }\n                            }\n                        }\n                        return builder.content.appendChild(token);\n                    }\n                    builder.content.appendChild(content);\n                }\n                function splitSpaces(text, trailingBefore) {\n                    if (text.length > 1 && !/  /.test(text)) {\n                        return text;\n                    }\n                    var spaceBefore = trailingBefore, result = '';\n                    for (var i = 0; i < text.length; i++) {\n                        var ch = text.charAt(i);\n                        if (ch == ' ' && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {\n                            ch = '\\xA0';\n                        }\n                        result += ch;\n                        spaceBefore = ch == ' ';\n                    }\n                    return result;\n                }\n                function buildTokenBadBidi(inner, order) {\n                    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n                        style = style ? style + ' cm-force-border' : 'cm-force-border';\n                        var start = builder.pos, end = start + text.length;\n                        for (;;) {\n                            var part = void 0;\n                            for (var i = 0; i < order.length; i++) {\n                                part = order[i];\n                                if (part.to > start && part.from <= start) {\n                                    break;\n                                }\n                            }\n                            if (part.to >= end) {\n                                return inner(builder, text, style, startStyle, endStyle, css, attributes);\n                            }\n                            inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n                            startStyle = null;\n                            text = text.slice(part.to - start);\n                            start = part.to;\n                        }\n                    };\n                }\n                function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n                    var widget = !ignoreWidget && marker.widgetNode;\n                    if (widget) {\n                        builder.map.push(builder.pos, builder.pos + size, widget);\n                    }\n                    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n                        if (!widget) {\n                            widget = builder.content.appendChild(document.createElement('span'));\n                        }\n                        widget.setAttribute('cm-marker', marker.id);\n                    }\n                    if (widget) {\n                        builder.cm.display.input.setUneditable(widget);\n                        builder.content.appendChild(widget);\n                    }\n                    builder.pos += size;\n                    builder.trailingSpace = false;\n                }\n                function insertLineContent(line, builder, styles) {\n                    var spans = line.markedSpans, allText = line.text, at = 0;\n                    if (!spans) {\n                        for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {\n                            builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));\n                        }\n                        return;\n                    }\n                    var len = allText.length, pos = 0, i = 1, text = '', style, css;\n                    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n                    for (;;) {\n                        if (nextChange == pos) {\n                            spanStyle = spanEndStyle = spanStartStyle = css = '';\n                            attributes = null;\n                            collapsed = null;\n                            nextChange = Infinity;\n                            var foundBookmarks = [], endStyles = void 0;\n                            for (var j = 0; j < spans.length; ++j) {\n                                var sp = spans[j], m = sp.marker;\n                                if (m.type == 'bookmark' && sp.from == pos && m.widgetNode) {\n                                    foundBookmarks.push(m);\n                                } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n                                    if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n                                        nextChange = sp.to;\n                                        spanEndStyle = '';\n                                    }\n                                    if (m.className) {\n                                        spanStyle += ' ' + m.className;\n                                    }\n                                    if (m.css) {\n                                        css = (css ? css + ';' : '') + m.css;\n                                    }\n                                    if (m.startStyle && sp.from == pos) {\n                                        spanStartStyle += ' ' + m.startStyle;\n                                    }\n                                    if (m.endStyle && sp.to == nextChange) {\n                                        (endStyles || (endStyles = [])).push(m.endStyle, sp.to);\n                                    }\n                                    if (m.title) {\n                                        (attributes || (attributes = {})).title = m.title;\n                                    }\n                                    if (m.attributes) {\n                                        for (var attr in m.attributes) {\n                                            (attributes || (attributes = {}))[attr] = m.attributes[attr];\n                                        }\n                                    }\n                                    if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {\n                                        collapsed = sp;\n                                    }\n                                } else if (sp.from > pos && nextChange > sp.from) {\n                                    nextChange = sp.from;\n                                }\n                            }\n                            if (endStyles) {\n                                for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {\n                                    if (endStyles[j$1 + 1] == nextChange) {\n                                        spanEndStyle += ' ' + endStyles[j$1];\n                                    }\n                                }\n                            }\n                            if (!collapsed || collapsed.from == pos) {\n                                for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {\n                                    buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);\n                                }\n                            }\n                            if (collapsed && (collapsed.from || 0) == pos) {\n                                buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);\n                                if (collapsed.to == null) {\n                                    return;\n                                }\n                                if (collapsed.to == pos) {\n                                    collapsed = false;\n                                }\n                            }\n                        }\n                        if (pos >= len) {\n                            break;\n                        }\n                        var upto = Math.min(len, nextChange);\n                        while (true) {\n                            if (text) {\n                                var end = pos + text.length;\n                                if (!collapsed) {\n                                    var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n                                    builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : '', css, attributes);\n                                }\n                                if (end >= upto) {\n                                    text = text.slice(upto - pos);\n                                    pos = upto;\n                                    break;\n                                }\n                                pos = end;\n                                spanStartStyle = '';\n                            }\n                            text = allText.slice(at, at = styles[i++]);\n                            style = interpretTokenStyle(styles[i++], builder.cm.options);\n                        }\n                    }\n                }\n                function LineView(doc, line, lineN) {\n                    this.line = line;\n                    this.rest = visualLineContinued(line);\n                    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n                    this.node = this.text = null;\n                    this.hidden = lineIsHidden(doc, line);\n                }\n                function buildViewArray(cm, from, to) {\n                    var array = [], nextPos;\n                    for (var pos = from; pos < to; pos = nextPos) {\n                        var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n                        nextPos = pos + view.size;\n                        array.push(view);\n                    }\n                    return array;\n                }\n                var operationGroup = null;\n                function pushOperation(op) {\n                    if (operationGroup) {\n                        operationGroup.ops.push(op);\n                    } else {\n                        op.ownsGroup = operationGroup = {\n                            ops: [op],\n                            delayedCallbacks: []\n                        };\n                    }\n                }\n                function fireCallbacksForOps(group) {\n                    var callbacks = group.delayedCallbacks, i = 0;\n                    do {\n                        for (; i < callbacks.length; i++) {\n                            callbacks[i].call(null);\n                        }\n                        for (var j = 0; j < group.ops.length; j++) {\n                            var op = group.ops[j];\n                            if (op.cursorActivityHandlers) {\n                                while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {\n                                    op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n                                }\n                            }\n                        }\n                    } while (i < callbacks.length);\n                }\n                function finishOperation(op, endCb) {\n                    var group = op.ownsGroup;\n                    if (!group) {\n                        return;\n                    }\n                    try {\n                        fireCallbacksForOps(group);\n                    } finally {\n                        operationGroup = null;\n                        endCb(group);\n                    }\n                }\n                var orphanDelayedCallbacks = null;\n                function signalLater(emitter, type) {\n                    var arr = getHandlers(emitter, type);\n                    if (!arr.length) {\n                        return;\n                    }\n                    var args = Array.prototype.slice.call(arguments, 2), list;\n                    if (operationGroup) {\n                        list = operationGroup.delayedCallbacks;\n                    } else if (orphanDelayedCallbacks) {\n                        list = orphanDelayedCallbacks;\n                    } else {\n                        list = orphanDelayedCallbacks = [];\n                        setTimeout(fireOrphanDelayed, 0);\n                    }\n                    var loop = function (i) {\n                        list.push(function () {\n                            return arr[i].apply(null, args);\n                        });\n                    };\n                    for (var i = 0; i < arr.length; ++i)\n                        loop(i);\n                }\n                function fireOrphanDelayed() {\n                    var delayed = orphanDelayedCallbacks;\n                    orphanDelayedCallbacks = null;\n                    for (var i = 0; i < delayed.length; ++i) {\n                        delayed[i]();\n                    }\n                }\n                function updateLineForChanges(cm, lineView, lineN, dims) {\n                    for (var j = 0; j < lineView.changes.length; j++) {\n                        var type = lineView.changes[j];\n                        if (type == 'text') {\n                            updateLineText(cm, lineView);\n                        } else if (type == 'gutter') {\n                            updateLineGutter(cm, lineView, lineN, dims);\n                        } else if (type == 'class') {\n                            updateLineClasses(cm, lineView);\n                        } else if (type == 'widget') {\n                            updateLineWidgets(cm, lineView, dims);\n                        }\n                    }\n                    lineView.changes = null;\n                }\n                function ensureLineWrapped(lineView) {\n                    if (lineView.node == lineView.text) {\n                        lineView.node = elt('div', null, null, 'position: relative');\n                        if (lineView.text.parentNode) {\n                            lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n                        }\n                        lineView.node.appendChild(lineView.text);\n                        if (ie && ie_version < 8) {\n                            lineView.node.style.zIndex = 2;\n                        }\n                    }\n                    return lineView.node;\n                }\n                function updateLineBackground(cm, lineView) {\n                    var cls = lineView.bgClass ? lineView.bgClass + ' ' + (lineView.line.bgClass || '') : lineView.line.bgClass;\n                    if (cls) {\n                        cls += ' CodeMirror-linebackground';\n                    }\n                    if (lineView.background) {\n                        if (cls) {\n                            lineView.background.className = cls;\n                        } else {\n                            lineView.background.parentNode.removeChild(lineView.background);\n                            lineView.background = null;\n                        }\n                    } else if (cls) {\n                        var wrap = ensureLineWrapped(lineView);\n                        lineView.background = wrap.insertBefore(elt('div', null, cls), wrap.firstChild);\n                        cm.display.input.setUneditable(lineView.background);\n                    }\n                }\n                function getLineContent(cm, lineView) {\n                    var ext = cm.display.externalMeasured;\n                    if (ext && ext.line == lineView.line) {\n                        cm.display.externalMeasured = null;\n                        lineView.measure = ext.measure;\n                        return ext.built;\n                    }\n                    return buildLineContent(cm, lineView);\n                }\n                function updateLineText(cm, lineView) {\n                    var cls = lineView.text.className;\n                    var built = getLineContent(cm, lineView);\n                    if (lineView.text == lineView.node) {\n                        lineView.node = built.pre;\n                    }\n                    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n                    lineView.text = built.pre;\n                    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n                        lineView.bgClass = built.bgClass;\n                        lineView.textClass = built.textClass;\n                        updateLineClasses(cm, lineView);\n                    } else if (cls) {\n                        lineView.text.className = cls;\n                    }\n                }\n                function updateLineClasses(cm, lineView) {\n                    updateLineBackground(cm, lineView);\n                    if (lineView.line.wrapClass) {\n                        ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n                    } else if (lineView.node != lineView.text) {\n                        lineView.node.className = '';\n                    }\n                    var textClass = lineView.textClass ? lineView.textClass + ' ' + (lineView.line.textClass || '') : lineView.line.textClass;\n                    lineView.text.className = textClass || '';\n                }\n                function updateLineGutter(cm, lineView, lineN, dims) {\n                    if (lineView.gutter) {\n                        lineView.node.removeChild(lineView.gutter);\n                        lineView.gutter = null;\n                    }\n                    if (lineView.gutterBackground) {\n                        lineView.node.removeChild(lineView.gutterBackground);\n                        lineView.gutterBackground = null;\n                    }\n                    if (lineView.line.gutterClass) {\n                        var wrap = ensureLineWrapped(lineView);\n                        lineView.gutterBackground = elt('div', null, 'CodeMirror-gutter-background ' + lineView.line.gutterClass, 'left: ' + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + 'px; width: ' + dims.gutterTotalWidth + 'px');\n                        cm.display.input.setUneditable(lineView.gutterBackground);\n                        wrap.insertBefore(lineView.gutterBackground, lineView.text);\n                    }\n                    var markers = lineView.line.gutterMarkers;\n                    if (cm.options.lineNumbers || markers) {\n                        var wrap$1 = ensureLineWrapped(lineView);\n                        var gutterWrap = lineView.gutter = elt('div', null, 'CodeMirror-gutter-wrapper', 'left: ' + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + 'px');\n                        gutterWrap.setAttribute('aria-hidden', 'true');\n                        cm.display.input.setUneditable(gutterWrap);\n                        wrap$1.insertBefore(gutterWrap, lineView.text);\n                        if (lineView.line.gutterClass) {\n                            gutterWrap.className += ' ' + lineView.line.gutterClass;\n                        }\n                        if (cm.options.lineNumbers && (!markers || !markers['CodeMirror-linenumbers'])) {\n                            lineView.lineNumber = gutterWrap.appendChild(elt('div', lineNumberFor(cm.options, lineN), 'CodeMirror-linenumber CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft['CodeMirror-linenumbers'] + 'px; width: ' + cm.display.lineNumInnerWidth + 'px'));\n                        }\n                        if (markers) {\n                            for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n                                var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];\n                                if (found) {\n                                    gutterWrap.appendChild(elt('div', [found], 'CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft[id] + 'px; width: ' + dims.gutterWidth[id] + 'px'));\n                                }\n                            }\n                        }\n                    }\n                }\n                function updateLineWidgets(cm, lineView, dims) {\n                    if (lineView.alignable) {\n                        lineView.alignable = null;\n                    }\n                    var isWidget = classTest('CodeMirror-linewidget');\n                    for (var node = lineView.node.firstChild, next = void 0; node; node = next) {\n                        next = node.nextSibling;\n                        if (isWidget.test(node.className)) {\n                            lineView.node.removeChild(node);\n                        }\n                    }\n                    insertLineWidgets(cm, lineView, dims);\n                }\n                function buildLineElement(cm, lineView, lineN, dims) {\n                    var built = getLineContent(cm, lineView);\n                    lineView.text = lineView.node = built.pre;\n                    if (built.bgClass) {\n                        lineView.bgClass = built.bgClass;\n                    }\n                    if (built.textClass) {\n                        lineView.textClass = built.textClass;\n                    }\n                    updateLineClasses(cm, lineView);\n                    updateLineGutter(cm, lineView, lineN, dims);\n                    insertLineWidgets(cm, lineView, dims);\n                    return lineView.node;\n                }\n                function insertLineWidgets(cm, lineView, dims) {\n                    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n                    if (lineView.rest) {\n                        for (var i = 0; i < lineView.rest.length; i++) {\n                            insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n                        }\n                    }\n                }\n                function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n                    if (!line.widgets) {\n                        return;\n                    }\n                    var wrap = ensureLineWrapped(lineView);\n                    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n                        var widget = ws[i], node = elt('div', [widget.node], 'CodeMirror-linewidget' + (widget.className ? ' ' + widget.className : ''));\n                        if (!widget.handleMouseEvents) {\n                            node.setAttribute('cm-ignore-events', 'true');\n                        }\n                        positionLineWidget(widget, node, lineView, dims);\n                        cm.display.input.setUneditable(node);\n                        if (allowAbove && widget.above) {\n                            wrap.insertBefore(node, lineView.gutter || lineView.text);\n                        } else {\n                            wrap.appendChild(node);\n                        }\n                        signalLater(widget, 'redraw');\n                    }\n                }\n                function positionLineWidget(widget, node, lineView, dims) {\n                    if (widget.noHScroll) {\n                        (lineView.alignable || (lineView.alignable = [])).push(node);\n                        var width = dims.wrapperWidth;\n                        node.style.left = dims.fixedPos + 'px';\n                        if (!widget.coverGutter) {\n                            width -= dims.gutterTotalWidth;\n                            node.style.paddingLeft = dims.gutterTotalWidth + 'px';\n                        }\n                        node.style.width = width + 'px';\n                    }\n                    if (widget.coverGutter) {\n                        node.style.zIndex = 5;\n                        node.style.position = 'relative';\n                        if (!widget.noHScroll) {\n                            node.style.marginLeft = -dims.gutterTotalWidth + 'px';\n                        }\n                    }\n                }\n                function widgetHeight(widget) {\n                    if (widget.height != null) {\n                        return widget.height;\n                    }\n                    var cm = widget.doc.cm;\n                    if (!cm) {\n                        return 0;\n                    }\n                    if (!contains(document.body, widget.node)) {\n                        var parentStyle = 'position: relative;';\n                        if (widget.coverGutter) {\n                            parentStyle += 'margin-left: -' + cm.display.gutters.offsetWidth + 'px;';\n                        }\n                        if (widget.noHScroll) {\n                            parentStyle += 'width: ' + cm.display.wrapper.clientWidth + 'px;';\n                        }\n                        removeChildrenAndAdd(cm.display.measure, elt('div', [widget.node], null, parentStyle));\n                    }\n                    return widget.height = widget.node.parentNode.offsetHeight;\n                }\n                function eventInWidget(display, e) {\n                    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n                        if (!n || n.nodeType == 1 && n.getAttribute('cm-ignore-events') == 'true' || n.parentNode == display.sizer && n != display.mover) {\n                            return true;\n                        }\n                    }\n                }\n                function paddingTop(display) {\n                    return display.lineSpace.offsetTop;\n                }\n                function paddingVert(display) {\n                    return display.mover.offsetHeight - display.lineSpace.offsetHeight;\n                }\n                function paddingH(display) {\n                    if (display.cachedPaddingH) {\n                        return display.cachedPaddingH;\n                    }\n                    var e = removeChildrenAndAdd(display.measure, elt('pre', 'x', 'CodeMirror-line-like'));\n                    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n                    var data = {\n                        left: parseInt(style.paddingLeft),\n                        right: parseInt(style.paddingRight)\n                    };\n                    if (!isNaN(data.left) && !isNaN(data.right)) {\n                        display.cachedPaddingH = data;\n                    }\n                    return data;\n                }\n                function scrollGap(cm) {\n                    return scrollerGap - cm.display.nativeBarWidth;\n                }\n                function displayWidth(cm) {\n                    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n                }\n                function displayHeight(cm) {\n                    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n                }\n                function ensureLineHeights(cm, lineView, rect) {\n                    var wrapping = cm.options.lineWrapping;\n                    var curWidth = wrapping && displayWidth(cm);\n                    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n                        var heights = lineView.measure.heights = [];\n                        if (wrapping) {\n                            lineView.measure.width = curWidth;\n                            var rects = lineView.text.firstChild.getClientRects();\n                            for (var i = 0; i < rects.length - 1; i++) {\n                                var cur = rects[i], next = rects[i + 1];\n                                if (Math.abs(cur.bottom - next.bottom) > 2) {\n                                    heights.push((cur.bottom + next.top) / 2 - rect.top);\n                                }\n                            }\n                        }\n                        heights.push(rect.bottom - rect.top);\n                    }\n                }\n                function mapFromLineView(lineView, line, lineN) {\n                    if (lineView.line == line) {\n                        return {\n                            map: lineView.measure.map,\n                            cache: lineView.measure.cache\n                        };\n                    }\n                    if (lineView.rest) {\n                        for (var i = 0; i < lineView.rest.length; i++) {\n                            if (lineView.rest[i] == line) {\n                                return {\n                                    map: lineView.measure.maps[i],\n                                    cache: lineView.measure.caches[i]\n                                };\n                            }\n                        }\n                        for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {\n                            if (lineNo(lineView.rest[i$1]) > lineN) {\n                                return {\n                                    map: lineView.measure.maps[i$1],\n                                    cache: lineView.measure.caches[i$1],\n                                    before: true\n                                };\n                            }\n                        }\n                    }\n                }\n                function updateExternalMeasurement(cm, line) {\n                    line = visualLine(line);\n                    var lineN = lineNo(line);\n                    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n                    view.lineN = lineN;\n                    var built = view.built = buildLineContent(cm, view);\n                    view.text = built.pre;\n                    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n                    return view;\n                }\n                function measureChar(cm, line, ch, bias) {\n                    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n                }\n                function findViewForLine(cm, lineN) {\n                    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {\n                        return cm.display.view[findViewIndex(cm, lineN)];\n                    }\n                    var ext = cm.display.externalMeasured;\n                    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {\n                        return ext;\n                    }\n                }\n                function prepareMeasureForLine(cm, line) {\n                    var lineN = lineNo(line);\n                    var view = findViewForLine(cm, lineN);\n                    if (view && !view.text) {\n                        view = null;\n                    } else if (view && view.changes) {\n                        updateLineForChanges(cm, view, lineN, getDimensions(cm));\n                        cm.curOp.forceUpdate = true;\n                    }\n                    if (!view) {\n                        view = updateExternalMeasurement(cm, line);\n                    }\n                    var info = mapFromLineView(view, line, lineN);\n                    return {\n                        line: line,\n                        view: view,\n                        rect: null,\n                        map: info.map,\n                        cache: info.cache,\n                        before: info.before,\n                        hasHeights: false\n                    };\n                }\n                function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n                    if (prepared.before) {\n                        ch = -1;\n                    }\n                    var key = ch + (bias || ''), found;\n                    if (prepared.cache.hasOwnProperty(key)) {\n                        found = prepared.cache[key];\n                    } else {\n                        if (!prepared.rect) {\n                            prepared.rect = prepared.view.text.getBoundingClientRect();\n                        }\n                        if (!prepared.hasHeights) {\n                            ensureLineHeights(cm, prepared.view, prepared.rect);\n                            prepared.hasHeights = true;\n                        }\n                        found = measureCharInner(cm, prepared, ch, bias);\n                        if (!found.bogus) {\n                            prepared.cache[key] = found;\n                        }\n                    }\n                    return {\n                        left: found.left,\n                        right: found.right,\n                        top: varHeight ? found.rtop : found.top,\n                        bottom: varHeight ? found.rbottom : found.bottom\n                    };\n                }\n                var nullRect = {\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                    bottom: 0\n                };\n                function nodeAndOffsetInLineMap(map, ch, bias) {\n                    var node, start, end, collapse, mStart, mEnd;\n                    for (var i = 0; i < map.length; i += 3) {\n                        mStart = map[i];\n                        mEnd = map[i + 1];\n                        if (ch < mStart) {\n                            start = 0;\n                            end = 1;\n                            collapse = 'left';\n                        } else if (ch < mEnd) {\n                            start = ch - mStart;\n                            end = start + 1;\n                        } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n                            end = mEnd - mStart;\n                            start = end - 1;\n                            if (ch >= mEnd) {\n                                collapse = 'right';\n                            }\n                        }\n                        if (start != null) {\n                            node = map[i + 2];\n                            if (mStart == mEnd && bias == (node.insertLeft ? 'left' : 'right')) {\n                                collapse = bias;\n                            }\n                            if (bias == 'left' && start == 0) {\n                                while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n                                    node = map[(i -= 3) + 2];\n                                    collapse = 'left';\n                                }\n                            }\n                            if (bias == 'right' && start == mEnd - mStart) {\n                                while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n                                    node = map[(i += 3) + 2];\n                                    collapse = 'right';\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    return {\n                        node: node,\n                        start: start,\n                        end: end,\n                        collapse: collapse,\n                        coverStart: mStart,\n                        coverEnd: mEnd\n                    };\n                }\n                function getUsefulRect(rects, bias) {\n                    var rect = nullRect;\n                    if (bias == 'left') {\n                        for (var i = 0; i < rects.length; i++) {\n                            if ((rect = rects[i]).left != rect.right) {\n                                break;\n                            }\n                        }\n                    } else {\n                        for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n                            if ((rect = rects[i$1]).left != rect.right) {\n                                break;\n                            }\n                        }\n                    }\n                    return rect;\n                }\n                function measureCharInner(cm, prepared, ch, bias) {\n                    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n                    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n                    var rect;\n                    if (node.nodeType == 3) {\n                        for (var i$1 = 0; i$1 < 4; i$1++) {\n                            while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {\n                                --start;\n                            }\n                            while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {\n                                ++end;\n                            }\n                            if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n                                rect = node.parentNode.getBoundingClientRect();\n                            } else {\n                                rect = getUsefulRect(range(node, start, end).getClientRects(), bias);\n                            }\n                            if (rect.left || rect.right || start == 0) {\n                                break;\n                            }\n                            end = start;\n                            start = start - 1;\n                            collapse = 'right';\n                        }\n                        if (ie && ie_version < 11) {\n                            rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n                        }\n                    } else {\n                        if (start > 0) {\n                            collapse = bias = 'right';\n                        }\n                        var rects;\n                        if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {\n                            rect = rects[bias == 'right' ? rects.length - 1 : 0];\n                        } else {\n                            rect = node.getBoundingClientRect();\n                        }\n                    }\n                    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n                        var rSpan = node.parentNode.getClientRects()[0];\n                        if (rSpan) {\n                            rect = {\n                                left: rSpan.left,\n                                right: rSpan.left + charWidth(cm.display),\n                                top: rSpan.top,\n                                bottom: rSpan.bottom\n                            };\n                        } else {\n                            rect = nullRect;\n                        }\n                    }\n                    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n                    var mid = (rtop + rbot) / 2;\n                    var heights = prepared.view.measure.heights;\n                    var i = 0;\n                    for (; i < heights.length - 1; i++) {\n                        if (mid < heights[i]) {\n                            break;\n                        }\n                    }\n                    var top = i ? heights[i - 1] : 0, bot = heights[i];\n                    var result = {\n                        left: (collapse == 'right' ? rect.right : rect.left) - prepared.rect.left,\n                        right: (collapse == 'left' ? rect.left : rect.right) - prepared.rect.left,\n                        top: top,\n                        bottom: bot\n                    };\n                    if (!rect.left && !rect.right) {\n                        result.bogus = true;\n                    }\n                    if (!cm.options.singleCursorHeightPerLine) {\n                        result.rtop = rtop;\n                        result.rbottom = rbot;\n                    }\n                    return result;\n                }\n                function maybeUpdateRectForZooming(measure, rect) {\n                    if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {\n                        return rect;\n                    }\n                    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n                    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n                    return {\n                        left: rect.left * scaleX,\n                        right: rect.right * scaleX,\n                        top: rect.top * scaleY,\n                        bottom: rect.bottom * scaleY\n                    };\n                }\n                function clearLineMeasurementCacheFor(lineView) {\n                    if (lineView.measure) {\n                        lineView.measure.cache = {};\n                        lineView.measure.heights = null;\n                        if (lineView.rest) {\n                            for (var i = 0; i < lineView.rest.length; i++) {\n                                lineView.measure.caches[i] = {};\n                            }\n                        }\n                    }\n                }\n                function clearLineMeasurementCache(cm) {\n                    cm.display.externalMeasure = null;\n                    removeChildren(cm.display.lineMeasure);\n                    for (var i = 0; i < cm.display.view.length; i++) {\n                        clearLineMeasurementCacheFor(cm.display.view[i]);\n                    }\n                }\n                function clearCaches(cm) {\n                    clearLineMeasurementCache(cm);\n                    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n                    if (!cm.options.lineWrapping) {\n                        cm.display.maxLineChanged = true;\n                    }\n                    cm.display.lineNumChars = null;\n                }\n                function pageScrollX(doc) {\n                    if (chrome && android) {\n                        return -(doc.body.getBoundingClientRect().left - parseInt(getComputedStyle(doc.body).marginLeft));\n                    }\n                    return doc.defaultView.pageXOffset || (doc.documentElement || doc.body).scrollLeft;\n                }\n                function pageScrollY(doc) {\n                    if (chrome && android) {\n                        return -(doc.body.getBoundingClientRect().top - parseInt(getComputedStyle(doc.body).marginTop));\n                    }\n                    return doc.defaultView.pageYOffset || (doc.documentElement || doc.body).scrollTop;\n                }\n                function widgetTopHeight(lineObj) {\n                    var ref = visualLine(lineObj);\n                    var widgets = ref.widgets;\n                    var height = 0;\n                    if (widgets) {\n                        for (var i = 0; i < widgets.length; ++i) {\n                            if (widgets[i].above) {\n                                height += widgetHeight(widgets[i]);\n                            }\n                        }\n                    }\n                    return height;\n                }\n                function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n                    if (!includeWidgets) {\n                        var height = widgetTopHeight(lineObj);\n                        rect.top += height;\n                        rect.bottom += height;\n                    }\n                    if (context == 'line') {\n                        return rect;\n                    }\n                    if (!context) {\n                        context = 'local';\n                    }\n                    var yOff = heightAtLine(lineObj);\n                    if (context == 'local') {\n                        yOff += paddingTop(cm.display);\n                    } else {\n                        yOff -= cm.display.viewOffset;\n                    }\n                    if (context == 'page' || context == 'window') {\n                        var lOff = cm.display.lineSpace.getBoundingClientRect();\n                        yOff += lOff.top + (context == 'window' ? 0 : pageScrollY(doc(cm)));\n                        var xOff = lOff.left + (context == 'window' ? 0 : pageScrollX(doc(cm)));\n                        rect.left += xOff;\n                        rect.right += xOff;\n                    }\n                    rect.top += yOff;\n                    rect.bottom += yOff;\n                    return rect;\n                }\n                function fromCoordSystem(cm, coords, context) {\n                    if (context == 'div') {\n                        return coords;\n                    }\n                    var left = coords.left, top = coords.top;\n                    if (context == 'page') {\n                        left -= pageScrollX(doc(cm));\n                        top -= pageScrollY(doc(cm));\n                    } else if (context == 'local' || !context) {\n                        var localBox = cm.display.sizer.getBoundingClientRect();\n                        left += localBox.left;\n                        top += localBox.top;\n                    }\n                    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n                    return {\n                        left: left - lineSpaceBox.left,\n                        top: top - lineSpaceBox.top\n                    };\n                }\n                function charCoords(cm, pos, context, lineObj, bias) {\n                    if (!lineObj) {\n                        lineObj = getLine(cm.doc, pos.line);\n                    }\n                    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n                }\n                function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n                    lineObj = lineObj || getLine(cm.doc, pos.line);\n                    if (!preparedMeasure) {\n                        preparedMeasure = prepareMeasureForLine(cm, lineObj);\n                    }\n                    function get(ch, right) {\n                        var m = measureCharPrepared(cm, preparedMeasure, ch, right ? 'right' : 'left', varHeight);\n                        if (right) {\n                            m.left = m.right;\n                        } else {\n                            m.right = m.left;\n                        }\n                        return intoCoordSystem(cm, lineObj, m, context);\n                    }\n                    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n                    if (ch >= lineObj.text.length) {\n                        ch = lineObj.text.length;\n                        sticky = 'before';\n                    } else if (ch <= 0) {\n                        ch = 0;\n                        sticky = 'after';\n                    }\n                    if (!order) {\n                        return get(sticky == 'before' ? ch - 1 : ch, sticky == 'before');\n                    }\n                    function getBidi(ch, partPos, invert) {\n                        var part = order[partPos], right = part.level == 1;\n                        return get(invert ? ch - 1 : ch, right != invert);\n                    }\n                    var partPos = getBidiPartAt(order, ch, sticky);\n                    var other = bidiOther;\n                    var val = getBidi(ch, partPos, sticky == 'before');\n                    if (other != null) {\n                        val.other = getBidi(ch, other, sticky != 'before');\n                    }\n                    return val;\n                }\n                function estimateCoords(cm, pos) {\n                    var left = 0;\n                    pos = clipPos(cm.doc, pos);\n                    if (!cm.options.lineWrapping) {\n                        left = charWidth(cm.display) * pos.ch;\n                    }\n                    var lineObj = getLine(cm.doc, pos.line);\n                    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n                    return {\n                        left: left,\n                        right: left,\n                        top: top,\n                        bottom: top + lineObj.height\n                    };\n                }\n                function PosWithInfo(line, ch, sticky, outside, xRel) {\n                    var pos = Pos(line, ch, sticky);\n                    pos.xRel = xRel;\n                    if (outside) {\n                        pos.outside = outside;\n                    }\n                    return pos;\n                }\n                function coordsChar(cm, x, y) {\n                    var doc = cm.doc;\n                    y += cm.display.viewOffset;\n                    if (y < 0) {\n                        return PosWithInfo(doc.first, 0, null, -1, -1);\n                    }\n                    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n                    if (lineN > last) {\n                        return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);\n                    }\n                    if (x < 0) {\n                        x = 0;\n                    }\n                    var lineObj = getLine(doc, lineN);\n                    for (;;) {\n                        var found = coordsCharInner(cm, lineObj, lineN, x, y);\n                        var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n                        if (!collapsed) {\n                            return found;\n                        }\n                        var rangeEnd = collapsed.find(1);\n                        if (rangeEnd.line == lineN) {\n                            return rangeEnd;\n                        }\n                        lineObj = getLine(doc, lineN = rangeEnd.line);\n                    }\n                }\n                function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n                    y -= widgetTopHeight(lineObj);\n                    var end = lineObj.text.length;\n                    var begin = findFirst(function (ch) {\n                        return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;\n                    }, end, 0);\n                    end = findFirst(function (ch) {\n                        return measureCharPrepared(cm, preparedMeasure, ch).top > y;\n                    }, begin, end);\n                    return {\n                        begin: begin,\n                        end: end\n                    };\n                }\n                function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n                    if (!preparedMeasure) {\n                        preparedMeasure = prepareMeasureForLine(cm, lineObj);\n                    }\n                    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), 'line').top;\n                    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);\n                }\n                function boxIsAfter(box, x, y, left) {\n                    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;\n                }\n                function coordsCharInner(cm, lineObj, lineNo, x, y) {\n                    y -= heightAtLine(lineObj);\n                    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n                    var widgetHeight = widgetTopHeight(lineObj);\n                    var begin = 0, end = lineObj.text.length, ltr = true;\n                    var order = getOrder(lineObj, cm.doc.direction);\n                    if (order) {\n                        var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo, preparedMeasure, order, x, y);\n                        ltr = part.level != 1;\n                        begin = ltr ? part.from : part.to - 1;\n                        end = ltr ? part.to : part.from - 1;\n                    }\n                    var chAround = null, boxAround = null;\n                    var ch = findFirst(function (ch) {\n                        var box = measureCharPrepared(cm, preparedMeasure, ch);\n                        box.top += widgetHeight;\n                        box.bottom += widgetHeight;\n                        if (!boxIsAfter(box, x, y, false)) {\n                            return false;\n                        }\n                        if (box.top <= y && box.left <= x) {\n                            chAround = ch;\n                            boxAround = box;\n                        }\n                        return true;\n                    }, begin, end);\n                    var baseX, sticky, outside = false;\n                    if (boxAround) {\n                        var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n                        ch = chAround + (atStart ? 0 : 1);\n                        sticky = atStart ? 'after' : 'before';\n                        baseX = atLeft ? boxAround.left : boxAround.right;\n                    } else {\n                        if (!ltr && (ch == end || ch == begin)) {\n                            ch++;\n                        }\n                        sticky = ch == 0 ? 'after' : ch == lineObj.text.length ? 'before' : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y == ltr ? 'after' : 'before';\n                        var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), 'line', lineObj, preparedMeasure);\n                        baseX = coords.left;\n                        outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;\n                    }\n                    ch = skipExtendingChars(lineObj.text, ch, 1);\n                    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX);\n                }\n                function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {\n                    var index = findFirst(function (i) {\n                        var part = order[i], ltr = part.level != 1;\n                        return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? 'before' : 'after'), 'line', lineObj, preparedMeasure), x, y, true);\n                    }, 0, order.length - 1);\n                    var part = order[index];\n                    if (index > 0) {\n                        var ltr = part.level != 1;\n                        var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? 'after' : 'before'), 'line', lineObj, preparedMeasure);\n                        if (boxIsAfter(start, x, y, true) && start.top > y) {\n                            part = order[index - 1];\n                        }\n                    }\n                    return part;\n                }\n                function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n                    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n                    var begin = ref.begin;\n                    var end = ref.end;\n                    if (/\\s/.test(lineObj.text.charAt(end - 1))) {\n                        end--;\n                    }\n                    var part = null, closestDist = null;\n                    for (var i = 0; i < order.length; i++) {\n                        var p = order[i];\n                        if (p.from >= end || p.to <= begin) {\n                            continue;\n                        }\n                        var ltr = p.level != 1;\n                        var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n                        var dist = endX < x ? x - endX + 1000000000 : endX - x;\n                        if (!part || closestDist > dist) {\n                            part = p;\n                            closestDist = dist;\n                        }\n                    }\n                    if (!part) {\n                        part = order[order.length - 1];\n                    }\n                    if (part.from < begin) {\n                        part = {\n                            from: begin,\n                            to: part.to,\n                            level: part.level\n                        };\n                    }\n                    if (part.to > end) {\n                        part = {\n                            from: part.from,\n                            to: end,\n                            level: part.level\n                        };\n                    }\n                    return part;\n                }\n                var measureText;\n                function textHeight(display) {\n                    if (display.cachedTextHeight != null) {\n                        return display.cachedTextHeight;\n                    }\n                    if (measureText == null) {\n                        measureText = elt('pre', null, 'CodeMirror-line-like');\n                        for (var i = 0; i < 49; ++i) {\n                            measureText.appendChild(document.createTextNode('x'));\n                            measureText.appendChild(elt('br'));\n                        }\n                        measureText.appendChild(document.createTextNode('x'));\n                    }\n                    removeChildrenAndAdd(display.measure, measureText);\n                    var height = measureText.offsetHeight / 50;\n                    if (height > 3) {\n                        display.cachedTextHeight = height;\n                    }\n                    removeChildren(display.measure);\n                    return height || 1;\n                }\n                function charWidth(display) {\n                    if (display.cachedCharWidth != null) {\n                        return display.cachedCharWidth;\n                    }\n                    var anchor = elt('span', 'xxxxxxxxxx');\n                    var pre = elt('pre', [anchor], 'CodeMirror-line-like');\n                    removeChildrenAndAdd(display.measure, pre);\n                    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n                    if (width > 2) {\n                        display.cachedCharWidth = width;\n                    }\n                    return width || 10;\n                }\n                function getDimensions(cm) {\n                    var d = cm.display, left = {}, width = {};\n                    var gutterLeft = d.gutters.clientLeft;\n                    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n                        var id = cm.display.gutterSpecs[i].className;\n                        left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n                        width[id] = n.clientWidth;\n                    }\n                    return {\n                        fixedPos: compensateForHScroll(d),\n                        gutterTotalWidth: d.gutters.offsetWidth,\n                        gutterLeft: left,\n                        gutterWidth: width,\n                        wrapperWidth: d.wrapper.clientWidth\n                    };\n                }\n                function compensateForHScroll(display) {\n                    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n                }\n                function estimateHeight(cm) {\n                    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n                    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n                    return function (line) {\n                        if (lineIsHidden(cm.doc, line)) {\n                            return 0;\n                        }\n                        var widgetsHeight = 0;\n                        if (line.widgets) {\n                            for (var i = 0; i < line.widgets.length; i++) {\n                                if (line.widgets[i].height) {\n                                    widgetsHeight += line.widgets[i].height;\n                                }\n                            }\n                        }\n                        if (wrapping) {\n                            return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n                        } else {\n                            return widgetsHeight + th;\n                        }\n                    };\n                }\n                function estimateLineHeights(cm) {\n                    var doc = cm.doc, est = estimateHeight(cm);\n                    doc.iter(function (line) {\n                        var estHeight = est(line);\n                        if (estHeight != line.height) {\n                            updateLineHeight(line, estHeight);\n                        }\n                    });\n                }\n                function posFromMouse(cm, e, liberal, forRect) {\n                    var display = cm.display;\n                    if (!liberal && e_target(e).getAttribute('cm-not-content') == 'true') {\n                        return null;\n                    }\n                    var x, y, space = display.lineSpace.getBoundingClientRect();\n                    try {\n                        x = e.clientX - space.left;\n                        y = e.clientY - space.top;\n                    } catch (e$1) {\n                        return null;\n                    }\n                    var coords = coordsChar(cm, x, y), line;\n                    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n                        var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n                        coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n                    }\n                    return coords;\n                }\n                function findViewIndex(cm, n) {\n                    if (n >= cm.display.viewTo) {\n                        return null;\n                    }\n                    n -= cm.display.viewFrom;\n                    if (n < 0) {\n                        return null;\n                    }\n                    var view = cm.display.view;\n                    for (var i = 0; i < view.length; i++) {\n                        n -= view[i].size;\n                        if (n < 0) {\n                            return i;\n                        }\n                    }\n                }\n                function regChange(cm, from, to, lendiff) {\n                    if (from == null) {\n                        from = cm.doc.first;\n                    }\n                    if (to == null) {\n                        to = cm.doc.first + cm.doc.size;\n                    }\n                    if (!lendiff) {\n                        lendiff = 0;\n                    }\n                    var display = cm.display;\n                    if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {\n                        display.updateLineNumbers = from;\n                    }\n                    cm.curOp.viewChanged = true;\n                    if (from >= display.viewTo) {\n                        if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {\n                            resetView(cm);\n                        }\n                    } else if (to <= display.viewFrom) {\n                        if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n                            resetView(cm);\n                        } else {\n                            display.viewFrom += lendiff;\n                            display.viewTo += lendiff;\n                        }\n                    } else if (from <= display.viewFrom && to >= display.viewTo) {\n                        resetView(cm);\n                    } else if (from <= display.viewFrom) {\n                        var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n                        if (cut) {\n                            display.view = display.view.slice(cut.index);\n                            display.viewFrom = cut.lineN;\n                            display.viewTo += lendiff;\n                        } else {\n                            resetView(cm);\n                        }\n                    } else if (to >= display.viewTo) {\n                        var cut$1 = viewCuttingPoint(cm, from, from, -1);\n                        if (cut$1) {\n                            display.view = display.view.slice(0, cut$1.index);\n                            display.viewTo = cut$1.lineN;\n                        } else {\n                            resetView(cm);\n                        }\n                    } else {\n                        var cutTop = viewCuttingPoint(cm, from, from, -1);\n                        var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n                        if (cutTop && cutBot) {\n                            display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));\n                            display.viewTo += lendiff;\n                        } else {\n                            resetView(cm);\n                        }\n                    }\n                    var ext = display.externalMeasured;\n                    if (ext) {\n                        if (to < ext.lineN) {\n                            ext.lineN += lendiff;\n                        } else if (from < ext.lineN + ext.size) {\n                            display.externalMeasured = null;\n                        }\n                    }\n                }\n                function regLineChange(cm, line, type) {\n                    cm.curOp.viewChanged = true;\n                    var display = cm.display, ext = cm.display.externalMeasured;\n                    if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {\n                        display.externalMeasured = null;\n                    }\n                    if (line < display.viewFrom || line >= display.viewTo) {\n                        return;\n                    }\n                    var lineView = display.view[findViewIndex(cm, line)];\n                    if (lineView.node == null) {\n                        return;\n                    }\n                    var arr = lineView.changes || (lineView.changes = []);\n                    if (indexOf(arr, type) == -1) {\n                        arr.push(type);\n                    }\n                }\n                function resetView(cm) {\n                    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n                    cm.display.view = [];\n                    cm.display.viewOffset = 0;\n                }\n                function viewCuttingPoint(cm, oldN, newN, dir) {\n                    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n                    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {\n                        return {\n                            index: index,\n                            lineN: newN\n                        };\n                    }\n                    var n = cm.display.viewFrom;\n                    for (var i = 0; i < index; i++) {\n                        n += view[i].size;\n                    }\n                    if (n != oldN) {\n                        if (dir > 0) {\n                            if (index == view.length - 1) {\n                                return null;\n                            }\n                            diff = n + view[index].size - oldN;\n                            index++;\n                        } else {\n                            diff = n - oldN;\n                        }\n                        oldN += diff;\n                        newN += diff;\n                    }\n                    while (visualLineNo(cm.doc, newN) != newN) {\n                        if (index == (dir < 0 ? 0 : view.length - 1)) {\n                            return null;\n                        }\n                        newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n                        index += dir;\n                    }\n                    return {\n                        index: index,\n                        lineN: newN\n                    };\n                }\n                function adjustView(cm, from, to) {\n                    var display = cm.display, view = display.view;\n                    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n                        display.view = buildViewArray(cm, from, to);\n                        display.viewFrom = from;\n                    } else {\n                        if (display.viewFrom > from) {\n                            display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n                        } else if (display.viewFrom < from) {\n                            display.view = display.view.slice(findViewIndex(cm, from));\n                        }\n                        display.viewFrom = from;\n                        if (display.viewTo < to) {\n                            display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n                        } else if (display.viewTo > to) {\n                            display.view = display.view.slice(0, findViewIndex(cm, to));\n                        }\n                    }\n                    display.viewTo = to;\n                }\n                function countDirtyView(cm) {\n                    var view = cm.display.view, dirty = 0;\n                    for (var i = 0; i < view.length; i++) {\n                        var lineView = view[i];\n                        if (!lineView.hidden && (!lineView.node || lineView.changes)) {\n                            ++dirty;\n                        }\n                    }\n                    return dirty;\n                }\n                function updateSelection(cm) {\n                    cm.display.input.showSelection(cm.display.input.prepareSelection());\n                }\n                function prepareSelection(cm, primary) {\n                    if (primary === void 0)\n                        primary = true;\n                    var doc = cm.doc, result = {};\n                    var curFragment = result.cursors = document.createDocumentFragment();\n                    var selFragment = result.selection = document.createDocumentFragment();\n                    var customCursor = cm.options.$customCursor;\n                    if (customCursor) {\n                        primary = true;\n                    }\n                    for (var i = 0; i < doc.sel.ranges.length; i++) {\n                        if (!primary && i == doc.sel.primIndex) {\n                            continue;\n                        }\n                        var range = doc.sel.ranges[i];\n                        if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) {\n                            continue;\n                        }\n                        var collapsed = range.empty();\n                        if (customCursor) {\n                            var head = customCursor(cm, range);\n                            if (head) {\n                                drawSelectionCursor(cm, head, curFragment);\n                            }\n                        } else if (collapsed || cm.options.showCursorWhenSelecting) {\n                            drawSelectionCursor(cm, range.head, curFragment);\n                        }\n                        if (!collapsed) {\n                            drawSelectionRange(cm, range, selFragment);\n                        }\n                    }\n                    return result;\n                }\n                function drawSelectionCursor(cm, head, output) {\n                    var pos = cursorCoords(cm, head, 'div', null, null, !cm.options.singleCursorHeightPerLine);\n                    var cursor = output.appendChild(elt('div', '\\xA0', 'CodeMirror-cursor'));\n                    cursor.style.left = pos.left + 'px';\n                    cursor.style.top = pos.top + 'px';\n                    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + 'px';\n                    if (/\\bcm-fat-cursor\\b/.test(cm.getWrapperElement().className)) {\n                        var charPos = charCoords(cm, head, 'div', null, null);\n                        var width = charPos.right - charPos.left;\n                        cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + 'px';\n                    }\n                    if (pos.other) {\n                        var otherCursor = output.appendChild(elt('div', '\\xA0', 'CodeMirror-cursor CodeMirror-secondarycursor'));\n                        otherCursor.style.display = '';\n                        otherCursor.style.left = pos.other.left + 'px';\n                        otherCursor.style.top = pos.other.top + 'px';\n                        otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + 'px';\n                    }\n                }\n                function cmpCoords(a, b) {\n                    return a.top - b.top || a.left - b.left;\n                }\n                function drawSelectionRange(cm, range, output) {\n                    var display = cm.display, doc = cm.doc;\n                    var fragment = document.createDocumentFragment();\n                    var padding = paddingH(cm.display), leftSide = padding.left;\n                    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n                    var docLTR = doc.direction == 'ltr';\n                    function add(left, top, width, bottom) {\n                        if (top < 0) {\n                            top = 0;\n                        }\n                        top = Math.round(top);\n                        bottom = Math.round(bottom);\n                        fragment.appendChild(elt('div', null, 'CodeMirror-selected', 'position: absolute; left: ' + left + 'px;\\n                             top: ' + top + 'px; width: ' + (width == null ? rightSide - left : width) + 'px;\\n                             height: ' + (bottom - top) + 'px'));\n                    }\n                    function drawForLine(line, fromArg, toArg) {\n                        var lineObj = getLine(doc, line);\n                        var lineLen = lineObj.text.length;\n                        var start, end;\n                        function coords(ch, bias) {\n                            return charCoords(cm, Pos(line, ch), 'div', lineObj, bias);\n                        }\n                        function wrapX(pos, dir, side) {\n                            var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n                            var prop = dir == 'ltr' == (side == 'after') ? 'left' : 'right';\n                            var ch = side == 'after' ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n                            return coords(ch, prop)[prop];\n                        }\n                        var order = getOrder(lineObj, doc.direction);\n                        iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n                            var ltr = dir == 'ltr';\n                            var fromPos = coords(from, ltr ? 'left' : 'right');\n                            var toPos = coords(to - 1, ltr ? 'right' : 'left');\n                            var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n                            var first = i == 0, last = !order || i == order.length - 1;\n                            if (toPos.top - fromPos.top <= 3) {\n                                var openLeft = (docLTR ? openStart : openEnd) && first;\n                                var openRight = (docLTR ? openEnd : openStart) && last;\n                                var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n                                var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n                                add(left, fromPos.top, right - left, fromPos.bottom);\n                            } else {\n                                var topLeft, topRight, botLeft, botRight;\n                                if (ltr) {\n                                    topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n                                    topRight = docLTR ? rightSide : wrapX(from, dir, 'before');\n                                    botLeft = docLTR ? leftSide : wrapX(to, dir, 'after');\n                                    botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n                                } else {\n                                    topLeft = !docLTR ? leftSide : wrapX(from, dir, 'before');\n                                    topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n                                    botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n                                    botRight = !docLTR ? rightSide : wrapX(to, dir, 'after');\n                                }\n                                add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n                                if (fromPos.bottom < toPos.top) {\n                                    add(leftSide, fromPos.bottom, null, toPos.top);\n                                }\n                                add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n                            }\n                            if (!start || cmpCoords(fromPos, start) < 0) {\n                                start = fromPos;\n                            }\n                            if (cmpCoords(toPos, start) < 0) {\n                                start = toPos;\n                            }\n                            if (!end || cmpCoords(fromPos, end) < 0) {\n                                end = fromPos;\n                            }\n                            if (cmpCoords(toPos, end) < 0) {\n                                end = toPos;\n                            }\n                        });\n                        return {\n                            start: start,\n                            end: end\n                        };\n                    }\n                    var sFrom = range.from(), sTo = range.to();\n                    if (sFrom.line == sTo.line) {\n                        drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n                    } else {\n                        var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n                        var singleVLine = visualLine(fromLine) == visualLine(toLine);\n                        var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n                        var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n                        if (singleVLine) {\n                            if (leftEnd.top < rightStart.top - 2) {\n                                add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n                                add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n                            } else {\n                                add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n                            }\n                        }\n                        if (leftEnd.bottom < rightStart.top) {\n                            add(leftSide, leftEnd.bottom, null, rightStart.top);\n                        }\n                    }\n                    output.appendChild(fragment);\n                }\n                function restartBlink(cm) {\n                    if (!cm.state.focused) {\n                        return;\n                    }\n                    var display = cm.display;\n                    clearInterval(display.blinker);\n                    var on = true;\n                    display.cursorDiv.style.visibility = '';\n                    if (cm.options.cursorBlinkRate > 0) {\n                        display.blinker = setInterval(function () {\n                            if (!cm.hasFocus()) {\n                                onBlur(cm);\n                            }\n                            display.cursorDiv.style.visibility = (on = !on) ? '' : 'hidden';\n                        }, cm.options.cursorBlinkRate);\n                    } else if (cm.options.cursorBlinkRate < 0) {\n                        display.cursorDiv.style.visibility = 'hidden';\n                    }\n                }\n                function ensureFocus(cm) {\n                    if (!cm.hasFocus()) {\n                        cm.display.input.focus();\n                        if (!cm.state.focused) {\n                            onFocus(cm);\n                        }\n                    }\n                }\n                function delayBlurEvent(cm) {\n                    cm.state.delayingBlurEvent = true;\n                    setTimeout(function () {\n                        if (cm.state.delayingBlurEvent) {\n                            cm.state.delayingBlurEvent = false;\n                            if (cm.state.focused) {\n                                onBlur(cm);\n                            }\n                        }\n                    }, 100);\n                }\n                function onFocus(cm, e) {\n                    if (cm.state.delayingBlurEvent && !cm.state.draggingText) {\n                        cm.state.delayingBlurEvent = false;\n                    }\n                    if (cm.options.readOnly == 'nocursor') {\n                        return;\n                    }\n                    if (!cm.state.focused) {\n                        signal(cm, 'focus', cm, e);\n                        cm.state.focused = true;\n                        addClass(cm.display.wrapper, 'CodeMirror-focused');\n                        if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n                            cm.display.input.reset();\n                            if (webkit) {\n                                setTimeout(function () {\n                                    return cm.display.input.reset(true);\n                                }, 20);\n                            }\n                        }\n                        cm.display.input.receivedFocus();\n                    }\n                    restartBlink(cm);\n                }\n                function onBlur(cm, e) {\n                    if (cm.state.delayingBlurEvent) {\n                        return;\n                    }\n                    if (cm.state.focused) {\n                        signal(cm, 'blur', cm, e);\n                        cm.state.focused = false;\n                        rmClass(cm.display.wrapper, 'CodeMirror-focused');\n                    }\n                    clearInterval(cm.display.blinker);\n                    setTimeout(function () {\n                        if (!cm.state.focused) {\n                            cm.display.shift = false;\n                        }\n                    }, 150);\n                }\n                function updateHeightsInViewport(cm) {\n                    var display = cm.display;\n                    var prevBottom = display.lineDiv.offsetTop;\n                    var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);\n                    var oldHeight = display.lineDiv.getBoundingClientRect().top;\n                    var mustScroll = 0;\n                    for (var i = 0; i < display.view.length; i++) {\n                        var cur = display.view[i], wrapping = cm.options.lineWrapping;\n                        var height = void 0, width = 0;\n                        if (cur.hidden) {\n                            continue;\n                        }\n                        oldHeight += cur.line.height;\n                        if (ie && ie_version < 8) {\n                            var bot = cur.node.offsetTop + cur.node.offsetHeight;\n                            height = bot - prevBottom;\n                            prevBottom = bot;\n                        } else {\n                            var box = cur.node.getBoundingClientRect();\n                            height = box.bottom - box.top;\n                            if (!wrapping && cur.text.firstChild) {\n                                width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;\n                            }\n                        }\n                        var diff = cur.line.height - height;\n                        if (diff > 0.005 || diff < -0.005) {\n                            if (oldHeight < viewTop) {\n                                mustScroll -= diff;\n                            }\n                            updateLineHeight(cur.line, height);\n                            updateWidgetHeight(cur.line);\n                            if (cur.rest) {\n                                for (var j = 0; j < cur.rest.length; j++) {\n                                    updateWidgetHeight(cur.rest[j]);\n                                }\n                            }\n                        }\n                        if (width > cm.display.sizerWidth) {\n                            var chWidth = Math.ceil(width / charWidth(cm.display));\n                            if (chWidth > cm.display.maxLineLength) {\n                                cm.display.maxLineLength = chWidth;\n                                cm.display.maxLine = cur.line;\n                                cm.display.maxLineChanged = true;\n                            }\n                        }\n                    }\n                    if (Math.abs(mustScroll) > 2) {\n                        display.scroller.scrollTop += mustScroll;\n                    }\n                }\n                function updateWidgetHeight(line) {\n                    if (line.widgets) {\n                        for (var i = 0; i < line.widgets.length; ++i) {\n                            var w = line.widgets[i], parent = w.node.parentNode;\n                            if (parent) {\n                                w.height = parent.offsetHeight;\n                            }\n                        }\n                    }\n                }\n                function visibleLines(display, doc, viewport) {\n                    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n                    top = Math.floor(top - paddingTop(display));\n                    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n                    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n                    if (viewport && viewport.ensure) {\n                        var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n                        if (ensureFrom < from) {\n                            from = ensureFrom;\n                            to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n                        } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n                            from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n                            to = ensureTo;\n                        }\n                    }\n                    return {\n                        from: from,\n                        to: Math.max(to, from + 1)\n                    };\n                }\n                function maybeScrollWindow(cm, rect) {\n                    if (signalDOMEvent(cm, 'scrollCursorIntoView')) {\n                        return;\n                    }\n                    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n                    var doc = display.wrapper.ownerDocument;\n                    if (rect.top + box.top < 0) {\n                        doScroll = true;\n                    } else if (rect.bottom + box.top > (doc.defaultView.innerHeight || doc.documentElement.clientHeight)) {\n                        doScroll = false;\n                    }\n                    if (doScroll != null && !phantom) {\n                        var scrollNode = elt('div', '\\u200B', null, 'position: absolute;\\n                         top: ' + (rect.top - display.viewOffset - paddingTop(cm.display)) + 'px;\\n                         height: ' + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + 'px;\\n                         left: ' + rect.left + 'px; width: ' + Math.max(2, rect.right - rect.left) + 'px;');\n                        cm.display.lineSpace.appendChild(scrollNode);\n                        scrollNode.scrollIntoView(doScroll);\n                        cm.display.lineSpace.removeChild(scrollNode);\n                    }\n                }\n                function scrollPosIntoView(cm, pos, end, margin) {\n                    if (margin == null) {\n                        margin = 0;\n                    }\n                    var rect;\n                    if (!cm.options.lineWrapping && pos == end) {\n                        end = pos.sticky == 'before' ? Pos(pos.line, pos.ch + 1, 'before') : pos;\n                        pos = pos.ch ? Pos(pos.line, pos.sticky == 'before' ? pos.ch - 1 : pos.ch, 'after') : pos;\n                    }\n                    for (var limit = 0; limit < 5; limit++) {\n                        var changed = false;\n                        var coords = cursorCoords(cm, pos);\n                        var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n                        rect = {\n                            left: Math.min(coords.left, endCoords.left),\n                            top: Math.min(coords.top, endCoords.top) - margin,\n                            right: Math.max(coords.left, endCoords.left),\n                            bottom: Math.max(coords.bottom, endCoords.bottom) + margin\n                        };\n                        var scrollPos = calculateScrollPos(cm, rect);\n                        var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n                        if (scrollPos.scrollTop != null) {\n                            updateScrollTop(cm, scrollPos.scrollTop);\n                            if (Math.abs(cm.doc.scrollTop - startTop) > 1) {\n                                changed = true;\n                            }\n                        }\n                        if (scrollPos.scrollLeft != null) {\n                            setScrollLeft(cm, scrollPos.scrollLeft);\n                            if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {\n                                changed = true;\n                            }\n                        }\n                        if (!changed) {\n                            break;\n                        }\n                    }\n                    return rect;\n                }\n                function scrollIntoView(cm, rect) {\n                    var scrollPos = calculateScrollPos(cm, rect);\n                    if (scrollPos.scrollTop != null) {\n                        updateScrollTop(cm, scrollPos.scrollTop);\n                    }\n                    if (scrollPos.scrollLeft != null) {\n                        setScrollLeft(cm, scrollPos.scrollLeft);\n                    }\n                }\n                function calculateScrollPos(cm, rect) {\n                    var display = cm.display, snapMargin = textHeight(cm.display);\n                    if (rect.top < 0) {\n                        rect.top = 0;\n                    }\n                    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n                    var screen = displayHeight(cm), result = {};\n                    if (rect.bottom - rect.top > screen) {\n                        rect.bottom = rect.top + screen;\n                    }\n                    var docBottom = cm.doc.height + paddingVert(display);\n                    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n                    if (rect.top < screentop) {\n                        result.scrollTop = atTop ? 0 : rect.top;\n                    } else if (rect.bottom > screentop + screen) {\n                        var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n                        if (newTop != screentop) {\n                            result.scrollTop = newTop;\n                        }\n                    }\n                    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n                    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n                    var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n                    var tooWide = rect.right - rect.left > screenw;\n                    if (tooWide) {\n                        rect.right = rect.left + screenw;\n                    }\n                    if (rect.left < 10) {\n                        result.scrollLeft = 0;\n                    } else if (rect.left < screenleft) {\n                        result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));\n                    } else if (rect.right > screenw + screenleft - 3) {\n                        result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;\n                    }\n                    return result;\n                }\n                function addToScrollTop(cm, top) {\n                    if (top == null) {\n                        return;\n                    }\n                    resolveScrollToPos(cm);\n                    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n                }\n                function ensureCursorVisible(cm) {\n                    resolveScrollToPos(cm);\n                    var cur = cm.getCursor();\n                    cm.curOp.scrollToPos = {\n                        from: cur,\n                        to: cur,\n                        margin: cm.options.cursorScrollMargin\n                    };\n                }\n                function scrollToCoords(cm, x, y) {\n                    if (x != null || y != null) {\n                        resolveScrollToPos(cm);\n                    }\n                    if (x != null) {\n                        cm.curOp.scrollLeft = x;\n                    }\n                    if (y != null) {\n                        cm.curOp.scrollTop = y;\n                    }\n                }\n                function scrollToRange(cm, range) {\n                    resolveScrollToPos(cm);\n                    cm.curOp.scrollToPos = range;\n                }\n                function resolveScrollToPos(cm) {\n                    var range = cm.curOp.scrollToPos;\n                    if (range) {\n                        cm.curOp.scrollToPos = null;\n                        var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n                        scrollToCoordsRange(cm, from, to, range.margin);\n                    }\n                }\n                function scrollToCoordsRange(cm, from, to, margin) {\n                    var sPos = calculateScrollPos(cm, {\n                        left: Math.min(from.left, to.left),\n                        top: Math.min(from.top, to.top) - margin,\n                        right: Math.max(from.right, to.right),\n                        bottom: Math.max(from.bottom, to.bottom) + margin\n                    });\n                    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n                }\n                function updateScrollTop(cm, val) {\n                    if (Math.abs(cm.doc.scrollTop - val) < 2) {\n                        return;\n                    }\n                    if (!gecko) {\n                        updateDisplaySimple(cm, { top: val });\n                    }\n                    setScrollTop(cm, val, true);\n                    if (gecko) {\n                        updateDisplaySimple(cm);\n                    }\n                    startWorker(cm, 100);\n                }\n                function setScrollTop(cm, val, forceScroll) {\n                    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n                    if (cm.display.scroller.scrollTop == val && !forceScroll) {\n                        return;\n                    }\n                    cm.doc.scrollTop = val;\n                    cm.display.scrollbars.setScrollTop(val);\n                    if (cm.display.scroller.scrollTop != val) {\n                        cm.display.scroller.scrollTop = val;\n                    }\n                }\n                function setScrollLeft(cm, val, isScroller, forceScroll) {\n                    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n                    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {\n                        return;\n                    }\n                    cm.doc.scrollLeft = val;\n                    alignHorizontally(cm);\n                    if (cm.display.scroller.scrollLeft != val) {\n                        cm.display.scroller.scrollLeft = val;\n                    }\n                    cm.display.scrollbars.setScrollLeft(val);\n                }\n                function measureForScrollbars(cm) {\n                    var d = cm.display, gutterW = d.gutters.offsetWidth;\n                    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n                    return {\n                        clientHeight: d.scroller.clientHeight,\n                        viewHeight: d.wrapper.clientHeight,\n                        scrollWidth: d.scroller.scrollWidth,\n                        clientWidth: d.scroller.clientWidth,\n                        viewWidth: d.wrapper.clientWidth,\n                        barLeft: cm.options.fixedGutter ? gutterW : 0,\n                        docHeight: docH,\n                        scrollHeight: docH + scrollGap(cm) + d.barHeight,\n                        nativeBarWidth: d.nativeBarWidth,\n                        gutterWidth: gutterW\n                    };\n                }\n                var NativeScrollbars = function (place, scroll, cm) {\n                    this.cm = cm;\n                    var vert = this.vert = elt('div', [elt('div', null, null, 'min-width: 1px')], 'CodeMirror-vscrollbar');\n                    var horiz = this.horiz = elt('div', [elt('div', null, null, 'height: 100%; min-height: 1px')], 'CodeMirror-hscrollbar');\n                    vert.tabIndex = horiz.tabIndex = -1;\n                    place(vert);\n                    place(horiz);\n                    on(vert, 'scroll', function () {\n                        if (vert.clientHeight) {\n                            scroll(vert.scrollTop, 'vertical');\n                        }\n                    });\n                    on(horiz, 'scroll', function () {\n                        if (horiz.clientWidth) {\n                            scroll(horiz.scrollLeft, 'horizontal');\n                        }\n                    });\n                    this.checkedZeroWidth = false;\n                    if (ie && ie_version < 8) {\n                        this.horiz.style.minHeight = this.vert.style.minWidth = '18px';\n                    }\n                };\n                NativeScrollbars.prototype.update = function (measure) {\n                    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n                    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n                    var sWidth = measure.nativeBarWidth;\n                    if (needsV) {\n                        this.vert.style.display = 'block';\n                        this.vert.style.bottom = needsH ? sWidth + 'px' : '0';\n                        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n                        this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + 'px';\n                    } else {\n                        this.vert.scrollTop = 0;\n                        this.vert.style.display = '';\n                        this.vert.firstChild.style.height = '0';\n                    }\n                    if (needsH) {\n                        this.horiz.style.display = 'block';\n                        this.horiz.style.right = needsV ? sWidth + 'px' : '0';\n                        this.horiz.style.left = measure.barLeft + 'px';\n                        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n                        this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + 'px';\n                    } else {\n                        this.horiz.style.display = '';\n                        this.horiz.firstChild.style.width = '0';\n                    }\n                    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n                        if (sWidth == 0) {\n                            this.zeroWidthHack();\n                        }\n                        this.checkedZeroWidth = true;\n                    }\n                    return {\n                        right: needsV ? sWidth : 0,\n                        bottom: needsH ? sWidth : 0\n                    };\n                };\n                NativeScrollbars.prototype.setScrollLeft = function (pos) {\n                    if (this.horiz.scrollLeft != pos) {\n                        this.horiz.scrollLeft = pos;\n                    }\n                    if (this.disableHoriz) {\n                        this.enableZeroWidthBar(this.horiz, this.disableHoriz, 'horiz');\n                    }\n                };\n                NativeScrollbars.prototype.setScrollTop = function (pos) {\n                    if (this.vert.scrollTop != pos) {\n                        this.vert.scrollTop = pos;\n                    }\n                    if (this.disableVert) {\n                        this.enableZeroWidthBar(this.vert, this.disableVert, 'vert');\n                    }\n                };\n                NativeScrollbars.prototype.zeroWidthHack = function () {\n                    var w = mac && !mac_geMountainLion ? '12px' : '18px';\n                    this.horiz.style.height = this.vert.style.width = w;\n                    this.horiz.style.visibility = this.vert.style.visibility = 'hidden';\n                    this.disableHoriz = new Delayed();\n                    this.disableVert = new Delayed();\n                };\n                NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n                    bar.style.visibility = '';\n                    function maybeDisable() {\n                        var box = bar.getBoundingClientRect();\n                        var elt = type == 'vert' ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n                        if (elt != bar) {\n                            bar.style.visibility = 'hidden';\n                        } else {\n                            delay.set(1000, maybeDisable);\n                        }\n                    }\n                    delay.set(1000, maybeDisable);\n                };\n                NativeScrollbars.prototype.clear = function () {\n                    var parent = this.horiz.parentNode;\n                    parent.removeChild(this.horiz);\n                    parent.removeChild(this.vert);\n                };\n                var NullScrollbars = function () {\n                };\n                NullScrollbars.prototype.update = function () {\n                    return {\n                        bottom: 0,\n                        right: 0\n                    };\n                };\n                NullScrollbars.prototype.setScrollLeft = function () {\n                };\n                NullScrollbars.prototype.setScrollTop = function () {\n                };\n                NullScrollbars.prototype.clear = function () {\n                };\n                function updateScrollbars(cm, measure) {\n                    if (!measure) {\n                        measure = measureForScrollbars(cm);\n                    }\n                    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n                    updateScrollbarsInner(cm, measure);\n                    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n                        if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {\n                            updateHeightsInViewport(cm);\n                        }\n                        updateScrollbarsInner(cm, measureForScrollbars(cm));\n                        startWidth = cm.display.barWidth;\n                        startHeight = cm.display.barHeight;\n                    }\n                }\n                function updateScrollbarsInner(cm, measure) {\n                    var d = cm.display;\n                    var sizes = d.scrollbars.update(measure);\n                    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + 'px';\n                    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + 'px';\n                    d.heightForcer.style.borderBottom = sizes.bottom + 'px solid transparent';\n                    if (sizes.right && sizes.bottom) {\n                        d.scrollbarFiller.style.display = 'block';\n                        d.scrollbarFiller.style.height = sizes.bottom + 'px';\n                        d.scrollbarFiller.style.width = sizes.right + 'px';\n                    } else {\n                        d.scrollbarFiller.style.display = '';\n                    }\n                    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n                        d.gutterFiller.style.display = 'block';\n                        d.gutterFiller.style.height = sizes.bottom + 'px';\n                        d.gutterFiller.style.width = measure.gutterWidth + 'px';\n                    } else {\n                        d.gutterFiller.style.display = '';\n                    }\n                }\n                var scrollbarModel = {\n                    'native': NativeScrollbars,\n                    'null': NullScrollbars\n                };\n                function initScrollbars(cm) {\n                    if (cm.display.scrollbars) {\n                        cm.display.scrollbars.clear();\n                        if (cm.display.scrollbars.addClass) {\n                            rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n                        }\n                    }\n                    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n                        cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n                        on(node, 'mousedown', function () {\n                            if (cm.state.focused) {\n                                setTimeout(function () {\n                                    return cm.display.input.focus();\n                                }, 0);\n                            }\n                        });\n                        node.setAttribute('cm-not-content', 'true');\n                    }, function (pos, axis) {\n                        if (axis == 'horizontal') {\n                            setScrollLeft(cm, pos);\n                        } else {\n                            updateScrollTop(cm, pos);\n                        }\n                    }, cm);\n                    if (cm.display.scrollbars.addClass) {\n                        addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n                    }\n                }\n                var nextOpId = 0;\n                function startOperation(cm) {\n                    cm.curOp = {\n                        cm: cm,\n                        viewChanged: false,\n                        startHeight: cm.doc.height,\n                        forceUpdate: false,\n                        updateInput: 0,\n                        typing: false,\n                        changeObjs: null,\n                        cursorActivityHandlers: null,\n                        cursorActivityCalled: 0,\n                        selectionChanged: false,\n                        updateMaxLine: false,\n                        scrollLeft: null,\n                        scrollTop: null,\n                        scrollToPos: null,\n                        focus: false,\n                        id: ++nextOpId,\n                        markArrays: null\n                    };\n                    pushOperation(cm.curOp);\n                }\n                function endOperation(cm) {\n                    var op = cm.curOp;\n                    if (op) {\n                        finishOperation(op, function (group) {\n                            for (var i = 0; i < group.ops.length; i++) {\n                                group.ops[i].cm.curOp = null;\n                            }\n                            endOperations(group);\n                        });\n                    }\n                }\n                function endOperations(group) {\n                    var ops = group.ops;\n                    for (var i = 0; i < ops.length; i++) {\n                        endOperation_R1(ops[i]);\n                    }\n                    for (var i$1 = 0; i$1 < ops.length; i$1++) {\n                        endOperation_W1(ops[i$1]);\n                    }\n                    for (var i$2 = 0; i$2 < ops.length; i$2++) {\n                        endOperation_R2(ops[i$2]);\n                    }\n                    for (var i$3 = 0; i$3 < ops.length; i$3++) {\n                        endOperation_W2(ops[i$3]);\n                    }\n                    for (var i$4 = 0; i$4 < ops.length; i$4++) {\n                        endOperation_finish(ops[i$4]);\n                    }\n                }\n                function endOperation_R1(op) {\n                    var cm = op.cm, display = cm.display;\n                    maybeClipScrollbars(cm);\n                    if (op.updateMaxLine) {\n                        findMaxLine(cm);\n                    }\n                    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;\n                    op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {\n                        top: op.scrollTop,\n                        ensure: op.scrollToPos\n                    }, op.forceUpdate);\n                }\n                function endOperation_W1(op) {\n                    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n                }\n                function endOperation_R2(op) {\n                    var cm = op.cm, display = cm.display;\n                    if (op.updatedDisplay) {\n                        updateHeightsInViewport(cm);\n                    }\n                    op.barMeasure = measureForScrollbars(cm);\n                    if (display.maxLineChanged && !cm.options.lineWrapping) {\n                        op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n                        cm.display.sizerWidth = op.adjustWidthTo;\n                        op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n                        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n                    }\n                    if (op.updatedDisplay || op.selectionChanged) {\n                        op.preparedSelection = display.input.prepareSelection();\n                    }\n                }\n                function endOperation_W2(op) {\n                    var cm = op.cm;\n                    if (op.adjustWidthTo != null) {\n                        cm.display.sizer.style.minWidth = op.adjustWidthTo + 'px';\n                        if (op.maxScrollLeft < cm.doc.scrollLeft) {\n                            setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n                        }\n                        cm.display.maxLineChanged = false;\n                    }\n                    var takeFocus = op.focus && op.focus == activeElt(root(cm));\n                    if (op.preparedSelection) {\n                        cm.display.input.showSelection(op.preparedSelection, takeFocus);\n                    }\n                    if (op.updatedDisplay || op.startHeight != cm.doc.height) {\n                        updateScrollbars(cm, op.barMeasure);\n                    }\n                    if (op.updatedDisplay) {\n                        setDocumentHeight(cm, op.barMeasure);\n                    }\n                    if (op.selectionChanged) {\n                        restartBlink(cm);\n                    }\n                    if (cm.state.focused && op.updateInput) {\n                        cm.display.input.reset(op.typing);\n                    }\n                    if (takeFocus) {\n                        ensureFocus(op.cm);\n                    }\n                }\n                function endOperation_finish(op) {\n                    var cm = op.cm, display = cm.display, doc = cm.doc;\n                    if (op.updatedDisplay) {\n                        postUpdateDisplay(cm, op.update);\n                    }\n                    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {\n                        display.wheelStartX = display.wheelStartY = null;\n                    }\n                    if (op.scrollTop != null) {\n                        setScrollTop(cm, op.scrollTop, op.forceScroll);\n                    }\n                    if (op.scrollLeft != null) {\n                        setScrollLeft(cm, op.scrollLeft, true, true);\n                    }\n                    if (op.scrollToPos) {\n                        var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n                        maybeScrollWindow(cm, rect);\n                    }\n                    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n                    if (hidden) {\n                        for (var i = 0; i < hidden.length; ++i) {\n                            if (!hidden[i].lines.length) {\n                                signal(hidden[i], 'hide');\n                            }\n                        }\n                    }\n                    if (unhidden) {\n                        for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {\n                            if (unhidden[i$1].lines.length) {\n                                signal(unhidden[i$1], 'unhide');\n                            }\n                        }\n                    }\n                    if (display.wrapper.offsetHeight) {\n                        doc.scrollTop = cm.display.scroller.scrollTop;\n                    }\n                    if (op.changeObjs) {\n                        signal(cm, 'changes', cm, op.changeObjs);\n                    }\n                    if (op.update) {\n                        op.update.finish();\n                    }\n                }\n                function runInOp(cm, f) {\n                    if (cm.curOp) {\n                        return f();\n                    }\n                    startOperation(cm);\n                    try {\n                        return f();\n                    } finally {\n                        endOperation(cm);\n                    }\n                }\n                function operation(cm, f) {\n                    return function () {\n                        if (cm.curOp) {\n                            return f.apply(cm, arguments);\n                        }\n                        startOperation(cm);\n                        try {\n                            return f.apply(cm, arguments);\n                        } finally {\n                            endOperation(cm);\n                        }\n                    };\n                }\n                function methodOp(f) {\n                    return function () {\n                        if (this.curOp) {\n                            return f.apply(this, arguments);\n                        }\n                        startOperation(this);\n                        try {\n                            return f.apply(this, arguments);\n                        } finally {\n                            endOperation(this);\n                        }\n                    };\n                }\n                function docMethodOp(f) {\n                    return function () {\n                        var cm = this.cm;\n                        if (!cm || cm.curOp) {\n                            return f.apply(this, arguments);\n                        }\n                        startOperation(cm);\n                        try {\n                            return f.apply(this, arguments);\n                        } finally {\n                            endOperation(cm);\n                        }\n                    };\n                }\n                function startWorker(cm, time) {\n                    if (cm.doc.highlightFrontier < cm.display.viewTo) {\n                        cm.state.highlight.set(time, bind(highlightWorker, cm));\n                    }\n                }\n                function highlightWorker(cm) {\n                    var doc = cm.doc;\n                    if (doc.highlightFrontier >= cm.display.viewTo) {\n                        return;\n                    }\n                    var end = +new Date() + cm.options.workTime;\n                    var context = getContextBefore(cm, doc.highlightFrontier);\n                    var changedLines = [];\n                    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n                        if (context.line >= cm.display.viewFrom) {\n                            var oldStyles = line.styles;\n                            var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n                            var highlighted = highlightLine(cm, line, context, true);\n                            if (resetState) {\n                                context.state = resetState;\n                            }\n                            line.styles = highlighted.styles;\n                            var oldCls = line.styleClasses, newCls = highlighted.classes;\n                            if (newCls) {\n                                line.styleClasses = newCls;\n                            } else if (oldCls) {\n                                line.styleClasses = null;\n                            }\n                            var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n                            for (var i = 0; !ischange && i < oldStyles.length; ++i) {\n                                ischange = oldStyles[i] != line.styles[i];\n                            }\n                            if (ischange) {\n                                changedLines.push(context.line);\n                            }\n                            line.stateAfter = context.save();\n                            context.nextLine();\n                        } else {\n                            if (line.text.length <= cm.options.maxHighlightLength) {\n                                processLine(cm, line.text, context);\n                            }\n                            line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n                            context.nextLine();\n                        }\n                        if (+new Date() > end) {\n                            startWorker(cm, cm.options.workDelay);\n                            return true;\n                        }\n                    });\n                    doc.highlightFrontier = context.line;\n                    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n                    if (changedLines.length) {\n                        runInOp(cm, function () {\n                            for (var i = 0; i < changedLines.length; i++) {\n                                regLineChange(cm, changedLines[i], 'text');\n                            }\n                        });\n                    }\n                }\n                var DisplayUpdate = function (cm, viewport, force) {\n                    var display = cm.display;\n                    this.viewport = viewport;\n                    this.visible = visibleLines(display, cm.doc, viewport);\n                    this.editorIsHidden = !display.wrapper.offsetWidth;\n                    this.wrapperHeight = display.wrapper.clientHeight;\n                    this.wrapperWidth = display.wrapper.clientWidth;\n                    this.oldDisplayWidth = displayWidth(cm);\n                    this.force = force;\n                    this.dims = getDimensions(cm);\n                    this.events = [];\n                };\n                DisplayUpdate.prototype.signal = function (emitter, type) {\n                    if (hasHandler(emitter, type)) {\n                        this.events.push(arguments);\n                    }\n                };\n                DisplayUpdate.prototype.finish = function () {\n                    for (var i = 0; i < this.events.length; i++) {\n                        signal.apply(null, this.events[i]);\n                    }\n                };\n                function maybeClipScrollbars(cm) {\n                    var display = cm.display;\n                    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n                        display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n                        display.heightForcer.style.height = scrollGap(cm) + 'px';\n                        display.sizer.style.marginBottom = -display.nativeBarWidth + 'px';\n                        display.sizer.style.borderRightWidth = scrollGap(cm) + 'px';\n                        display.scrollbarsClipped = true;\n                    }\n                }\n                function selectionSnapshot(cm) {\n                    if (cm.hasFocus()) {\n                        return null;\n                    }\n                    var active = activeElt(root(cm));\n                    if (!active || !contains(cm.display.lineDiv, active)) {\n                        return null;\n                    }\n                    var result = { activeElt: active };\n                    if (window.getSelection) {\n                        var sel = win(cm).getSelection();\n                        if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n                            result.anchorNode = sel.anchorNode;\n                            result.anchorOffset = sel.anchorOffset;\n                            result.focusNode = sel.focusNode;\n                            result.focusOffset = sel.focusOffset;\n                        }\n                    }\n                    return result;\n                }\n                function restoreSelection(snapshot) {\n                    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt(rootNode(snapshot.activeElt))) {\n                        return;\n                    }\n                    snapshot.activeElt.focus();\n                    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n                        var doc = snapshot.activeElt.ownerDocument;\n                        var sel = doc.defaultView.getSelection(), range = doc.createRange();\n                        range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n                        range.collapse(false);\n                        sel.removeAllRanges();\n                        sel.addRange(range);\n                        sel.extend(snapshot.focusNode, snapshot.focusOffset);\n                    }\n                }\n                function updateDisplayIfNeeded(cm, update) {\n                    var display = cm.display, doc = cm.doc;\n                    if (update.editorIsHidden) {\n                        resetView(cm);\n                        return false;\n                    }\n                    if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {\n                        return false;\n                    }\n                    if (maybeUpdateLineNumberWidth(cm)) {\n                        resetView(cm);\n                        update.dims = getDimensions(cm);\n                    }\n                    var end = doc.first + doc.size;\n                    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n                    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n                    if (display.viewFrom < from && from - display.viewFrom < 20) {\n                        from = Math.max(doc.first, display.viewFrom);\n                    }\n                    if (display.viewTo > to && display.viewTo - to < 20) {\n                        to = Math.min(end, display.viewTo);\n                    }\n                    if (sawCollapsedSpans) {\n                        from = visualLineNo(cm.doc, from);\n                        to = visualLineEndNo(cm.doc, to);\n                    }\n                    var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n                    adjustView(cm, from, to);\n                    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n                    cm.display.mover.style.top = display.viewOffset + 'px';\n                    var toUpdate = countDirtyView(cm);\n                    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {\n                        return false;\n                    }\n                    var selSnapshot = selectionSnapshot(cm);\n                    if (toUpdate > 4) {\n                        display.lineDiv.style.display = 'none';\n                    }\n                    patchDisplay(cm, display.updateLineNumbers, update.dims);\n                    if (toUpdate > 4) {\n                        display.lineDiv.style.display = '';\n                    }\n                    display.renderedView = display.view;\n                    restoreSelection(selSnapshot);\n                    removeChildren(display.cursorDiv);\n                    removeChildren(display.selectionDiv);\n                    display.gutters.style.height = display.sizer.style.minHeight = 0;\n                    if (different) {\n                        display.lastWrapHeight = update.wrapperHeight;\n                        display.lastWrapWidth = update.wrapperWidth;\n                        startWorker(cm, 400);\n                    }\n                    display.updateLineNumbers = null;\n                    return true;\n                }\n                function postUpdateDisplay(cm, update) {\n                    var viewport = update.viewport;\n                    for (var first = true;; first = false) {\n                        if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n                            if (viewport && viewport.top != null) {\n                                viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };\n                            }\n                            update.visible = visibleLines(cm.display, cm.doc, viewport);\n                            if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {\n                                break;\n                            }\n                        } else if (first) {\n                            update.visible = visibleLines(cm.display, cm.doc, viewport);\n                        }\n                        if (!updateDisplayIfNeeded(cm, update)) {\n                            break;\n                        }\n                        updateHeightsInViewport(cm);\n                        var barMeasure = measureForScrollbars(cm);\n                        updateSelection(cm);\n                        updateScrollbars(cm, barMeasure);\n                        setDocumentHeight(cm, barMeasure);\n                        update.force = false;\n                    }\n                    update.signal(cm, 'update', cm);\n                    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n                        update.signal(cm, 'viewportChange', cm, cm.display.viewFrom, cm.display.viewTo);\n                        cm.display.reportedViewFrom = cm.display.viewFrom;\n                        cm.display.reportedViewTo = cm.display.viewTo;\n                    }\n                }\n                function updateDisplaySimple(cm, viewport) {\n                    var update = new DisplayUpdate(cm, viewport);\n                    if (updateDisplayIfNeeded(cm, update)) {\n                        updateHeightsInViewport(cm);\n                        postUpdateDisplay(cm, update);\n                        var barMeasure = measureForScrollbars(cm);\n                        updateSelection(cm);\n                        updateScrollbars(cm, barMeasure);\n                        setDocumentHeight(cm, barMeasure);\n                        update.finish();\n                    }\n                }\n                function patchDisplay(cm, updateNumbersFrom, dims) {\n                    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n                    var container = display.lineDiv, cur = container.firstChild;\n                    function rm(node) {\n                        var next = node.nextSibling;\n                        if (webkit && mac && cm.display.currentWheelTarget == node) {\n                            node.style.display = 'none';\n                        } else {\n                            node.parentNode.removeChild(node);\n                        }\n                        return next;\n                    }\n                    var view = display.view, lineN = display.viewFrom;\n                    for (var i = 0; i < view.length; i++) {\n                        var lineView = view[i];\n                        if (lineView.hidden);\n                        else if (!lineView.node || lineView.node.parentNode != container) {\n                            var node = buildLineElement(cm, lineView, lineN, dims);\n                            container.insertBefore(node, cur);\n                        } else {\n                            while (cur != lineView.node) {\n                                cur = rm(cur);\n                            }\n                            var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;\n                            if (lineView.changes) {\n                                if (indexOf(lineView.changes, 'gutter') > -1) {\n                                    updateNumber = false;\n                                }\n                                updateLineForChanges(cm, lineView, lineN, dims);\n                            }\n                            if (updateNumber) {\n                                removeChildren(lineView.lineNumber);\n                                lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n                            }\n                            cur = lineView.node.nextSibling;\n                        }\n                        lineN += lineView.size;\n                    }\n                    while (cur) {\n                        cur = rm(cur);\n                    }\n                }\n                function updateGutterSpace(display) {\n                    var width = display.gutters.offsetWidth;\n                    display.sizer.style.marginLeft = width + 'px';\n                    signalLater(display, 'gutterChanged', display);\n                }\n                function setDocumentHeight(cm, measure) {\n                    cm.display.sizer.style.minHeight = measure.docHeight + 'px';\n                    cm.display.heightForcer.style.top = measure.docHeight + 'px';\n                    cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + 'px';\n                }\n                function alignHorizontally(cm) {\n                    var display = cm.display, view = display.view;\n                    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {\n                        return;\n                    }\n                    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n                    var gutterW = display.gutters.offsetWidth, left = comp + 'px';\n                    for (var i = 0; i < view.length; i++) {\n                        if (!view[i].hidden) {\n                            if (cm.options.fixedGutter) {\n                                if (view[i].gutter) {\n                                    view[i].gutter.style.left = left;\n                                }\n                                if (view[i].gutterBackground) {\n                                    view[i].gutterBackground.style.left = left;\n                                }\n                            }\n                            var align = view[i].alignable;\n                            if (align) {\n                                for (var j = 0; j < align.length; j++) {\n                                    align[j].style.left = left;\n                                }\n                            }\n                        }\n                    }\n                    if (cm.options.fixedGutter) {\n                        display.gutters.style.left = comp + gutterW + 'px';\n                    }\n                }\n                function maybeUpdateLineNumberWidth(cm) {\n                    if (!cm.options.lineNumbers) {\n                        return false;\n                    }\n                    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n                    if (last.length != display.lineNumChars) {\n                        var test = display.measure.appendChild(elt('div', [elt('div', last)], 'CodeMirror-linenumber CodeMirror-gutter-elt'));\n                        var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n                        display.lineGutter.style.width = '';\n                        display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n                        display.lineNumWidth = display.lineNumInnerWidth + padding;\n                        display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n                        display.lineGutter.style.width = display.lineNumWidth + 'px';\n                        updateGutterSpace(cm.display);\n                        return true;\n                    }\n                    return false;\n                }\n                function getGutters(gutters, lineNumbers) {\n                    var result = [], sawLineNumbers = false;\n                    for (var i = 0; i < gutters.length; i++) {\n                        var name = gutters[i], style = null;\n                        if (typeof name != 'string') {\n                            style = name.style;\n                            name = name.className;\n                        }\n                        if (name == 'CodeMirror-linenumbers') {\n                            if (!lineNumbers) {\n                                continue;\n                            } else {\n                                sawLineNumbers = true;\n                            }\n                        }\n                        result.push({\n                            className: name,\n                            style: style\n                        });\n                    }\n                    if (lineNumbers && !sawLineNumbers) {\n                        result.push({\n                            className: 'CodeMirror-linenumbers',\n                            style: null\n                        });\n                    }\n                    return result;\n                }\n                function renderGutters(display) {\n                    var gutters = display.gutters, specs = display.gutterSpecs;\n                    removeChildren(gutters);\n                    display.lineGutter = null;\n                    for (var i = 0; i < specs.length; ++i) {\n                        var ref = specs[i];\n                        var className = ref.className;\n                        var style = ref.style;\n                        var gElt = gutters.appendChild(elt('div', null, 'CodeMirror-gutter ' + className));\n                        if (style) {\n                            gElt.style.cssText = style;\n                        }\n                        if (className == 'CodeMirror-linenumbers') {\n                            display.lineGutter = gElt;\n                            gElt.style.width = (display.lineNumWidth || 1) + 'px';\n                        }\n                    }\n                    gutters.style.display = specs.length ? '' : 'none';\n                    updateGutterSpace(display);\n                }\n                function updateGutters(cm) {\n                    renderGutters(cm.display);\n                    regChange(cm);\n                    alignHorizontally(cm);\n                }\n                function Display(place, doc, input, options) {\n                    var d = this;\n                    this.input = input;\n                    d.scrollbarFiller = elt('div', null, 'CodeMirror-scrollbar-filler');\n                    d.scrollbarFiller.setAttribute('cm-not-content', 'true');\n                    d.gutterFiller = elt('div', null, 'CodeMirror-gutter-filler');\n                    d.gutterFiller.setAttribute('cm-not-content', 'true');\n                    d.lineDiv = eltP('div', null, 'CodeMirror-code');\n                    d.selectionDiv = elt('div', null, null, 'position: relative; z-index: 1');\n                    d.cursorDiv = elt('div', null, 'CodeMirror-cursors');\n                    d.measure = elt('div', null, 'CodeMirror-measure');\n                    d.lineMeasure = elt('div', null, 'CodeMirror-measure');\n                    d.lineSpace = eltP('div', [\n                        d.measure,\n                        d.lineMeasure,\n                        d.selectionDiv,\n                        d.cursorDiv,\n                        d.lineDiv\n                    ], null, 'position: relative; outline: none');\n                    var lines = eltP('div', [d.lineSpace], 'CodeMirror-lines');\n                    d.mover = elt('div', [lines], null, 'position: relative');\n                    d.sizer = elt('div', [d.mover], 'CodeMirror-sizer');\n                    d.sizerWidth = null;\n                    d.heightForcer = elt('div', null, null, 'position: absolute; height: ' + scrollerGap + 'px; width: 1px;');\n                    d.gutters = elt('div', null, 'CodeMirror-gutters');\n                    d.lineGutter = null;\n                    d.scroller = elt('div', [\n                        d.sizer,\n                        d.heightForcer,\n                        d.gutters\n                    ], 'CodeMirror-scroll');\n                    d.scroller.setAttribute('tabIndex', '-1');\n                    d.wrapper = elt('div', [\n                        d.scrollbarFiller,\n                        d.gutterFiller,\n                        d.scroller\n                    ], 'CodeMirror');\n                    if (chrome && chrome_version >= 105) {\n                        d.wrapper.style.clipPath = 'inset(0px)';\n                    }\n                    d.wrapper.setAttribute('translate', 'no');\n                    if (ie && ie_version < 8) {\n                        d.gutters.style.zIndex = -1;\n                        d.scroller.style.paddingRight = 0;\n                    }\n                    if (!webkit && !(gecko && mobile)) {\n                        d.scroller.draggable = true;\n                    }\n                    if (place) {\n                        if (place.appendChild) {\n                            place.appendChild(d.wrapper);\n                        } else {\n                            place(d.wrapper);\n                        }\n                    }\n                    d.viewFrom = d.viewTo = doc.first;\n                    d.reportedViewFrom = d.reportedViewTo = doc.first;\n                    d.view = [];\n                    d.renderedView = null;\n                    d.externalMeasured = null;\n                    d.viewOffset = 0;\n                    d.lastWrapHeight = d.lastWrapWidth = 0;\n                    d.updateLineNumbers = null;\n                    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n                    d.scrollbarsClipped = false;\n                    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n                    d.alignWidgets = false;\n                    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n                    d.maxLine = null;\n                    d.maxLineLength = 0;\n                    d.maxLineChanged = false;\n                    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n                    d.shift = false;\n                    d.selForContextMenu = null;\n                    d.activeTouch = null;\n                    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n                    renderGutters(d);\n                    input.init(d);\n                }\n                var wheelSamples = 0, wheelPixelsPerUnit = null;\n                if (ie) {\n                    wheelPixelsPerUnit = -0.53;\n                } else if (gecko) {\n                    wheelPixelsPerUnit = 15;\n                } else if (chrome) {\n                    wheelPixelsPerUnit = -0.7;\n                } else if (safari) {\n                    wheelPixelsPerUnit = -1 / 3;\n                }\n                function wheelEventDelta(e) {\n                    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n                    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {\n                        dx = e.detail;\n                    }\n                    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {\n                        dy = e.detail;\n                    } else if (dy == null) {\n                        dy = e.wheelDelta;\n                    }\n                    return {\n                        x: dx,\n                        y: dy\n                    };\n                }\n                function wheelEventPixels(e) {\n                    var delta = wheelEventDelta(e);\n                    delta.x *= wheelPixelsPerUnit;\n                    delta.y *= wheelPixelsPerUnit;\n                    return delta;\n                }\n                function onScrollWheel(cm, e) {\n                    if (chrome && chrome_version == 102) {\n                        if (cm.display.chromeScrollHack == null) {\n                            cm.display.sizer.style.pointerEvents = 'none';\n                        } else {\n                            clearTimeout(cm.display.chromeScrollHack);\n                        }\n                        cm.display.chromeScrollHack = setTimeout(function () {\n                            cm.display.chromeScrollHack = null;\n                            cm.display.sizer.style.pointerEvents = '';\n                        }, 100);\n                    }\n                    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n                    var pixelsPerUnit = wheelPixelsPerUnit;\n                    if (e.deltaMode === 0) {\n                        dx = e.deltaX;\n                        dy = e.deltaY;\n                        pixelsPerUnit = 1;\n                    }\n                    var display = cm.display, scroll = display.scroller;\n                    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n                    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n                    if (!(dx && canScrollX || dy && canScrollY)) {\n                        return;\n                    }\n                    if (dy && mac && webkit) {\n                        outer:\n                            for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n                                for (var i = 0; i < view.length; i++) {\n                                    if (view[i].node == cur) {\n                                        cm.display.currentWheelTarget = cur;\n                                        break outer;\n                                    }\n                                }\n                            }\n                    }\n                    if (dx && !gecko && !presto && pixelsPerUnit != null) {\n                        if (dy && canScrollY) {\n                            updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));\n                        }\n                        setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));\n                        if (!dy || dy && canScrollY) {\n                            e_preventDefault(e);\n                        }\n                        display.wheelStartX = null;\n                        return;\n                    }\n                    if (dy && pixelsPerUnit != null) {\n                        var pixels = dy * pixelsPerUnit;\n                        var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n                        if (pixels < 0) {\n                            top = Math.max(0, top + pixels - 50);\n                        } else {\n                            bot = Math.min(cm.doc.height, bot + pixels + 50);\n                        }\n                        updateDisplaySimple(cm, {\n                            top: top,\n                            bottom: bot\n                        });\n                    }\n                    if (wheelSamples < 20 && e.deltaMode !== 0) {\n                        if (display.wheelStartX == null) {\n                            display.wheelStartX = scroll.scrollLeft;\n                            display.wheelStartY = scroll.scrollTop;\n                            display.wheelDX = dx;\n                            display.wheelDY = dy;\n                            setTimeout(function () {\n                                if (display.wheelStartX == null) {\n                                    return;\n                                }\n                                var movedX = scroll.scrollLeft - display.wheelStartX;\n                                var movedY = scroll.scrollTop - display.wheelStartY;\n                                var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;\n                                display.wheelStartX = display.wheelStartY = null;\n                                if (!sample) {\n                                    return;\n                                }\n                                wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n                                ++wheelSamples;\n                            }, 200);\n                        } else {\n                            display.wheelDX += dx;\n                            display.wheelDY += dy;\n                        }\n                    }\n                }\n                var Selection = function (ranges, primIndex) {\n                    this.ranges = ranges;\n                    this.primIndex = primIndex;\n                };\n                Selection.prototype.primary = function () {\n                    return this.ranges[this.primIndex];\n                };\n                Selection.prototype.equals = function (other) {\n                    if (other == this) {\n                        return true;\n                    }\n                    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {\n                        return false;\n                    }\n                    for (var i = 0; i < this.ranges.length; i++) {\n                        var here = this.ranges[i], there = other.ranges[i];\n                        if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                };\n                Selection.prototype.deepCopy = function () {\n                    var out = [];\n                    for (var i = 0; i < this.ranges.length; i++) {\n                        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n                    }\n                    return new Selection(out, this.primIndex);\n                };\n                Selection.prototype.somethingSelected = function () {\n                    for (var i = 0; i < this.ranges.length; i++) {\n                        if (!this.ranges[i].empty()) {\n                            return true;\n                        }\n                    }\n                    return false;\n                };\n                Selection.prototype.contains = function (pos, end) {\n                    if (!end) {\n                        end = pos;\n                    }\n                    for (var i = 0; i < this.ranges.length; i++) {\n                        var range = this.ranges[i];\n                        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {\n                            return i;\n                        }\n                    }\n                    return -1;\n                };\n                var Range = function (anchor, head) {\n                    this.anchor = anchor;\n                    this.head = head;\n                };\n                Range.prototype.from = function () {\n                    return minPos(this.anchor, this.head);\n                };\n                Range.prototype.to = function () {\n                    return maxPos(this.anchor, this.head);\n                };\n                Range.prototype.empty = function () {\n                    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n                };\n                function normalizeSelection(cm, ranges, primIndex) {\n                    var mayTouch = cm && cm.options.selectionsMayTouch;\n                    var prim = ranges[primIndex];\n                    ranges.sort(function (a, b) {\n                        return cmp(a.from(), b.from());\n                    });\n                    primIndex = indexOf(ranges, prim);\n                    for (var i = 1; i < ranges.length; i++) {\n                        var cur = ranges[i], prev = ranges[i - 1];\n                        var diff = cmp(prev.to(), cur.from());\n                        if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n                            var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n                            var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n                            if (i <= primIndex) {\n                                --primIndex;\n                            }\n                            ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n                        }\n                    }\n                    return new Selection(ranges, primIndex);\n                }\n                function simpleSelection(anchor, head) {\n                    return new Selection([new Range(anchor, head || anchor)], 0);\n                }\n                function changeEnd(change) {\n                    if (!change.text) {\n                        return change.to;\n                    }\n                    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n                }\n                function adjustForChange(pos, change) {\n                    if (cmp(pos, change.from) < 0) {\n                        return pos;\n                    }\n                    if (cmp(pos, change.to) <= 0) {\n                        return changeEnd(change);\n                    }\n                    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n                    if (pos.line == change.to.line) {\n                        ch += changeEnd(change).ch - change.to.ch;\n                    }\n                    return Pos(line, ch);\n                }\n                function computeSelAfterChange(doc, change) {\n                    var out = [];\n                    for (var i = 0; i < doc.sel.ranges.length; i++) {\n                        var range = doc.sel.ranges[i];\n                        out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));\n                    }\n                    return normalizeSelection(doc.cm, out, doc.sel.primIndex);\n                }\n                function offsetPos(pos, old, nw) {\n                    if (pos.line == old.line) {\n                        return Pos(nw.line, pos.ch - old.ch + nw.ch);\n                    } else {\n                        return Pos(nw.line + (pos.line - old.line), pos.ch);\n                    }\n                }\n                function computeReplacedSel(doc, changes, hint) {\n                    var out = [];\n                    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n                    for (var i = 0; i < changes.length; i++) {\n                        var change = changes[i];\n                        var from = offsetPos(change.from, oldPrev, newPrev);\n                        var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n                        oldPrev = change.to;\n                        newPrev = to;\n                        if (hint == 'around') {\n                            var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n                            out[i] = new Range(inv ? to : from, inv ? from : to);\n                        } else {\n                            out[i] = new Range(from, from);\n                        }\n                    }\n                    return new Selection(out, doc.sel.primIndex);\n                }\n                function loadMode(cm) {\n                    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n                    resetModeState(cm);\n                }\n                function resetModeState(cm) {\n                    cm.doc.iter(function (line) {\n                        if (line.stateAfter) {\n                            line.stateAfter = null;\n                        }\n                        if (line.styles) {\n                            line.styles = null;\n                        }\n                    });\n                    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n                    startWorker(cm, 100);\n                    cm.state.modeGen++;\n                    if (cm.curOp) {\n                        regChange(cm);\n                    }\n                }\n                function isWholeLineUpdate(doc, change) {\n                    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == '' && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n                }\n                function updateDoc(doc, change, markedSpans, estimateHeight) {\n                    function spansFor(n) {\n                        return markedSpans ? markedSpans[n] : null;\n                    }\n                    function update(line, text, spans) {\n                        updateLine(line, text, spans, estimateHeight);\n                        signalLater(line, 'change', line, change);\n                    }\n                    function linesFor(start, end) {\n                        var result = [];\n                        for (var i = start; i < end; ++i) {\n                            result.push(new Line(text[i], spansFor(i), estimateHeight));\n                        }\n                        return result;\n                    }\n                    var from = change.from, to = change.to, text = change.text;\n                    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n                    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n                    if (change.full) {\n                        doc.insert(0, linesFor(0, text.length));\n                        doc.remove(text.length, doc.size - text.length);\n                    } else if (isWholeLineUpdate(doc, change)) {\n                        var added = linesFor(0, text.length - 1);\n                        update(lastLine, lastLine.text, lastSpans);\n                        if (nlines) {\n                            doc.remove(from.line, nlines);\n                        }\n                        if (added.length) {\n                            doc.insert(from.line, added);\n                        }\n                    } else if (firstLine == lastLine) {\n                        if (text.length == 1) {\n                            update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n                        } else {\n                            var added$1 = linesFor(1, text.length - 1);\n                            added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n                            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n                            doc.insert(from.line + 1, added$1);\n                        }\n                    } else if (text.length == 1) {\n                        update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n                        doc.remove(from.line + 1, nlines);\n                    } else {\n                        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n                        update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n                        var added$2 = linesFor(1, text.length - 1);\n                        if (nlines > 1) {\n                            doc.remove(from.line + 1, nlines - 1);\n                        }\n                        doc.insert(from.line + 1, added$2);\n                    }\n                    signalLater(doc, 'change', doc, change);\n                }\n                function linkedDocs(doc, f, sharedHistOnly) {\n                    function propagate(doc, skip, sharedHist) {\n                        if (doc.linked) {\n                            for (var i = 0; i < doc.linked.length; ++i) {\n                                var rel = doc.linked[i];\n                                if (rel.doc == skip) {\n                                    continue;\n                                }\n                                var shared = sharedHist && rel.sharedHist;\n                                if (sharedHistOnly && !shared) {\n                                    continue;\n                                }\n                                f(rel.doc, shared);\n                                propagate(rel.doc, doc, shared);\n                            }\n                        }\n                    }\n                    propagate(doc, null, true);\n                }\n                function attachDoc(cm, doc) {\n                    if (doc.cm) {\n                        throw new Error('This document is already in use.');\n                    }\n                    cm.doc = doc;\n                    doc.cm = cm;\n                    estimateLineHeights(cm);\n                    loadMode(cm);\n                    setDirectionClass(cm);\n                    cm.options.direction = doc.direction;\n                    if (!cm.options.lineWrapping) {\n                        findMaxLine(cm);\n                    }\n                    cm.options.mode = doc.modeOption;\n                    regChange(cm);\n                }\n                function setDirectionClass(cm) {\n                    (cm.doc.direction == 'rtl' ? addClass : rmClass)(cm.display.lineDiv, 'CodeMirror-rtl');\n                }\n                function directionChanged(cm) {\n                    runInOp(cm, function () {\n                        setDirectionClass(cm);\n                        regChange(cm);\n                    });\n                }\n                function History(prev) {\n                    this.done = [];\n                    this.undone = [];\n                    this.undoDepth = prev ? prev.undoDepth : Infinity;\n                    this.lastModTime = this.lastSelTime = 0;\n                    this.lastOp = this.lastSelOp = null;\n                    this.lastOrigin = this.lastSelOrigin = null;\n                    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;\n                }\n                function historyChangeFromChange(doc, change) {\n                    var histChange = {\n                        from: copyPos(change.from),\n                        to: changeEnd(change),\n                        text: getBetween(doc, change.from, change.to)\n                    };\n                    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n                    linkedDocs(doc, function (doc) {\n                        return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n                    }, true);\n                    return histChange;\n                }\n                function clearSelectionEvents(array) {\n                    while (array.length) {\n                        var last = lst(array);\n                        if (last.ranges) {\n                            array.pop();\n                        } else {\n                            break;\n                        }\n                    }\n                }\n                function lastChangeEvent(hist, force) {\n                    if (force) {\n                        clearSelectionEvents(hist.done);\n                        return lst(hist.done);\n                    } else if (hist.done.length && !lst(hist.done).ranges) {\n                        return lst(hist.done);\n                    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n                        hist.done.pop();\n                        return lst(hist.done);\n                    }\n                }\n                function addChangeToHistory(doc, change, selAfter, opId) {\n                    var hist = doc.history;\n                    hist.undone.length = 0;\n                    var time = +new Date(), cur;\n                    var last;\n                    if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == '*')) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n                        last = lst(cur.changes);\n                        if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n                            last.to = changeEnd(change);\n                        } else {\n                            cur.changes.push(historyChangeFromChange(doc, change));\n                        }\n                    } else {\n                        var before = lst(hist.done);\n                        if (!before || !before.ranges) {\n                            pushSelectionToHistory(doc.sel, hist.done);\n                        }\n                        cur = {\n                            changes: [historyChangeFromChange(doc, change)],\n                            generation: hist.generation\n                        };\n                        hist.done.push(cur);\n                        while (hist.done.length > hist.undoDepth) {\n                            hist.done.shift();\n                            if (!hist.done[0].ranges) {\n                                hist.done.shift();\n                            }\n                        }\n                    }\n                    hist.done.push(selAfter);\n                    hist.generation = ++hist.maxGeneration;\n                    hist.lastModTime = hist.lastSelTime = time;\n                    hist.lastOp = hist.lastSelOp = opId;\n                    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n                    if (!last) {\n                        signal(doc, 'historyAdded');\n                    }\n                }\n                function selectionEventCanBeMerged(doc, origin, prev, sel) {\n                    var ch = origin.charAt(0);\n                    return ch == '*' || ch == '+' && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n                }\n                function addSelectionToHistory(doc, sel, opId, options) {\n                    var hist = doc.history, origin = options && options.origin;\n                    if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {\n                        hist.done[hist.done.length - 1] = sel;\n                    } else {\n                        pushSelectionToHistory(sel, hist.done);\n                    }\n                    hist.lastSelTime = +new Date();\n                    hist.lastSelOrigin = origin;\n                    hist.lastSelOp = opId;\n                    if (options && options.clearRedo !== false) {\n                        clearSelectionEvents(hist.undone);\n                    }\n                }\n                function pushSelectionToHistory(sel, dest) {\n                    var top = lst(dest);\n                    if (!(top && top.ranges && top.equals(sel))) {\n                        dest.push(sel);\n                    }\n                }\n                function attachLocalSpans(doc, change, from, to) {\n                    var existing = change['spans_' + doc.id], n = 0;\n                    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n                        if (line.markedSpans) {\n                            (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;\n                        }\n                        ++n;\n                    });\n                }\n                function removeClearedSpans(spans) {\n                    if (!spans) {\n                        return null;\n                    }\n                    var out;\n                    for (var i = 0; i < spans.length; ++i) {\n                        if (spans[i].marker.explicitlyCleared) {\n                            if (!out) {\n                                out = spans.slice(0, i);\n                            }\n                        } else if (out) {\n                            out.push(spans[i]);\n                        }\n                    }\n                    return !out ? spans : out.length ? out : null;\n                }\n                function getOldSpans(doc, change) {\n                    var found = change['spans_' + doc.id];\n                    if (!found) {\n                        return null;\n                    }\n                    var nw = [];\n                    for (var i = 0; i < change.text.length; ++i) {\n                        nw.push(removeClearedSpans(found[i]));\n                    }\n                    return nw;\n                }\n                function mergeOldSpans(doc, change) {\n                    var old = getOldSpans(doc, change);\n                    var stretched = stretchSpansOverChange(doc, change);\n                    if (!old) {\n                        return stretched;\n                    }\n                    if (!stretched) {\n                        return old;\n                    }\n                    for (var i = 0; i < old.length; ++i) {\n                        var oldCur = old[i], stretchCur = stretched[i];\n                        if (oldCur && stretchCur) {\n                            spans:\n                                for (var j = 0; j < stretchCur.length; ++j) {\n                                    var span = stretchCur[j];\n                                    for (var k = 0; k < oldCur.length; ++k) {\n                                        if (oldCur[k].marker == span.marker) {\n                                            continue spans;\n                                        }\n                                    }\n                                    oldCur.push(span);\n                                }\n                        } else if (stretchCur) {\n                            old[i] = stretchCur;\n                        }\n                    }\n                    return old;\n                }\n                function copyHistoryArray(events, newGroup, instantiateSel) {\n                    var copy = [];\n                    for (var i = 0; i < events.length; ++i) {\n                        var event = events[i];\n                        if (event.ranges) {\n                            copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n                            continue;\n                        }\n                        var changes = event.changes, newChanges = [];\n                        copy.push({ changes: newChanges });\n                        for (var j = 0; j < changes.length; ++j) {\n                            var change = changes[j], m = void 0;\n                            newChanges.push({\n                                from: change.from,\n                                to: change.to,\n                                text: change.text\n                            });\n                            if (newGroup) {\n                                for (var prop in change) {\n                                    if (m = prop.match(/^spans_(\\d+)$/)) {\n                                        if (indexOf(newGroup, Number(m[1])) > -1) {\n                                            lst(newChanges)[prop] = change[prop];\n                                            delete change[prop];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return copy;\n                }\n                function extendRange(range, head, other, extend) {\n                    if (extend) {\n                        var anchor = range.anchor;\n                        if (other) {\n                            var posBefore = cmp(head, anchor) < 0;\n                            if (posBefore != cmp(other, anchor) < 0) {\n                                anchor = head;\n                                head = other;\n                            } else if (posBefore != cmp(head, other) < 0) {\n                                head = other;\n                            }\n                        }\n                        return new Range(anchor, head);\n                    } else {\n                        return new Range(other || head, head);\n                    }\n                }\n                function extendSelection(doc, head, other, options, extend) {\n                    if (extend == null) {\n                        extend = doc.cm && (doc.cm.display.shift || doc.extend);\n                    }\n                    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n                }\n                function extendSelections(doc, heads, options) {\n                    var out = [];\n                    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n                    for (var i = 0; i < doc.sel.ranges.length; i++) {\n                        out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);\n                    }\n                    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n                    setSelection(doc, newSel, options);\n                }\n                function replaceOneSelection(doc, i, range, options) {\n                    var ranges = doc.sel.ranges.slice(0);\n                    ranges[i] = range;\n                    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n                }\n                function setSimpleSelection(doc, anchor, head, options) {\n                    setSelection(doc, simpleSelection(anchor, head), options);\n                }\n                function filterSelectionChange(doc, sel, options) {\n                    var obj = {\n                        ranges: sel.ranges,\n                        update: function (ranges) {\n                            this.ranges = [];\n                            for (var i = 0; i < ranges.length; i++) {\n                                this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));\n                            }\n                        },\n                        origin: options && options.origin\n                    };\n                    signal(doc, 'beforeSelectionChange', doc, obj);\n                    if (doc.cm) {\n                        signal(doc.cm, 'beforeSelectionChange', doc.cm, obj);\n                    }\n                    if (obj.ranges != sel.ranges) {\n                        return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);\n                    } else {\n                        return sel;\n                    }\n                }\n                function setSelectionReplaceHistory(doc, sel, options) {\n                    var done = doc.history.done, last = lst(done);\n                    if (last && last.ranges) {\n                        done[done.length - 1] = sel;\n                        setSelectionNoUndo(doc, sel, options);\n                    } else {\n                        setSelection(doc, sel, options);\n                    }\n                }\n                function setSelection(doc, sel, options) {\n                    setSelectionNoUndo(doc, sel, options);\n                    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n                }\n                function setSelectionNoUndo(doc, sel, options) {\n                    if (hasHandler(doc, 'beforeSelectionChange') || doc.cm && hasHandler(doc.cm, 'beforeSelectionChange')) {\n                        sel = filterSelectionChange(doc, sel, options);\n                    }\n                    var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n                    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n                    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption('readOnly') != 'nocursor') {\n                        ensureCursorVisible(doc.cm);\n                    }\n                }\n                function setSelectionInner(doc, sel) {\n                    if (sel.equals(doc.sel)) {\n                        return;\n                    }\n                    doc.sel = sel;\n                    if (doc.cm) {\n                        doc.cm.curOp.updateInput = 1;\n                        doc.cm.curOp.selectionChanged = true;\n                        signalCursorActivity(doc.cm);\n                    }\n                    signalLater(doc, 'cursorActivity', doc);\n                }\n                function reCheckSelection(doc) {\n                    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n                }\n                function skipAtomicInSelection(doc, sel, bias, mayClear) {\n                    var out;\n                    for (var i = 0; i < sel.ranges.length; i++) {\n                        var range = sel.ranges[i];\n                        var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n                        var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n                        var newHead = range.head == range.anchor ? newAnchor : skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n                        if (out || newAnchor != range.anchor || newHead != range.head) {\n                            if (!out) {\n                                out = sel.ranges.slice(0, i);\n                            }\n                            out[i] = new Range(newAnchor, newHead);\n                        }\n                    }\n                    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;\n                }\n                function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n                    var line = getLine(doc, pos.line);\n                    if (line.markedSpans) {\n                        for (var i = 0; i < line.markedSpans.length; ++i) {\n                            var sp = line.markedSpans[i], m = sp.marker;\n                            var preventCursorLeft = 'selectLeft' in m ? !m.selectLeft : m.inclusiveLeft;\n                            var preventCursorRight = 'selectRight' in m ? !m.selectRight : m.inclusiveRight;\n                            if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n                                if (mayClear) {\n                                    signal(m, 'beforeCursorEnter');\n                                    if (m.explicitlyCleared) {\n                                        if (!line.markedSpans) {\n                                            break;\n                                        } else {\n                                            --i;\n                                            continue;\n                                        }\n                                    }\n                                }\n                                if (!m.atomic) {\n                                    continue;\n                                }\n                                if (oldPos) {\n                                    var near = m.find(dir < 0 ? 1 : -1), diff = void 0;\n                                    if (dir < 0 ? preventCursorRight : preventCursorLeft) {\n                                        near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);\n                                    }\n                                    if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {\n                                        return skipAtomicInner(doc, near, pos, dir, mayClear);\n                                    }\n                                }\n                                var far = m.find(dir < 0 ? -1 : 1);\n                                if (dir < 0 ? preventCursorLeft : preventCursorRight) {\n                                    far = movePos(doc, far, dir, far.line == pos.line ? line : null);\n                                }\n                                return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n                            }\n                        }\n                    }\n                    return pos;\n                }\n                function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n                    var dir = bias || 1;\n                    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);\n                    if (!found) {\n                        doc.cantEdit = true;\n                        return Pos(doc.first, 0);\n                    }\n                    return found;\n                }\n                function movePos(doc, pos, dir, line) {\n                    if (dir < 0 && pos.ch == 0) {\n                        if (pos.line > doc.first) {\n                            return clipPos(doc, Pos(pos.line - 1));\n                        } else {\n                            return null;\n                        }\n                    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n                        if (pos.line < doc.first + doc.size - 1) {\n                            return Pos(pos.line + 1, 0);\n                        } else {\n                            return null;\n                        }\n                    } else {\n                        return new Pos(pos.line, pos.ch + dir);\n                    }\n                }\n                function selectAll(cm) {\n                    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n                }\n                function filterChange(doc, change, update) {\n                    var obj = {\n                        canceled: false,\n                        from: change.from,\n                        to: change.to,\n                        text: change.text,\n                        origin: change.origin,\n                        cancel: function () {\n                            return obj.canceled = true;\n                        }\n                    };\n                    if (update) {\n                        obj.update = function (from, to, text, origin) {\n                            if (from) {\n                                obj.from = clipPos(doc, from);\n                            }\n                            if (to) {\n                                obj.to = clipPos(doc, to);\n                            }\n                            if (text) {\n                                obj.text = text;\n                            }\n                            if (origin !== undefined) {\n                                obj.origin = origin;\n                            }\n                        };\n                    }\n                    signal(doc, 'beforeChange', doc, obj);\n                    if (doc.cm) {\n                        signal(doc.cm, 'beforeChange', doc.cm, obj);\n                    }\n                    if (obj.canceled) {\n                        if (doc.cm) {\n                            doc.cm.curOp.updateInput = 2;\n                        }\n                        return null;\n                    }\n                    return {\n                        from: obj.from,\n                        to: obj.to,\n                        text: obj.text,\n                        origin: obj.origin\n                    };\n                }\n                function makeChange(doc, change, ignoreReadOnly) {\n                    if (doc.cm) {\n                        if (!doc.cm.curOp) {\n                            return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n                        }\n                        if (doc.cm.state.suppressEdits) {\n                            return;\n                        }\n                    }\n                    if (hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange')) {\n                        change = filterChange(doc, change, true);\n                        if (!change) {\n                            return;\n                        }\n                    }\n                    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n                    if (split) {\n                        for (var i = split.length - 1; i >= 0; --i) {\n                            makeChangeInner(doc, {\n                                from: split[i].from,\n                                to: split[i].to,\n                                text: i ? [''] : change.text,\n                                origin: change.origin\n                            });\n                        }\n                    } else {\n                        makeChangeInner(doc, change);\n                    }\n                }\n                function makeChangeInner(doc, change) {\n                    if (change.text.length == 1 && change.text[0] == '' && cmp(change.from, change.to) == 0) {\n                        return;\n                    }\n                    var selAfter = computeSelAfterChange(doc, change);\n                    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n                    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n                    var rebased = [];\n                    linkedDocs(doc, function (doc, sharedHist) {\n                        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n                            rebaseHist(doc.history, change);\n                            rebased.push(doc.history);\n                        }\n                        makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n                    });\n                }\n                function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n                    var suppress = doc.cm && doc.cm.state.suppressEdits;\n                    if (suppress && !allowSelectionOnly) {\n                        return;\n                    }\n                    var hist = doc.history, event, selAfter = doc.sel;\n                    var source = type == 'undo' ? hist.done : hist.undone, dest = type == 'undo' ? hist.undone : hist.done;\n                    var i = 0;\n                    for (; i < source.length; i++) {\n                        event = source[i];\n                        if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {\n                            break;\n                        }\n                    }\n                    if (i == source.length) {\n                        return;\n                    }\n                    hist.lastOrigin = hist.lastSelOrigin = null;\n                    for (;;) {\n                        event = source.pop();\n                        if (event.ranges) {\n                            pushSelectionToHistory(event, dest);\n                            if (allowSelectionOnly && !event.equals(doc.sel)) {\n                                setSelection(doc, event, { clearRedo: false });\n                                return;\n                            }\n                            selAfter = event;\n                        } else if (suppress) {\n                            source.push(event);\n                            return;\n                        } else {\n                            break;\n                        }\n                    }\n                    var antiChanges = [];\n                    pushSelectionToHistory(selAfter, dest);\n                    dest.push({\n                        changes: antiChanges,\n                        generation: hist.generation\n                    });\n                    hist.generation = event.generation || ++hist.maxGeneration;\n                    var filter = hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange');\n                    var loop = function (i) {\n                        var change = event.changes[i];\n                        change.origin = type;\n                        if (filter && !filterChange(doc, change, false)) {\n                            source.length = 0;\n                            return {};\n                        }\n                        antiChanges.push(historyChangeFromChange(doc, change));\n                        var after = i ? computeSelAfterChange(doc, change) : lst(source);\n                        makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n                        if (!i && doc.cm) {\n                            doc.cm.scrollIntoView({\n                                from: change.from,\n                                to: changeEnd(change)\n                            });\n                        }\n                        var rebased = [];\n                        linkedDocs(doc, function (doc, sharedHist) {\n                            if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n                                rebaseHist(doc.history, change);\n                                rebased.push(doc.history);\n                            }\n                            makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n                        });\n                    };\n                    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n                        var returned = loop(i$1);\n                        if (returned)\n                            return returned.v;\n                    }\n                }\n                function shiftDoc(doc, distance) {\n                    if (distance == 0) {\n                        return;\n                    }\n                    doc.first += distance;\n                    doc.sel = new Selection(map(doc.sel.ranges, function (range) {\n                        return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));\n                    }), doc.sel.primIndex);\n                    if (doc.cm) {\n                        regChange(doc.cm, doc.first, doc.first - distance, distance);\n                        for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {\n                            regLineChange(doc.cm, l, 'gutter');\n                        }\n                    }\n                }\n                function makeChangeSingleDoc(doc, change, selAfter, spans) {\n                    if (doc.cm && !doc.cm.curOp) {\n                        return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n                    }\n                    if (change.to.line < doc.first) {\n                        shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n                        return;\n                    }\n                    if (change.from.line > doc.lastLine()) {\n                        return;\n                    }\n                    if (change.from.line < doc.first) {\n                        var shift = change.text.length - 1 - (doc.first - change.from.line);\n                        shiftDoc(doc, shift);\n                        change = {\n                            from: Pos(doc.first, 0),\n                            to: Pos(change.to.line + shift, change.to.ch),\n                            text: [lst(change.text)],\n                            origin: change.origin\n                        };\n                    }\n                    var last = doc.lastLine();\n                    if (change.to.line > last) {\n                        change = {\n                            from: change.from,\n                            to: Pos(last, getLine(doc, last).text.length),\n                            text: [change.text[0]],\n                            origin: change.origin\n                        };\n                    }\n                    change.removed = getBetween(doc, change.from, change.to);\n                    if (!selAfter) {\n                        selAfter = computeSelAfterChange(doc, change);\n                    }\n                    if (doc.cm) {\n                        makeChangeSingleDocInEditor(doc.cm, change, spans);\n                    } else {\n                        updateDoc(doc, change, spans);\n                    }\n                    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n                    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {\n                        doc.cantEdit = false;\n                    }\n                }\n                function makeChangeSingleDocInEditor(cm, change, spans) {\n                    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n                    var recomputeMaxLength = false, checkWidthStart = from.line;\n                    if (!cm.options.lineWrapping) {\n                        checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n                        doc.iter(checkWidthStart, to.line + 1, function (line) {\n                            if (line == display.maxLine) {\n                                recomputeMaxLength = true;\n                                return true;\n                            }\n                        });\n                    }\n                    if (doc.sel.contains(change.from, change.to) > -1) {\n                        signalCursorActivity(cm);\n                    }\n                    updateDoc(doc, change, spans, estimateHeight(cm));\n                    if (!cm.options.lineWrapping) {\n                        doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n                            var len = lineLength(line);\n                            if (len > display.maxLineLength) {\n                                display.maxLine = line;\n                                display.maxLineLength = len;\n                                display.maxLineChanged = true;\n                                recomputeMaxLength = false;\n                            }\n                        });\n                        if (recomputeMaxLength) {\n                            cm.curOp.updateMaxLine = true;\n                        }\n                    }\n                    retreatFrontier(doc, from.line);\n                    startWorker(cm, 400);\n                    var lendiff = change.text.length - (to.line - from.line) - 1;\n                    if (change.full) {\n                        regChange(cm);\n                    } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {\n                        regLineChange(cm, from.line, 'text');\n                    } else {\n                        regChange(cm, from.line, to.line + 1, lendiff);\n                    }\n                    var changesHandler = hasHandler(cm, 'changes'), changeHandler = hasHandler(cm, 'change');\n                    if (changeHandler || changesHandler) {\n                        var obj = {\n                            from: from,\n                            to: to,\n                            text: change.text,\n                            removed: change.removed,\n                            origin: change.origin\n                        };\n                        if (changeHandler) {\n                            signalLater(cm, 'change', cm, obj);\n                        }\n                        if (changesHandler) {\n                            (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n                        }\n                    }\n                    cm.display.selForContextMenu = null;\n                }\n                function replaceRange(doc, code, from, to, origin) {\n                    var assign;\n                    if (!to) {\n                        to = from;\n                    }\n                    if (cmp(to, from) < 0) {\n                        assign = [\n                            to,\n                            from\n                        ], from = assign[0], to = assign[1];\n                    }\n                    if (typeof code == 'string') {\n                        code = doc.splitLines(code);\n                    }\n                    makeChange(doc, {\n                        from: from,\n                        to: to,\n                        text: code,\n                        origin: origin\n                    });\n                }\n                function rebaseHistSelSingle(pos, from, to, diff) {\n                    if (to < pos.line) {\n                        pos.line += diff;\n                    } else if (from < pos.line) {\n                        pos.line = from;\n                        pos.ch = 0;\n                    }\n                }\n                function rebaseHistArray(array, from, to, diff) {\n                    for (var i = 0; i < array.length; ++i) {\n                        var sub = array[i], ok = true;\n                        if (sub.ranges) {\n                            if (!sub.copied) {\n                                sub = array[i] = sub.deepCopy();\n                                sub.copied = true;\n                            }\n                            for (var j = 0; j < sub.ranges.length; j++) {\n                                rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n                                rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n                            }\n                            continue;\n                        }\n                        for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n                            var cur = sub.changes[j$1];\n                            if (to < cur.from.line) {\n                                cur.from = Pos(cur.from.line + diff, cur.from.ch);\n                                cur.to = Pos(cur.to.line + diff, cur.to.ch);\n                            } else if (from <= cur.to.line) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                        if (!ok) {\n                            array.splice(0, i + 1);\n                            i = 0;\n                        }\n                    }\n                }\n                function rebaseHist(hist, change) {\n                    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n                    rebaseHistArray(hist.done, from, to, diff);\n                    rebaseHistArray(hist.undone, from, to, diff);\n                }\n                function changeLine(doc, handle, changeType, op) {\n                    var no = handle, line = handle;\n                    if (typeof handle == 'number') {\n                        line = getLine(doc, clipLine(doc, handle));\n                    } else {\n                        no = lineNo(handle);\n                    }\n                    if (no == null) {\n                        return null;\n                    }\n                    if (op(line, no) && doc.cm) {\n                        regLineChange(doc.cm, no, changeType);\n                    }\n                    return line;\n                }\n                function LeafChunk(lines) {\n                    this.lines = lines;\n                    this.parent = null;\n                    var height = 0;\n                    for (var i = 0; i < lines.length; ++i) {\n                        lines[i].parent = this;\n                        height += lines[i].height;\n                    }\n                    this.height = height;\n                }\n                LeafChunk.prototype = {\n                    chunkSize: function () {\n                        return this.lines.length;\n                    },\n                    removeInner: function (at, n) {\n                        for (var i = at, e = at + n; i < e; ++i) {\n                            var line = this.lines[i];\n                            this.height -= line.height;\n                            cleanUpLine(line);\n                            signalLater(line, 'delete');\n                        }\n                        this.lines.splice(at, n);\n                    },\n                    collapse: function (lines) {\n                        lines.push.apply(lines, this.lines);\n                    },\n                    insertInner: function (at, lines, height) {\n                        this.height += height;\n                        this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n                        for (var i = 0; i < lines.length; ++i) {\n                            lines[i].parent = this;\n                        }\n                    },\n                    iterN: function (at, n, op) {\n                        for (var e = at + n; at < e; ++at) {\n                            if (op(this.lines[at])) {\n                                return true;\n                            }\n                        }\n                    }\n                };\n                function BranchChunk(children) {\n                    this.children = children;\n                    var size = 0, height = 0;\n                    for (var i = 0; i < children.length; ++i) {\n                        var ch = children[i];\n                        size += ch.chunkSize();\n                        height += ch.height;\n                        ch.parent = this;\n                    }\n                    this.size = size;\n                    this.height = height;\n                    this.parent = null;\n                }\n                BranchChunk.prototype = {\n                    chunkSize: function () {\n                        return this.size;\n                    },\n                    removeInner: function (at, n) {\n                        this.size -= n;\n                        for (var i = 0; i < this.children.length; ++i) {\n                            var child = this.children[i], sz = child.chunkSize();\n                            if (at < sz) {\n                                var rm = Math.min(n, sz - at), oldHeight = child.height;\n                                child.removeInner(at, rm);\n                                this.height -= oldHeight - child.height;\n                                if (sz == rm) {\n                                    this.children.splice(i--, 1);\n                                    child.parent = null;\n                                }\n                                if ((n -= rm) == 0) {\n                                    break;\n                                }\n                                at = 0;\n                            } else {\n                                at -= sz;\n                            }\n                        }\n                        if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n                            var lines = [];\n                            this.collapse(lines);\n                            this.children = [new LeafChunk(lines)];\n                            this.children[0].parent = this;\n                        }\n                    },\n                    collapse: function (lines) {\n                        for (var i = 0; i < this.children.length; ++i) {\n                            this.children[i].collapse(lines);\n                        }\n                    },\n                    insertInner: function (at, lines, height) {\n                        this.size += lines.length;\n                        this.height += height;\n                        for (var i = 0; i < this.children.length; ++i) {\n                            var child = this.children[i], sz = child.chunkSize();\n                            if (at <= sz) {\n                                child.insertInner(at, lines, height);\n                                if (child.lines && child.lines.length > 50) {\n                                    var remaining = child.lines.length % 25 + 25;\n                                    for (var pos = remaining; pos < child.lines.length;) {\n                                        var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n                                        child.height -= leaf.height;\n                                        this.children.splice(++i, 0, leaf);\n                                        leaf.parent = this;\n                                    }\n                                    child.lines = child.lines.slice(0, remaining);\n                                    this.maybeSpill();\n                                }\n                                break;\n                            }\n                            at -= sz;\n                        }\n                    },\n                    maybeSpill: function () {\n                        if (this.children.length <= 10) {\n                            return;\n                        }\n                        var me = this;\n                        do {\n                            var spilled = me.children.splice(me.children.length - 5, 5);\n                            var sibling = new BranchChunk(spilled);\n                            if (!me.parent) {\n                                var copy = new BranchChunk(me.children);\n                                copy.parent = me;\n                                me.children = [\n                                    copy,\n                                    sibling\n                                ];\n                                me = copy;\n                            } else {\n                                me.size -= sibling.size;\n                                me.height -= sibling.height;\n                                var myIndex = indexOf(me.parent.children, me);\n                                me.parent.children.splice(myIndex + 1, 0, sibling);\n                            }\n                            sibling.parent = me.parent;\n                        } while (me.children.length > 10);\n                        me.parent.maybeSpill();\n                    },\n                    iterN: function (at, n, op) {\n                        for (var i = 0; i < this.children.length; ++i) {\n                            var child = this.children[i], sz = child.chunkSize();\n                            if (at < sz) {\n                                var used = Math.min(n, sz - at);\n                                if (child.iterN(at, used, op)) {\n                                    return true;\n                                }\n                                if ((n -= used) == 0) {\n                                    break;\n                                }\n                                at = 0;\n                            } else {\n                                at -= sz;\n                            }\n                        }\n                    }\n                };\n                var LineWidget = function (doc, node, options) {\n                    if (options) {\n                        for (var opt in options) {\n                            if (options.hasOwnProperty(opt)) {\n                                this[opt] = options[opt];\n                            }\n                        }\n                    }\n                    this.doc = doc;\n                    this.node = node;\n                };\n                LineWidget.prototype.clear = function () {\n                    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n                    if (no == null || !ws) {\n                        return;\n                    }\n                    for (var i = 0; i < ws.length; ++i) {\n                        if (ws[i] == this) {\n                            ws.splice(i--, 1);\n                        }\n                    }\n                    if (!ws.length) {\n                        line.widgets = null;\n                    }\n                    var height = widgetHeight(this);\n                    updateLineHeight(line, Math.max(0, line.height - height));\n                    if (cm) {\n                        runInOp(cm, function () {\n                            adjustScrollWhenAboveVisible(cm, line, -height);\n                            regLineChange(cm, no, 'widget');\n                        });\n                        signalLater(cm, 'lineWidgetCleared', cm, this, no);\n                    }\n                };\n                LineWidget.prototype.changed = function () {\n                    var this$1 = this;\n                    var oldH = this.height, cm = this.doc.cm, line = this.line;\n                    this.height = null;\n                    var diff = widgetHeight(this) - oldH;\n                    if (!diff) {\n                        return;\n                    }\n                    if (!lineIsHidden(this.doc, line)) {\n                        updateLineHeight(line, line.height + diff);\n                    }\n                    if (cm) {\n                        runInOp(cm, function () {\n                            cm.curOp.forceUpdate = true;\n                            adjustScrollWhenAboveVisible(cm, line, diff);\n                            signalLater(cm, 'lineWidgetChanged', cm, this$1, lineNo(line));\n                        });\n                    }\n                };\n                eventMixin(LineWidget);\n                function adjustScrollWhenAboveVisible(cm, line, diff) {\n                    if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {\n                        addToScrollTop(cm, diff);\n                    }\n                }\n                function addLineWidget(doc, handle, node, options) {\n                    var widget = new LineWidget(doc, node, options);\n                    var cm = doc.cm;\n                    if (cm && widget.noHScroll) {\n                        cm.display.alignWidgets = true;\n                    }\n                    changeLine(doc, handle, 'widget', function (line) {\n                        var widgets = line.widgets || (line.widgets = []);\n                        if (widget.insertAt == null) {\n                            widgets.push(widget);\n                        } else {\n                            widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);\n                        }\n                        widget.line = line;\n                        if (cm && !lineIsHidden(doc, line)) {\n                            var aboveVisible = heightAtLine(line) < doc.scrollTop;\n                            updateLineHeight(line, line.height + widgetHeight(widget));\n                            if (aboveVisible) {\n                                addToScrollTop(cm, widget.height);\n                            }\n                            cm.curOp.forceUpdate = true;\n                        }\n                        return true;\n                    });\n                    if (cm) {\n                        signalLater(cm, 'lineWidgetAdded', cm, widget, typeof handle == 'number' ? handle : lineNo(handle));\n                    }\n                    return widget;\n                }\n                var nextMarkerId = 0;\n                var TextMarker = function (doc, type) {\n                    this.lines = [];\n                    this.type = type;\n                    this.doc = doc;\n                    this.id = ++nextMarkerId;\n                };\n                TextMarker.prototype.clear = function () {\n                    if (this.explicitlyCleared) {\n                        return;\n                    }\n                    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n                    if (withOp) {\n                        startOperation(cm);\n                    }\n                    if (hasHandler(this, 'clear')) {\n                        var found = this.find();\n                        if (found) {\n                            signalLater(this, 'clear', found.from, found.to);\n                        }\n                    }\n                    var min = null, max = null;\n                    for (var i = 0; i < this.lines.length; ++i) {\n                        var line = this.lines[i];\n                        var span = getMarkedSpanFor(line.markedSpans, this);\n                        if (cm && !this.collapsed) {\n                            regLineChange(cm, lineNo(line), 'text');\n                        } else if (cm) {\n                            if (span.to != null) {\n                                max = lineNo(line);\n                            }\n                            if (span.from != null) {\n                                min = lineNo(line);\n                            }\n                        }\n                        line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n                        if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {\n                            updateLineHeight(line, textHeight(cm.display));\n                        }\n                    }\n                    if (cm && this.collapsed && !cm.options.lineWrapping) {\n                        for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n                            var visual = visualLine(this.lines[i$1]), len = lineLength(visual);\n                            if (len > cm.display.maxLineLength) {\n                                cm.display.maxLine = visual;\n                                cm.display.maxLineLength = len;\n                                cm.display.maxLineChanged = true;\n                            }\n                        }\n                    }\n                    if (min != null && cm && this.collapsed) {\n                        regChange(cm, min, max + 1);\n                    }\n                    this.lines.length = 0;\n                    this.explicitlyCleared = true;\n                    if (this.atomic && this.doc.cantEdit) {\n                        this.doc.cantEdit = false;\n                        if (cm) {\n                            reCheckSelection(cm.doc);\n                        }\n                    }\n                    if (cm) {\n                        signalLater(cm, 'markerCleared', cm, this, min, max);\n                    }\n                    if (withOp) {\n                        endOperation(cm);\n                    }\n                    if (this.parent) {\n                        this.parent.clear();\n                    }\n                };\n                TextMarker.prototype.find = function (side, lineObj) {\n                    if (side == null && this.type == 'bookmark') {\n                        side = 1;\n                    }\n                    var from, to;\n                    for (var i = 0; i < this.lines.length; ++i) {\n                        var line = this.lines[i];\n                        var span = getMarkedSpanFor(line.markedSpans, this);\n                        if (span.from != null) {\n                            from = Pos(lineObj ? line : lineNo(line), span.from);\n                            if (side == -1) {\n                                return from;\n                            }\n                        }\n                        if (span.to != null) {\n                            to = Pos(lineObj ? line : lineNo(line), span.to);\n                            if (side == 1) {\n                                return to;\n                            }\n                        }\n                    }\n                    return from && {\n                        from: from,\n                        to: to\n                    };\n                };\n                TextMarker.prototype.changed = function () {\n                    var this$1 = this;\n                    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n                    if (!pos || !cm) {\n                        return;\n                    }\n                    runInOp(cm, function () {\n                        var line = pos.line, lineN = lineNo(pos.line);\n                        var view = findViewForLine(cm, lineN);\n                        if (view) {\n                            clearLineMeasurementCacheFor(view);\n                            cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n                        }\n                        cm.curOp.updateMaxLine = true;\n                        if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n                            var oldHeight = widget.height;\n                            widget.height = null;\n                            var dHeight = widgetHeight(widget) - oldHeight;\n                            if (dHeight) {\n                                updateLineHeight(line, line.height + dHeight);\n                            }\n                        }\n                        signalLater(cm, 'markerChanged', cm, this$1);\n                    });\n                };\n                TextMarker.prototype.attachLine = function (line) {\n                    if (!this.lines.length && this.doc.cm) {\n                        var op = this.doc.cm.curOp;\n                        if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {\n                            (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n                        }\n                    }\n                    this.lines.push(line);\n                };\n                TextMarker.prototype.detachLine = function (line) {\n                    this.lines.splice(indexOf(this.lines, line), 1);\n                    if (!this.lines.length && this.doc.cm) {\n                        var op = this.doc.cm.curOp;\n                        (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n                    }\n                };\n                eventMixin(TextMarker);\n                function markText(doc, from, to, options, type) {\n                    if (options && options.shared) {\n                        return markTextShared(doc, from, to, options, type);\n                    }\n                    if (doc.cm && !doc.cm.curOp) {\n                        return operation(doc.cm, markText)(doc, from, to, options, type);\n                    }\n                    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n                    if (options) {\n                        copyObj(options, marker, false);\n                    }\n                    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {\n                        return marker;\n                    }\n                    if (marker.replacedWith) {\n                        marker.collapsed = true;\n                        marker.widgetNode = eltP('span', [marker.replacedWith], 'CodeMirror-widget');\n                        if (!options.handleMouseEvents) {\n                            marker.widgetNode.setAttribute('cm-ignore-events', 'true');\n                        }\n                        if (options.insertLeft) {\n                            marker.widgetNode.insertLeft = true;\n                        }\n                    }\n                    if (marker.collapsed) {\n                        if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {\n                            throw new Error('Inserting collapsed marker partially overlapping an existing one');\n                        }\n                        seeCollapsedSpans();\n                    }\n                    if (marker.addToHistory) {\n                        addChangeToHistory(doc, {\n                            from: from,\n                            to: to,\n                            origin: 'markText'\n                        }, doc.sel, NaN);\n                    }\n                    var curLine = from.line, cm = doc.cm, updateMaxLine;\n                    doc.iter(curLine, to.line + 1, function (line) {\n                        if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {\n                            updateMaxLine = true;\n                        }\n                        if (marker.collapsed && curLine != from.line) {\n                            updateLineHeight(line, 0);\n                        }\n                        addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);\n                        ++curLine;\n                    });\n                    if (marker.collapsed) {\n                        doc.iter(from.line, to.line + 1, function (line) {\n                            if (lineIsHidden(doc, line)) {\n                                updateLineHeight(line, 0);\n                            }\n                        });\n                    }\n                    if (marker.clearOnEnter) {\n                        on(marker, 'beforeCursorEnter', function () {\n                            return marker.clear();\n                        });\n                    }\n                    if (marker.readOnly) {\n                        seeReadOnlySpans();\n                        if (doc.history.done.length || doc.history.undone.length) {\n                            doc.clearHistory();\n                        }\n                    }\n                    if (marker.collapsed) {\n                        marker.id = ++nextMarkerId;\n                        marker.atomic = true;\n                    }\n                    if (cm) {\n                        if (updateMaxLine) {\n                            cm.curOp.updateMaxLine = true;\n                        }\n                        if (marker.collapsed) {\n                            regChange(cm, from.line, to.line + 1);\n                        } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {\n                            for (var i = from.line; i <= to.line; i++) {\n                                regLineChange(cm, i, 'text');\n                            }\n                        }\n                        if (marker.atomic) {\n                            reCheckSelection(cm.doc);\n                        }\n                        signalLater(cm, 'markerAdded', cm, marker);\n                    }\n                    return marker;\n                }\n                var SharedTextMarker = function (markers, primary) {\n                    this.markers = markers;\n                    this.primary = primary;\n                    for (var i = 0; i < markers.length; ++i) {\n                        markers[i].parent = this;\n                    }\n                };\n                SharedTextMarker.prototype.clear = function () {\n                    if (this.explicitlyCleared) {\n                        return;\n                    }\n                    this.explicitlyCleared = true;\n                    for (var i = 0; i < this.markers.length; ++i) {\n                        this.markers[i].clear();\n                    }\n                    signalLater(this, 'clear');\n                };\n                SharedTextMarker.prototype.find = function (side, lineObj) {\n                    return this.primary.find(side, lineObj);\n                };\n                eventMixin(SharedTextMarker);\n                function markTextShared(doc, from, to, options, type) {\n                    options = copyObj(options);\n                    options.shared = false;\n                    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n                    var widget = options.widgetNode;\n                    linkedDocs(doc, function (doc) {\n                        if (widget) {\n                            options.widgetNode = widget.cloneNode(true);\n                        }\n                        markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n                        for (var i = 0; i < doc.linked.length; ++i) {\n                            if (doc.linked[i].isParent) {\n                                return;\n                            }\n                        }\n                        primary = lst(markers);\n                    });\n                    return new SharedTextMarker(markers, primary);\n                }\n                function findSharedMarkers(doc) {\n                    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {\n                        return m.parent;\n                    });\n                }\n                function copySharedMarkers(doc, markers) {\n                    for (var i = 0; i < markers.length; i++) {\n                        var marker = markers[i], pos = marker.find();\n                        var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n                        if (cmp(mFrom, mTo)) {\n                            var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n                            marker.markers.push(subMark);\n                            subMark.parent = marker;\n                        }\n                    }\n                }\n                function detachSharedMarkers(markers) {\n                    var loop = function (i) {\n                        var marker = markers[i], linked = [marker.primary.doc];\n                        linkedDocs(marker.primary.doc, function (d) {\n                            return linked.push(d);\n                        });\n                        for (var j = 0; j < marker.markers.length; j++) {\n                            var subMarker = marker.markers[j];\n                            if (indexOf(linked, subMarker.doc) == -1) {\n                                subMarker.parent = null;\n                                marker.markers.splice(j--, 1);\n                            }\n                        }\n                    };\n                    for (var i = 0; i < markers.length; i++)\n                        loop(i);\n                }\n                var nextDocId = 0;\n                var Doc = function (text, mode, firstLine, lineSep, direction) {\n                    if (!(this instanceof Doc)) {\n                        return new Doc(text, mode, firstLine, lineSep, direction);\n                    }\n                    if (firstLine == null) {\n                        firstLine = 0;\n                    }\n                    BranchChunk.call(this, [new LeafChunk([new Line('', null)])]);\n                    this.first = firstLine;\n                    this.scrollTop = this.scrollLeft = 0;\n                    this.cantEdit = false;\n                    this.cleanGeneration = 1;\n                    this.modeFrontier = this.highlightFrontier = firstLine;\n                    var start = Pos(firstLine, 0);\n                    this.sel = simpleSelection(start);\n                    this.history = new History(null);\n                    this.id = ++nextDocId;\n                    this.modeOption = mode;\n                    this.lineSep = lineSep;\n                    this.direction = direction == 'rtl' ? 'rtl' : 'ltr';\n                    this.extend = false;\n                    if (typeof text == 'string') {\n                        text = this.splitLines(text);\n                    }\n                    updateDoc(this, {\n                        from: start,\n                        to: start,\n                        text: text\n                    });\n                    setSelection(this, simpleSelection(start), sel_dontScroll);\n                };\n                Doc.prototype = createObj(BranchChunk.prototype, {\n                    constructor: Doc,\n                    iter: function (from, to, op) {\n                        if (op) {\n                            this.iterN(from - this.first, to - from, op);\n                        } else {\n                            this.iterN(this.first, this.first + this.size, from);\n                        }\n                    },\n                    insert: function (at, lines) {\n                        var height = 0;\n                        for (var i = 0; i < lines.length; ++i) {\n                            height += lines[i].height;\n                        }\n                        this.insertInner(at - this.first, lines, height);\n                    },\n                    remove: function (at, n) {\n                        this.removeInner(at - this.first, n);\n                    },\n                    getValue: function (lineSep) {\n                        var lines = getLines(this, this.first, this.first + this.size);\n                        if (lineSep === false) {\n                            return lines;\n                        }\n                        return lines.join(lineSep || this.lineSeparator());\n                    },\n                    setValue: docMethodOp(function (code) {\n                        var top = Pos(this.first, 0), last = this.first + this.size - 1;\n                        makeChange(this, {\n                            from: top,\n                            to: Pos(last, getLine(this, last).text.length),\n                            text: this.splitLines(code),\n                            origin: 'setValue',\n                            full: true\n                        }, true);\n                        if (this.cm) {\n                            scrollToCoords(this.cm, 0, 0);\n                        }\n                        setSelection(this, simpleSelection(top), sel_dontScroll);\n                    }),\n                    replaceRange: function (code, from, to, origin) {\n                        from = clipPos(this, from);\n                        to = to ? clipPos(this, to) : from;\n                        replaceRange(this, code, from, to, origin);\n                    },\n                    getRange: function (from, to, lineSep) {\n                        var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n                        if (lineSep === false) {\n                            return lines;\n                        }\n                        if (lineSep === '') {\n                            return lines.join('');\n                        }\n                        return lines.join(lineSep || this.lineSeparator());\n                    },\n                    getLine: function (line) {\n                        var l = this.getLineHandle(line);\n                        return l && l.text;\n                    },\n                    getLineHandle: function (line) {\n                        if (isLine(this, line)) {\n                            return getLine(this, line);\n                        }\n                    },\n                    getLineNumber: function (line) {\n                        return lineNo(line);\n                    },\n                    getLineHandleVisualStart: function (line) {\n                        if (typeof line == 'number') {\n                            line = getLine(this, line);\n                        }\n                        return visualLine(line);\n                    },\n                    lineCount: function () {\n                        return this.size;\n                    },\n                    firstLine: function () {\n                        return this.first;\n                    },\n                    lastLine: function () {\n                        return this.first + this.size - 1;\n                    },\n                    clipPos: function (pos) {\n                        return clipPos(this, pos);\n                    },\n                    getCursor: function (start) {\n                        var range = this.sel.primary(), pos;\n                        if (start == null || start == 'head') {\n                            pos = range.head;\n                        } else if (start == 'anchor') {\n                            pos = range.anchor;\n                        } else if (start == 'end' || start == 'to' || start === false) {\n                            pos = range.to();\n                        } else {\n                            pos = range.from();\n                        }\n                        return pos;\n                    },\n                    listSelections: function () {\n                        return this.sel.ranges;\n                    },\n                    somethingSelected: function () {\n                        return this.sel.somethingSelected();\n                    },\n                    setCursor: docMethodOp(function (line, ch, options) {\n                        setSimpleSelection(this, clipPos(this, typeof line == 'number' ? Pos(line, ch || 0) : line), null, options);\n                    }),\n                    setSelection: docMethodOp(function (anchor, head, options) {\n                        setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n                    }),\n                    extendSelection: docMethodOp(function (head, other, options) {\n                        extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n                    }),\n                    extendSelections: docMethodOp(function (heads, options) {\n                        extendSelections(this, clipPosArray(this, heads), options);\n                    }),\n                    extendSelectionsBy: docMethodOp(function (f, options) {\n                        var heads = map(this.sel.ranges, f);\n                        extendSelections(this, clipPosArray(this, heads), options);\n                    }),\n                    setSelections: docMethodOp(function (ranges, primary, options) {\n                        if (!ranges.length) {\n                            return;\n                        }\n                        var out = [];\n                        for (var i = 0; i < ranges.length; i++) {\n                            out[i] = new Range(clipPos(this, ranges[i].anchor), clipPos(this, ranges[i].head || ranges[i].anchor));\n                        }\n                        if (primary == null) {\n                            primary = Math.min(ranges.length - 1, this.sel.primIndex);\n                        }\n                        setSelection(this, normalizeSelection(this.cm, out, primary), options);\n                    }),\n                    addSelection: docMethodOp(function (anchor, head, options) {\n                        var ranges = this.sel.ranges.slice(0);\n                        ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n                        setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n                    }),\n                    getSelection: function (lineSep) {\n                        var ranges = this.sel.ranges, lines;\n                        for (var i = 0; i < ranges.length; i++) {\n                            var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n                            lines = lines ? lines.concat(sel) : sel;\n                        }\n                        if (lineSep === false) {\n                            return lines;\n                        } else {\n                            return lines.join(lineSep || this.lineSeparator());\n                        }\n                    },\n                    getSelections: function (lineSep) {\n                        var parts = [], ranges = this.sel.ranges;\n                        for (var i = 0; i < ranges.length; i++) {\n                            var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n                            if (lineSep !== false) {\n                                sel = sel.join(lineSep || this.lineSeparator());\n                            }\n                            parts[i] = sel;\n                        }\n                        return parts;\n                    },\n                    replaceSelection: function (code, collapse, origin) {\n                        var dup = [];\n                        for (var i = 0; i < this.sel.ranges.length; i++) {\n                            dup[i] = code;\n                        }\n                        this.replaceSelections(dup, collapse, origin || '+input');\n                    },\n                    replaceSelections: docMethodOp(function (code, collapse, origin) {\n                        var changes = [], sel = this.sel;\n                        for (var i = 0; i < sel.ranges.length; i++) {\n                            var range = sel.ranges[i];\n                            changes[i] = {\n                                from: range.from(),\n                                to: range.to(),\n                                text: this.splitLines(code[i]),\n                                origin: origin\n                            };\n                        }\n                        var newSel = collapse && collapse != 'end' && computeReplacedSel(this, changes, collapse);\n                        for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {\n                            makeChange(this, changes[i$1]);\n                        }\n                        if (newSel) {\n                            setSelectionReplaceHistory(this, newSel);\n                        } else if (this.cm) {\n                            ensureCursorVisible(this.cm);\n                        }\n                    }),\n                    undo: docMethodOp(function () {\n                        makeChangeFromHistory(this, 'undo');\n                    }),\n                    redo: docMethodOp(function () {\n                        makeChangeFromHistory(this, 'redo');\n                    }),\n                    undoSelection: docMethodOp(function () {\n                        makeChangeFromHistory(this, 'undo', true);\n                    }),\n                    redoSelection: docMethodOp(function () {\n                        makeChangeFromHistory(this, 'redo', true);\n                    }),\n                    setExtending: function (val) {\n                        this.extend = val;\n                    },\n                    getExtending: function () {\n                        return this.extend;\n                    },\n                    historySize: function () {\n                        var hist = this.history, done = 0, undone = 0;\n                        for (var i = 0; i < hist.done.length; i++) {\n                            if (!hist.done[i].ranges) {\n                                ++done;\n                            }\n                        }\n                        for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {\n                            if (!hist.undone[i$1].ranges) {\n                                ++undone;\n                            }\n                        }\n                        return {\n                            undo: done,\n                            redo: undone\n                        };\n                    },\n                    clearHistory: function () {\n                        var this$1 = this;\n                        this.history = new History(this.history);\n                        linkedDocs(this, function (doc) {\n                            return doc.history = this$1.history;\n                        }, true);\n                    },\n                    markClean: function () {\n                        this.cleanGeneration = this.changeGeneration(true);\n                    },\n                    changeGeneration: function (forceSplit) {\n                        if (forceSplit) {\n                            this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n                        }\n                        return this.history.generation;\n                    },\n                    isClean: function (gen) {\n                        return this.history.generation == (gen || this.cleanGeneration);\n                    },\n                    getHistory: function () {\n                        return {\n                            done: copyHistoryArray(this.history.done),\n                            undone: copyHistoryArray(this.history.undone)\n                        };\n                    },\n                    setHistory: function (histData) {\n                        var hist = this.history = new History(this.history);\n                        hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n                        hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n                    },\n                    setGutterMarker: docMethodOp(function (line, gutterID, value) {\n                        return changeLine(this, line, 'gutter', function (line) {\n                            var markers = line.gutterMarkers || (line.gutterMarkers = {});\n                            markers[gutterID] = value;\n                            if (!value && isEmpty(markers)) {\n                                line.gutterMarkers = null;\n                            }\n                            return true;\n                        });\n                    }),\n                    clearGutter: docMethodOp(function (gutterID) {\n                        var this$1 = this;\n                        this.iter(function (line) {\n                            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n                                changeLine(this$1, line, 'gutter', function () {\n                                    line.gutterMarkers[gutterID] = null;\n                                    if (isEmpty(line.gutterMarkers)) {\n                                        line.gutterMarkers = null;\n                                    }\n                                    return true;\n                                });\n                            }\n                        });\n                    }),\n                    lineInfo: function (line) {\n                        var n;\n                        if (typeof line == 'number') {\n                            if (!isLine(this, line)) {\n                                return null;\n                            }\n                            n = line;\n                            line = getLine(this, line);\n                            if (!line) {\n                                return null;\n                            }\n                        } else {\n                            n = lineNo(line);\n                            if (n == null) {\n                                return null;\n                            }\n                        }\n                        return {\n                            line: n,\n                            handle: line,\n                            text: line.text,\n                            gutterMarkers: line.gutterMarkers,\n                            textClass: line.textClass,\n                            bgClass: line.bgClass,\n                            wrapClass: line.wrapClass,\n                            widgets: line.widgets\n                        };\n                    },\n                    addLineClass: docMethodOp(function (handle, where, cls) {\n                        return changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', function (line) {\n                            var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\n                            if (!line[prop]) {\n                                line[prop] = cls;\n                            } else if (classTest(cls).test(line[prop])) {\n                                return false;\n                            } else {\n                                line[prop] += ' ' + cls;\n                            }\n                            return true;\n                        });\n                    }),\n                    removeLineClass: docMethodOp(function (handle, where, cls) {\n                        return changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', function (line) {\n                            var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';\n                            var cur = line[prop];\n                            if (!cur) {\n                                return false;\n                            } else if (cls == null) {\n                                line[prop] = null;\n                            } else {\n                                var found = cur.match(classTest(cls));\n                                if (!found) {\n                                    return false;\n                                }\n                                var end = found.index + found[0].length;\n                                line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;\n                            }\n                            return true;\n                        });\n                    }),\n                    addLineWidget: docMethodOp(function (handle, node, options) {\n                        return addLineWidget(this, handle, node, options);\n                    }),\n                    removeLineWidget: function (widget) {\n                        widget.clear();\n                    },\n                    markText: function (from, to, options) {\n                        return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || 'range');\n                    },\n                    setBookmark: function (pos, options) {\n                        var realOpts = {\n                            replacedWith: options && (options.nodeType == null ? options.widget : options),\n                            insertLeft: options && options.insertLeft,\n                            clearWhenEmpty: false,\n                            shared: options && options.shared,\n                            handleMouseEvents: options && options.handleMouseEvents\n                        };\n                        pos = clipPos(this, pos);\n                        return markText(this, pos, pos, realOpts, 'bookmark');\n                    },\n                    findMarksAt: function (pos) {\n                        pos = clipPos(this, pos);\n                        var markers = [], spans = getLine(this, pos.line).markedSpans;\n                        if (spans) {\n                            for (var i = 0; i < spans.length; ++i) {\n                                var span = spans[i];\n                                if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {\n                                    markers.push(span.marker.parent || span.marker);\n                                }\n                            }\n                        }\n                        return markers;\n                    },\n                    findMarks: function (from, to, filter) {\n                        from = clipPos(this, from);\n                        to = clipPos(this, to);\n                        var found = [], lineNo = from.line;\n                        this.iter(from.line, to.line + 1, function (line) {\n                            var spans = line.markedSpans;\n                            if (spans) {\n                                for (var i = 0; i < spans.length; i++) {\n                                    var span = spans[i];\n                                    if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {\n                                        found.push(span.marker.parent || span.marker);\n                                    }\n                                }\n                            }\n                            ++lineNo;\n                        });\n                        return found;\n                    },\n                    getAllMarks: function () {\n                        var markers = [];\n                        this.iter(function (line) {\n                            var sps = line.markedSpans;\n                            if (sps) {\n                                for (var i = 0; i < sps.length; ++i) {\n                                    if (sps[i].from != null) {\n                                        markers.push(sps[i].marker);\n                                    }\n                                }\n                            }\n                        });\n                        return markers;\n                    },\n                    posFromIndex: function (off) {\n                        var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n                        this.iter(function (line) {\n                            var sz = line.text.length + sepSize;\n                            if (sz > off) {\n                                ch = off;\n                                return true;\n                            }\n                            off -= sz;\n                            ++lineNo;\n                        });\n                        return clipPos(this, Pos(lineNo, ch));\n                    },\n                    indexFromPos: function (coords) {\n                        coords = clipPos(this, coords);\n                        var index = coords.ch;\n                        if (coords.line < this.first || coords.ch < 0) {\n                            return 0;\n                        }\n                        var sepSize = this.lineSeparator().length;\n                        this.iter(this.first, coords.line, function (line) {\n                            index += line.text.length + sepSize;\n                        });\n                        return index;\n                    },\n                    copy: function (copyHistory) {\n                        var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);\n                        doc.scrollTop = this.scrollTop;\n                        doc.scrollLeft = this.scrollLeft;\n                        doc.sel = this.sel;\n                        doc.extend = false;\n                        if (copyHistory) {\n                            doc.history.undoDepth = this.history.undoDepth;\n                            doc.setHistory(this.getHistory());\n                        }\n                        return doc;\n                    },\n                    linkedDoc: function (options) {\n                        if (!options) {\n                            options = {};\n                        }\n                        var from = this.first, to = this.first + this.size;\n                        if (options.from != null && options.from > from) {\n                            from = options.from;\n                        }\n                        if (options.to != null && options.to < to) {\n                            to = options.to;\n                        }\n                        var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n                        if (options.sharedHist) {\n                            copy.history = this.history;\n                        }\n                        (this.linked || (this.linked = [])).push({\n                            doc: copy,\n                            sharedHist: options.sharedHist\n                        });\n                        copy.linked = [{\n                                doc: this,\n                                isParent: true,\n                                sharedHist: options.sharedHist\n                            }];\n                        copySharedMarkers(copy, findSharedMarkers(this));\n                        return copy;\n                    },\n                    unlinkDoc: function (other) {\n                        if (other instanceof CodeMirror) {\n                            other = other.doc;\n                        }\n                        if (this.linked) {\n                            for (var i = 0; i < this.linked.length; ++i) {\n                                var link = this.linked[i];\n                                if (link.doc != other) {\n                                    continue;\n                                }\n                                this.linked.splice(i, 1);\n                                other.unlinkDoc(this);\n                                detachSharedMarkers(findSharedMarkers(this));\n                                break;\n                            }\n                        }\n                        if (other.history == this.history) {\n                            var splitIds = [other.id];\n                            linkedDocs(other, function (doc) {\n                                return splitIds.push(doc.id);\n                            }, true);\n                            other.history = new History(null);\n                            other.history.done = copyHistoryArray(this.history.done, splitIds);\n                            other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n                        }\n                    },\n                    iterLinkedDocs: function (f) {\n                        linkedDocs(this, f);\n                    },\n                    getMode: function () {\n                        return this.mode;\n                    },\n                    getEditor: function () {\n                        return this.cm;\n                    },\n                    splitLines: function (str) {\n                        if (this.lineSep) {\n                            return str.split(this.lineSep);\n                        }\n                        return splitLinesAuto(str);\n                    },\n                    lineSeparator: function () {\n                        return this.lineSep || '\\n';\n                    },\n                    setDirection: docMethodOp(function (dir) {\n                        if (dir != 'rtl') {\n                            dir = 'ltr';\n                        }\n                        if (dir == this.direction) {\n                            return;\n                        }\n                        this.direction = dir;\n                        this.iter(function (line) {\n                            return line.order = null;\n                        });\n                        if (this.cm) {\n                            directionChanged(this.cm);\n                        }\n                    })\n                });\n                Doc.prototype.eachLine = Doc.prototype.iter;\n                var lastDrop = 0;\n                function onDrop(e) {\n                    var cm = this;\n                    clearDragCursor(cm);\n                    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n                        return;\n                    }\n                    e_preventDefault(e);\n                    if (ie) {\n                        lastDrop = +new Date();\n                    }\n                    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n                    if (!pos || cm.isReadOnly()) {\n                        return;\n                    }\n                    if (files && files.length && window.FileReader && window.File) {\n                        var n = files.length, text = Array(n), read = 0;\n                        var markAsReadAndPasteIfAllFilesAreRead = function () {\n                            if (++read == n) {\n                                operation(cm, function () {\n                                    pos = clipPos(cm.doc, pos);\n                                    var change = {\n                                        from: pos,\n                                        to: pos,\n                                        text: cm.doc.splitLines(text.filter(function (t) {\n                                            return t != null;\n                                        }).join(cm.doc.lineSeparator())),\n                                        origin: 'paste'\n                                    };\n                                    makeChange(cm.doc, change);\n                                    setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));\n                                })();\n                            }\n                        };\n                        var readTextFromFile = function (file, i) {\n                            if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n                                markAsReadAndPasteIfAllFilesAreRead();\n                                return;\n                            }\n                            var reader = new FileReader();\n                            reader.onerror = function () {\n                                return markAsReadAndPasteIfAllFilesAreRead();\n                            };\n                            reader.onload = function () {\n                                var content = reader.result;\n                                if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n                                    markAsReadAndPasteIfAllFilesAreRead();\n                                    return;\n                                }\n                                text[i] = content;\n                                markAsReadAndPasteIfAllFilesAreRead();\n                            };\n                            reader.readAsText(file);\n                        };\n                        for (var i = 0; i < files.length; i++) {\n                            readTextFromFile(files[i], i);\n                        }\n                    } else {\n                        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n                            cm.state.draggingText(e);\n                            setTimeout(function () {\n                                return cm.display.input.focus();\n                            }, 20);\n                            return;\n                        }\n                        try {\n                            var text$1 = e.dataTransfer.getData('Text');\n                            if (text$1) {\n                                var selected;\n                                if (cm.state.draggingText && !cm.state.draggingText.copy) {\n                                    selected = cm.listSelections();\n                                }\n                                setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n                                if (selected) {\n                                    for (var i$1 = 0; i$1 < selected.length; ++i$1) {\n                                        replaceRange(cm.doc, '', selected[i$1].anchor, selected[i$1].head, 'drag');\n                                    }\n                                }\n                                cm.replaceSelection(text$1, 'around', 'paste');\n                                cm.display.input.focus();\n                            }\n                        } catch (e$1) {\n                        }\n                    }\n                }\n                function onDragStart(cm, e) {\n                    if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {\n                        e_stop(e);\n                        return;\n                    }\n                    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n                        return;\n                    }\n                    e.dataTransfer.setData('Text', cm.getSelection());\n                    e.dataTransfer.effectAllowed = 'copyMove';\n                    if (e.dataTransfer.setDragImage && !safari) {\n                        var img = elt('img', null, null, 'position: fixed; left: 0; top: 0;');\n                        img.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n                        if (presto) {\n                            img.width = img.height = 1;\n                            cm.display.wrapper.appendChild(img);\n                            img._top = img.offsetTop;\n                        }\n                        e.dataTransfer.setDragImage(img, 0, 0);\n                        if (presto) {\n                            img.parentNode.removeChild(img);\n                        }\n                    }\n                }\n                function onDragOver(cm, e) {\n                    var pos = posFromMouse(cm, e);\n                    if (!pos) {\n                        return;\n                    }\n                    var frag = document.createDocumentFragment();\n                    drawSelectionCursor(cm, pos, frag);\n                    if (!cm.display.dragCursor) {\n                        cm.display.dragCursor = elt('div', null, 'CodeMirror-cursors CodeMirror-dragcursors');\n                        cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n                    }\n                    removeChildrenAndAdd(cm.display.dragCursor, frag);\n                }\n                function clearDragCursor(cm) {\n                    if (cm.display.dragCursor) {\n                        cm.display.lineSpace.removeChild(cm.display.dragCursor);\n                        cm.display.dragCursor = null;\n                    }\n                }\n                function forEachCodeMirror(f) {\n                    if (!document.getElementsByClassName) {\n                        return;\n                    }\n                    var byClass = document.getElementsByClassName('CodeMirror'), editors = [];\n                    for (var i = 0; i < byClass.length; i++) {\n                        var cm = byClass[i].CodeMirror;\n                        if (cm) {\n                            editors.push(cm);\n                        }\n                    }\n                    if (editors.length) {\n                        editors[0].operation(function () {\n                            for (var i = 0; i < editors.length; i++) {\n                                f(editors[i]);\n                            }\n                        });\n                    }\n                }\n                var globalsRegistered = false;\n                function ensureGlobalHandlers() {\n                    if (globalsRegistered) {\n                        return;\n                    }\n                    registerGlobalHandlers();\n                    globalsRegistered = true;\n                }\n                function registerGlobalHandlers() {\n                    var resizeTimer;\n                    on(window, 'resize', function () {\n                        if (resizeTimer == null) {\n                            resizeTimer = setTimeout(function () {\n                                resizeTimer = null;\n                                forEachCodeMirror(onResize);\n                            }, 100);\n                        }\n                    });\n                    on(window, 'blur', function () {\n                        return forEachCodeMirror(onBlur);\n                    });\n                }\n                function onResize(cm) {\n                    var d = cm.display;\n                    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n                    d.scrollbarsClipped = false;\n                    cm.setSize();\n                }\n                var keyNames = {\n                    3: 'Pause',\n                    8: 'Backspace',\n                    9: 'Tab',\n                    13: 'Enter',\n                    16: 'Shift',\n                    17: 'Ctrl',\n                    18: 'Alt',\n                    19: 'Pause',\n                    20: 'CapsLock',\n                    27: 'Esc',\n                    32: 'Space',\n                    33: 'PageUp',\n                    34: 'PageDown',\n                    35: 'End',\n                    36: 'Home',\n                    37: 'Left',\n                    38: 'Up',\n                    39: 'Right',\n                    40: 'Down',\n                    44: 'PrintScrn',\n                    45: 'Insert',\n                    46: 'Delete',\n                    59: ';',\n                    61: '=',\n                    91: 'Mod',\n                    92: 'Mod',\n                    93: 'Mod',\n                    106: '*',\n                    107: '=',\n                    109: '-',\n                    110: '.',\n                    111: '/',\n                    145: 'ScrollLock',\n                    173: '-',\n                    186: ';',\n                    187: '=',\n                    188: ',',\n                    189: '-',\n                    190: '.',\n                    191: '/',\n                    192: '`',\n                    219: '[',\n                    220: '\\\\',\n                    221: ']',\n                    222: '\\'',\n                    224: 'Mod',\n                    63232: 'Up',\n                    63233: 'Down',\n                    63234: 'Left',\n                    63235: 'Right',\n                    63272: 'Delete',\n                    63273: 'Home',\n                    63275: 'End',\n                    63276: 'PageUp',\n                    63277: 'PageDown',\n                    63302: 'Insert'\n                };\n                for (var i = 0; i < 10; i++) {\n                    keyNames[i + 48] = keyNames[i + 96] = String(i);\n                }\n                for (var i$1 = 65; i$1 <= 90; i$1++) {\n                    keyNames[i$1] = String.fromCharCode(i$1);\n                }\n                for (var i$2 = 1; i$2 <= 12; i$2++) {\n                    keyNames[i$2 + 111] = keyNames[i$2 + 63235] = 'F' + i$2;\n                }\n                var keyMap = {};\n                keyMap.basic = {\n                    'Left': 'goCharLeft',\n                    'Right': 'goCharRight',\n                    'Up': 'goLineUp',\n                    'Down': 'goLineDown',\n                    'End': 'goLineEnd',\n                    'Home': 'goLineStartSmart',\n                    'PageUp': 'goPageUp',\n                    'PageDown': 'goPageDown',\n                    'Delete': 'delCharAfter',\n                    'Backspace': 'delCharBefore',\n                    'Shift-Backspace': 'delCharBefore',\n                    'Tab': 'defaultTab',\n                    'Shift-Tab': 'indentAuto',\n                    'Enter': 'newlineAndIndent',\n                    'Insert': 'toggleOverwrite',\n                    'Esc': 'singleSelection'\n                };\n                keyMap.pcDefault = {\n                    'Ctrl-A': 'selectAll',\n                    'Ctrl-D': 'deleteLine',\n                    'Ctrl-Z': 'undo',\n                    'Shift-Ctrl-Z': 'redo',\n                    'Ctrl-Y': 'redo',\n                    'Ctrl-Home': 'goDocStart',\n                    'Ctrl-End': 'goDocEnd',\n                    'Ctrl-Up': 'goLineUp',\n                    'Ctrl-Down': 'goLineDown',\n                    'Ctrl-Left': 'goGroupLeft',\n                    'Ctrl-Right': 'goGroupRight',\n                    'Alt-Left': 'goLineStart',\n                    'Alt-Right': 'goLineEnd',\n                    'Ctrl-Backspace': 'delGroupBefore',\n                    'Ctrl-Delete': 'delGroupAfter',\n                    'Ctrl-S': 'save',\n                    'Ctrl-F': 'find',\n                    'Ctrl-G': 'findNext',\n                    'Shift-Ctrl-G': 'findPrev',\n                    'Shift-Ctrl-F': 'replace',\n                    'Shift-Ctrl-R': 'replaceAll',\n                    'Ctrl-[': 'indentLess',\n                    'Ctrl-]': 'indentMore',\n                    'Ctrl-U': 'undoSelection',\n                    'Shift-Ctrl-U': 'redoSelection',\n                    'Alt-U': 'redoSelection',\n                    'fallthrough': 'basic'\n                };\n                keyMap.emacsy = {\n                    'Ctrl-F': 'goCharRight',\n                    'Ctrl-B': 'goCharLeft',\n                    'Ctrl-P': 'goLineUp',\n                    'Ctrl-N': 'goLineDown',\n                    'Ctrl-A': 'goLineStart',\n                    'Ctrl-E': 'goLineEnd',\n                    'Ctrl-V': 'goPageDown',\n                    'Shift-Ctrl-V': 'goPageUp',\n                    'Ctrl-D': 'delCharAfter',\n                    'Ctrl-H': 'delCharBefore',\n                    'Alt-Backspace': 'delWordBefore',\n                    'Ctrl-K': 'killLine',\n                    'Ctrl-T': 'transposeChars',\n                    'Ctrl-O': 'openLine'\n                };\n                keyMap.macDefault = {\n                    'Cmd-A': 'selectAll',\n                    'Cmd-D': 'deleteLine',\n                    'Cmd-Z': 'undo',\n                    'Shift-Cmd-Z': 'redo',\n                    'Cmd-Y': 'redo',\n                    'Cmd-Home': 'goDocStart',\n                    'Cmd-Up': 'goDocStart',\n                    'Cmd-End': 'goDocEnd',\n                    'Cmd-Down': 'goDocEnd',\n                    'Alt-Left': 'goGroupLeft',\n                    'Alt-Right': 'goGroupRight',\n                    'Cmd-Left': 'goLineLeft',\n                    'Cmd-Right': 'goLineRight',\n                    'Alt-Backspace': 'delGroupBefore',\n                    'Ctrl-Alt-Backspace': 'delGroupAfter',\n                    'Alt-Delete': 'delGroupAfter',\n                    'Cmd-S': 'save',\n                    'Cmd-F': 'find',\n                    'Cmd-G': 'findNext',\n                    'Shift-Cmd-G': 'findPrev',\n                    'Cmd-Alt-F': 'replace',\n                    'Shift-Cmd-Alt-F': 'replaceAll',\n                    'Cmd-[': 'indentLess',\n                    'Cmd-]': 'indentMore',\n                    'Cmd-Backspace': 'delWrappedLineLeft',\n                    'Cmd-Delete': 'delWrappedLineRight',\n                    'Cmd-U': 'undoSelection',\n                    'Shift-Cmd-U': 'redoSelection',\n                    'Ctrl-Up': 'goDocStart',\n                    'Ctrl-Down': 'goDocEnd',\n                    'fallthrough': [\n                        'basic',\n                        'emacsy'\n                    ]\n                };\n                keyMap['default'] = mac ? keyMap.macDefault : keyMap.pcDefault;\n                function normalizeKeyName(name) {\n                    var parts = name.split(/-(?!$)/);\n                    name = parts[parts.length - 1];\n                    var alt, ctrl, shift, cmd;\n                    for (var i = 0; i < parts.length - 1; i++) {\n                        var mod = parts[i];\n                        if (/^(cmd|meta|m)$/i.test(mod)) {\n                            cmd = true;\n                        } else if (/^a(lt)?$/i.test(mod)) {\n                            alt = true;\n                        } else if (/^(c|ctrl|control)$/i.test(mod)) {\n                            ctrl = true;\n                        } else if (/^s(hift)?$/i.test(mod)) {\n                            shift = true;\n                        } else {\n                            throw new Error('Unrecognized modifier name: ' + mod);\n                        }\n                    }\n                    if (alt) {\n                        name = 'Alt-' + name;\n                    }\n                    if (ctrl) {\n                        name = 'Ctrl-' + name;\n                    }\n                    if (cmd) {\n                        name = 'Cmd-' + name;\n                    }\n                    if (shift) {\n                        name = 'Shift-' + name;\n                    }\n                    return name;\n                }\n                function normalizeKeyMap(keymap) {\n                    var copy = {};\n                    for (var keyname in keymap) {\n                        if (keymap.hasOwnProperty(keyname)) {\n                            var value = keymap[keyname];\n                            if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {\n                                continue;\n                            }\n                            if (value == '...') {\n                                delete keymap[keyname];\n                                continue;\n                            }\n                            var keys = map(keyname.split(' '), normalizeKeyName);\n                            for (var i = 0; i < keys.length; i++) {\n                                var val = void 0, name = void 0;\n                                if (i == keys.length - 1) {\n                                    name = keys.join(' ');\n                                    val = value;\n                                } else {\n                                    name = keys.slice(0, i + 1).join(' ');\n                                    val = '...';\n                                }\n                                var prev = copy[name];\n                                if (!prev) {\n                                    copy[name] = val;\n                                } else if (prev != val) {\n                                    throw new Error('Inconsistent bindings for ' + name);\n                                }\n                            }\n                            delete keymap[keyname];\n                        }\n                    }\n                    for (var prop in copy) {\n                        keymap[prop] = copy[prop];\n                    }\n                    return keymap;\n                }\n                function lookupKey(key, map, handle, context) {\n                    map = getKeyMap(map);\n                    var found = map.call ? map.call(key, context) : map[key];\n                    if (found === false) {\n                        return 'nothing';\n                    }\n                    if (found === '...') {\n                        return 'multi';\n                    }\n                    if (found != null && handle(found)) {\n                        return 'handled';\n                    }\n                    if (map.fallthrough) {\n                        if (Object.prototype.toString.call(map.fallthrough) != '[object Array]') {\n                            return lookupKey(key, map.fallthrough, handle, context);\n                        }\n                        for (var i = 0; i < map.fallthrough.length; i++) {\n                            var result = lookupKey(key, map.fallthrough[i], handle, context);\n                            if (result) {\n                                return result;\n                            }\n                        }\n                    }\n                }\n                function isModifierKey(value) {\n                    var name = typeof value == 'string' ? value : keyNames[value.keyCode];\n                    return name == 'Ctrl' || name == 'Alt' || name == 'Shift' || name == 'Mod';\n                }\n                function addModifierNames(name, event, noShift) {\n                    var base = name;\n                    if (event.altKey && base != 'Alt') {\n                        name = 'Alt-' + name;\n                    }\n                    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != 'Ctrl') {\n                        name = 'Ctrl-' + name;\n                    }\n                    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != 'Mod') {\n                        name = 'Cmd-' + name;\n                    }\n                    if (!noShift && event.shiftKey && base != 'Shift') {\n                        name = 'Shift-' + name;\n                    }\n                    return name;\n                }\n                function keyName(event, noShift) {\n                    if (presto && event.keyCode == 34 && event['char']) {\n                        return false;\n                    }\n                    var name = keyNames[event.keyCode];\n                    if (name == null || event.altGraphKey) {\n                        return false;\n                    }\n                    if (event.keyCode == 3 && event.code) {\n                        name = event.code;\n                    }\n                    return addModifierNames(name, event, noShift);\n                }\n                function getKeyMap(val) {\n                    return typeof val == 'string' ? keyMap[val] : val;\n                }\n                function deleteNearSelection(cm, compute) {\n                    var ranges = cm.doc.sel.ranges, kill = [];\n                    for (var i = 0; i < ranges.length; i++) {\n                        var toKill = compute(ranges[i]);\n                        while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n                            var replaced = kill.pop();\n                            if (cmp(replaced.from, toKill.from) < 0) {\n                                toKill.from = replaced.from;\n                                break;\n                            }\n                        }\n                        kill.push(toKill);\n                    }\n                    runInOp(cm, function () {\n                        for (var i = kill.length - 1; i >= 0; i--) {\n                            replaceRange(cm.doc, '', kill[i].from, kill[i].to, '+delete');\n                        }\n                        ensureCursorVisible(cm);\n                    });\n                }\n                function moveCharLogically(line, ch, dir) {\n                    var target = skipExtendingChars(line.text, ch + dir, dir);\n                    return target < 0 || target > line.text.length ? null : target;\n                }\n                function moveLogically(line, start, dir) {\n                    var ch = moveCharLogically(line, start.ch, dir);\n                    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? 'after' : 'before');\n                }\n                function endOfLine(visually, cm, lineObj, lineNo, dir) {\n                    if (visually) {\n                        if (cm.doc.direction == 'rtl') {\n                            dir = -dir;\n                        }\n                        var order = getOrder(lineObj, cm.doc.direction);\n                        if (order) {\n                            var part = dir < 0 ? lst(order) : order[0];\n                            var moveInStorageOrder = dir < 0 == (part.level == 1);\n                            var sticky = moveInStorageOrder ? 'after' : 'before';\n                            var ch;\n                            if (part.level > 0 || cm.doc.direction == 'rtl') {\n                                var prep = prepareMeasureForLine(cm, lineObj);\n                                ch = dir < 0 ? lineObj.text.length - 1 : 0;\n                                var targetTop = measureCharPrepared(cm, prep, ch).top;\n                                ch = findFirst(function (ch) {\n                                    return measureCharPrepared(cm, prep, ch).top == targetTop;\n                                }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);\n                                if (sticky == 'before') {\n                                    ch = moveCharLogically(lineObj, ch, 1);\n                                }\n                            } else {\n                                ch = dir < 0 ? part.to : part.from;\n                            }\n                            return new Pos(lineNo, ch, sticky);\n                        }\n                    }\n                    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? 'before' : 'after');\n                }\n                function moveVisually(cm, line, start, dir) {\n                    var bidi = getOrder(line, cm.doc.direction);\n                    if (!bidi) {\n                        return moveLogically(line, start, dir);\n                    }\n                    if (start.ch >= line.text.length) {\n                        start.ch = line.text.length;\n                        start.sticky = 'before';\n                    } else if (start.ch <= 0) {\n                        start.ch = 0;\n                        start.sticky = 'after';\n                    }\n                    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n                    if (cm.doc.direction == 'ltr' && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n                        return moveLogically(line, start, dir);\n                    }\n                    var mv = function (pos, dir) {\n                        return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);\n                    };\n                    var prep;\n                    var getWrappedLineExtent = function (ch) {\n                        if (!cm.options.lineWrapping) {\n                            return {\n                                begin: 0,\n                                end: line.text.length\n                            };\n                        }\n                        prep = prep || prepareMeasureForLine(cm, line);\n                        return wrappedLineExtentChar(cm, line, prep, ch);\n                    };\n                    var wrappedLineExtent = getWrappedLineExtent(start.sticky == 'before' ? mv(start, -1) : start.ch);\n                    if (cm.doc.direction == 'rtl' || part.level == 1) {\n                        var moveInStorageOrder = part.level == 1 == dir < 0;\n                        var ch = mv(start, moveInStorageOrder ? 1 : -1);\n                        if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n                            var sticky = moveInStorageOrder ? 'before' : 'after';\n                            return new Pos(start.line, ch, sticky);\n                        }\n                    }\n                    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n                        var getRes = function (ch, moveInStorageOrder) {\n                            return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), 'before') : new Pos(start.line, ch, 'after');\n                        };\n                        for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n                            var part = bidi[partPos];\n                            var moveInStorageOrder = dir > 0 == (part.level != 1);\n                            var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n                            if (part.from <= ch && ch < part.to) {\n                                return getRes(ch, moveInStorageOrder);\n                            }\n                            ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n                            if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {\n                                return getRes(ch, moveInStorageOrder);\n                            }\n                        }\n                    };\n                    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n                    if (res) {\n                        return res;\n                    }\n                    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n                    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n                        res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n                        if (res) {\n                            return res;\n                        }\n                    }\n                    return null;\n                }\n                var commands = {\n                    selectAll: selectAll,\n                    singleSelection: function (cm) {\n                        return cm.setSelection(cm.getCursor('anchor'), cm.getCursor('head'), sel_dontScroll);\n                    },\n                    killLine: function (cm) {\n                        return deleteNearSelection(cm, function (range) {\n                            if (range.empty()) {\n                                var len = getLine(cm.doc, range.head.line).text.length;\n                                if (range.head.ch == len && range.head.line < cm.lastLine()) {\n                                    return {\n                                        from: range.head,\n                                        to: Pos(range.head.line + 1, 0)\n                                    };\n                                } else {\n                                    return {\n                                        from: range.head,\n                                        to: Pos(range.head.line, len)\n                                    };\n                                }\n                            } else {\n                                return {\n                                    from: range.from(),\n                                    to: range.to()\n                                };\n                            }\n                        });\n                    },\n                    deleteLine: function (cm) {\n                        return deleteNearSelection(cm, function (range) {\n                            return {\n                                from: Pos(range.from().line, 0),\n                                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n                            };\n                        });\n                    },\n                    delLineLeft: function (cm) {\n                        return deleteNearSelection(cm, function (range) {\n                            return {\n                                from: Pos(range.from().line, 0),\n                                to: range.from()\n                            };\n                        });\n                    },\n                    delWrappedLineLeft: function (cm) {\n                        return deleteNearSelection(cm, function (range) {\n                            var top = cm.charCoords(range.head, 'div').top + 5;\n                            var leftPos = cm.coordsChar({\n                                left: 0,\n                                top: top\n                            }, 'div');\n                            return {\n                                from: leftPos,\n                                to: range.from()\n                            };\n                        });\n                    },\n                    delWrappedLineRight: function (cm) {\n                        return deleteNearSelection(cm, function (range) {\n                            var top = cm.charCoords(range.head, 'div').top + 5;\n                            var rightPos = cm.coordsChar({\n                                left: cm.display.lineDiv.offsetWidth + 100,\n                                top: top\n                            }, 'div');\n                            return {\n                                from: range.from(),\n                                to: rightPos\n                            };\n                        });\n                    },\n                    undo: function (cm) {\n                        return cm.undo();\n                    },\n                    redo: function (cm) {\n                        return cm.redo();\n                    },\n                    undoSelection: function (cm) {\n                        return cm.undoSelection();\n                    },\n                    redoSelection: function (cm) {\n                        return cm.redoSelection();\n                    },\n                    goDocStart: function (cm) {\n                        return cm.extendSelection(Pos(cm.firstLine(), 0));\n                    },\n                    goDocEnd: function (cm) {\n                        return cm.extendSelection(Pos(cm.lastLine()));\n                    },\n                    goLineStart: function (cm) {\n                        return cm.extendSelectionsBy(function (range) {\n                            return lineStart(cm, range.head.line);\n                        }, {\n                            origin: '+move',\n                            bias: 1\n                        });\n                    },\n                    goLineStartSmart: function (cm) {\n                        return cm.extendSelectionsBy(function (range) {\n                            return lineStartSmart(cm, range.head);\n                        }, {\n                            origin: '+move',\n                            bias: 1\n                        });\n                    },\n                    goLineEnd: function (cm) {\n                        return cm.extendSelectionsBy(function (range) {\n                            return lineEnd(cm, range.head.line);\n                        }, {\n                            origin: '+move',\n                            bias: -1\n                        });\n                    },\n                    goLineRight: function (cm) {\n                        return cm.extendSelectionsBy(function (range) {\n                            var top = cm.cursorCoords(range.head, 'div').top + 5;\n                            return cm.coordsChar({\n                                left: cm.display.lineDiv.offsetWidth + 100,\n                                top: top\n                            }, 'div');\n                        }, sel_move);\n                    },\n                    goLineLeft: function (cm) {\n                        return cm.extendSelectionsBy(function (range) {\n                            var top = cm.cursorCoords(range.head, 'div').top + 5;\n                            return cm.coordsChar({\n                                left: 0,\n                                top: top\n                            }, 'div');\n                        }, sel_move);\n                    },\n                    goLineLeftSmart: function (cm) {\n                        return cm.extendSelectionsBy(function (range) {\n                            var top = cm.cursorCoords(range.head, 'div').top + 5;\n                            var pos = cm.coordsChar({\n                                left: 0,\n                                top: top\n                            }, 'div');\n                            if (pos.ch < cm.getLine(pos.line).search(/\\S/)) {\n                                return lineStartSmart(cm, range.head);\n                            }\n                            return pos;\n                        }, sel_move);\n                    },\n                    goLineUp: function (cm) {\n                        return cm.moveV(-1, 'line');\n                    },\n                    goLineDown: function (cm) {\n                        return cm.moveV(1, 'line');\n                    },\n                    goPageUp: function (cm) {\n                        return cm.moveV(-1, 'page');\n                    },\n                    goPageDown: function (cm) {\n                        return cm.moveV(1, 'page');\n                    },\n                    goCharLeft: function (cm) {\n                        return cm.moveH(-1, 'char');\n                    },\n                    goCharRight: function (cm) {\n                        return cm.moveH(1, 'char');\n                    },\n                    goColumnLeft: function (cm) {\n                        return cm.moveH(-1, 'column');\n                    },\n                    goColumnRight: function (cm) {\n                        return cm.moveH(1, 'column');\n                    },\n                    goWordLeft: function (cm) {\n                        return cm.moveH(-1, 'word');\n                    },\n                    goGroupRight: function (cm) {\n                        return cm.moveH(1, 'group');\n                    },\n                    goGroupLeft: function (cm) {\n                        return cm.moveH(-1, 'group');\n                    },\n                    goWordRight: function (cm) {\n                        return cm.moveH(1, 'word');\n                    },\n                    delCharBefore: function (cm) {\n                        return cm.deleteH(-1, 'codepoint');\n                    },\n                    delCharAfter: function (cm) {\n                        return cm.deleteH(1, 'char');\n                    },\n                    delWordBefore: function (cm) {\n                        return cm.deleteH(-1, 'word');\n                    },\n                    delWordAfter: function (cm) {\n                        return cm.deleteH(1, 'word');\n                    },\n                    delGroupBefore: function (cm) {\n                        return cm.deleteH(-1, 'group');\n                    },\n                    delGroupAfter: function (cm) {\n                        return cm.deleteH(1, 'group');\n                    },\n                    indentAuto: function (cm) {\n                        return cm.indentSelection('smart');\n                    },\n                    indentMore: function (cm) {\n                        return cm.indentSelection('add');\n                    },\n                    indentLess: function (cm) {\n                        return cm.indentSelection('subtract');\n                    },\n                    insertTab: function (cm) {\n                        return cm.replaceSelection('\\t');\n                    },\n                    insertSoftTab: function (cm) {\n                        var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n                        for (var i = 0; i < ranges.length; i++) {\n                            var pos = ranges[i].from();\n                            var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n                            spaces.push(spaceStr(tabSize - col % tabSize));\n                        }\n                        cm.replaceSelections(spaces);\n                    },\n                    defaultTab: function (cm) {\n                        if (cm.somethingSelected()) {\n                            cm.indentSelection('add');\n                        } else {\n                            cm.execCommand('insertTab');\n                        }\n                    },\n                    transposeChars: function (cm) {\n                        return runInOp(cm, function () {\n                            var ranges = cm.listSelections(), newSel = [];\n                            for (var i = 0; i < ranges.length; i++) {\n                                if (!ranges[i].empty()) {\n                                    continue;\n                                }\n                                var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n                                if (line) {\n                                    if (cur.ch == line.length) {\n                                        cur = new Pos(cur.line, cur.ch - 1);\n                                    }\n                                    if (cur.ch > 0) {\n                                        cur = new Pos(cur.line, cur.ch + 1);\n                                        cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, '+transpose');\n                                    } else if (cur.line > cm.doc.first) {\n                                        var prev = getLine(cm.doc, cur.line - 1).text;\n                                        if (prev) {\n                                            cur = new Pos(cur.line, 1);\n                                            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, '+transpose');\n                                        }\n                                    }\n                                }\n                                newSel.push(new Range(cur, cur));\n                            }\n                            cm.setSelections(newSel);\n                        });\n                    },\n                    newlineAndIndent: function (cm) {\n                        return runInOp(cm, function () {\n                            var sels = cm.listSelections();\n                            for (var i = sels.length - 1; i >= 0; i--) {\n                                cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, '+input');\n                            }\n                            sels = cm.listSelections();\n                            for (var i$1 = 0; i$1 < sels.length; i$1++) {\n                                cm.indentLine(sels[i$1].from().line, null, true);\n                            }\n                            ensureCursorVisible(cm);\n                        });\n                    },\n                    openLine: function (cm) {\n                        return cm.replaceSelection('\\n', 'start');\n                    },\n                    toggleOverwrite: function (cm) {\n                        return cm.toggleOverwrite();\n                    }\n                };\n                function lineStart(cm, lineN) {\n                    var line = getLine(cm.doc, lineN);\n                    var visual = visualLine(line);\n                    if (visual != line) {\n                        lineN = lineNo(visual);\n                    }\n                    return endOfLine(true, cm, visual, lineN, 1);\n                }\n                function lineEnd(cm, lineN) {\n                    var line = getLine(cm.doc, lineN);\n                    var visual = visualLineEnd(line);\n                    if (visual != line) {\n                        lineN = lineNo(visual);\n                    }\n                    return endOfLine(true, cm, line, lineN, -1);\n                }\n                function lineStartSmart(cm, pos) {\n                    var start = lineStart(cm, pos.line);\n                    var line = getLine(cm.doc, start.line);\n                    var order = getOrder(line, cm.doc.direction);\n                    if (!order || order[0].level == 0) {\n                        var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));\n                        var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n                        return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);\n                    }\n                    return start;\n                }\n                function doHandleBinding(cm, bound, dropShift) {\n                    if (typeof bound == 'string') {\n                        bound = commands[bound];\n                        if (!bound) {\n                            return false;\n                        }\n                    }\n                    cm.display.input.ensurePolled();\n                    var prevShift = cm.display.shift, done = false;\n                    try {\n                        if (cm.isReadOnly()) {\n                            cm.state.suppressEdits = true;\n                        }\n                        if (dropShift) {\n                            cm.display.shift = false;\n                        }\n                        done = bound(cm) != Pass;\n                    } finally {\n                        cm.display.shift = prevShift;\n                        cm.state.suppressEdits = false;\n                    }\n                    return done;\n                }\n                function lookupKeyForEditor(cm, name, handle) {\n                    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n                        var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n                        if (result) {\n                            return result;\n                        }\n                    }\n                    return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);\n                }\n                var stopSeq = new Delayed();\n                function dispatchKey(cm, name, e, handle) {\n                    var seq = cm.state.keySeq;\n                    if (seq) {\n                        if (isModifierKey(name)) {\n                            return 'handled';\n                        }\n                        if (/\\'$/.test(name)) {\n                            cm.state.keySeq = null;\n                        } else {\n                            stopSeq.set(50, function () {\n                                if (cm.state.keySeq == seq) {\n                                    cm.state.keySeq = null;\n                                    cm.display.input.reset();\n                                }\n                            });\n                        }\n                        if (dispatchKeyInner(cm, seq + ' ' + name, e, handle)) {\n                            return true;\n                        }\n                    }\n                    return dispatchKeyInner(cm, name, e, handle);\n                }\n                function dispatchKeyInner(cm, name, e, handle) {\n                    var result = lookupKeyForEditor(cm, name, handle);\n                    if (result == 'multi') {\n                        cm.state.keySeq = name;\n                    }\n                    if (result == 'handled') {\n                        signalLater(cm, 'keyHandled', cm, name, e);\n                    }\n                    if (result == 'handled' || result == 'multi') {\n                        e_preventDefault(e);\n                        restartBlink(cm);\n                    }\n                    return !!result;\n                }\n                function handleKeyBinding(cm, e) {\n                    var name = keyName(e, true);\n                    if (!name) {\n                        return false;\n                    }\n                    if (e.shiftKey && !cm.state.keySeq) {\n                        return dispatchKey(cm, 'Shift-' + name, e, function (b) {\n                            return doHandleBinding(cm, b, true);\n                        }) || dispatchKey(cm, name, e, function (b) {\n                            if (typeof b == 'string' ? /^go[A-Z]/.test(b) : b.motion) {\n                                return doHandleBinding(cm, b);\n                            }\n                        });\n                    } else {\n                        return dispatchKey(cm, name, e, function (b) {\n                            return doHandleBinding(cm, b);\n                        });\n                    }\n                }\n                function handleCharBinding(cm, e, ch) {\n                    return dispatchKey(cm, '\\'' + ch + '\\'', e, function (b) {\n                        return doHandleBinding(cm, b, true);\n                    });\n                }\n                var lastStoppedKey = null;\n                function onKeyDown(e) {\n                    var cm = this;\n                    if (e.target && e.target != cm.display.input.getField()) {\n                        return;\n                    }\n                    cm.curOp.focus = activeElt(root(cm));\n                    if (signalDOMEvent(cm, e)) {\n                        return;\n                    }\n                    if (ie && ie_version < 11 && e.keyCode == 27) {\n                        e.returnValue = false;\n                    }\n                    var code = e.keyCode;\n                    cm.display.shift = code == 16 || e.shiftKey;\n                    var handled = handleKeyBinding(cm, e);\n                    if (presto) {\n                        lastStoppedKey = handled ? code : null;\n                        if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {\n                            cm.replaceSelection('', null, 'cut');\n                        }\n                    }\n                    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {\n                        document.execCommand('cut');\n                    }\n                    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className)) {\n                        showCrossHair(cm);\n                    }\n                }\n                function showCrossHair(cm) {\n                    var lineDiv = cm.display.lineDiv;\n                    addClass(lineDiv, 'CodeMirror-crosshair');\n                    function up(e) {\n                        if (e.keyCode == 18 || !e.altKey) {\n                            rmClass(lineDiv, 'CodeMirror-crosshair');\n                            off(document, 'keyup', up);\n                            off(document, 'mouseover', up);\n                        }\n                    }\n                    on(document, 'keyup', up);\n                    on(document, 'mouseover', up);\n                }\n                function onKeyUp(e) {\n                    if (e.keyCode == 16) {\n                        this.doc.sel.shift = false;\n                    }\n                    signalDOMEvent(this, e);\n                }\n                function onKeyPress(e) {\n                    var cm = this;\n                    if (e.target && e.target != cm.display.input.getField()) {\n                        return;\n                    }\n                    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {\n                        return;\n                    }\n                    var keyCode = e.keyCode, charCode = e.charCode;\n                    if (presto && keyCode == lastStoppedKey) {\n                        lastStoppedKey = null;\n                        e_preventDefault(e);\n                        return;\n                    }\n                    if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {\n                        return;\n                    }\n                    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n                    if (ch == '\\b') {\n                        return;\n                    }\n                    if (handleCharBinding(cm, e, ch)) {\n                        return;\n                    }\n                    cm.display.input.onKeyPress(e);\n                }\n                var DOUBLECLICK_DELAY = 400;\n                var PastClick = function (time, pos, button) {\n                    this.time = time;\n                    this.pos = pos;\n                    this.button = button;\n                };\n                PastClick.prototype.compare = function (time, pos, button) {\n                    return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;\n                };\n                var lastClick, lastDoubleClick;\n                function clickRepeat(pos, button) {\n                    var now = +new Date();\n                    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n                        lastClick = lastDoubleClick = null;\n                        return 'triple';\n                    } else if (lastClick && lastClick.compare(now, pos, button)) {\n                        lastDoubleClick = new PastClick(now, pos, button);\n                        lastClick = null;\n                        return 'double';\n                    } else {\n                        lastClick = new PastClick(now, pos, button);\n                        lastDoubleClick = null;\n                        return 'single';\n                    }\n                }\n                function onMouseDown(e) {\n                    var cm = this, display = cm.display;\n                    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {\n                        return;\n                    }\n                    display.input.ensurePolled();\n                    display.shift = e.shiftKey;\n                    if (eventInWidget(display, e)) {\n                        if (!webkit) {\n                            display.scroller.draggable = false;\n                            setTimeout(function () {\n                                return display.scroller.draggable = true;\n                            }, 100);\n                        }\n                        return;\n                    }\n                    if (clickInGutter(cm, e)) {\n                        return;\n                    }\n                    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : 'single';\n                    win(cm).focus();\n                    if (button == 1 && cm.state.selectingText) {\n                        cm.state.selectingText(e);\n                    }\n                    if (pos && handleMappedButton(cm, button, pos, repeat, e)) {\n                        return;\n                    }\n                    if (button == 1) {\n                        if (pos) {\n                            leftButtonDown(cm, pos, repeat, e);\n                        } else if (e_target(e) == display.scroller) {\n                            e_preventDefault(e);\n                        }\n                    } else if (button == 2) {\n                        if (pos) {\n                            extendSelection(cm.doc, pos);\n                        }\n                        setTimeout(function () {\n                            return display.input.focus();\n                        }, 20);\n                    } else if (button == 3) {\n                        if (captureRightClick) {\n                            cm.display.input.onContextMenu(e);\n                        } else {\n                            delayBlurEvent(cm);\n                        }\n                    }\n                }\n                function handleMappedButton(cm, button, pos, repeat, event) {\n                    var name = 'Click';\n                    if (repeat == 'double') {\n                        name = 'Double' + name;\n                    } else if (repeat == 'triple') {\n                        name = 'Triple' + name;\n                    }\n                    name = (button == 1 ? 'Left' : button == 2 ? 'Middle' : 'Right') + name;\n                    return dispatchKey(cm, addModifierNames(name, event), event, function (bound) {\n                        if (typeof bound == 'string') {\n                            bound = commands[bound];\n                        }\n                        if (!bound) {\n                            return false;\n                        }\n                        var done = false;\n                        try {\n                            if (cm.isReadOnly()) {\n                                cm.state.suppressEdits = true;\n                            }\n                            done = bound(cm, pos) != Pass;\n                        } finally {\n                            cm.state.suppressEdits = false;\n                        }\n                        return done;\n                    });\n                }\n                function configureMouse(cm, repeat, event) {\n                    var option = cm.getOption('configureMouse');\n                    var value = option ? option(cm, repeat, event) : {};\n                    if (value.unit == null) {\n                        var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n                        value.unit = rect ? 'rectangle' : repeat == 'single' ? 'char' : repeat == 'double' ? 'word' : 'line';\n                    }\n                    if (value.extend == null || cm.doc.extend) {\n                        value.extend = cm.doc.extend || event.shiftKey;\n                    }\n                    if (value.addNew == null) {\n                        value.addNew = mac ? event.metaKey : event.ctrlKey;\n                    }\n                    if (value.moveOnDrag == null) {\n                        value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);\n                    }\n                    return value;\n                }\n                function leftButtonDown(cm, pos, repeat, event) {\n                    if (ie) {\n                        setTimeout(bind(ensureFocus, cm), 0);\n                    } else {\n                        cm.curOp.focus = activeElt(root(cm));\n                    }\n                    var behavior = configureMouse(cm, repeat, event);\n                    var sel = cm.doc.sel, contained;\n                    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == 'single' && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {\n                        leftButtonStartDrag(cm, event, pos, behavior);\n                    } else {\n                        leftButtonSelect(cm, event, pos, behavior);\n                    }\n                }\n                function leftButtonStartDrag(cm, event, pos, behavior) {\n                    var display = cm.display, moved = false;\n                    var dragEnd = operation(cm, function (e) {\n                        if (webkit) {\n                            display.scroller.draggable = false;\n                        }\n                        cm.state.draggingText = false;\n                        if (cm.state.delayingBlurEvent) {\n                            if (cm.hasFocus()) {\n                                cm.state.delayingBlurEvent = false;\n                            } else {\n                                delayBlurEvent(cm);\n                            }\n                        }\n                        off(display.wrapper.ownerDocument, 'mouseup', dragEnd);\n                        off(display.wrapper.ownerDocument, 'mousemove', mouseMove);\n                        off(display.scroller, 'dragstart', dragStart);\n                        off(display.scroller, 'drop', dragEnd);\n                        if (!moved) {\n                            e_preventDefault(e);\n                            if (!behavior.addNew) {\n                                extendSelection(cm.doc, pos, null, null, behavior.extend);\n                            }\n                            if (webkit && !safari || ie && ie_version == 9) {\n                                setTimeout(function () {\n                                    display.wrapper.ownerDocument.body.focus({ preventScroll: true });\n                                    display.input.focus();\n                                }, 20);\n                            } else {\n                                display.input.focus();\n                            }\n                        }\n                    });\n                    var mouseMove = function (e2) {\n                        moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n                    };\n                    var dragStart = function () {\n                        return moved = true;\n                    };\n                    if (webkit) {\n                        display.scroller.draggable = true;\n                    }\n                    cm.state.draggingText = dragEnd;\n                    dragEnd.copy = !behavior.moveOnDrag;\n                    on(display.wrapper.ownerDocument, 'mouseup', dragEnd);\n                    on(display.wrapper.ownerDocument, 'mousemove', mouseMove);\n                    on(display.scroller, 'dragstart', dragStart);\n                    on(display.scroller, 'drop', dragEnd);\n                    cm.state.delayingBlurEvent = true;\n                    setTimeout(function () {\n                        return display.input.focus();\n                    }, 20);\n                    if (display.scroller.dragDrop) {\n                        display.scroller.dragDrop();\n                    }\n                }\n                function rangeForUnit(cm, pos, unit) {\n                    if (unit == 'char') {\n                        return new Range(pos, pos);\n                    }\n                    if (unit == 'word') {\n                        return cm.findWordAt(pos);\n                    }\n                    if (unit == 'line') {\n                        return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n                    }\n                    var result = unit(cm, pos);\n                    return new Range(result.from, result.to);\n                }\n                function leftButtonSelect(cm, event, start, behavior) {\n                    if (ie) {\n                        delayBlurEvent(cm);\n                    }\n                    var display = cm.display, doc = cm.doc;\n                    e_preventDefault(event);\n                    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n                    if (behavior.addNew && !behavior.extend) {\n                        ourIndex = doc.sel.contains(start);\n                        if (ourIndex > -1) {\n                            ourRange = ranges[ourIndex];\n                        } else {\n                            ourRange = new Range(start, start);\n                        }\n                    } else {\n                        ourRange = doc.sel.primary();\n                        ourIndex = doc.sel.primIndex;\n                    }\n                    if (behavior.unit == 'rectangle') {\n                        if (!behavior.addNew) {\n                            ourRange = new Range(start, start);\n                        }\n                        start = posFromMouse(cm, event, true, true);\n                        ourIndex = -1;\n                    } else {\n                        var range = rangeForUnit(cm, start, behavior.unit);\n                        if (behavior.extend) {\n                            ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend);\n                        } else {\n                            ourRange = range;\n                        }\n                    }\n                    if (!behavior.addNew) {\n                        ourIndex = 0;\n                        setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n                        startSel = doc.sel;\n                    } else if (ourIndex == -1) {\n                        ourIndex = ranges.length;\n                        setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), {\n                            scroll: false,\n                            origin: '*mouse'\n                        });\n                    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == 'char' && !behavior.extend) {\n                        setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {\n                            scroll: false,\n                            origin: '*mouse'\n                        });\n                        startSel = doc.sel;\n                    } else {\n                        replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n                    }\n                    var lastPos = start;\n                    function extendTo(pos) {\n                        if (cmp(lastPos, pos) == 0) {\n                            return;\n                        }\n                        lastPos = pos;\n                        if (behavior.unit == 'rectangle') {\n                            var ranges = [], tabSize = cm.options.tabSize;\n                            var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n                            var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n                            var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n                            for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {\n                                var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n                                if (left == right) {\n                                    ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n                                } else if (text.length > leftPos) {\n                                    ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n                                }\n                            }\n                            if (!ranges.length) {\n                                ranges.push(new Range(start, start));\n                            }\n                            setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {\n                                origin: '*mouse',\n                                scroll: false\n                            });\n                            cm.scrollIntoView(pos);\n                        } else {\n                            var oldRange = ourRange;\n                            var range = rangeForUnit(cm, pos, behavior.unit);\n                            var anchor = oldRange.anchor, head;\n                            if (cmp(range.anchor, anchor) > 0) {\n                                head = range.head;\n                                anchor = minPos(oldRange.from(), range.anchor);\n                            } else {\n                                head = range.anchor;\n                                anchor = maxPos(oldRange.to(), range.head);\n                            }\n                            var ranges$1 = startSel.ranges.slice(0);\n                            ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n                            setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n                        }\n                    }\n                    var editorSize = display.wrapper.getBoundingClientRect();\n                    var counter = 0;\n                    function extend(e) {\n                        var curCount = ++counter;\n                        var cur = posFromMouse(cm, e, true, behavior.unit == 'rectangle');\n                        if (!cur) {\n                            return;\n                        }\n                        if (cmp(cur, lastPos) != 0) {\n                            cm.curOp.focus = activeElt(root(cm));\n                            extendTo(cur);\n                            var visible = visibleLines(display, doc);\n                            if (cur.line >= visible.to || cur.line < visible.from) {\n                                setTimeout(operation(cm, function () {\n                                    if (counter == curCount) {\n                                        extend(e);\n                                    }\n                                }), 150);\n                            }\n                        } else {\n                            var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n                            if (outside) {\n                                setTimeout(operation(cm, function () {\n                                    if (counter != curCount) {\n                                        return;\n                                    }\n                                    display.scroller.scrollTop += outside;\n                                    extend(e);\n                                }), 50);\n                            }\n                        }\n                    }\n                    function done(e) {\n                        cm.state.selectingText = false;\n                        counter = Infinity;\n                        if (e) {\n                            e_preventDefault(e);\n                            display.input.focus();\n                        }\n                        off(display.wrapper.ownerDocument, 'mousemove', move);\n                        off(display.wrapper.ownerDocument, 'mouseup', up);\n                        doc.history.lastSelOrigin = null;\n                    }\n                    var move = operation(cm, function (e) {\n                        if (e.buttons === 0 || !e_button(e)) {\n                            done(e);\n                        } else {\n                            extend(e);\n                        }\n                    });\n                    var up = operation(cm, done);\n                    cm.state.selectingText = up;\n                    on(display.wrapper.ownerDocument, 'mousemove', move);\n                    on(display.wrapper.ownerDocument, 'mouseup', up);\n                }\n                function bidiSimplify(cm, range) {\n                    var anchor = range.anchor;\n                    var head = range.head;\n                    var anchorLine = getLine(cm.doc, anchor.line);\n                    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {\n                        return range;\n                    }\n                    var order = getOrder(anchorLine);\n                    if (!order) {\n                        return range;\n                    }\n                    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n                    if (part.from != anchor.ch && part.to != anchor.ch) {\n                        return range;\n                    }\n                    var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);\n                    if (boundary == 0 || boundary == order.length) {\n                        return range;\n                    }\n                    var leftSide;\n                    if (head.line != anchor.line) {\n                        leftSide = (head.line - anchor.line) * (cm.doc.direction == 'ltr' ? 1 : -1) > 0;\n                    } else {\n                        var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n                        var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n                        if (headIndex == boundary - 1 || headIndex == boundary) {\n                            leftSide = dir < 0;\n                        } else {\n                            leftSide = dir > 0;\n                        }\n                    }\n                    var usePart = order[boundary + (leftSide ? -1 : 0)];\n                    var from = leftSide == (usePart.level == 1);\n                    var ch = from ? usePart.from : usePart.to, sticky = from ? 'after' : 'before';\n                    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head);\n                }\n                function gutterEvent(cm, e, type, prevent) {\n                    var mX, mY;\n                    if (e.touches) {\n                        mX = e.touches[0].clientX;\n                        mY = e.touches[0].clientY;\n                    } else {\n                        try {\n                            mX = e.clientX;\n                            mY = e.clientY;\n                        } catch (e$1) {\n                            return false;\n                        }\n                    }\n                    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {\n                        return false;\n                    }\n                    if (prevent) {\n                        e_preventDefault(e);\n                    }\n                    var display = cm.display;\n                    var lineBox = display.lineDiv.getBoundingClientRect();\n                    if (mY > lineBox.bottom || !hasHandler(cm, type)) {\n                        return e_defaultPrevented(e);\n                    }\n                    mY -= lineBox.top - display.viewOffset;\n                    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {\n                        var g = display.gutters.childNodes[i];\n                        if (g && g.getBoundingClientRect().right >= mX) {\n                            var line = lineAtHeight(cm.doc, mY);\n                            var gutter = cm.display.gutterSpecs[i];\n                            signal(cm, type, cm, line, gutter.className, e);\n                            return e_defaultPrevented(e);\n                        }\n                    }\n                }\n                function clickInGutter(cm, e) {\n                    return gutterEvent(cm, e, 'gutterClick', true);\n                }\n                function onContextMenu(cm, e) {\n                    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {\n                        return;\n                    }\n                    if (signalDOMEvent(cm, e, 'contextmenu')) {\n                        return;\n                    }\n                    if (!captureRightClick) {\n                        cm.display.input.onContextMenu(e);\n                    }\n                }\n                function contextMenuInGutter(cm, e) {\n                    if (!hasHandler(cm, 'gutterContextMenu')) {\n                        return false;\n                    }\n                    return gutterEvent(cm, e, 'gutterContextMenu', false);\n                }\n                function themeChanged(cm) {\n                    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, '') + cm.options.theme.replace(/(^|\\s)\\s*/g, ' cm-s-');\n                    clearCaches(cm);\n                }\n                var Init = {\n                    toString: function () {\n                        return 'CodeMirror.Init';\n                    }\n                };\n                var defaults = {};\n                var optionHandlers = {};\n                function defineOptions(CodeMirror) {\n                    var optionHandlers = CodeMirror.optionHandlers;\n                    function option(name, deflt, handle, notOnInit) {\n                        CodeMirror.defaults[name] = deflt;\n                        if (handle) {\n                            optionHandlers[name] = notOnInit ? function (cm, val, old) {\n                                if (old != Init) {\n                                    handle(cm, val, old);\n                                }\n                            } : handle;\n                        }\n                    }\n                    CodeMirror.defineOption = option;\n                    CodeMirror.Init = Init;\n                    option('value', '', function (cm, val) {\n                        return cm.setValue(val);\n                    }, true);\n                    option('mode', null, function (cm, val) {\n                        cm.doc.modeOption = val;\n                        loadMode(cm);\n                    }, true);\n                    option('indentUnit', 2, loadMode, true);\n                    option('indentWithTabs', false);\n                    option('smartIndent', true);\n                    option('tabSize', 4, function (cm) {\n                        resetModeState(cm);\n                        clearCaches(cm);\n                        regChange(cm);\n                    }, true);\n                    option('lineSeparator', null, function (cm, val) {\n                        cm.doc.lineSep = val;\n                        if (!val) {\n                            return;\n                        }\n                        var newBreaks = [], lineNo = cm.doc.first;\n                        cm.doc.iter(function (line) {\n                            for (var pos = 0;;) {\n                                var found = line.text.indexOf(val, pos);\n                                if (found == -1) {\n                                    break;\n                                }\n                                pos = found + val.length;\n                                newBreaks.push(Pos(lineNo, found));\n                            }\n                            lineNo++;\n                        });\n                        for (var i = newBreaks.length - 1; i >= 0; i--) {\n                            replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));\n                        }\n                    });\n                    option('specialChars', /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\u202d\\u202e\\u2066\\u2067\\u2069\\ufeff\\ufff9-\\ufffc]/g, function (cm, val, old) {\n                        cm.state.specialChars = new RegExp(val.source + (val.test('\\t') ? '' : '|\\t'), 'g');\n                        if (old != Init) {\n                            cm.refresh();\n                        }\n                    });\n                    option('specialCharPlaceholder', defaultSpecialCharPlaceholder, function (cm) {\n                        return cm.refresh();\n                    }, true);\n                    option('electricChars', true);\n                    option('inputStyle', mobile ? 'contenteditable' : 'textarea', function () {\n                        throw new Error('inputStyle can not (yet) be changed in a running editor');\n                    }, true);\n                    option('spellcheck', false, function (cm, val) {\n                        return cm.getInputField().spellcheck = val;\n                    }, true);\n                    option('autocorrect', false, function (cm, val) {\n                        return cm.getInputField().autocorrect = val;\n                    }, true);\n                    option('autocapitalize', false, function (cm, val) {\n                        return cm.getInputField().autocapitalize = val;\n                    }, true);\n                    option('rtlMoveVisually', !windows);\n                    option('wholeLineUpdateBefore', true);\n                    option('theme', 'default', function (cm) {\n                        themeChanged(cm);\n                        updateGutters(cm);\n                    }, true);\n                    option('keyMap', 'default', function (cm, val, old) {\n                        var next = getKeyMap(val);\n                        var prev = old != Init && getKeyMap(old);\n                        if (prev && prev.detach) {\n                            prev.detach(cm, next);\n                        }\n                        if (next.attach) {\n                            next.attach(cm, prev || null);\n                        }\n                    });\n                    option('extraKeys', null);\n                    option('configureMouse', null);\n                    option('lineWrapping', false, wrappingChanged, true);\n                    option('gutters', [], function (cm, val) {\n                        cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n                        updateGutters(cm);\n                    }, true);\n                    option('fixedGutter', true, function (cm, val) {\n                        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + 'px' : '0';\n                        cm.refresh();\n                    }, true);\n                    option('coverGutterNextToScrollbar', false, function (cm) {\n                        return updateScrollbars(cm);\n                    }, true);\n                    option('scrollbarStyle', 'native', function (cm) {\n                        initScrollbars(cm);\n                        updateScrollbars(cm);\n                        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n                        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n                    }, true);\n                    option('lineNumbers', false, function (cm, val) {\n                        cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n                        updateGutters(cm);\n                    }, true);\n                    option('firstLineNumber', 1, updateGutters, true);\n                    option('lineNumberFormatter', function (integer) {\n                        return integer;\n                    }, updateGutters, true);\n                    option('showCursorWhenSelecting', false, updateSelection, true);\n                    option('resetSelectionOnContextMenu', true);\n                    option('lineWiseCopyCut', true);\n                    option('pasteLinesPerSelection', true);\n                    option('selectionsMayTouch', false);\n                    option('readOnly', false, function (cm, val) {\n                        if (val == 'nocursor') {\n                            onBlur(cm);\n                            cm.display.input.blur();\n                        }\n                        cm.display.input.readOnlyChanged(val);\n                    });\n                    option('screenReaderLabel', null, function (cm, val) {\n                        val = val === '' ? null : val;\n                        cm.display.input.screenReaderLabelChanged(val);\n                    });\n                    option('disableInput', false, function (cm, val) {\n                        if (!val) {\n                            cm.display.input.reset();\n                        }\n                    }, true);\n                    option('dragDrop', true, dragDropChanged);\n                    option('allowDropFileTypes', null);\n                    option('cursorBlinkRate', 530);\n                    option('cursorScrollMargin', 0);\n                    option('cursorHeight', 1, updateSelection, true);\n                    option('singleCursorHeightPerLine', true, updateSelection, true);\n                    option('workTime', 100);\n                    option('workDelay', 100);\n                    option('flattenSpans', true, resetModeState, true);\n                    option('addModeClass', false, resetModeState, true);\n                    option('pollInterval', 100);\n                    option('undoDepth', 200, function (cm, val) {\n                        return cm.doc.history.undoDepth = val;\n                    });\n                    option('historyEventDelay', 1250);\n                    option('viewportMargin', 10, function (cm) {\n                        return cm.refresh();\n                    }, true);\n                    option('maxHighlightLength', 10000, resetModeState, true);\n                    option('moveInputWithCursor', true, function (cm, val) {\n                        if (!val) {\n                            cm.display.input.resetPosition();\n                        }\n                    });\n                    option('tabindex', null, function (cm, val) {\n                        return cm.display.input.getField().tabIndex = val || '';\n                    });\n                    option('autofocus', null);\n                    option('direction', 'ltr', function (cm, val) {\n                        return cm.doc.setDirection(val);\n                    }, true);\n                    option('phrases', null);\n                }\n                function dragDropChanged(cm, value, old) {\n                    var wasOn = old && old != Init;\n                    if (!value != !wasOn) {\n                        var funcs = cm.display.dragFunctions;\n                        var toggle = value ? on : off;\n                        toggle(cm.display.scroller, 'dragstart', funcs.start);\n                        toggle(cm.display.scroller, 'dragenter', funcs.enter);\n                        toggle(cm.display.scroller, 'dragover', funcs.over);\n                        toggle(cm.display.scroller, 'dragleave', funcs.leave);\n                        toggle(cm.display.scroller, 'drop', funcs.drop);\n                    }\n                }\n                function wrappingChanged(cm) {\n                    if (cm.options.lineWrapping) {\n                        addClass(cm.display.wrapper, 'CodeMirror-wrap');\n                        cm.display.sizer.style.minWidth = '';\n                        cm.display.sizerWidth = null;\n                    } else {\n                        rmClass(cm.display.wrapper, 'CodeMirror-wrap');\n                        findMaxLine(cm);\n                    }\n                    estimateLineHeights(cm);\n                    regChange(cm);\n                    clearCaches(cm);\n                    setTimeout(function () {\n                        return updateScrollbars(cm);\n                    }, 100);\n                }\n                function CodeMirror(place, options) {\n                    var this$1 = this;\n                    if (!(this instanceof CodeMirror)) {\n                        return new CodeMirror(place, options);\n                    }\n                    this.options = options = options ? copyObj(options) : {};\n                    copyObj(defaults, options, false);\n                    var doc = options.value;\n                    if (typeof doc == 'string') {\n                        doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);\n                    } else if (options.mode) {\n                        doc.modeOption = options.mode;\n                    }\n                    this.doc = doc;\n                    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n                    var display = this.display = new Display(place, doc, input, options);\n                    display.wrapper.CodeMirror = this;\n                    themeChanged(this);\n                    if (options.lineWrapping) {\n                        this.display.wrapper.className += ' CodeMirror-wrap';\n                    }\n                    initScrollbars(this);\n                    this.state = {\n                        keyMaps: [],\n                        overlays: [],\n                        modeGen: 0,\n                        overwrite: false,\n                        delayingBlurEvent: false,\n                        focused: false,\n                        suppressEdits: false,\n                        pasteIncoming: -1,\n                        cutIncoming: -1,\n                        selectingText: false,\n                        draggingText: false,\n                        highlight: new Delayed(),\n                        keySeq: null,\n                        specialChars: null\n                    };\n                    if (options.autofocus && !mobile) {\n                        display.input.focus();\n                    }\n                    if (ie && ie_version < 11) {\n                        setTimeout(function () {\n                            return this$1.display.input.reset(true);\n                        }, 20);\n                    }\n                    registerEventHandlers(this);\n                    ensureGlobalHandlers();\n                    startOperation(this);\n                    this.curOp.forceUpdate = true;\n                    attachDoc(this, doc);\n                    if (options.autofocus && !mobile || this.hasFocus()) {\n                        setTimeout(function () {\n                            if (this$1.hasFocus() && !this$1.state.focused) {\n                                onFocus(this$1);\n                            }\n                        }, 20);\n                    } else {\n                        onBlur(this);\n                    }\n                    for (var opt in optionHandlers) {\n                        if (optionHandlers.hasOwnProperty(opt)) {\n                            optionHandlers[opt](this, options[opt], Init);\n                        }\n                    }\n                    maybeUpdateLineNumberWidth(this);\n                    if (options.finishInit) {\n                        options.finishInit(this);\n                    }\n                    for (var i = 0; i < initHooks.length; ++i) {\n                        initHooks[i](this);\n                    }\n                    endOperation(this);\n                    if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == 'optimizelegibility') {\n                        display.lineDiv.style.textRendering = 'auto';\n                    }\n                }\n                CodeMirror.defaults = defaults;\n                CodeMirror.optionHandlers = optionHandlers;\n                function registerEventHandlers(cm) {\n                    var d = cm.display;\n                    on(d.scroller, 'mousedown', operation(cm, onMouseDown));\n                    if (ie && ie_version < 11) {\n                        on(d.scroller, 'dblclick', operation(cm, function (e) {\n                            if (signalDOMEvent(cm, e)) {\n                                return;\n                            }\n                            var pos = posFromMouse(cm, e);\n                            if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {\n                                return;\n                            }\n                            e_preventDefault(e);\n                            var word = cm.findWordAt(pos);\n                            extendSelection(cm.doc, word.anchor, word.head);\n                        }));\n                    } else {\n                        on(d.scroller, 'dblclick', function (e) {\n                            return signalDOMEvent(cm, e) || e_preventDefault(e);\n                        });\n                    }\n                    on(d.scroller, 'contextmenu', function (e) {\n                        return onContextMenu(cm, e);\n                    });\n                    on(d.input.getField(), 'contextmenu', function (e) {\n                        if (!d.scroller.contains(e.target)) {\n                            onContextMenu(cm, e);\n                        }\n                    });\n                    var touchFinished, prevTouch = { end: 0 };\n                    function finishTouch() {\n                        if (d.activeTouch) {\n                            touchFinished = setTimeout(function () {\n                                return d.activeTouch = null;\n                            }, 1000);\n                            prevTouch = d.activeTouch;\n                            prevTouch.end = +new Date();\n                        }\n                    }\n                    function isMouseLikeTouchEvent(e) {\n                        if (e.touches.length != 1) {\n                            return false;\n                        }\n                        var touch = e.touches[0];\n                        return touch.radiusX <= 1 && touch.radiusY <= 1;\n                    }\n                    function farAway(touch, other) {\n                        if (other.left == null) {\n                            return true;\n                        }\n                        var dx = other.left - touch.left, dy = other.top - touch.top;\n                        return dx * dx + dy * dy > 20 * 20;\n                    }\n                    on(d.scroller, 'touchstart', function (e) {\n                        if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n                            d.input.ensurePolled();\n                            clearTimeout(touchFinished);\n                            var now = +new Date();\n                            d.activeTouch = {\n                                start: now,\n                                moved: false,\n                                prev: now - prevTouch.end <= 300 ? prevTouch : null\n                            };\n                            if (e.touches.length == 1) {\n                                d.activeTouch.left = e.touches[0].pageX;\n                                d.activeTouch.top = e.touches[0].pageY;\n                            }\n                        }\n                    });\n                    on(d.scroller, 'touchmove', function () {\n                        if (d.activeTouch) {\n                            d.activeTouch.moved = true;\n                        }\n                    });\n                    on(d.scroller, 'touchend', function (e) {\n                        var touch = d.activeTouch;\n                        if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {\n                            var pos = cm.coordsChar(d.activeTouch, 'page'), range;\n                            if (!touch.prev || farAway(touch, touch.prev)) {\n                                range = new Range(pos, pos);\n                            } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {\n                                range = cm.findWordAt(pos);\n                            } else {\n                                range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n                            }\n                            cm.setSelection(range.anchor, range.head);\n                            cm.focus();\n                            e_preventDefault(e);\n                        }\n                        finishTouch();\n                    });\n                    on(d.scroller, 'touchcancel', finishTouch);\n                    on(d.scroller, 'scroll', function () {\n                        if (d.scroller.clientHeight) {\n                            updateScrollTop(cm, d.scroller.scrollTop);\n                            setScrollLeft(cm, d.scroller.scrollLeft, true);\n                            signal(cm, 'scroll', cm);\n                        }\n                    });\n                    on(d.scroller, 'mousewheel', function (e) {\n                        return onScrollWheel(cm, e);\n                    });\n                    on(d.scroller, 'DOMMouseScroll', function (e) {\n                        return onScrollWheel(cm, e);\n                    });\n                    on(d.wrapper, 'scroll', function () {\n                        return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;\n                    });\n                    d.dragFunctions = {\n                        enter: function (e) {\n                            if (!signalDOMEvent(cm, e)) {\n                                e_stop(e);\n                            }\n                        },\n                        over: function (e) {\n                            if (!signalDOMEvent(cm, e)) {\n                                onDragOver(cm, e);\n                                e_stop(e);\n                            }\n                        },\n                        start: function (e) {\n                            return onDragStart(cm, e);\n                        },\n                        drop: operation(cm, onDrop),\n                        leave: function (e) {\n                            if (!signalDOMEvent(cm, e)) {\n                                clearDragCursor(cm);\n                            }\n                        }\n                    };\n                    var inp = d.input.getField();\n                    on(inp, 'keyup', function (e) {\n                        return onKeyUp.call(cm, e);\n                    });\n                    on(inp, 'keydown', operation(cm, onKeyDown));\n                    on(inp, 'keypress', operation(cm, onKeyPress));\n                    on(inp, 'focus', function (e) {\n                        return onFocus(cm, e);\n                    });\n                    on(inp, 'blur', function (e) {\n                        return onBlur(cm, e);\n                    });\n                }\n                var initHooks = [];\n                CodeMirror.defineInitHook = function (f) {\n                    return initHooks.push(f);\n                };\n                function indentLine(cm, n, how, aggressive) {\n                    var doc = cm.doc, state;\n                    if (how == null) {\n                        how = 'add';\n                    }\n                    if (how == 'smart') {\n                        if (!doc.mode.indent) {\n                            how = 'prev';\n                        } else {\n                            state = getContextBefore(cm, n).state;\n                        }\n                    }\n                    var tabSize = cm.options.tabSize;\n                    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n                    if (line.stateAfter) {\n                        line.stateAfter = null;\n                    }\n                    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n                    if (!aggressive && !/\\S/.test(line.text)) {\n                        indentation = 0;\n                        how = 'not';\n                    } else if (how == 'smart') {\n                        indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n                        if (indentation == Pass || indentation > 150) {\n                            if (!aggressive) {\n                                return;\n                            }\n                            how = 'prev';\n                        }\n                    }\n                    if (how == 'prev') {\n                        if (n > doc.first) {\n                            indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);\n                        } else {\n                            indentation = 0;\n                        }\n                    } else if (how == 'add') {\n                        indentation = curSpace + cm.options.indentUnit;\n                    } else if (how == 'subtract') {\n                        indentation = curSpace - cm.options.indentUnit;\n                    } else if (typeof how == 'number') {\n                        indentation = curSpace + how;\n                    }\n                    indentation = Math.max(0, indentation);\n                    var indentString = '', pos = 0;\n                    if (cm.options.indentWithTabs) {\n                        for (var i = Math.floor(indentation / tabSize); i; --i) {\n                            pos += tabSize;\n                            indentString += '\\t';\n                        }\n                    }\n                    if (pos < indentation) {\n                        indentString += spaceStr(indentation - pos);\n                    }\n                    if (indentString != curSpaceString) {\n                        replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), '+input');\n                        line.stateAfter = null;\n                        return true;\n                    } else {\n                        for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n                            var range = doc.sel.ranges[i$1];\n                            if (range.head.line == n && range.head.ch < curSpaceString.length) {\n                                var pos$1 = Pos(n, curSpaceString.length);\n                                replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n                                break;\n                            }\n                        }\n                    }\n                }\n                var lastCopied = null;\n                function setLastCopied(newLastCopied) {\n                    lastCopied = newLastCopied;\n                }\n                function applyTextInput(cm, inserted, deleted, sel, origin) {\n                    var doc = cm.doc;\n                    cm.display.shift = false;\n                    if (!sel) {\n                        sel = doc.sel;\n                    }\n                    var recent = +new Date() - 200;\n                    var paste = origin == 'paste' || cm.state.pasteIncoming > recent;\n                    var textLines = splitLinesAuto(inserted), multiPaste = null;\n                    if (paste && sel.ranges.length > 1) {\n                        if (lastCopied && lastCopied.text.join('\\n') == inserted) {\n                            if (sel.ranges.length % lastCopied.text.length == 0) {\n                                multiPaste = [];\n                                for (var i = 0; i < lastCopied.text.length; i++) {\n                                    multiPaste.push(doc.splitLines(lastCopied.text[i]));\n                                }\n                            }\n                        } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n                            multiPaste = map(textLines, function (l) {\n                                return [l];\n                            });\n                        }\n                    }\n                    var updateInput = cm.curOp.updateInput;\n                    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n                        var range = sel.ranges[i$1];\n                        var from = range.from(), to = range.to();\n                        if (range.empty()) {\n                            if (deleted && deleted > 0) {\n                                from = Pos(from.line, from.ch - deleted);\n                            } else if (cm.state.overwrite && !paste) {\n                                to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n                            } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join('\\n') == textLines.join('\\n')) {\n                                from = to = Pos(from.line, 0);\n                            }\n                        }\n                        var changeEvent = {\n                            from: from,\n                            to: to,\n                            text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                            origin: origin || (paste ? 'paste' : cm.state.cutIncoming > recent ? 'cut' : '+input')\n                        };\n                        makeChange(cm.doc, changeEvent);\n                        signalLater(cm, 'inputRead', cm, changeEvent);\n                    }\n                    if (inserted && !paste) {\n                        triggerElectric(cm, inserted);\n                    }\n                    ensureCursorVisible(cm);\n                    if (cm.curOp.updateInput < 2) {\n                        cm.curOp.updateInput = updateInput;\n                    }\n                    cm.curOp.typing = true;\n                    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n                }\n                function handlePaste(e, cm) {\n                    var pasted = e.clipboardData && e.clipboardData.getData('Text');\n                    if (pasted) {\n                        e.preventDefault();\n                        if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus()) {\n                            runInOp(cm, function () {\n                                return applyTextInput(cm, pasted, 0, null, 'paste');\n                            });\n                        }\n                        return true;\n                    }\n                }\n                function triggerElectric(cm, inserted) {\n                    if (!cm.options.electricChars || !cm.options.smartIndent) {\n                        return;\n                    }\n                    var sel = cm.doc.sel;\n                    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n                        var range = sel.ranges[i];\n                        if (range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line) {\n                            continue;\n                        }\n                        var mode = cm.getModeAt(range.head);\n                        var indented = false;\n                        if (mode.electricChars) {\n                            for (var j = 0; j < mode.electricChars.length; j++) {\n                                if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n                                    indented = indentLine(cm, range.head.line, 'smart');\n                                    break;\n                                }\n                            }\n                        } else if (mode.electricInput) {\n                            if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch))) {\n                                indented = indentLine(cm, range.head.line, 'smart');\n                            }\n                        }\n                        if (indented) {\n                            signalLater(cm, 'electricInput', cm, range.head.line);\n                        }\n                    }\n                }\n                function copyableRanges(cm) {\n                    var text = [], ranges = [];\n                    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n                        var line = cm.doc.sel.ranges[i].head.line;\n                        var lineRange = {\n                            anchor: Pos(line, 0),\n                            head: Pos(line + 1, 0)\n                        };\n                        ranges.push(lineRange);\n                        text.push(cm.getRange(lineRange.anchor, lineRange.head));\n                    }\n                    return {\n                        text: text,\n                        ranges: ranges\n                    };\n                }\n                function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n                    field.setAttribute('autocorrect', autocorrect ? 'on' : 'off');\n                    field.setAttribute('autocapitalize', autocapitalize ? 'on' : 'off');\n                    field.setAttribute('spellcheck', !!spellcheck);\n                }\n                function hiddenTextarea() {\n                    var te = elt('textarea', null, null, 'position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none');\n                    var div = elt('div', [te], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;');\n                    if (webkit) {\n                        te.style.width = '1000px';\n                    } else {\n                        te.setAttribute('wrap', 'off');\n                    }\n                    if (ios) {\n                        te.style.border = '1px solid black';\n                    }\n                    return div;\n                }\n                function addEditorMethods(CodeMirror) {\n                    var optionHandlers = CodeMirror.optionHandlers;\n                    var helpers = CodeMirror.helpers = {};\n                    CodeMirror.prototype = {\n                        constructor: CodeMirror,\n                        focus: function () {\n                            win(this).focus();\n                            this.display.input.focus();\n                        },\n                        setOption: function (option, value) {\n                            var options = this.options, old = options[option];\n                            if (options[option] == value && option != 'mode') {\n                                return;\n                            }\n                            options[option] = value;\n                            if (optionHandlers.hasOwnProperty(option)) {\n                                operation(this, optionHandlers[option])(this, value, old);\n                            }\n                            signal(this, 'optionChange', this, option);\n                        },\n                        getOption: function (option) {\n                            return this.options[option];\n                        },\n                        getDoc: function () {\n                            return this.doc;\n                        },\n                        addKeyMap: function (map, bottom) {\n                            this.state.keyMaps[bottom ? 'push' : 'unshift'](getKeyMap(map));\n                        },\n                        removeKeyMap: function (map) {\n                            var maps = this.state.keyMaps;\n                            for (var i = 0; i < maps.length; ++i) {\n                                if (maps[i] == map || maps[i].name == map) {\n                                    maps.splice(i, 1);\n                                    return true;\n                                }\n                            }\n                        },\n                        addOverlay: methodOp(function (spec, options) {\n                            var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n                            if (mode.startState) {\n                                throw new Error('Overlays may not be stateful.');\n                            }\n                            insertSorted(this.state.overlays, {\n                                mode: mode,\n                                modeSpec: spec,\n                                opaque: options && options.opaque,\n                                priority: options && options.priority || 0\n                            }, function (overlay) {\n                                return overlay.priority;\n                            });\n                            this.state.modeGen++;\n                            regChange(this);\n                        }),\n                        removeOverlay: methodOp(function (spec) {\n                            var overlays = this.state.overlays;\n                            for (var i = 0; i < overlays.length; ++i) {\n                                var cur = overlays[i].modeSpec;\n                                if (cur == spec || typeof spec == 'string' && cur.name == spec) {\n                                    overlays.splice(i, 1);\n                                    this.state.modeGen++;\n                                    regChange(this);\n                                    return;\n                                }\n                            }\n                        }),\n                        indentLine: methodOp(function (n, dir, aggressive) {\n                            if (typeof dir != 'string' && typeof dir != 'number') {\n                                if (dir == null) {\n                                    dir = this.options.smartIndent ? 'smart' : 'prev';\n                                } else {\n                                    dir = dir ? 'add' : 'subtract';\n                                }\n                            }\n                            if (isLine(this.doc, n)) {\n                                indentLine(this, n, dir, aggressive);\n                            }\n                        }),\n                        indentSelection: methodOp(function (how) {\n                            var ranges = this.doc.sel.ranges, end = -1;\n                            for (var i = 0; i < ranges.length; i++) {\n                                var range = ranges[i];\n                                if (!range.empty()) {\n                                    var from = range.from(), to = range.to();\n                                    var start = Math.max(end, from.line);\n                                    end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n                                    for (var j = start; j < end; ++j) {\n                                        indentLine(this, j, how);\n                                    }\n                                    var newRanges = this.doc.sel.ranges;\n                                    if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {\n                                        replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n                                    }\n                                } else if (range.head.line > end) {\n                                    indentLine(this, range.head.line, how, true);\n                                    end = range.head.line;\n                                    if (i == this.doc.sel.primIndex) {\n                                        ensureCursorVisible(this);\n                                    }\n                                }\n                            }\n                        }),\n                        getTokenAt: function (pos, precise) {\n                            return takeToken(this, pos, precise);\n                        },\n                        getLineTokens: function (line, precise) {\n                            return takeToken(this, Pos(line), precise, true);\n                        },\n                        getTokenTypeAt: function (pos) {\n                            pos = clipPos(this.doc, pos);\n                            var styles = getLineStyles(this, getLine(this.doc, pos.line));\n                            var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n                            var type;\n                            if (ch == 0) {\n                                type = styles[2];\n                            } else {\n                                for (;;) {\n                                    var mid = before + after >> 1;\n                                    if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {\n                                        after = mid;\n                                    } else if (styles[mid * 2 + 1] < ch) {\n                                        before = mid + 1;\n                                    } else {\n                                        type = styles[mid * 2 + 2];\n                                        break;\n                                    }\n                                }\n                            }\n                            var cut = type ? type.indexOf('overlay ') : -1;\n                            return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n                        },\n                        getModeAt: function (pos) {\n                            var mode = this.doc.mode;\n                            if (!mode.innerMode) {\n                                return mode;\n                            }\n                            return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n                        },\n                        getHelper: function (pos, type) {\n                            return this.getHelpers(pos, type)[0];\n                        },\n                        getHelpers: function (pos, type) {\n                            var found = [];\n                            if (!helpers.hasOwnProperty(type)) {\n                                return found;\n                            }\n                            var help = helpers[type], mode = this.getModeAt(pos);\n                            if (typeof mode[type] == 'string') {\n                                if (help[mode[type]]) {\n                                    found.push(help[mode[type]]);\n                                }\n                            } else if (mode[type]) {\n                                for (var i = 0; i < mode[type].length; i++) {\n                                    var val = help[mode[type][i]];\n                                    if (val) {\n                                        found.push(val);\n                                    }\n                                }\n                            } else if (mode.helperType && help[mode.helperType]) {\n                                found.push(help[mode.helperType]);\n                            } else if (help[mode.name]) {\n                                found.push(help[mode.name]);\n                            }\n                            for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n                                var cur = help._global[i$1];\n                                if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {\n                                    found.push(cur.val);\n                                }\n                            }\n                            return found;\n                        },\n                        getStateAfter: function (line, precise) {\n                            var doc = this.doc;\n                            line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);\n                            return getContextBefore(this, line + 1, precise).state;\n                        },\n                        cursorCoords: function (start, mode) {\n                            var pos, range = this.doc.sel.primary();\n                            if (start == null) {\n                                pos = range.head;\n                            } else if (typeof start == 'object') {\n                                pos = clipPos(this.doc, start);\n                            } else {\n                                pos = start ? range.from() : range.to();\n                            }\n                            return cursorCoords(this, pos, mode || 'page');\n                        },\n                        charCoords: function (pos, mode) {\n                            return charCoords(this, clipPos(this.doc, pos), mode || 'page');\n                        },\n                        coordsChar: function (coords, mode) {\n                            coords = fromCoordSystem(this, coords, mode || 'page');\n                            return coordsChar(this, coords.left, coords.top);\n                        },\n                        lineAtHeight: function (height, mode) {\n                            height = fromCoordSystem(this, {\n                                top: height,\n                                left: 0\n                            }, mode || 'page').top;\n                            return lineAtHeight(this.doc, height + this.display.viewOffset);\n                        },\n                        heightAtLine: function (line, mode, includeWidgets) {\n                            var end = false, lineObj;\n                            if (typeof line == 'number') {\n                                var last = this.doc.first + this.doc.size - 1;\n                                if (line < this.doc.first) {\n                                    line = this.doc.first;\n                                } else if (line > last) {\n                                    line = last;\n                                    end = true;\n                                }\n                                lineObj = getLine(this.doc, line);\n                            } else {\n                                lineObj = line;\n                            }\n                            return intoCoordSystem(this, lineObj, {\n                                top: 0,\n                                left: 0\n                            }, mode || 'page', includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);\n                        },\n                        defaultTextHeight: function () {\n                            return textHeight(this.display);\n                        },\n                        defaultCharWidth: function () {\n                            return charWidth(this.display);\n                        },\n                        getViewport: function () {\n                            return {\n                                from: this.display.viewFrom,\n                                to: this.display.viewTo\n                            };\n                        },\n                        addWidget: function (pos, node, scroll, vert, horiz) {\n                            var display = this.display;\n                            pos = cursorCoords(this, clipPos(this.doc, pos));\n                            var top = pos.bottom, left = pos.left;\n                            node.style.position = 'absolute';\n                            node.setAttribute('cm-ignore-events', 'true');\n                            this.display.input.setUneditable(node);\n                            display.sizer.appendChild(node);\n                            if (vert == 'over') {\n                                top = pos.top;\n                            } else if (vert == 'above' || vert == 'near') {\n                                var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n                                if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {\n                                    top = pos.top - node.offsetHeight;\n                                } else if (pos.bottom + node.offsetHeight <= vspace) {\n                                    top = pos.bottom;\n                                }\n                                if (left + node.offsetWidth > hspace) {\n                                    left = hspace - node.offsetWidth;\n                                }\n                            }\n                            node.style.top = top + 'px';\n                            node.style.left = node.style.right = '';\n                            if (horiz == 'right') {\n                                left = display.sizer.clientWidth - node.offsetWidth;\n                                node.style.right = '0px';\n                            } else {\n                                if (horiz == 'left') {\n                                    left = 0;\n                                } else if (horiz == 'middle') {\n                                    left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n                                }\n                                node.style.left = left + 'px';\n                            }\n                            if (scroll) {\n                                scrollIntoView(this, {\n                                    left: left,\n                                    top: top,\n                                    right: left + node.offsetWidth,\n                                    bottom: top + node.offsetHeight\n                                });\n                            }\n                        },\n                        triggerOnKeyDown: methodOp(onKeyDown),\n                        triggerOnKeyPress: methodOp(onKeyPress),\n                        triggerOnKeyUp: onKeyUp,\n                        triggerOnMouseDown: methodOp(onMouseDown),\n                        execCommand: function (cmd) {\n                            if (commands.hasOwnProperty(cmd)) {\n                                return commands[cmd].call(null, this);\n                            }\n                        },\n                        triggerElectric: methodOp(function (text) {\n                            triggerElectric(this, text);\n                        }),\n                        findPosH: function (from, amount, unit, visually) {\n                            var dir = 1;\n                            if (amount < 0) {\n                                dir = -1;\n                                amount = -amount;\n                            }\n                            var cur = clipPos(this.doc, from);\n                            for (var i = 0; i < amount; ++i) {\n                                cur = findPosH(this.doc, cur, dir, unit, visually);\n                                if (cur.hitSide) {\n                                    break;\n                                }\n                            }\n                            return cur;\n                        },\n                        moveH: methodOp(function (dir, unit) {\n                            var this$1 = this;\n                            this.extendSelectionsBy(function (range) {\n                                if (this$1.display.shift || this$1.doc.extend || range.empty()) {\n                                    return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually);\n                                } else {\n                                    return dir < 0 ? range.from() : range.to();\n                                }\n                            }, sel_move);\n                        }),\n                        deleteH: methodOp(function (dir, unit) {\n                            var sel = this.doc.sel, doc = this.doc;\n                            if (sel.somethingSelected()) {\n                                doc.replaceSelection('', null, '+delete');\n                            } else {\n                                deleteNearSelection(this, function (range) {\n                                    var other = findPosH(doc, range.head, dir, unit, false);\n                                    return dir < 0 ? {\n                                        from: other,\n                                        to: range.head\n                                    } : {\n                                        from: range.head,\n                                        to: other\n                                    };\n                                });\n                            }\n                        }),\n                        findPosV: function (from, amount, unit, goalColumn) {\n                            var dir = 1, x = goalColumn;\n                            if (amount < 0) {\n                                dir = -1;\n                                amount = -amount;\n                            }\n                            var cur = clipPos(this.doc, from);\n                            for (var i = 0; i < amount; ++i) {\n                                var coords = cursorCoords(this, cur, 'div');\n                                if (x == null) {\n                                    x = coords.left;\n                                } else {\n                                    coords.left = x;\n                                }\n                                cur = findPosV(this, coords, dir, unit);\n                                if (cur.hitSide) {\n                                    break;\n                                }\n                            }\n                            return cur;\n                        },\n                        moveV: methodOp(function (dir, unit) {\n                            var this$1 = this;\n                            var doc = this.doc, goals = [];\n                            var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n                            doc.extendSelectionsBy(function (range) {\n                                if (collapse) {\n                                    return dir < 0 ? range.from() : range.to();\n                                }\n                                var headPos = cursorCoords(this$1, range.head, 'div');\n                                if (range.goalColumn != null) {\n                                    headPos.left = range.goalColumn;\n                                }\n                                goals.push(headPos.left);\n                                var pos = findPosV(this$1, headPos, dir, unit);\n                                if (unit == 'page' && range == doc.sel.primary()) {\n                                    addToScrollTop(this$1, charCoords(this$1, pos, 'div').top - headPos.top);\n                                }\n                                return pos;\n                            }, sel_move);\n                            if (goals.length) {\n                                for (var i = 0; i < doc.sel.ranges.length; i++) {\n                                    doc.sel.ranges[i].goalColumn = goals[i];\n                                }\n                            }\n                        }),\n                        findWordAt: function (pos) {\n                            var doc = this.doc, line = getLine(doc, pos.line).text;\n                            var start = pos.ch, end = pos.ch;\n                            if (line) {\n                                var helper = this.getHelper(pos, 'wordChars');\n                                if ((pos.sticky == 'before' || end == line.length) && start) {\n                                    --start;\n                                } else {\n                                    ++end;\n                                }\n                                var startChar = line.charAt(start);\n                                var check = isWordChar(startChar, helper) ? function (ch) {\n                                    return isWordChar(ch, helper);\n                                } : /\\s/.test(startChar) ? function (ch) {\n                                    return /\\s/.test(ch);\n                                } : function (ch) {\n                                    return !/\\s/.test(ch) && !isWordChar(ch);\n                                };\n                                while (start > 0 && check(line.charAt(start - 1))) {\n                                    --start;\n                                }\n                                while (end < line.length && check(line.charAt(end))) {\n                                    ++end;\n                                }\n                            }\n                            return new Range(Pos(pos.line, start), Pos(pos.line, end));\n                        },\n                        toggleOverwrite: function (value) {\n                            if (value != null && value == this.state.overwrite) {\n                                return;\n                            }\n                            if (this.state.overwrite = !this.state.overwrite) {\n                                addClass(this.display.cursorDiv, 'CodeMirror-overwrite');\n                            } else {\n                                rmClass(this.display.cursorDiv, 'CodeMirror-overwrite');\n                            }\n                            signal(this, 'overwriteToggle', this, this.state.overwrite);\n                        },\n                        hasFocus: function () {\n                            return this.display.input.getField() == activeElt(root(this));\n                        },\n                        isReadOnly: function () {\n                            return !!(this.options.readOnly || this.doc.cantEdit);\n                        },\n                        scrollTo: methodOp(function (x, y) {\n                            scrollToCoords(this, x, y);\n                        }),\n                        getScrollInfo: function () {\n                            var scroller = this.display.scroller;\n                            return {\n                                left: scroller.scrollLeft,\n                                top: scroller.scrollTop,\n                                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                                clientHeight: displayHeight(this),\n                                clientWidth: displayWidth(this)\n                            };\n                        },\n                        scrollIntoView: methodOp(function (range, margin) {\n                            if (range == null) {\n                                range = {\n                                    from: this.doc.sel.primary().head,\n                                    to: null\n                                };\n                                if (margin == null) {\n                                    margin = this.options.cursorScrollMargin;\n                                }\n                            } else if (typeof range == 'number') {\n                                range = {\n                                    from: Pos(range, 0),\n                                    to: null\n                                };\n                            } else if (range.from == null) {\n                                range = {\n                                    from: range,\n                                    to: null\n                                };\n                            }\n                            if (!range.to) {\n                                range.to = range.from;\n                            }\n                            range.margin = margin || 0;\n                            if (range.from.line != null) {\n                                scrollToRange(this, range);\n                            } else {\n                                scrollToCoordsRange(this, range.from, range.to, range.margin);\n                            }\n                        }),\n                        setSize: methodOp(function (width, height) {\n                            var this$1 = this;\n                            var interpret = function (val) {\n                                return typeof val == 'number' || /^\\d+$/.test(String(val)) ? val + 'px' : val;\n                            };\n                            if (width != null) {\n                                this.display.wrapper.style.width = interpret(width);\n                            }\n                            if (height != null) {\n                                this.display.wrapper.style.height = interpret(height);\n                            }\n                            if (this.options.lineWrapping) {\n                                clearLineMeasurementCache(this);\n                            }\n                            var lineNo = this.display.viewFrom;\n                            this.doc.iter(lineNo, this.display.viewTo, function (line) {\n                                if (line.widgets) {\n                                    for (var i = 0; i < line.widgets.length; i++) {\n                                        if (line.widgets[i].noHScroll) {\n                                            regLineChange(this$1, lineNo, 'widget');\n                                            break;\n                                        }\n                                    }\n                                }\n                                ++lineNo;\n                            });\n                            this.curOp.forceUpdate = true;\n                            signal(this, 'refresh', this);\n                        }),\n                        operation: function (f) {\n                            return runInOp(this, f);\n                        },\n                        startOperation: function () {\n                            return startOperation(this);\n                        },\n                        endOperation: function () {\n                            return endOperation(this);\n                        },\n                        refresh: methodOp(function () {\n                            var oldHeight = this.display.cachedTextHeight;\n                            regChange(this);\n                            this.curOp.forceUpdate = true;\n                            clearCaches(this);\n                            scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n                            updateGutterSpace(this.display);\n                            if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {\n                                estimateLineHeights(this);\n                            }\n                            signal(this, 'refresh', this);\n                        }),\n                        swapDoc: methodOp(function (doc) {\n                            var old = this.doc;\n                            old.cm = null;\n                            if (this.state.selectingText) {\n                                this.state.selectingText();\n                            }\n                            attachDoc(this, doc);\n                            clearCaches(this);\n                            this.display.input.reset();\n                            scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n                            this.curOp.forceScroll = true;\n                            signalLater(this, 'swapDoc', this, old);\n                            return old;\n                        }),\n                        phrase: function (phraseText) {\n                            var phrases = this.options.phrases;\n                            return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;\n                        },\n                        getInputField: function () {\n                            return this.display.input.getField();\n                        },\n                        getWrapperElement: function () {\n                            return this.display.wrapper;\n                        },\n                        getScrollerElement: function () {\n                            return this.display.scroller;\n                        },\n                        getGutterElement: function () {\n                            return this.display.gutters;\n                        }\n                    };\n                    eventMixin(CodeMirror);\n                    CodeMirror.registerHelper = function (type, name, value) {\n                        if (!helpers.hasOwnProperty(type)) {\n                            helpers[type] = CodeMirror[type] = { _global: [] };\n                        }\n                        helpers[type][name] = value;\n                    };\n                    CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {\n                        CodeMirror.registerHelper(type, name, value);\n                        helpers[type]._global.push({\n                            pred: predicate,\n                            val: value\n                        });\n                    };\n                }\n                function findPosH(doc, pos, dir, unit, visually) {\n                    var oldPos = pos;\n                    var origDir = dir;\n                    var lineObj = getLine(doc, pos.line);\n                    var lineDir = visually && doc.direction == 'rtl' ? -dir : dir;\n                    function findNextLine() {\n                        var l = pos.line + lineDir;\n                        if (l < doc.first || l >= doc.first + doc.size) {\n                            return false;\n                        }\n                        pos = new Pos(l, pos.ch, pos.sticky);\n                        return lineObj = getLine(doc, l);\n                    }\n                    function moveOnce(boundToLine) {\n                        var next;\n                        if (unit == 'codepoint') {\n                            var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));\n                            if (isNaN(ch)) {\n                                next = null;\n                            } else {\n                                var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;\n                                next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);\n                            }\n                        } else if (visually) {\n                            next = moveVisually(doc.cm, lineObj, pos, dir);\n                        } else {\n                            next = moveLogically(lineObj, pos, dir);\n                        }\n                        if (next == null) {\n                            if (!boundToLine && findNextLine()) {\n                                pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);\n                            } else {\n                                return false;\n                            }\n                        } else {\n                            pos = next;\n                        }\n                        return true;\n                    }\n                    if (unit == 'char' || unit == 'codepoint') {\n                        moveOnce();\n                    } else if (unit == 'column') {\n                        moveOnce(true);\n                    } else if (unit == 'word' || unit == 'group') {\n                        var sawType = null, group = unit == 'group';\n                        var helper = doc.cm && doc.cm.getHelper(pos, 'wordChars');\n                        for (var first = true;; first = false) {\n                            if (dir < 0 && !moveOnce(!first)) {\n                                break;\n                            }\n                            var cur = lineObj.text.charAt(pos.ch) || '\\n';\n                            var type = isWordChar(cur, helper) ? 'w' : group && cur == '\\n' ? 'n' : !group || /\\s/.test(cur) ? null : 'p';\n                            if (group && !first && !type) {\n                                type = 's';\n                            }\n                            if (sawType && sawType != type) {\n                                if (dir < 0) {\n                                    dir = 1;\n                                    moveOnce();\n                                    pos.sticky = 'after';\n                                }\n                                break;\n                            }\n                            if (type) {\n                                sawType = type;\n                            }\n                            if (dir > 0 && !moveOnce(!first)) {\n                                break;\n                            }\n                        }\n                    }\n                    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n                    if (equalCursorPos(oldPos, result)) {\n                        result.hitSide = true;\n                    }\n                    return result;\n                }\n                function findPosV(cm, pos, dir, unit) {\n                    var doc = cm.doc, x = pos.left, y;\n                    if (unit == 'page') {\n                        var pageSize = Math.min(cm.display.wrapper.clientHeight, win(cm).innerHeight || doc(cm).documentElement.clientHeight);\n                        var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);\n                        y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n                    } else if (unit == 'line') {\n                        y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n                    }\n                    var target;\n                    for (;;) {\n                        target = coordsChar(cm, x, y);\n                        if (!target.outside) {\n                            break;\n                        }\n                        if (dir < 0 ? y <= 0 : y >= doc.height) {\n                            target.hitSide = true;\n                            break;\n                        }\n                        y += dir * 5;\n                    }\n                    return target;\n                }\n                var ContentEditableInput = function (cm) {\n                    this.cm = cm;\n                    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n                    this.polling = new Delayed();\n                    this.composing = null;\n                    this.gracePeriod = false;\n                    this.readDOMTimeout = null;\n                };\n                ContentEditableInput.prototype.init = function (display) {\n                    var this$1 = this;\n                    var input = this, cm = input.cm;\n                    var div = input.div = display.lineDiv;\n                    div.contentEditable = true;\n                    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n                    function belongsToInput(e) {\n                        for (var t = e.target; t; t = t.parentNode) {\n                            if (t == div) {\n                                return true;\n                            }\n                            if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) {\n                                break;\n                            }\n                        }\n                        return false;\n                    }\n                    on(div, 'paste', function (e) {\n                        if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n                            return;\n                        }\n                        if (ie_version <= 11) {\n                            setTimeout(operation(cm, function () {\n                                return this$1.updateFromDOM();\n                            }), 20);\n                        }\n                    });\n                    on(div, 'compositionstart', function (e) {\n                        this$1.composing = {\n                            data: e.data,\n                            done: false\n                        };\n                    });\n                    on(div, 'compositionupdate', function (e) {\n                        if (!this$1.composing) {\n                            this$1.composing = {\n                                data: e.data,\n                                done: false\n                            };\n                        }\n                    });\n                    on(div, 'compositionend', function (e) {\n                        if (this$1.composing) {\n                            if (e.data != this$1.composing.data) {\n                                this$1.readFromDOMSoon();\n                            }\n                            this$1.composing.done = true;\n                        }\n                    });\n                    on(div, 'touchstart', function () {\n                        return input.forceCompositionEnd();\n                    });\n                    on(div, 'input', function () {\n                        if (!this$1.composing) {\n                            this$1.readFromDOMSoon();\n                        }\n                    });\n                    function onCopyCut(e) {\n                        if (!belongsToInput(e) || signalDOMEvent(cm, e)) {\n                            return;\n                        }\n                        if (cm.somethingSelected()) {\n                            setLastCopied({\n                                lineWise: false,\n                                text: cm.getSelections()\n                            });\n                            if (e.type == 'cut') {\n                                cm.replaceSelection('', null, 'cut');\n                            }\n                        } else if (!cm.options.lineWiseCopyCut) {\n                            return;\n                        } else {\n                            var ranges = copyableRanges(cm);\n                            setLastCopied({\n                                lineWise: true,\n                                text: ranges.text\n                            });\n                            if (e.type == 'cut') {\n                                cm.operation(function () {\n                                    cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n                                    cm.replaceSelection('', null, 'cut');\n                                });\n                            }\n                        }\n                        if (e.clipboardData) {\n                            e.clipboardData.clearData();\n                            var content = lastCopied.text.join('\\n');\n                            e.clipboardData.setData('Text', content);\n                            if (e.clipboardData.getData('Text') == content) {\n                                e.preventDefault();\n                                return;\n                            }\n                        }\n                        var kludge = hiddenTextarea(), te = kludge.firstChild;\n                        disableBrowserMagic(te);\n                        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n                        te.value = lastCopied.text.join('\\n');\n                        var hadFocus = activeElt(rootNode(div));\n                        selectInput(te);\n                        setTimeout(function () {\n                            cm.display.lineSpace.removeChild(kludge);\n                            hadFocus.focus();\n                            if (hadFocus == div) {\n                                input.showPrimarySelection();\n                            }\n                        }, 50);\n                    }\n                    on(div, 'copy', onCopyCut);\n                    on(div, 'cut', onCopyCut);\n                };\n                ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {\n                    if (label) {\n                        this.div.setAttribute('aria-label', label);\n                    } else {\n                        this.div.removeAttribute('aria-label');\n                    }\n                };\n                ContentEditableInput.prototype.prepareSelection = function () {\n                    var result = prepareSelection(this.cm, false);\n                    result.focus = activeElt(rootNode(this.div)) == this.div;\n                    return result;\n                };\n                ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n                    if (!info || !this.cm.display.view.length) {\n                        return;\n                    }\n                    if (info.focus || takeFocus) {\n                        this.showPrimarySelection();\n                    }\n                    this.showMultipleSelections(info);\n                };\n                ContentEditableInput.prototype.getSelection = function () {\n                    return this.cm.display.wrapper.ownerDocument.getSelection();\n                };\n                ContentEditableInput.prototype.showPrimarySelection = function () {\n                    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n                    var from = prim.from(), to = prim.to();\n                    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n                        sel.removeAllRanges();\n                        return;\n                    }\n                    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n                    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n                    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {\n                        return;\n                    }\n                    var view = cm.display.view;\n                    var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {\n                        node: view[0].measure.map[2],\n                        offset: 0\n                    };\n                    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n                    if (!end) {\n                        var measure = view[view.length - 1].measure;\n                        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n                        end = {\n                            node: map[map.length - 1],\n                            offset: map[map.length - 2] - map[map.length - 3]\n                        };\n                    }\n                    if (!start || !end) {\n                        sel.removeAllRanges();\n                        return;\n                    }\n                    var old = sel.rangeCount && sel.getRangeAt(0), rng;\n                    try {\n                        rng = range(start.node, start.offset, end.offset, end.node);\n                    } catch (e) {\n                    }\n                    if (rng) {\n                        if (!gecko && cm.state.focused) {\n                            sel.collapse(start.node, start.offset);\n                            if (!rng.collapsed) {\n                                sel.removeAllRanges();\n                                sel.addRange(rng);\n                            }\n                        } else {\n                            sel.removeAllRanges();\n                            sel.addRange(rng);\n                        }\n                        if (old && sel.anchorNode == null) {\n                            sel.addRange(old);\n                        } else if (gecko) {\n                            this.startGracePeriod();\n                        }\n                    }\n                    this.rememberSelection();\n                };\n                ContentEditableInput.prototype.startGracePeriod = function () {\n                    var this$1 = this;\n                    clearTimeout(this.gracePeriod);\n                    this.gracePeriod = setTimeout(function () {\n                        this$1.gracePeriod = false;\n                        if (this$1.selectionChanged()) {\n                            this$1.cm.operation(function () {\n                                return this$1.cm.curOp.selectionChanged = true;\n                            });\n                        }\n                    }, 20);\n                };\n                ContentEditableInput.prototype.showMultipleSelections = function (info) {\n                    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n                    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n                };\n                ContentEditableInput.prototype.rememberSelection = function () {\n                    var sel = this.getSelection();\n                    this.lastAnchorNode = sel.anchorNode;\n                    this.lastAnchorOffset = sel.anchorOffset;\n                    this.lastFocusNode = sel.focusNode;\n                    this.lastFocusOffset = sel.focusOffset;\n                };\n                ContentEditableInput.prototype.selectionInEditor = function () {\n                    var sel = this.getSelection();\n                    if (!sel.rangeCount) {\n                        return false;\n                    }\n                    var node = sel.getRangeAt(0).commonAncestorContainer;\n                    return contains(this.div, node);\n                };\n                ContentEditableInput.prototype.focus = function () {\n                    if (this.cm.options.readOnly != 'nocursor') {\n                        if (!this.selectionInEditor() || activeElt(rootNode(this.div)) != this.div) {\n                            this.showSelection(this.prepareSelection(), true);\n                        }\n                        this.div.focus();\n                    }\n                };\n                ContentEditableInput.prototype.blur = function () {\n                    this.div.blur();\n                };\n                ContentEditableInput.prototype.getField = function () {\n                    return this.div;\n                };\n                ContentEditableInput.prototype.supportsTouch = function () {\n                    return true;\n                };\n                ContentEditableInput.prototype.receivedFocus = function () {\n                    var this$1 = this;\n                    var input = this;\n                    if (this.selectionInEditor()) {\n                        setTimeout(function () {\n                            return this$1.pollSelection();\n                        }, 20);\n                    } else {\n                        runInOp(this.cm, function () {\n                            return input.cm.curOp.selectionChanged = true;\n                        });\n                    }\n                    function poll() {\n                        if (input.cm.state.focused) {\n                            input.pollSelection();\n                            input.polling.set(input.cm.options.pollInterval, poll);\n                        }\n                    }\n                    this.polling.set(this.cm.options.pollInterval, poll);\n                };\n                ContentEditableInput.prototype.selectionChanged = function () {\n                    var sel = this.getSelection();\n                    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n                };\n                ContentEditableInput.prototype.pollSelection = function () {\n                    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {\n                        return;\n                    }\n                    var sel = this.getSelection(), cm = this.cm;\n                    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n                        this.cm.triggerOnKeyDown({\n                            type: 'keydown',\n                            keyCode: 8,\n                            preventDefault: Math.abs\n                        });\n                        this.blur();\n                        this.focus();\n                        return;\n                    }\n                    if (this.composing) {\n                        return;\n                    }\n                    this.rememberSelection();\n                    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n                    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n                    if (anchor && head) {\n                        runInOp(cm, function () {\n                            setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n                            if (anchor.bad || head.bad) {\n                                cm.curOp.selectionChanged = true;\n                            }\n                        });\n                    }\n                };\n                ContentEditableInput.prototype.pollContent = function () {\n                    if (this.readDOMTimeout != null) {\n                        clearTimeout(this.readDOMTimeout);\n                        this.readDOMTimeout = null;\n                    }\n                    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n                    var from = sel.from(), to = sel.to();\n                    if (from.ch == 0 && from.line > cm.firstLine()) {\n                        from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);\n                    }\n                    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {\n                        to = Pos(to.line + 1, 0);\n                    }\n                    if (from.line < display.viewFrom || to.line > display.viewTo - 1) {\n                        return false;\n                    }\n                    var fromIndex, fromLine, fromNode;\n                    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n                        fromLine = lineNo(display.view[0].line);\n                        fromNode = display.view[0].node;\n                    } else {\n                        fromLine = lineNo(display.view[fromIndex].line);\n                        fromNode = display.view[fromIndex - 1].node.nextSibling;\n                    }\n                    var toIndex = findViewIndex(cm, to.line);\n                    var toLine, toNode;\n                    if (toIndex == display.view.length - 1) {\n                        toLine = display.viewTo - 1;\n                        toNode = display.lineDiv.lastChild;\n                    } else {\n                        toLine = lineNo(display.view[toIndex + 1].line) - 1;\n                        toNode = display.view[toIndex + 1].node.previousSibling;\n                    }\n                    if (!fromNode) {\n                        return false;\n                    }\n                    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n                    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n                    while (newText.length > 1 && oldText.length > 1) {\n                        if (lst(newText) == lst(oldText)) {\n                            newText.pop();\n                            oldText.pop();\n                            toLine--;\n                        } else if (newText[0] == oldText[0]) {\n                            newText.shift();\n                            oldText.shift();\n                            fromLine++;\n                        } else {\n                            break;\n                        }\n                    }\n                    var cutFront = 0, cutEnd = 0;\n                    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n                    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {\n                        ++cutFront;\n                    }\n                    var newBot = lst(newText), oldBot = lst(oldText);\n                    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));\n                    while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n                        ++cutEnd;\n                    }\n                    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n                        while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n                            cutFront--;\n                            cutEnd++;\n                        }\n                    }\n                    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, '');\n                    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, '');\n                    var chFrom = Pos(fromLine, cutFront);\n                    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n                    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n                        replaceRange(cm.doc, newText, chFrom, chTo, '+input');\n                        return true;\n                    }\n                };\n                ContentEditableInput.prototype.ensurePolled = function () {\n                    this.forceCompositionEnd();\n                };\n                ContentEditableInput.prototype.reset = function () {\n                    this.forceCompositionEnd();\n                };\n                ContentEditableInput.prototype.forceCompositionEnd = function () {\n                    if (!this.composing) {\n                        return;\n                    }\n                    clearTimeout(this.readDOMTimeout);\n                    this.composing = null;\n                    this.updateFromDOM();\n                    this.div.blur();\n                    this.div.focus();\n                };\n                ContentEditableInput.prototype.readFromDOMSoon = function () {\n                    var this$1 = this;\n                    if (this.readDOMTimeout != null) {\n                        return;\n                    }\n                    this.readDOMTimeout = setTimeout(function () {\n                        this$1.readDOMTimeout = null;\n                        if (this$1.composing) {\n                            if (this$1.composing.done) {\n                                this$1.composing = null;\n                            } else {\n                                return;\n                            }\n                        }\n                        this$1.updateFromDOM();\n                    }, 80);\n                };\n                ContentEditableInput.prototype.updateFromDOM = function () {\n                    var this$1 = this;\n                    if (this.cm.isReadOnly() || !this.pollContent()) {\n                        runInOp(this.cm, function () {\n                            return regChange(this$1.cm);\n                        });\n                    }\n                };\n                ContentEditableInput.prototype.setUneditable = function (node) {\n                    node.contentEditable = 'false';\n                };\n                ContentEditableInput.prototype.onKeyPress = function (e) {\n                    if (e.charCode == 0 || this.composing) {\n                        return;\n                    }\n                    e.preventDefault();\n                    if (!this.cm.isReadOnly()) {\n                        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n                    }\n                };\n                ContentEditableInput.prototype.readOnlyChanged = function (val) {\n                    this.div.contentEditable = String(val != 'nocursor');\n                };\n                ContentEditableInput.prototype.onContextMenu = function () {\n                };\n                ContentEditableInput.prototype.resetPosition = function () {\n                };\n                ContentEditableInput.prototype.needsContentAttribute = true;\n                function posToDOM(cm, pos) {\n                    var view = findViewForLine(cm, pos.line);\n                    if (!view || view.hidden) {\n                        return null;\n                    }\n                    var line = getLine(cm.doc, pos.line);\n                    var info = mapFromLineView(view, line, pos.line);\n                    var order = getOrder(line, cm.doc.direction), side = 'left';\n                    if (order) {\n                        var partPos = getBidiPartAt(order, pos.ch);\n                        side = partPos % 2 ? 'right' : 'left';\n                    }\n                    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n                    result.offset = result.collapse == 'right' ? result.end : result.start;\n                    return result;\n                }\n                function isInGutter(node) {\n                    for (var scan = node; scan; scan = scan.parentNode) {\n                        if (/CodeMirror-gutter-wrapper/.test(scan.className)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n                function badPos(pos, bad) {\n                    if (bad) {\n                        pos.bad = true;\n                    }\n                    return pos;\n                }\n                function domTextBetween(cm, from, to, fromLine, toLine) {\n                    var text = '', closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n                    function recognizeMarker(id) {\n                        return function (marker) {\n                            return marker.id == id;\n                        };\n                    }\n                    function close() {\n                        if (closing) {\n                            text += lineSep;\n                            if (extraLinebreak) {\n                                text += lineSep;\n                            }\n                            closing = extraLinebreak = false;\n                        }\n                    }\n                    function addText(str) {\n                        if (str) {\n                            close();\n                            text += str;\n                        }\n                    }\n                    function walk(node) {\n                        if (node.nodeType == 1) {\n                            var cmText = node.getAttribute('cm-text');\n                            if (cmText) {\n                                addText(cmText);\n                                return;\n                            }\n                            var markerID = node.getAttribute('cm-marker'), range;\n                            if (markerID) {\n                                var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n                                if (found.length && (range = found[0].find(0))) {\n                                    addText(getBetween(cm.doc, range.from, range.to).join(lineSep));\n                                }\n                                return;\n                            }\n                            if (node.getAttribute('contenteditable') == 'false') {\n                                return;\n                            }\n                            var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n                            if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {\n                                return;\n                            }\n                            if (isBlock) {\n                                close();\n                            }\n                            for (var i = 0; i < node.childNodes.length; i++) {\n                                walk(node.childNodes[i]);\n                            }\n                            if (/^(pre|p)$/i.test(node.nodeName)) {\n                                extraLinebreak = true;\n                            }\n                            if (isBlock) {\n                                closing = true;\n                            }\n                        } else if (node.nodeType == 3) {\n                            addText(node.nodeValue.replace(/\\u200b/g, '').replace(/\\u00a0/g, ' '));\n                        }\n                    }\n                    for (;;) {\n                        walk(from);\n                        if (from == to) {\n                            break;\n                        }\n                        from = from.nextSibling;\n                        extraLinebreak = false;\n                    }\n                    return text;\n                }\n                function domToPos(cm, node, offset) {\n                    var lineNode;\n                    if (node == cm.display.lineDiv) {\n                        lineNode = cm.display.lineDiv.childNodes[offset];\n                        if (!lineNode) {\n                            return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n                        }\n                        node = null;\n                        offset = 0;\n                    } else {\n                        for (lineNode = node;; lineNode = lineNode.parentNode) {\n                            if (!lineNode || lineNode == cm.display.lineDiv) {\n                                return null;\n                            }\n                            if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {\n                                break;\n                            }\n                        }\n                    }\n                    for (var i = 0; i < cm.display.view.length; i++) {\n                        var lineView = cm.display.view[i];\n                        if (lineView.node == lineNode) {\n                            return locateNodeInLineView(lineView, node, offset);\n                        }\n                    }\n                }\n                function locateNodeInLineView(lineView, node, offset) {\n                    var wrapper = lineView.text.firstChild, bad = false;\n                    if (!node || !contains(wrapper, node)) {\n                        return badPos(Pos(lineNo(lineView.line), 0), true);\n                    }\n                    if (node == wrapper) {\n                        bad = true;\n                        node = wrapper.childNodes[offset];\n                        offset = 0;\n                        if (!node) {\n                            var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n                            return badPos(Pos(lineNo(line), line.text.length), bad);\n                        }\n                    }\n                    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n                    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n                        textNode = node.firstChild;\n                        if (offset) {\n                            offset = textNode.nodeValue.length;\n                        }\n                    }\n                    while (topNode.parentNode != wrapper) {\n                        topNode = topNode.parentNode;\n                    }\n                    var measure = lineView.measure, maps = measure.maps;\n                    function find(textNode, topNode, offset) {\n                        for (var i = -1; i < (maps ? maps.length : 0); i++) {\n                            var map = i < 0 ? measure.map : maps[i];\n                            for (var j = 0; j < map.length; j += 3) {\n                                var curNode = map[j + 2];\n                                if (curNode == textNode || curNode == topNode) {\n                                    var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n                                    var ch = map[j] + offset;\n                                    if (offset < 0 || curNode != textNode) {\n                                        ch = map[j + (offset ? 1 : 0)];\n                                    }\n                                    return Pos(line, ch);\n                                }\n                            }\n                        }\n                    }\n                    var found = find(textNode, topNode, offset);\n                    if (found) {\n                        return badPos(found, bad);\n                    }\n                    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n                        found = find(after, after.firstChild, 0);\n                        if (found) {\n                            return badPos(Pos(found.line, found.ch - dist), bad);\n                        } else {\n                            dist += after.textContent.length;\n                        }\n                    }\n                    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n                        found = find(before, before.firstChild, -1);\n                        if (found) {\n                            return badPos(Pos(found.line, found.ch + dist$1), bad);\n                        } else {\n                            dist$1 += before.textContent.length;\n                        }\n                    }\n                }\n                var TextareaInput = function (cm) {\n                    this.cm = cm;\n                    this.prevInput = '';\n                    this.pollingFast = false;\n                    this.polling = new Delayed();\n                    this.hasSelection = false;\n                    this.composing = null;\n                    this.resetting = false;\n                };\n                TextareaInput.prototype.init = function (display) {\n                    var this$1 = this;\n                    var input = this, cm = this.cm;\n                    this.createField(display);\n                    var te = this.textarea;\n                    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n                    if (ios) {\n                        te.style.width = '0px';\n                    }\n                    on(te, 'input', function () {\n                        if (ie && ie_version >= 9 && this$1.hasSelection) {\n                            this$1.hasSelection = null;\n                        }\n                        input.poll();\n                    });\n                    on(te, 'paste', function (e) {\n                        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n                            return;\n                        }\n                        cm.state.pasteIncoming = +new Date();\n                        input.fastPoll();\n                    });\n                    function prepareCopyCut(e) {\n                        if (signalDOMEvent(cm, e)) {\n                            return;\n                        }\n                        if (cm.somethingSelected()) {\n                            setLastCopied({\n                                lineWise: false,\n                                text: cm.getSelections()\n                            });\n                        } else if (!cm.options.lineWiseCopyCut) {\n                            return;\n                        } else {\n                            var ranges = copyableRanges(cm);\n                            setLastCopied({\n                                lineWise: true,\n                                text: ranges.text\n                            });\n                            if (e.type == 'cut') {\n                                cm.setSelections(ranges.ranges, null, sel_dontScroll);\n                            } else {\n                                input.prevInput = '';\n                                te.value = ranges.text.join('\\n');\n                                selectInput(te);\n                            }\n                        }\n                        if (e.type == 'cut') {\n                            cm.state.cutIncoming = +new Date();\n                        }\n                    }\n                    on(te, 'cut', prepareCopyCut);\n                    on(te, 'copy', prepareCopyCut);\n                    on(display.scroller, 'paste', function (e) {\n                        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {\n                            return;\n                        }\n                        if (!te.dispatchEvent) {\n                            cm.state.pasteIncoming = +new Date();\n                            input.focus();\n                            return;\n                        }\n                        var event = new Event('paste');\n                        event.clipboardData = e.clipboardData;\n                        te.dispatchEvent(event);\n                    });\n                    on(display.lineSpace, 'selectstart', function (e) {\n                        if (!eventInWidget(display, e)) {\n                            e_preventDefault(e);\n                        }\n                    });\n                    on(te, 'compositionstart', function () {\n                        var start = cm.getCursor('from');\n                        if (input.composing) {\n                            input.composing.range.clear();\n                        }\n                        input.composing = {\n                            start: start,\n                            range: cm.markText(start, cm.getCursor('to'), { className: 'CodeMirror-composing' })\n                        };\n                    });\n                    on(te, 'compositionend', function () {\n                        if (input.composing) {\n                            input.poll();\n                            input.composing.range.clear();\n                            input.composing = null;\n                        }\n                    });\n                };\n                TextareaInput.prototype.createField = function (_display) {\n                    this.wrapper = hiddenTextarea();\n                    this.textarea = this.wrapper.firstChild;\n                    var opts = this.cm.options;\n                    disableBrowserMagic(this.textarea, opts.spellcheck, opts.autocorrect, opts.autocapitalize);\n                };\n                TextareaInput.prototype.screenReaderLabelChanged = function (label) {\n                    if (label) {\n                        this.textarea.setAttribute('aria-label', label);\n                    } else {\n                        this.textarea.removeAttribute('aria-label');\n                    }\n                };\n                TextareaInput.prototype.prepareSelection = function () {\n                    var cm = this.cm, display = cm.display, doc = cm.doc;\n                    var result = prepareSelection(cm);\n                    if (cm.options.moveInputWithCursor) {\n                        var headPos = cursorCoords(cm, doc.sel.primary().head, 'div');\n                        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n                        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));\n                        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));\n                    }\n                    return result;\n                };\n                TextareaInput.prototype.showSelection = function (drawn) {\n                    var cm = this.cm, display = cm.display;\n                    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n                    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n                    if (drawn.teTop != null) {\n                        this.wrapper.style.top = drawn.teTop + 'px';\n                        this.wrapper.style.left = drawn.teLeft + 'px';\n                    }\n                };\n                TextareaInput.prototype.reset = function (typing) {\n                    if (this.contextMenuPending || this.composing && typing) {\n                        return;\n                    }\n                    var cm = this.cm;\n                    this.resetting = true;\n                    if (cm.somethingSelected()) {\n                        this.prevInput = '';\n                        var content = cm.getSelection();\n                        this.textarea.value = content;\n                        if (cm.state.focused) {\n                            selectInput(this.textarea);\n                        }\n                        if (ie && ie_version >= 9) {\n                            this.hasSelection = content;\n                        }\n                    } else if (!typing) {\n                        this.prevInput = this.textarea.value = '';\n                        if (ie && ie_version >= 9) {\n                            this.hasSelection = null;\n                        }\n                    }\n                    this.resetting = false;\n                };\n                TextareaInput.prototype.getField = function () {\n                    return this.textarea;\n                };\n                TextareaInput.prototype.supportsTouch = function () {\n                    return false;\n                };\n                TextareaInput.prototype.focus = function () {\n                    if (this.cm.options.readOnly != 'nocursor' && (!mobile || activeElt(rootNode(this.textarea)) != this.textarea)) {\n                        try {\n                            this.textarea.focus();\n                        } catch (e) {\n                        }\n                    }\n                };\n                TextareaInput.prototype.blur = function () {\n                    this.textarea.blur();\n                };\n                TextareaInput.prototype.resetPosition = function () {\n                    this.wrapper.style.top = this.wrapper.style.left = 0;\n                };\n                TextareaInput.prototype.receivedFocus = function () {\n                    this.slowPoll();\n                };\n                TextareaInput.prototype.slowPoll = function () {\n                    var this$1 = this;\n                    if (this.pollingFast) {\n                        return;\n                    }\n                    this.polling.set(this.cm.options.pollInterval, function () {\n                        this$1.poll();\n                        if (this$1.cm.state.focused) {\n                            this$1.slowPoll();\n                        }\n                    });\n                };\n                TextareaInput.prototype.fastPoll = function () {\n                    var missed = false, input = this;\n                    input.pollingFast = true;\n                    function p() {\n                        var changed = input.poll();\n                        if (!changed && !missed) {\n                            missed = true;\n                            input.polling.set(60, p);\n                        } else {\n                            input.pollingFast = false;\n                            input.slowPoll();\n                        }\n                    }\n                    input.polling.set(20, p);\n                };\n                TextareaInput.prototype.poll = function () {\n                    var this$1 = this;\n                    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n                    if (this.contextMenuPending || this.resetting || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {\n                        return false;\n                    }\n                    var text = input.value;\n                    if (text == prevInput && !cm.somethingSelected()) {\n                        return false;\n                    }\n                    if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\\uf700-\\uf7ff]/.test(text)) {\n                        cm.display.input.reset();\n                        return false;\n                    }\n                    if (cm.doc.sel == cm.display.selForContextMenu) {\n                        var first = text.charCodeAt(0);\n                        if (first == 8203 && !prevInput) {\n                            prevInput = '\\u200B';\n                        }\n                        if (first == 8666) {\n                            this.reset();\n                            return this.cm.execCommand('undo');\n                        }\n                    }\n                    var same = 0, l = Math.min(prevInput.length, text.length);\n                    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {\n                        ++same;\n                    }\n                    runInOp(cm, function () {\n                        applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? '*compose' : null);\n                        if (text.length > 1000 || text.indexOf('\\n') > -1) {\n                            input.value = this$1.prevInput = '';\n                        } else {\n                            this$1.prevInput = text;\n                        }\n                        if (this$1.composing) {\n                            this$1.composing.range.clear();\n                            this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor('to'), { className: 'CodeMirror-composing' });\n                        }\n                    });\n                    return true;\n                };\n                TextareaInput.prototype.ensurePolled = function () {\n                    if (this.pollingFast && this.poll()) {\n                        this.pollingFast = false;\n                    }\n                };\n                TextareaInput.prototype.onKeyPress = function () {\n                    if (ie && ie_version >= 9) {\n                        this.hasSelection = null;\n                    }\n                    this.fastPoll();\n                };\n                TextareaInput.prototype.onContextMenu = function (e) {\n                    var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n                    if (input.contextMenuPending) {\n                        input.contextMenuPending();\n                    }\n                    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n                    if (!pos || presto) {\n                        return;\n                    }\n                    var reset = cm.options.resetSelectionOnContextMenu;\n                    if (reset && cm.doc.sel.contains(pos) == -1) {\n                        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n                    }\n                    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n                    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n                    input.wrapper.style.cssText = 'position: static';\n                    te.style.cssText = 'position: absolute; width: 30px; height: 30px;\\n      top: ' + (e.clientY - wrapperBox.top - 5) + 'px; left: ' + (e.clientX - wrapperBox.left - 5) + 'px;\\n      z-index: 1000; background: ' + (ie ? 'rgba(255, 255, 255, .05)' : 'transparent') + ';\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);';\n                    var oldScrollY;\n                    if (webkit) {\n                        oldScrollY = te.ownerDocument.defaultView.scrollY;\n                    }\n                    display.input.focus();\n                    if (webkit) {\n                        te.ownerDocument.defaultView.scrollTo(null, oldScrollY);\n                    }\n                    display.input.reset();\n                    if (!cm.somethingSelected()) {\n                        te.value = input.prevInput = ' ';\n                    }\n                    input.contextMenuPending = rehide;\n                    display.selForContextMenu = cm.doc.sel;\n                    clearTimeout(display.detectingSelectAll);\n                    function prepareSelectAllHack() {\n                        if (te.selectionStart != null) {\n                            var selected = cm.somethingSelected();\n                            var extval = '\\u200B' + (selected ? te.value : '');\n                            te.value = '\\u21DA';\n                            te.value = extval;\n                            input.prevInput = selected ? '' : '\\u200B';\n                            te.selectionStart = 1;\n                            te.selectionEnd = extval.length;\n                            display.selForContextMenu = cm.doc.sel;\n                        }\n                    }\n                    function rehide() {\n                        if (input.contextMenuPending != rehide) {\n                            return;\n                        }\n                        input.contextMenuPending = false;\n                        input.wrapper.style.cssText = oldWrapperCSS;\n                        te.style.cssText = oldCSS;\n                        if (ie && ie_version < 9) {\n                            display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n                        }\n                        if (te.selectionStart != null) {\n                            if (!ie || ie && ie_version < 9) {\n                                prepareSelectAllHack();\n                            }\n                            var i = 0, poll = function () {\n                                    if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == '\\u200B') {\n                                        operation(cm, selectAll)(cm);\n                                    } else if (i++ < 10) {\n                                        display.detectingSelectAll = setTimeout(poll, 500);\n                                    } else {\n                                        display.selForContextMenu = null;\n                                        display.input.reset();\n                                    }\n                                };\n                            display.detectingSelectAll = setTimeout(poll, 200);\n                        }\n                    }\n                    if (ie && ie_version >= 9) {\n                        prepareSelectAllHack();\n                    }\n                    if (captureRightClick) {\n                        e_stop(e);\n                        var mouseup = function () {\n                            off(window, 'mouseup', mouseup);\n                            setTimeout(rehide, 20);\n                        };\n                        on(window, 'mouseup', mouseup);\n                    } else {\n                        setTimeout(rehide, 50);\n                    }\n                };\n                TextareaInput.prototype.readOnlyChanged = function (val) {\n                    if (!val) {\n                        this.reset();\n                    }\n                    this.textarea.disabled = val == 'nocursor';\n                    this.textarea.readOnly = !!val;\n                };\n                TextareaInput.prototype.setUneditable = function () {\n                };\n                TextareaInput.prototype.needsContentAttribute = false;\n                function fromTextArea(textarea, options) {\n                    options = options ? copyObj(options) : {};\n                    options.value = textarea.value;\n                    if (!options.tabindex && textarea.tabIndex) {\n                        options.tabindex = textarea.tabIndex;\n                    }\n                    if (!options.placeholder && textarea.placeholder) {\n                        options.placeholder = textarea.placeholder;\n                    }\n                    if (options.autofocus == null) {\n                        var hasFocus = activeElt(rootNode(textarea));\n                        options.autofocus = hasFocus == textarea || textarea.getAttribute('autofocus') != null && hasFocus == document.body;\n                    }\n                    function save() {\n                        textarea.value = cm.getValue();\n                    }\n                    var realSubmit;\n                    if (textarea.form) {\n                        on(textarea.form, 'submit', save);\n                        if (!options.leaveSubmitMethodAlone) {\n                            var form = textarea.form;\n                            realSubmit = form.submit;\n                            try {\n                                var wrappedSubmit = form.submit = function () {\n                                    save();\n                                    form.submit = realSubmit;\n                                    form.submit();\n                                    form.submit = wrappedSubmit;\n                                };\n                            } catch (e) {\n                            }\n                        }\n                    }\n                    options.finishInit = function (cm) {\n                        cm.save = save;\n                        cm.getTextArea = function () {\n                            return textarea;\n                        };\n                        cm.toTextArea = function () {\n                            cm.toTextArea = isNaN;\n                            save();\n                            textarea.parentNode.removeChild(cm.getWrapperElement());\n                            textarea.style.display = '';\n                            if (textarea.form) {\n                                off(textarea.form, 'submit', save);\n                                if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == 'function') {\n                                    textarea.form.submit = realSubmit;\n                                }\n                            }\n                        };\n                    };\n                    textarea.style.display = 'none';\n                    var cm = CodeMirror(function (node) {\n                        return textarea.parentNode.insertBefore(node, textarea.nextSibling);\n                    }, options);\n                    return cm;\n                }\n                function addLegacyProps(CodeMirror) {\n                    CodeMirror.off = off;\n                    CodeMirror.on = on;\n                    CodeMirror.wheelEventPixels = wheelEventPixels;\n                    CodeMirror.Doc = Doc;\n                    CodeMirror.splitLines = splitLinesAuto;\n                    CodeMirror.countColumn = countColumn;\n                    CodeMirror.findColumn = findColumn;\n                    CodeMirror.isWordChar = isWordCharBasic;\n                    CodeMirror.Pass = Pass;\n                    CodeMirror.signal = signal;\n                    CodeMirror.Line = Line;\n                    CodeMirror.changeEnd = changeEnd;\n                    CodeMirror.scrollbarModel = scrollbarModel;\n                    CodeMirror.Pos = Pos;\n                    CodeMirror.cmpPos = cmp;\n                    CodeMirror.modes = modes;\n                    CodeMirror.mimeModes = mimeModes;\n                    CodeMirror.resolveMode = resolveMode;\n                    CodeMirror.getMode = getMode;\n                    CodeMirror.modeExtensions = modeExtensions;\n                    CodeMirror.extendMode = extendMode;\n                    CodeMirror.copyState = copyState;\n                    CodeMirror.startState = startState;\n                    CodeMirror.innerMode = innerMode;\n                    CodeMirror.commands = commands;\n                    CodeMirror.keyMap = keyMap;\n                    CodeMirror.keyName = keyName;\n                    CodeMirror.isModifierKey = isModifierKey;\n                    CodeMirror.lookupKey = lookupKey;\n                    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n                    CodeMirror.StringStream = StringStream;\n                    CodeMirror.SharedTextMarker = SharedTextMarker;\n                    CodeMirror.TextMarker = TextMarker;\n                    CodeMirror.LineWidget = LineWidget;\n                    CodeMirror.e_preventDefault = e_preventDefault;\n                    CodeMirror.e_stopPropagation = e_stopPropagation;\n                    CodeMirror.e_stop = e_stop;\n                    CodeMirror.addClass = addClass;\n                    CodeMirror.contains = contains;\n                    CodeMirror.rmClass = rmClass;\n                    CodeMirror.keyNames = keyNames;\n                }\n                defineOptions(CodeMirror);\n                addEditorMethods(CodeMirror);\n                var dontDelegate = 'iter insert remove copy getEditor constructor'.split(' ');\n                for (var prop in Doc.prototype) {\n                    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {\n                        CodeMirror.prototype[prop] = function (method) {\n                            return function () {\n                                return method.apply(this.doc, arguments);\n                            };\n                        }(Doc.prototype[prop]);\n                    }\n                }\n                eventMixin(Doc);\n                CodeMirror.inputStyles = {\n                    'textarea': TextareaInput,\n                    'contenteditable': ContentEditableInput\n                };\n                CodeMirror.defineMode = function (name) {\n                    if (!CodeMirror.defaults.mode && name != 'null') {\n                        CodeMirror.defaults.mode = name;\n                    }\n                    defineMode.apply(this, arguments);\n                };\n                CodeMirror.defineMIME = defineMIME;\n                CodeMirror.defineMode('null', function () {\n                    return {\n                        token: function (stream) {\n                            return stream.skipToEnd();\n                        }\n                    };\n                });\n                CodeMirror.defineMIME('text/plain', 'null');\n                CodeMirror.defineExtension = function (name, func) {\n                    CodeMirror.prototype[name] = func;\n                };\n                CodeMirror.defineDocExtension = function (name, func) {\n                    Doc.prototype[name] = func;\n                };\n                CodeMirror.fromTextArea = fromTextArea;\n                addLegacyProps(CodeMirror);\n                CodeMirror.version = '5.65.16';\n                return CodeMirror;\n            }));\n        },\n        {}\n    ]\n}, {}, [1]);","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * Copyright (c) Forward Email LLC\n * SPDX-License-Identifier: BUSL-1.1\n */\n\nconst $ = require(131);\nconst CodeMirror = require(79);\n\n// editing addons\nrequire(60);\nrequire(61);\nrequire(62);\nrequire(63);\nrequire(64);\nrequire(65);\n\n// code hinting addons\nrequire(67);\nrequire(68);\nrequire(69);\nrequire(70);\nrequire(71);\n\n// code linting addons\nrequire(77);\nrequire(74); // requires htmlhint\nrequire(73);\nrequire(75);\nrequire(76);\n\n// code selection active line\nrequire(78);\n\n// code modes\nrequire(82);\nrequire(80);\nrequire(81);\n\nconst debounce = require(5);\n\nconst $preview = $('#custom-verification-preview');\nconst $editor = $('#textarea-custom-verification-html');\nconst cm = CodeMirror.fromTextArea($editor.get(0), {\n  theme: 'material',\n  mode: 'htmlmixed',\n  lineNumbers: true,\n  lineWrapping: true,\n  spellcheck: true,\n  autocorrect: true,\n  showTrailingSpace: true,\n  styleActiveLine: true,\n  continueComments: true,\n  autoRefresh: true,\n  readOnly: window.IS_CUSTOM_VERIFICATION_DISABLED === true,\n  lint: true,\n  gutters: ['CodeMirror-lint-markers']\n});\n\nfunction change() {\n  const val = cm.getValue();\n  $preview.contents().find('html').html(val);\n}\n\nchange();\n\ncm.on('change', debounce(change, 300));\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79), require(83), require(82), require(80));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../javascript/javascript\", \"../css/css\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var defaultTags = {\n    script: [\n      [\"lang\", /(javascript|babel)/i, \"javascript\"],\n      [\"type\", /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, \"javascript\"],\n      [\"type\", /./, \"text/plain\"],\n      [null, null, \"javascript\"]\n    ],\n    style:  [\n      [\"lang\", /^css$/i, \"css\"],\n      [\"type\", /^(text\\/)?(x-)?(stylesheet|css)$/i, \"css\"],\n      [\"type\", /./, \"text/plain\"],\n      [null, null, \"css\"]\n    ]\n  };\n\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current(), close = cur.search(pat);\n    if (close > -1) {\n      stream.backUp(cur.length - close);\n    } else if (cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur);\n    }\n    return style;\n  }\n\n  var attrRegexpCache = {};\n  function getAttrRegexp(attr) {\n    var regexp = attrRegexpCache[attr];\n    if (regexp) return regexp;\n    return attrRegexpCache[attr] = new RegExp(\"\\\\s+\" + attr + \"\\\\s*=\\\\s*('|\\\")?([^'\\\"]+)('|\\\")?\\\\s*\");\n  }\n\n  function getAttrValue(text, attr) {\n    var match = text.match(getAttrRegexp(attr))\n    return match ? /^\\s*(.*?)\\s*$/.exec(match[2])[1] : \"\"\n  }\n\n  function getTagRegexp(tagName, anchored) {\n    return new RegExp((anchored ? \"^\" : \"\") + \"<\\/\\\\s*\" + tagName + \"\\\\s*>\", \"i\");\n  }\n\n  function addTags(from, to) {\n    for (var tag in from) {\n      var dest = to[tag] || (to[tag] = []);\n      var source = from[tag];\n      for (var i = source.length - 1; i >= 0; i--)\n        dest.unshift(source[i])\n    }\n  }\n\n  function findMatchingMode(tagInfo, tagText) {\n    for (var i = 0; i < tagInfo.length; i++) {\n      var spec = tagInfo[i];\n      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];\n    }\n  }\n\n  CodeMirror.defineMode(\"htmlmixed\", function (config, parserConfig) {\n    var htmlMode = CodeMirror.getMode(config, {\n      name: \"xml\",\n      htmlMode: true,\n      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,\n      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag,\n      allowMissingTagName: parserConfig.allowMissingTagName,\n    });\n\n    var tags = {};\n    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;\n    addTags(defaultTags, tags);\n    if (configTags) addTags(configTags, tags);\n    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)\n      tags.script.unshift([\"type\", configScript[i].matches, configScript[i].mode])\n\n    function html(stream, state) {\n      var style = htmlMode.token(stream, state.htmlState), tag = /\\btag\\b/.test(style), tagName\n      if (tag && !/[<>\\s\\/]/.test(stream.current()) &&\n          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&\n          tags.hasOwnProperty(tagName)) {\n        state.inTag = tagName + \" \"\n      } else if (state.inTag && tag && />$/.test(stream.current())) {\n        var inTag = /^([\\S]+) (.*)/.exec(state.inTag)\n        state.inTag = null\n        var modeSpec = stream.current() == \">\" && findMatchingMode(tags[inTag[1]], inTag[2])\n        var mode = CodeMirror.getMode(config, modeSpec)\n        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);\n        state.token = function (stream, state) {\n          if (stream.match(endTagA, false)) {\n            state.token = html;\n            state.localState = state.localMode = null;\n            return null;\n          }\n          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));\n        };\n        state.localMode = mode;\n        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, \"\", \"\"));\n      } else if (state.inTag) {\n        state.inTag += stream.current()\n        if (stream.eol()) state.inTag += \" \"\n      }\n      return style;\n    };\n\n    return {\n      startState: function () {\n        var state = CodeMirror.startState(htmlMode);\n        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};\n      },\n\n      copyState: function (state) {\n        var local;\n        if (state.localState) {\n          local = CodeMirror.copyState(state.localMode, state.localState);\n        }\n        return {token: state.token, inTag: state.inTag,\n                localMode: state.localMode, localState: local,\n                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n      },\n\n      token: function (stream, state) {\n        return state.token(stream, state);\n      },\n\n      indent: function (state, textAfter, line) {\n        if (!state.localMode || /^\\s*<\\//.test(textAfter))\n          return htmlMode.indent(state.htmlState, textAfter, line);\n        else if (state.localMode.indent)\n          return state.localMode.indent(state.localState, textAfter, line);\n        else\n          return CodeMirror.Pass;\n      },\n\n      innerMode: function (state) {\n        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n      }\n    };\n  }, \"xml\", \"javascript\", \"css\");\n\n  CodeMirror.defineMIME(\"text/html\", \"htmlmixed\");\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nvar htmlConfig = {\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                    'track': true, 'wbr': true, 'menuitem': true},\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                     'th': true, 'tr': true},\n  contextGrabbers: {\n    'dd': {'dd': true, 'dt': true},\n    'dt': {'dd': true, 'dt': true},\n    'li': {'li': true},\n    'option': {'option': true, 'optgroup': true},\n    'optgroup': {'optgroup': true},\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n    'rp': {'rp': true, 'rt': true},\n    'rt': {'rp': true, 'rt': true},\n    'tbody': {'tbody': true, 'tfoot': true},\n    'td': {'td': true, 'th': true},\n    'tfoot': {'tbody': true},\n    'th': {'td': true, 'th': true},\n    'thead': {'tbody': true, 'tfoot': true},\n    'tr': {'tr': true}\n  },\n  doNotIndent: {\"pre\": true},\n  allowUnquoted: true,\n  allowMissing: true,\n  caseFold: true\n}\n\nvar xmlConfig = {\n  autoSelfClosers: {},\n  implicitlyClosed: {},\n  contextGrabbers: {},\n  doNotIndent: {},\n  allowUnquoted: false,\n  allowMissing: false,\n  allowMissingTagName: false,\n  caseFold: false\n}\n\nCodeMirror.defineMode(\"xml\", function(editorConf, config_) {\n  var indentUnit = editorConf.indentUnit\n  var config = {}\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\n  for (var prop in defaults) config[prop] = defaults[prop]\n  for (var prop in config_) config[prop] = config_[prop]\n\n  // Return variables for tokenizers\n  var type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        } else if (stream.match(\"--\")) {\n          return chain(inBlock(\"comment\", \"-->\"));\n        } else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      } else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        state.tokenize = inTag;\n        return \"tag bracket\";\n      }\n    } else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n  inText.isInText = true;\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag bracket\";\n    } else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    } else if (ch == \"<\") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + \" tag error\" : \"tag error\";\n    } else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.match(/^[^\\s\\u00a0=<>\\\"\\']*[^\\s\\u00a0=<>\\\"\\'\\/]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    }\n  }\n\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  function lower(tagName) {\n    return tagName && tagName.toLowerCase();\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName || \"\";\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName;\n      if (!config.contextGrabbers.hasOwnProperty(lower(parentTagName)) ||\n          !config.contextGrabbers[lower(parentTagName)].hasOwnProperty(lower(nextTagName))) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == \"openTag\") {\n      state.tagStart = stream.column();\n      return tagNameState;\n    } else if (type == \"closeTag\") {\n      return closeTagNameState;\n    } else {\n      return baseState;\n    }\n  }\n  function tagNameState(type, stream, state) {\n    if (type == \"word\") {\n      state.tagName = stream.current();\n      setStyle = \"tag\";\n      return attrState;\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return attrState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return tagNameState;\n    }\n  }\n  function closeTagNameState(type, stream, state) {\n    if (type == \"word\") {\n      var tagName = stream.current();\n      if (state.context && state.context.tagName != tagName &&\n          config.implicitlyClosed.hasOwnProperty(lower(state.context.tagName)))\n        popContext(state);\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\n        setStyle = \"tag\";\n        return closeState;\n      } else {\n        setStyle = \"tag error\";\n        return closeStateErr;\n      }\n    } else if (config.allowMissingTagName && type == \"endTag\") {\n      setStyle = \"tag bracket\";\n      return closeState(type, stream, state);\n    } else {\n      setStyle = \"error\";\n      return closeStateErr;\n    }\n  }\n\n  function closeState(type, _stream, state) {\n    if (type != \"endTag\") {\n      setStyle = \"error\";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = \"error\";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == \"word\") {\n      setStyle = \"attribute\";\n      return attrEqState;\n    } else if (type == \"endTag\" || type == \"selfcloseTag\") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == \"selfcloseTag\" ||\n          config.autoSelfClosers.hasOwnProperty(lower(tagName))) {\n        maybePopContext(state, tagName);\n      } else {\n        maybePopContext(state, tagName);\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = \"error\";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == \"equals\") return attrValueState;\n    if (!config.allowMissing) setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    if (type == \"word\" && config.allowUnquoted) {setStyle = \"string\"; return attrState;}\n    setStyle = \"error\";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == \"string\") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function(baseIndent) {\n      var state = {tokenize: inText,\n                   state: baseState,\n                   indented: baseIndent || 0,\n                   tagName: null, tagStart: null,\n                   context: null}\n      if (baseIndent != null) state.baseIndent = baseIndent\n      return state\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != \"comment\") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == \"error\" ? style + \" error\" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        if (state.tagStart == state.indented)\n          return state.stringStartCol + 1;\n        else\n          return state.indented + indentUnit;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (config.multilineTagIndentPastTag !== false)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\n      }\n      if (config.alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      var tagAfter = textAfter && /^<(\\/)?([\\w_:\\.-]*)/.exec(textAfter);\n      if (tagAfter && tagAfter[1]) { // Closing tag spotted\n        while (context) {\n          if (context.tagName == tagAfter[2]) {\n            context = context.prev;\n            break;\n          } else if (config.implicitlyClosed.hasOwnProperty(lower(context.tagName))) {\n            context = context.prev;\n          } else {\n            break;\n          }\n        }\n      } else if (tagAfter) { // Opening tag spotted\n        while (context) {\n          var grabbers = config.contextGrabbers[lower(context.tagName)];\n          if (grabbers && grabbers.hasOwnProperty(lower(tagAfter[2])))\n            context = context.prev;\n          else\n            break;\n        }\n      }\n      while (context && context.prev && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return state.baseIndent || 0;\n    },\n\n    electricInput: /<\\/[\\s\\w:]+>$/,\n    blockCommentStart: \"<!--\",\n    blockCommentEnd: \"-->\",\n\n    configuration: config.htmlMode ? \"html\" : \"xml\",\n    helperType: config.htmlMode ? \"html\" : \"xml\",\n\n    skipAttribute: function(state) {\n      if (state.state == attrValueState)\n        state.state = attrState\n    },\n\n    xmlCurrentTag: function(state) {\n      return state.tagName ? {name: state.tagName, close: state.type == \"closeTag\"} : null\n    },\n\n    xmlCurrentContext: function(state) {\n      var context = []\n      for (var cx = state.context; cx; cx = cx.prev)\n        context.push(cx.tagName)\n      return context.reverse()\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/xml\", \"xml\");\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var trackScope = parserConfig.trackScope !== false\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\" && stream.peek() == \"!\") {\n      stream.skipToEnd();\n      return ret(\"meta\", \"meta\");\n    } else if (ch == \"#\" && stream.eatWhile(wordRE)) {\n      return ret(\"variable\", \"property\")\n    } else if (ch == \"<\" && stream.match(\"!--\") ||\n               (ch == \"-\" && stream.match(\"->\") && !/\\S/.test(stream.string.slice(0, stream.start)))) {\n      stream.skipToEnd()\n      return ret(\"comment\", \"comment\")\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-|&?]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      if (ch == \"?\" && stream.eat(\".\")) return ret(\".\")\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*([^*]|\\*(?!\\/))*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return\n          var next = stream.string.charAt(pos - 1)\n          if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true,\n                     \"regexp\": true, \"this\": true, \"import\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    if (!trackScope) return false\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (!trackScope) return\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  pushcontext.lex = pushblockcontext.lex = true\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), pushblockcontext, forspec, statement, popcontext, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(maybeexpression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(maybeexpression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\" || value == \"readonly\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), typeprops, poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n    if (type == \"quasi\") { return pass(quasiType, afterType); }\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprops(type) {\n    if (type.match(/[\\}\\)\\]]/)) return cont()\n    if (type == \",\" || type == \";\") return cont(typeprops)\n    return pass(typeprop, typeprops)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    } else if (!type.match(/[;\\}\\)\\],]/)) {\n      return cont()\n    }\n  }\n  function quasiType(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasiType);\n    return cont(typeexpr, continueQuasiType);\n  }\n  function continueQuasiType(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasiType);\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+#?[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(classfield, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(classfield, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), classfield, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"!\") return cont(classfield)\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    if (type == \".\") return pass(maybeoperatorComma);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse && c != popcontext) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      parseJS(state, \"atom\", \"atom\", \"true\", new CodeMirror.StringStream(\"\", 2, null))\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/x-json\", { name: \"javascript\", json: true });\nCodeMirror.defineMIME(\"application/manifest+json\", { name: \"javascript\", json: true })\nCodeMirror.defineMIME(\"application/ld+json\", { name: \"javascript\", jsonld: true });\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var WRAP_CLASS = \"CodeMirror-activeline\";\n  var BACK_CLASS = \"CodeMirror-activeline-background\";\n  var GUTT_CLASS = \"CodeMirror-activeline-gutter\";\n\n  CodeMirror.defineOption(\"styleActiveLine\", false, function(cm, val, old) {\n    var prev = old == CodeMirror.Init ? false : old;\n    if (val == prev) return\n    if (prev) {\n      cm.off(\"beforeSelectionChange\", selectionChange);\n      clearActiveLines(cm);\n      delete cm.state.activeLines;\n    }\n    if (val) {\n      cm.state.activeLines = [];\n      updateActiveLines(cm, cm.listSelections());\n      cm.on(\"beforeSelectionChange\", selectionChange);\n    }\n  });\n\n  function clearActiveLines(cm) {\n    for (var i = 0; i < cm.state.activeLines.length; i++) {\n      cm.removeLineClass(cm.state.activeLines[i], \"wrap\", WRAP_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], \"background\", BACK_CLASS);\n      cm.removeLineClass(cm.state.activeLines[i], \"gutter\", GUTT_CLASS);\n    }\n  }\n\n  function sameArray(a, b) {\n    if (a.length != b.length) return false;\n    for (var i = 0; i < a.length; i++)\n      if (a[i] != b[i]) return false;\n    return true;\n  }\n\n  function updateActiveLines(cm, ranges) {\n    var active = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i];\n      var option = cm.getOption(\"styleActiveLine\");\n      if (typeof option == \"object\" && option.nonEmpty ? range.anchor.line != range.head.line : !range.empty())\n        continue\n      var line = cm.getLineHandleVisualStart(range.head.line);\n      if (active[active.length - 1] != line) active.push(line);\n    }\n    if (sameArray(cm.state.activeLines, active)) return;\n    cm.operation(function() {\n      clearActiveLines(cm);\n      for (var i = 0; i < active.length; i++) {\n        cm.addLineClass(active[i], \"wrap\", WRAP_CLASS);\n        cm.addLineClass(active[i], \"background\", BACK_CLASS);\n        cm.addLineClass(active[i], \"gutter\", GUTT_CLASS);\n      }\n      cm.state.activeLines = active;\n    });\n  }\n\n  function selectionChange(cm, sel) {\n    updateActiveLines(cm, sel.ranges);\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  var GUTTER_ID = \"CodeMirror-lint-markers\";\n  var LINT_LINE_ID = \"CodeMirror-lint-line-\";\n\n  function showTooltip(cm, e, content) {\n    var tt = document.createElement(\"div\");\n    tt.className = \"CodeMirror-lint-tooltip cm-s-\" + cm.options.theme;\n    tt.appendChild(content.cloneNode(true));\n    if (cm.state.lint.options.selfContain)\n      cm.getWrapperElement().appendChild(tt);\n    else\n      document.body.appendChild(tt);\n\n    function position(e) {\n      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n      var top = Math.max(0, e.clientY - tt.offsetHeight - 5);\n      var left = Math.max(0, Math.min(e.clientX + 5, tt.ownerDocument.defaultView.innerWidth - tt.offsetWidth));\n      tt.style.top = top + \"px\"\n      tt.style.left = left + \"px\";\n    }\n    CodeMirror.on(document, \"mousemove\", position);\n    position(e);\n    if (tt.style.opacity != null) tt.style.opacity = 1;\n    return tt;\n  }\n  function rm(elt) {\n    if (elt.parentNode) elt.parentNode.removeChild(elt);\n  }\n  function hideTooltip(tt) {\n    if (!tt.parentNode) return;\n    if (tt.style.opacity == null) rm(tt);\n    tt.style.opacity = 0;\n    setTimeout(function() { rm(tt); }, 600);\n  }\n\n  function showTooltipFor(cm, e, content, node) {\n    var tooltip = showTooltip(cm, e, content);\n    function hide() {\n      CodeMirror.off(node, \"mouseout\", hide);\n      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n    }\n    var poll = setInterval(function() {\n      if (tooltip) for (var n = node;; n = n.parentNode) {\n        if (n && n.nodeType == 11) n = n.host;\n        if (n == document.body) return;\n        if (!n) { hide(); break; }\n      }\n      if (!tooltip) return clearInterval(poll);\n    }, 400);\n    CodeMirror.on(node, \"mouseout\", hide);\n  }\n\n  function LintState(cm, conf, hasGutter) {\n    this.marked = [];\n    if (conf instanceof Function) conf = {getAnnotations: conf};\n    if (!conf || conf === true) conf = {};\n    this.options = {};\n    this.linterOptions = conf.options || {};\n    for (var prop in defaults) this.options[prop] = defaults[prop];\n    for (var prop in conf) {\n      if (defaults.hasOwnProperty(prop)) {\n        if (conf[prop] != null) this.options[prop] = conf[prop];\n      } else if (!conf.options) {\n        this.linterOptions[prop] = conf[prop];\n      }\n    }\n    this.timeout = null;\n    this.hasGutter = hasGutter;\n    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n    this.waitingFor = 0\n  }\n\n  var defaults = {\n    highlightLines: false,\n    tooltips: true,\n    delay: 500,\n    lintOnChange: true,\n    getAnnotations: null,\n    async: false,\n    selfContain: null,\n    formatAnnotation: null,\n    onUpdateLinting: null\n  }\n\n  function clearMarks(cm) {\n    var state = cm.state.lint;\n    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n    if (state.options.highlightLines) clearErrorLines(cm);\n    for (var i = 0; i < state.marked.length; ++i)\n      state.marked[i].clear();\n    state.marked.length = 0;\n  }\n\n  function clearErrorLines(cm) {\n    cm.eachLine(function(line) {\n      var has = line.wrapClass && /\\bCodeMirror-lint-line-\\w+\\b/.exec(line.wrapClass);\n      if (has) cm.removeLineClass(line, \"wrap\", has[0]);\n    })\n  }\n\n  function makeMarker(cm, labels, severity, multiple, tooltips) {\n    var marker = document.createElement(\"div\"), inner = marker;\n    marker.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-\" + severity;\n    if (multiple) {\n      inner = marker.appendChild(document.createElement(\"div\"));\n      inner.className = \"CodeMirror-lint-marker CodeMirror-lint-marker-multiple\";\n    }\n\n    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n      showTooltipFor(cm, e, labels, inner);\n    });\n\n    return marker;\n  }\n\n  function getMaxSeverity(a, b) {\n    if (a == \"error\") return a;\n    else return b;\n  }\n\n  function groupByLine(annotations) {\n    var lines = [];\n    for (var i = 0; i < annotations.length; ++i) {\n      var ann = annotations[i], line = ann.from.line;\n      (lines[line] || (lines[line] = [])).push(ann);\n    }\n    return lines;\n  }\n\n  function annotationTooltip(ann) {\n    var severity = ann.severity;\n    if (!severity) severity = \"error\";\n    var tip = document.createElement(\"div\");\n    tip.className = \"CodeMirror-lint-message CodeMirror-lint-message-\" + severity;\n    if (typeof ann.messageHTML != 'undefined') {\n      tip.innerHTML = ann.messageHTML;\n    } else {\n      tip.appendChild(document.createTextNode(ann.message));\n    }\n    return tip;\n  }\n\n  function lintAsync(cm, getAnnotations) {\n    var state = cm.state.lint\n    var id = ++state.waitingFor\n    function abort() {\n      id = -1\n      cm.off(\"change\", abort)\n    }\n    cm.on(\"change\", abort)\n    getAnnotations(cm.getValue(), function(annotations, arg2) {\n      cm.off(\"change\", abort)\n      if (state.waitingFor != id) return\n      if (arg2 && annotations instanceof CodeMirror) annotations = arg2\n      cm.operation(function() {updateLinting(cm, annotations)})\n    }, state.linterOptions, cm);\n  }\n\n  function startLinting(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    var options = state.options;\n    /*\n     * Passing rules in `options` property prevents JSHint (and other linters) from complaining\n     * about unrecognized rules like `onUpdateLinting`, `delay`, `lintOnChange`, etc.\n     */\n    var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n    if (!getAnnotations) return;\n    if (options.async || getAnnotations.async) {\n      lintAsync(cm, getAnnotations)\n    } else {\n      var annotations = getAnnotations(cm.getValue(), state.linterOptions, cm);\n      if (!annotations) return;\n      if (annotations.then) annotations.then(function(issues) {\n        cm.operation(function() {updateLinting(cm, issues)})\n      });\n      else cm.operation(function() {updateLinting(cm, annotations)})\n    }\n  }\n\n  function updateLinting(cm, annotationsNotSorted) {\n    var state = cm.state.lint;\n    if (!state) return;\n    var options = state.options;\n    clearMarks(cm);\n\n    var annotations = groupByLine(annotationsNotSorted);\n\n    for (var line = 0; line < annotations.length; ++line) {\n      var anns = annotations[line];\n      if (!anns) continue;\n\n      var maxSeverity = null;\n      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\n      for (var i = 0; i < anns.length; ++i) {\n        var ann = anns[i];\n        var severity = ann.severity;\n        if (!severity) severity = \"error\";\n        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\n        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\n        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n          className: \"CodeMirror-lint-mark CodeMirror-lint-mark-\" + severity,\n          __annotation: ann\n        }));\n      }\n      if (state.hasGutter)\n        cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, anns.length > 1,\n                                                       options.tooltips));\n\n      if (options.highlightLines)\n        cm.addLineClass(line, \"wrap\", LINT_LINE_ID + maxSeverity);\n    }\n    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.lint;\n    if (!state) return;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay);\n  }\n\n  function popupTooltips(cm, annotations, e) {\n    var target = e.target || e.srcElement;\n    var tooltip = document.createDocumentFragment();\n    for (var i = 0; i < annotations.length; i++) {\n      var ann = annotations[i];\n      tooltip.appendChild(annotationTooltip(ann));\n    }\n    showTooltipFor(cm, e, tooltip, target);\n  }\n\n  function onMouseOver(cm, e) {\n    var target = e.target || e.srcElement;\n    if (!/\\bCodeMirror-lint-mark-/.test(target.className)) return;\n    var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;\n    var spans = cm.findMarksAt(cm.coordsChar({left: x, top: y}, \"client\"));\n\n    var annotations = [];\n    for (var i = 0; i < spans.length; ++i) {\n      var ann = spans[i].__annotation;\n      if (ann) annotations.push(ann);\n    }\n    if (annotations.length) popupTooltips(cm, annotations, e);\n  }\n\n  CodeMirror.defineOption(\"lint\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      clearMarks(cm);\n      if (cm.state.lint.options.lintOnChange !== false)\n        cm.off(\"change\", onChange);\n      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n      clearTimeout(cm.state.lint.timeout);\n      delete cm.state.lint;\n    }\n\n    if (val) {\n      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n      var state = cm.state.lint = new LintState(cm, val, hasLintGutter);\n      if (state.options.lintOnChange)\n        cm.on(\"change\", onChange);\n      if (state.options.tooltips != false && state.options.tooltips != \"gutter\")\n        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\n      startLinting(cm);\n    }\n  });\n\n  CodeMirror.defineExtension(\"performLint\", function() {\n    startLinting(this);\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// Depends on jsonlint.js from https://github.com/zaach/jsonlint\n\n// declare global: jsonlint\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"lint\", \"json\", function(text) {\n  var found = [];\n  if (!window.jsonlint) {\n    if (window.console) {\n      window.console.error(\"Error: window.jsonlint not defined, CodeMirror JSON linting cannot run.\");\n    }\n    return found;\n  }\n  // for jsonlint's web dist jsonlint is exported as an object with a single property parser, of which parseError\n  // is a subproperty\n  var jsonlint = window.jsonlint.parser || window.jsonlint\n  jsonlint.parseError = function(str, hash) {\n    var loc = hash.loc;\n    found.push({from: CodeMirror.Pos(loc.first_line - 1, loc.first_column),\n                to: CodeMirror.Pos(loc.last_line - 1, loc.last_column),\n                message: str});\n  };\n  try { jsonlint.parse(text); }\n  catch(e) {}\n  return found;\n});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// Depends on jshint.js from https://github.com/jshint/jshint\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n  // declare global: JSHINT\n\n  function validator(text, options) {\n    if (!window.JSHINT) {\n      if (window.console) {\n        window.console.error(\"Error: window.JSHINT not defined, CodeMirror JavaScript linting cannot run.\");\n      }\n      return [];\n    }\n    if (!options.indent) // JSHint error.character actually is a column index, this fixes underlining on lines using tabs for indentation\n      options.indent = 1; // JSHint default value is 4\n    JSHINT(text, options, options.globals);\n    var errors = JSHINT.data().errors, result = [];\n    if (errors) parseErrors(errors, result);\n    return result;\n  }\n\n  CodeMirror.registerHelper(\"lint\", \"javascript\", validator);\n\n  function parseErrors(errors, output) {\n    for ( var i = 0; i < errors.length; i++) {\n      var error = errors[i];\n      if (error) {\n        if (error.line <= 0) {\n          if (window.console) {\n            window.console.warn(\"Cannot display JSHint error (invalid line \" + error.line + \")\", error);\n          }\n          continue;\n        }\n\n        var start = error.character - 1, end = start + 1;\n        if (error.evidence) {\n          var index = error.evidence.substring(start).search(/.\\b/);\n          if (index > -1) {\n            end += index;\n          }\n        }\n\n        // Convert to format expected by validation service\n        var hint = {\n          message: error.reason,\n          severity: error.code ? (error.code.startsWith('W') ? \"warning\" : \"error\") : \"error\",\n          from: CodeMirror.Pos(error.line - 1, start),\n          to: CodeMirror.Pos(error.line - 1, end)\n        };\n\n        output.push(hint);\n      }\n    }\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// Depends on htmlhint.js from http://htmlhint.com/js/htmlhint.js\n\n// declare global: HTMLHint\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79), require(122));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"htmlhint\"], mod);\n  else // Plain browser env\n    mod(CodeMirror, window.HTMLHint);\n})(function(CodeMirror, HTMLHint) {\n  \"use strict\";\n\n  var defaultRules = {\n    \"tagname-lowercase\": true,\n    \"attr-lowercase\": true,\n    \"attr-value-double-quotes\": true,\n    \"doctype-first\": false,\n    \"tag-pair\": true,\n    \"spec-char-escape\": true,\n    \"id-unique\": true,\n    \"src-not-empty\": true,\n    \"attr-no-duplication\": true\n  };\n\n  CodeMirror.registerHelper(\"lint\", \"html\", function(text, options) {\n    var found = [];\n    if (HTMLHint && !HTMLHint.verify) {\n      if(typeof HTMLHint.default !== 'undefined') {\n        HTMLHint = HTMLHint.default;\n      } else {\n        HTMLHint = HTMLHint.HTMLHint;\n      }\n    }\n    if (!HTMLHint) HTMLHint = window.HTMLHint;\n    if (!HTMLHint) {\n      if (window.console) {\n          window.console.error(\"Error: HTMLHint not found, not defined on window, or not available through define/require, CodeMirror HTML linting cannot run.\");\n      }\n      return found;\n    }\n    var messages = HTMLHint.verify(text, options && options.rules || defaultRules);\n    for (var i = 0; i < messages.length; i++) {\n      var message = messages[i];\n      var startLine = message.line - 1, endLine = message.line - 1, startCol = message.col - 1, endCol = message.col;\n      found.push({\n        from: CodeMirror.Pos(startLine, startCol),\n        to: CodeMirror.Pos(endLine, endCol),\n        message: message.message,\n        severity : message.type\n      });\n    }\n    return found;\n  });\n});\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.HTMLHint = factory());\n})(this, (function () { 'use strict';\n\n\tfunction getDefaultExportFromCjs (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n\t}\n\n\tvar core$1 = {};\n\n\tvar htmlparser = {};\n\n\tObject.defineProperty(htmlparser, \"__esModule\", { value: true });\n\tclass HTMLParser {\n\t    constructor() {\n\t        this._listeners = {};\n\t        this._mapCdataTags = this.makeMap('script,style');\n\t        this._arrBlocks = [];\n\t        this.lastEvent = null;\n\t    }\n\t    makeMap(str) {\n\t        const obj = {};\n\t        const items = str.split(',');\n\t        for (let i = 0; i < items.length; i++) {\n\t            obj[items[i]] = true;\n\t        }\n\t        return obj;\n\t    }\n\t    parse(html) {\n\t        const mapCdataTags = this._mapCdataTags;\n\t        const regTag = /<(?:\\/([^\\s>]+)\\s*|!--([\\s\\S]*?)--|!([^>]*?)|([\\w\\-:]+)((?:\\s+[^\\s\"'>\\/=\\x00-\\x0F\\x7F\\x80-\\x9F]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s\"'>]*))?)*?)\\s*(\\/?))>/g;\n\t        const regAttr = /\\s*([^\\s\"'>\\/=\\x00-\\x0F\\x7F\\x80-\\x9F]+)(?:\\s*=\\s*(?:(\")([^\"]*)\"|(')([^']*)'|([^\\s\"'>]*)))?/g;\n\t        const regLine = /\\r?\\n/g;\n\t        let match;\n\t        let matchIndex;\n\t        let lastIndex = 0;\n\t        let tagName;\n\t        let arrAttrs;\n\t        let tagCDATA = null;\n\t        let attrsCDATA;\n\t        let arrCDATA = [];\n\t        let lastCDATAIndex = 0;\n\t        let text;\n\t        let lastLineIndex = 0;\n\t        let line = 1;\n\t        const arrBlocks = this._arrBlocks;\n\t        this.fire('start', {\n\t            pos: 0,\n\t            line: 1,\n\t            col: 1,\n\t        });\n\t        const isMapCdataTagsRequired = () => {\n\t            const attrType = arrAttrs.find((attr) => attr.name === 'type') || {\n\t                value: '',\n\t            };\n\t            return (mapCdataTags[tagName] &&\n\t                attrType.value.indexOf('text/ng-template') === -1);\n\t        };\n\t        const saveBlock = (type, raw, pos, data) => {\n\t            const col = pos - lastLineIndex + 1;\n\t            if (data === undefined) {\n\t                data = {};\n\t            }\n\t            data.raw = raw;\n\t            data.pos = pos;\n\t            data.line = line;\n\t            data.col = col;\n\t            arrBlocks.push(data);\n\t            this.fire(type, data);\n\t            while (regLine.exec(raw)) {\n\t                line++;\n\t                lastLineIndex = pos + regLine.lastIndex;\n\t            }\n\t        };\n\t        while ((match = regTag.exec(html))) {\n\t            matchIndex = match.index;\n\t            if (matchIndex > lastIndex) {\n\t                text = html.substring(lastIndex, matchIndex);\n\t                if (tagCDATA) {\n\t                    arrCDATA.push(text);\n\t                }\n\t                else {\n\t                    saveBlock('text', text, lastIndex);\n\t                }\n\t            }\n\t            lastIndex = regTag.lastIndex;\n\t            if ((tagName = match[1])) {\n\t                if (tagCDATA && tagName === tagCDATA) {\n\t                    text = arrCDATA.join('');\n\t                    saveBlock('cdata', text, lastCDATAIndex, {\n\t                        tagName: tagCDATA,\n\t                        attrs: attrsCDATA,\n\t                    });\n\t                    tagCDATA = null;\n\t                    attrsCDATA = undefined;\n\t                    arrCDATA = [];\n\t                }\n\t                if (!tagCDATA) {\n\t                    saveBlock('tagend', match[0], matchIndex, {\n\t                        tagName: tagName,\n\t                    });\n\t                    continue;\n\t                }\n\t            }\n\t            if (tagCDATA) {\n\t                arrCDATA.push(match[0]);\n\t            }\n\t            else {\n\t                if ((tagName = match[4])) {\n\t                    arrAttrs = [];\n\t                    const attrs = match[5];\n\t                    let attrMatch;\n\t                    let attrMatchCount = 0;\n\t                    while ((attrMatch = regAttr.exec(attrs))) {\n\t                        const name = attrMatch[1];\n\t                        const quote = attrMatch[2]\n\t                            ? attrMatch[2]\n\t                            : attrMatch[4]\n\t                                ? attrMatch[4]\n\t                                : '';\n\t                        const value = attrMatch[3]\n\t                            ? attrMatch[3]\n\t                            : attrMatch[5]\n\t                                ? attrMatch[5]\n\t                                : attrMatch[6]\n\t                                    ? attrMatch[6]\n\t                                    : '';\n\t                        arrAttrs.push({\n\t                            name: name,\n\t                            value: value,\n\t                            quote: quote,\n\t                            index: attrMatch.index,\n\t                            raw: attrMatch[0],\n\t                        });\n\t                        attrMatchCount += attrMatch[0].length;\n\t                    }\n\t                    if (attrMatchCount === attrs.length) {\n\t                        saveBlock('tagstart', match[0], matchIndex, {\n\t                            tagName: tagName,\n\t                            attrs: arrAttrs,\n\t                            close: match[6],\n\t                        });\n\t                        if (isMapCdataTagsRequired()) {\n\t                            tagCDATA = tagName;\n\t                            attrsCDATA = arrAttrs.concat();\n\t                            arrCDATA = [];\n\t                            lastCDATAIndex = lastIndex;\n\t                        }\n\t                    }\n\t                    else {\n\t                        saveBlock('text', match[0], matchIndex);\n\t                    }\n\t                }\n\t                else if (match[2] || match[3]) {\n\t                    saveBlock('comment', match[0], matchIndex, {\n\t                        content: match[2] || match[3],\n\t                        long: match[2] ? true : false,\n\t                    });\n\t                }\n\t            }\n\t        }\n\t        if (html.length > lastIndex) {\n\t            text = html.substring(lastIndex, html.length);\n\t            saveBlock('text', text, lastIndex);\n\t        }\n\t        this.fire('end', {\n\t            pos: lastIndex,\n\t            line: line,\n\t            col: html.length - lastLineIndex + 1,\n\t        });\n\t    }\n\t    addListener(types, listener) {\n\t        const _listeners = this._listeners;\n\t        const arrTypes = types.split(/[,\\s]/);\n\t        let type;\n\t        for (let i = 0, l = arrTypes.length; i < l; i++) {\n\t            type = arrTypes[i];\n\t            if (_listeners[type] === undefined) {\n\t                _listeners[type] = [];\n\t            }\n\t            _listeners[type].push(listener);\n\t        }\n\t    }\n\t    fire(type, data) {\n\t        if (data === undefined) {\n\t            data = {};\n\t        }\n\t        data.type = type;\n\t        let listeners = [];\n\t        const listenersType = this._listeners[type];\n\t        const listenersAll = this._listeners['all'];\n\t        if (listenersType !== undefined) {\n\t            listeners = listeners.concat(listenersType);\n\t        }\n\t        if (listenersAll !== undefined) {\n\t            listeners = listeners.concat(listenersAll);\n\t        }\n\t        const lastEvent = this.lastEvent;\n\t        if (lastEvent !== null) {\n\t            delete lastEvent['lastEvent'];\n\t            data.lastEvent = lastEvent;\n\t        }\n\t        this.lastEvent = data;\n\t        for (let i = 0, l = listeners.length; i < l; i++) {\n\t            listeners[i].call(this, data);\n\t        }\n\t    }\n\t    removeListener(type, listener) {\n\t        const listenersType = this._listeners[type];\n\t        if (listenersType !== undefined) {\n\t            for (let i = 0, l = listenersType.length; i < l; i++) {\n\t                if (listenersType[i] === listener) {\n\t                    listenersType.splice(i, 1);\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t    }\n\t    fixPos(event, index) {\n\t        const text = event.raw.substr(0, index);\n\t        const arrLines = text.split(/\\r?\\n/);\n\t        const lineCount = arrLines.length - 1;\n\t        let line = event.line;\n\t        let col;\n\t        if (lineCount > 0) {\n\t            line += lineCount;\n\t            col = arrLines[lineCount].length + 1;\n\t        }\n\t        else {\n\t            col = event.col + index;\n\t        }\n\t        return {\n\t            line: line,\n\t            col: col,\n\t        };\n\t    }\n\t    getMapAttrs(arrAttrs) {\n\t        const mapAttrs = {};\n\t        let attr;\n\t        for (let i = 0, l = arrAttrs.length; i < l; i++) {\n\t            attr = arrAttrs[i];\n\t            mapAttrs[attr.name] = attr.value;\n\t        }\n\t        return mapAttrs;\n\t    }\n\t}\n\thtmlparser.default = HTMLParser;\n\n\tvar reporter = {};\n\n\tObject.defineProperty(reporter, \"__esModule\", { value: true });\n\tclass Reporter {\n\t    constructor(html, ruleset) {\n\t        this.html = html;\n\t        this.lines = html.split(/\\r?\\n/);\n\t        const match = /\\r?\\n/.exec(html);\n\t        this.brLen = match !== null ? match[0].length : 0;\n\t        this.ruleset = ruleset;\n\t        this.messages = [];\n\t    }\n\t    info(message, line, col, rule, raw) {\n\t        this.report(\"info\", message, line, col, rule, raw);\n\t    }\n\t    warn(message, line, col, rule, raw) {\n\t        this.report(\"warning\", message, line, col, rule, raw);\n\t    }\n\t    error(message, line, col, rule, raw) {\n\t        this.report(\"error\", message, line, col, rule, raw);\n\t    }\n\t    report(type, message, line, col, rule, raw) {\n\t        const lines = this.lines;\n\t        const brLen = this.brLen;\n\t        let evidence = '';\n\t        let evidenceLen = 0;\n\t        for (let i = line - 1, lineCount = lines.length; i < lineCount; i++) {\n\t            evidence = lines[i];\n\t            evidenceLen = evidence.length;\n\t            if (col > evidenceLen && line < lineCount) {\n\t                line++;\n\t                col -= evidenceLen;\n\t                if (col !== 1) {\n\t                    col -= brLen;\n\t                }\n\t            }\n\t            else {\n\t                break;\n\t            }\n\t        }\n\t        this.messages.push({\n\t            type: type,\n\t            message: message,\n\t            raw: raw,\n\t            evidence: evidence,\n\t            line: line,\n\t            col: col,\n\t            rule: {\n\t                id: rule.id,\n\t                description: rule.description,\n\t                link: `https://htmlhint.com/docs/user-guide/rules/${rule.id}`,\n\t            },\n\t        });\n\t    }\n\t}\n\treporter.default = Reporter;\n\n\tvar rules = {};\n\n\tvar altRequire = {};\n\n\tObject.defineProperty(altRequire, \"__esModule\", { value: true });\n\taltRequire.default = {\n\t    id: 'alt-require',\n\t    description: 'The alt attribute of an <img> element must be present and alt attribute of area[href] and input[type=image] must have a value.',\n\t    init(parser, reporter) {\n\t        parser.addListener('tagstart', (event) => {\n\t            const tagName = event.tagName.toLowerCase();\n\t            const mapAttrs = parser.getMapAttrs(event.attrs);\n\t            const col = event.col + tagName.length + 1;\n\t            let selector;\n\t            if (tagName === 'img' && !('alt' in mapAttrs)) {\n\t                reporter.warn('An alt attribute must be present on <img> elements.', event.line, col, this, event.raw);\n\t            }\n\t            else if ((tagName === 'area' && 'href' in mapAttrs) ||\n\t                (tagName === 'input' && mapAttrs['type'] === 'image')) {\n\t                if (!('alt' in mapAttrs) || mapAttrs['alt'] === '') {\n\t                    selector = tagName === 'area' ? 'area[href]' : 'input[type=image]';\n\t                    reporter.warn(`The alt attribute of ${selector} must have a value.`, event.line, col, this, event.raw);\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar attrLowercase = {};\n\n\tObject.defineProperty(attrLowercase, \"__esModule\", { value: true });\n\tconst svgIgnores = [\n\t    'allowReorder',\n\t    'attributeName',\n\t    'attributeType',\n\t    'autoReverse',\n\t    'baseFrequency',\n\t    'baseProfile',\n\t    'calcMode',\n\t    'clipPath',\n\t    'clipPathUnits',\n\t    'contentScriptType',\n\t    'contentStyleType',\n\t    'diffuseConstant',\n\t    'edgeMode',\n\t    'externalResourcesRequired',\n\t    'filterRes',\n\t    'filterUnits',\n\t    'glyphRef',\n\t    'gradientTransform',\n\t    'gradientUnits',\n\t    'kernelMatrix',\n\t    'kernelUnitLength',\n\t    'keyPoints',\n\t    'keySplines',\n\t    'keyTimes',\n\t    'lengthAdjust',\n\t    'limitingConeAngle',\n\t    'markerHeight',\n\t    'markerUnits',\n\t    'markerWidth',\n\t    'maskContentUnits',\n\t    'maskUnits',\n\t    'numOctaves',\n\t    'onBlur',\n\t    'onChange',\n\t    'onClick',\n\t    'onFocus',\n\t    'onKeyUp',\n\t    'onLoad',\n\t    'pathLength',\n\t    'patternContentUnits',\n\t    'patternTransform',\n\t    'patternUnits',\n\t    'pointsAtX',\n\t    'pointsAtY',\n\t    'pointsAtZ',\n\t    'preserveAlpha',\n\t    'preserveAspectRatio',\n\t    'primitiveUnits',\n\t    'refX',\n\t    'refY',\n\t    'repeatCount',\n\t    'repeatDur',\n\t    'requiredExtensions',\n\t    'requiredFeatures',\n\t    'specularConstant',\n\t    'specularExponent',\n\t    'spreadMethod',\n\t    'startOffset',\n\t    'stdDeviation',\n\t    'stitchTiles',\n\t    'surfaceScale',\n\t    'systemLanguage',\n\t    'tableValues',\n\t    'targetX',\n\t    'targetY',\n\t    'textLength',\n\t    'viewBox',\n\t    'viewTarget',\n\t    'xChannelSelector',\n\t    'yChannelSelector',\n\t    'zoomAndPan',\n\t];\n\tfunction testAgainstStringOrRegExp(value, comparison) {\n\t    if (comparison instanceof RegExp) {\n\t        return comparison.test(value)\n\t            ? { match: value, pattern: comparison }\n\t            : false;\n\t    }\n\t    const firstComparisonChar = comparison[0];\n\t    const lastComparisonChar = comparison[comparison.length - 1];\n\t    const secondToLastComparisonChar = comparison[comparison.length - 2];\n\t    const comparisonIsRegex = firstComparisonChar === '/' &&\n\t        (lastComparisonChar === '/' ||\n\t            (secondToLastComparisonChar === '/' && lastComparisonChar === 'i'));\n\t    const hasCaseInsensitiveFlag = comparisonIsRegex && lastComparisonChar === 'i';\n\t    if (comparisonIsRegex) {\n\t        const valueMatches = hasCaseInsensitiveFlag\n\t            ? new RegExp(comparison.slice(1, -2), 'i').test(value)\n\t            : new RegExp(comparison.slice(1, -1)).test(value);\n\t        return valueMatches;\n\t    }\n\t    return value === comparison;\n\t}\n\tattrLowercase.default = {\n\t    id: 'attr-lowercase',\n\t    description: 'All attribute names must be in lowercase.',\n\t    init(parser, reporter, options) {\n\t        const exceptions = (Array.isArray(options) ? options : []).concat(svgIgnores);\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            let attr;\n\t            const col = event.col + event.tagName.length + 1;\n\t            for (let i = 0, l = attrs.length; i < l; i++) {\n\t                attr = attrs[i];\n\t                const attrName = attr.name;\n\t                if (!exceptions.find((exp) => testAgainstStringOrRegExp(attrName, exp)) &&\n\t                    attrName !== attrName.toLowerCase()) {\n\t                    reporter.error(`The attribute name of [ ${attrName} ] must be in lowercase.`, event.line, col + attr.index, this, attr.raw);\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar attrSorted = {};\n\n\tObject.defineProperty(attrSorted, \"__esModule\", { value: true });\n\tattrSorted.default = {\n\t    id: 'attr-sorted',\n\t    description: 'Attribute tags must be in proper order.',\n\t    init(parser, reporter) {\n\t        const orderMap = {};\n\t        const sortOrder = [\n\t            'class',\n\t            'id',\n\t            'name',\n\t            'src',\n\t            'for',\n\t            'type',\n\t            'href',\n\t            'value',\n\t            'title',\n\t            'alt',\n\t            'role',\n\t        ];\n\t        for (let i = 0; i < sortOrder.length; i++) {\n\t            orderMap[sortOrder[i]] = i;\n\t        }\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            const listOfAttributes = [];\n\t            for (let i = 0; i < attrs.length; i++) {\n\t                listOfAttributes.push(attrs[i].name);\n\t            }\n\t            const originalAttrs = JSON.stringify(listOfAttributes);\n\t            listOfAttributes.sort((a, b) => {\n\t                if (orderMap[a] == undefined && orderMap[b] == undefined) {\n\t                    return 0;\n\t                }\n\t                if (orderMap[a] == undefined) {\n\t                    return 1;\n\t                }\n\t                else if (orderMap[b] == undefined) {\n\t                    return -1;\n\t                }\n\t                return orderMap[a] - orderMap[b] || a.localeCompare(b);\n\t            });\n\t            if (originalAttrs !== JSON.stringify(listOfAttributes)) {\n\t                reporter.error(`Inaccurate order ${originalAttrs} should be in hierarchy ${JSON.stringify(listOfAttributes)} `, event.line, event.col, this, event.raw);\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar attrNoDuplication = {};\n\n\tObject.defineProperty(attrNoDuplication, \"__esModule\", { value: true });\n\tattrNoDuplication.default = {\n\t    id: 'attr-no-duplication',\n\t    description: 'Elements cannot have duplicate attributes.',\n\t    init(parser, reporter) {\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            let attr;\n\t            let attrName;\n\t            const col = event.col + event.tagName.length + 1;\n\t            const mapAttrName = {};\n\t            for (let i = 0, l = attrs.length; i < l; i++) {\n\t                attr = attrs[i];\n\t                attrName = attr.name;\n\t                if (mapAttrName[attrName] === true) {\n\t                    reporter.error(`Duplicate of attribute name [ ${attr.name} ] was found.`, event.line, col + attr.index, this, attr.raw);\n\t                }\n\t                mapAttrName[attrName] = true;\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar attrUnsafeChars = {};\n\n\tObject.defineProperty(attrUnsafeChars, \"__esModule\", { value: true });\n\tattrUnsafeChars.default = {\n\t    id: 'attr-unsafe-chars',\n\t    description: 'Attribute values cannot contain unsafe chars.',\n\t    init(parser, reporter) {\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            let attr;\n\t            const col = event.col + event.tagName.length + 1;\n\t            const regUnsafe = /[\\u0000-\\u0008\\u000b\\u000c\\u000e-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/;\n\t            let match;\n\t            for (let i = 0, l = attrs.length; i < l; i++) {\n\t                attr = attrs[i];\n\t                match = regUnsafe.exec(attr.value);\n\t                if (match !== null) {\n\t                    const unsafeCode = escape(match[0])\n\t                        .replace(/%u/, '\\\\u')\n\t                        .replace(/%/, '\\\\x');\n\t                    reporter.warn(`The value of attribute [ ${attr.name} ] cannot contain an unsafe char [ ${unsafeCode} ].`, event.line, col + attr.index, this, attr.raw);\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar attrValueDoubleQuotes = {};\n\n\tObject.defineProperty(attrValueDoubleQuotes, \"__esModule\", { value: true });\n\tattrValueDoubleQuotes.default = {\n\t    id: 'attr-value-double-quotes',\n\t    description: 'Attribute values must be in double quotes.',\n\t    init(parser, reporter) {\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            let attr;\n\t            const col = event.col + event.tagName.length + 1;\n\t            for (let i = 0, l = attrs.length; i < l; i++) {\n\t                attr = attrs[i];\n\t                if ((attr.value !== '' && attr.quote !== '\"') ||\n\t                    (attr.value === '' && attr.quote === \"'\")) {\n\t                    reporter.error(`The value of attribute [ ${attr.name} ] must be in double quotes.`, event.line, col + attr.index, this, attr.raw);\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar attrValueNotEmpty = {};\n\n\tObject.defineProperty(attrValueNotEmpty, \"__esModule\", { value: true });\n\tattrValueNotEmpty.default = {\n\t    id: 'attr-value-not-empty',\n\t    description: 'All attributes must have values.',\n\t    init(parser, reporter) {\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            let attr;\n\t            const col = event.col + event.tagName.length + 1;\n\t            for (let i = 0, l = attrs.length; i < l; i++) {\n\t                attr = attrs[i];\n\t                if (attr.quote === '' && attr.value === '') {\n\t                    reporter.warn(`The attribute [ ${attr.name} ] must have a value.`, event.line, col + attr.index, this, attr.raw);\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar attrValueSingleQuotes = {};\n\n\tObject.defineProperty(attrValueSingleQuotes, \"__esModule\", { value: true });\n\tattrValueSingleQuotes.default = {\n\t    id: 'attr-value-single-quotes',\n\t    description: 'Attribute values must be in single quotes.',\n\t    init(parser, reporter) {\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            let attr;\n\t            const col = event.col + event.tagName.length + 1;\n\t            for (let i = 0, l = attrs.length; i < l; i++) {\n\t                attr = attrs[i];\n\t                if ((attr.value !== '' && attr.quote !== \"'\") ||\n\t                    (attr.value === '' && attr.quote === '\"')) {\n\t                    reporter.error(`The value of attribute [ ${attr.name} ] must be in single quotes.`, event.line, col + attr.index, this, attr.raw);\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar attrWhitespace = {};\n\n\tObject.defineProperty(attrWhitespace, \"__esModule\", { value: true });\n\tattrWhitespace.default = {\n\t    id: 'attr-whitespace',\n\t    description: 'All attributes should be separated by only one space and not have leading/trailing whitespace.',\n\t    init(parser, reporter, options) {\n\t        const exceptions = Array.isArray(options)\n\t            ? options\n\t            : [];\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            let attr;\n\t            const col = event.col + event.tagName.length + 1;\n\t            attrs.forEach((elem) => {\n\t                attr = elem;\n\t                const attrName = elem.name;\n\t                if (exceptions.indexOf(attrName) !== -1) {\n\t                    return;\n\t                }\n\t                if (elem.value.trim() !== elem.value) {\n\t                    reporter.error(`The attributes of [ ${attrName} ] must not have leading or trailing whitespace.`, event.line, col + attr.index, this, attr.raw);\n\t                }\n\t                if (elem.value.replace(/ +(?= )/g, '') !== elem.value) {\n\t                    reporter.error(`The attributes of [ ${attrName} ] must be separated by only one space.`, event.line, col + attr.index, this, attr.raw);\n\t                }\n\t            });\n\t        });\n\t    },\n\t};\n\n\tvar doctypeFirst = {};\n\n\tObject.defineProperty(doctypeFirst, \"__esModule\", { value: true });\n\tdoctypeFirst.default = {\n\t    id: 'doctype-first',\n\t    description: 'Doctype must be declared first.',\n\t    init(parser, reporter) {\n\t        const allEvent = (event) => {\n\t            if (event.type === 'start' ||\n\t                (event.type === 'text' && /^\\s*$/.test(event.raw))) {\n\t                return;\n\t            }\n\t            if ((event.type !== 'comment' && event.long === false) ||\n\t                /^DOCTYPE\\s+/i.test(event.content) === false) {\n\t                reporter.error('Doctype must be declared first.', event.line, event.col, this, event.raw);\n\t            }\n\t            parser.removeListener('all', allEvent);\n\t        };\n\t        parser.addListener('all', allEvent);\n\t    },\n\t};\n\n\tvar doctypeHtml5 = {};\n\n\tObject.defineProperty(doctypeHtml5, \"__esModule\", { value: true });\n\tdoctypeHtml5.default = {\n\t    id: 'doctype-html5',\n\t    description: 'Invalid doctype. Use: \"<!DOCTYPE html>\"',\n\t    init(parser, reporter) {\n\t        const onComment = (event) => {\n\t            if (event.long === false &&\n\t                event.content.toLowerCase() !== 'doctype html') {\n\t                reporter.warn('Invalid doctype. Use: \"<!DOCTYPE html>\"', event.line, event.col, this, event.raw);\n\t            }\n\t        };\n\t        const onTagStart = () => {\n\t            parser.removeListener('comment', onComment);\n\t            parser.removeListener('tagstart', onTagStart);\n\t        };\n\t        parser.addListener('all', onComment);\n\t        parser.addListener('tagstart', onTagStart);\n\t    },\n\t};\n\n\tvar headScriptDisabled = {};\n\n\tObject.defineProperty(headScriptDisabled, \"__esModule\", { value: true });\n\theadScriptDisabled.default = {\n\t    id: 'head-script-disabled',\n\t    description: 'The <script> tag cannot be used in a <head> tag.',\n\t    init(parser, reporter) {\n\t        const reScript = /^(text\\/javascript|application\\/javascript)$/i;\n\t        let isInHead = false;\n\t        const onTagStart = (event) => {\n\t            const mapAttrs = parser.getMapAttrs(event.attrs);\n\t            const type = mapAttrs.type;\n\t            const tagName = event.tagName.toLowerCase();\n\t            if (tagName === 'head') {\n\t                isInHead = true;\n\t            }\n\t            if (isInHead === true &&\n\t                tagName === 'script' &&\n\t                (!type || reScript.test(type) === true)) {\n\t                reporter.warn('The <script> tag cannot be used in a <head> tag.', event.line, event.col, this, event.raw);\n\t            }\n\t        };\n\t        const onTagEnd = (event) => {\n\t            if (event.tagName.toLowerCase() === 'head') {\n\t                parser.removeListener('tagstart', onTagStart);\n\t                parser.removeListener('tagend', onTagEnd);\n\t            }\n\t        };\n\t        parser.addListener('tagstart', onTagStart);\n\t        parser.addListener('tagend', onTagEnd);\n\t    },\n\t};\n\n\tvar hrefAbsOrRel = {};\n\n\tObject.defineProperty(hrefAbsOrRel, \"__esModule\", { value: true });\n\threfAbsOrRel.default = {\n\t    id: 'href-abs-or-rel',\n\t    description: 'An href attribute must be either absolute or relative.',\n\t    init(parser, reporter, options) {\n\t        const hrefMode = options === 'abs' ? 'absolute' : 'relative';\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            let attr;\n\t            const col = event.col + event.tagName.length + 1;\n\t            for (let i = 0, l = attrs.length; i < l; i++) {\n\t                attr = attrs[i];\n\t                if (attr.name === 'href') {\n\t                    if ((hrefMode === 'absolute' && /^\\w+?:/.test(attr.value) === false) ||\n\t                        (hrefMode === 'relative' &&\n\t                            /^https?:\\/\\//.test(attr.value) === true)) {\n\t                        reporter.warn(`The value of the href attribute [ ${attr.value} ] must be ${hrefMode}.`, event.line, col + attr.index, this, attr.raw);\n\t                    }\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar htmlLangRequire = {};\n\n\tObject.defineProperty(htmlLangRequire, \"__esModule\", { value: true });\n\tconst regular = '(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)';\n\tconst irregular = '(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)';\n\tconst grandfathered = `(?<grandfathered>${irregular}|${regular})`;\n\tconst privateUse = '(?<privateUse>x(-[A-Za-z0-9]{1,8})+)';\n\tconst privateUse2 = '(?<privateUse2>x(-[A-Za-z0-9]{1,8})+)';\n\tconst singleton = '[0-9A-WY-Za-wy-z]';\n\tconst extension = `(?<extension>${singleton}(-[A-Za-z0-9]{2,8})+)`;\n\tconst variant = '(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3})';\n\tconst region = '(?<region>[A-Za-z]{2}|[0-9]{3})';\n\tconst script = '(?<script>[A-Za-z]{4})';\n\tconst extlang = '(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2})';\n\tconst language = `(?<language>([A-Za-z]{2,3}(-${extlang})?)|[A-Za-z]{4}|[A-Za-z]{5,8})`;\n\tconst langtag = `(${language}(-${script})?` +\n\t    `(-${region})?` +\n\t    `(-${variant})*` +\n\t    `(-${extension})*` +\n\t    `(-${privateUse})?` +\n\t    ')';\n\tconst languageTag = `(${grandfathered}|${langtag}|${privateUse2})`;\n\thtmlLangRequire.default = {\n\t    id: 'html-lang-require',\n\t    description: 'The lang attribute of an <html> element must be present and should be valid.',\n\t    init(parser, reporter) {\n\t        parser.addListener('tagstart', (event) => {\n\t            const tagName = event.tagName.toLowerCase();\n\t            const mapAttrs = parser.getMapAttrs(event.attrs);\n\t            const col = event.col + tagName.length + 1;\n\t            const langValidityPattern = new RegExp(languageTag, 'g');\n\t            if (tagName === 'html') {\n\t                if ('lang' in mapAttrs) {\n\t                    if (!mapAttrs['lang']) {\n\t                        reporter.warn('The lang attribute of <html> element must have a value.', event.line, col, this, event.raw);\n\t                    }\n\t                    else if (!langValidityPattern.test(mapAttrs['lang'])) {\n\t                        reporter.warn('The lang attribute value of <html> element must be a valid BCP47.', event.line, col, this, event.raw);\n\t                    }\n\t                }\n\t                else {\n\t                    reporter.warn('An lang attribute must be present on <html> elements.', event.line, col, this, event.raw);\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar idClassAdDisabled = {};\n\n\tObject.defineProperty(idClassAdDisabled, \"__esModule\", { value: true });\n\tidClassAdDisabled.default = {\n\t    id: 'id-class-ad-disabled',\n\t    description: 'The id and class attributes cannot use the ad keyword, it will be blocked by adblock software.',\n\t    init(parser, reporter) {\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            let attr;\n\t            let attrName;\n\t            const col = event.col + event.tagName.length + 1;\n\t            for (let i = 0, l = attrs.length; i < l; i++) {\n\t                attr = attrs[i];\n\t                attrName = attr.name;\n\t                if (/^(id|class)$/i.test(attrName)) {\n\t                    if (/(^|[-_])ad([-_]|$)/i.test(attr.value)) {\n\t                        reporter.warn(`The value of attribute ${attrName} cannot use the ad keyword.`, event.line, col + attr.index, this, attr.raw);\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar idClassValue = {};\n\n\tObject.defineProperty(idClassValue, \"__esModule\", { value: true });\n\tidClassValue.default = {\n\t    id: 'id-class-value',\n\t    description: 'The id and class attribute values must meet the specified rules.',\n\t    init(parser, reporter, options) {\n\t        const arrRules = {\n\t            underline: {\n\t                regId: /^[a-z\\d]+(_[a-z\\d]+)*$/,\n\t                message: 'The id and class attribute values must be in lowercase and split by an underscore.',\n\t            },\n\t            dash: {\n\t                regId: /^[a-z\\d]+(-[a-z\\d]+)*$/,\n\t                message: 'The id and class attribute values must be in lowercase and split by a dash.',\n\t            },\n\t            hump: {\n\t                regId: /^[a-z][a-zA-Z\\d]*([A-Z][a-zA-Z\\d]*)*$/,\n\t                message: 'The id and class attribute values must meet the camelCase style.',\n\t            },\n\t        };\n\t        let rule;\n\t        if (typeof options === 'string') {\n\t            rule = arrRules[options];\n\t        }\n\t        else {\n\t            rule = options;\n\t        }\n\t        if (typeof rule === 'object' && rule.regId) {\n\t            let regId = rule.regId;\n\t            const message = rule.message;\n\t            if (!(regId instanceof RegExp)) {\n\t                regId = new RegExp(regId);\n\t            }\n\t            parser.addListener('tagstart', (event) => {\n\t                const attrs = event.attrs;\n\t                let attr;\n\t                const col = event.col + event.tagName.length + 1;\n\t                for (let i = 0, l1 = attrs.length; i < l1; i++) {\n\t                    attr = attrs[i];\n\t                    if (attr.name.toLowerCase() === 'id') {\n\t                        if (regId.test(attr.value) === false) {\n\t                            reporter.warn(message, event.line, col + attr.index, this, attr.raw);\n\t                        }\n\t                    }\n\t                    if (attr.name.toLowerCase() === 'class') {\n\t                        const arrClass = attr.value.split(/\\s+/g);\n\t                        let classValue;\n\t                        for (let j = 0, l2 = arrClass.length; j < l2; j++) {\n\t                            classValue = arrClass[j];\n\t                            if (classValue && regId.test(classValue) === false) {\n\t                                reporter.warn(message, event.line, col + attr.index, this, classValue);\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t            });\n\t        }\n\t    },\n\t};\n\n\tvar idUnique = {};\n\n\tObject.defineProperty(idUnique, \"__esModule\", { value: true });\n\tidUnique.default = {\n\t    id: 'id-unique',\n\t    description: 'The value of id attributes must be unique.',\n\t    init(parser, reporter) {\n\t        const mapIdCount = {};\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            let attr;\n\t            let id;\n\t            const col = event.col + event.tagName.length + 1;\n\t            for (let i = 0, l = attrs.length; i < l; i++) {\n\t                attr = attrs[i];\n\t                if (attr.name.toLowerCase() === 'id') {\n\t                    id = attr.value;\n\t                    if (id) {\n\t                        if (mapIdCount[id] === undefined) {\n\t                            mapIdCount[id] = 1;\n\t                        }\n\t                        else {\n\t                            mapIdCount[id]++;\n\t                        }\n\t                        if (mapIdCount[id] > 1) {\n\t                            reporter.error(`The id value [ ${id} ] must be unique.`, event.line, col + attr.index, this, attr.raw);\n\t                        }\n\t                    }\n\t                    break;\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar inlineScriptDisabled = {};\n\n\tObject.defineProperty(inlineScriptDisabled, \"__esModule\", { value: true });\n\tinlineScriptDisabled.default = {\n\t    id: 'inline-script-disabled',\n\t    description: 'Inline script cannot be used.',\n\t    init(parser, reporter) {\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            let attr;\n\t            const col = event.col + event.tagName.length + 1;\n\t            let attrName;\n\t            const reEvent = /^on(unload|message|submit|select|scroll|resize|mouseover|mouseout|mousemove|mouseleave|mouseenter|mousedown|load|keyup|keypress|keydown|focus|dblclick|click|change|blur|error)$/i;\n\t            for (let i = 0, l = attrs.length; i < l; i++) {\n\t                attr = attrs[i];\n\t                attrName = attr.name.toLowerCase();\n\t                if (reEvent.test(attrName) === true) {\n\t                    reporter.warn(`Inline script [ ${attr.raw} ] cannot be used.`, event.line, col + attr.index, this, attr.raw);\n\t                }\n\t                else if (attrName === 'src' || attrName === 'href') {\n\t                    if (/^\\s*javascript:/i.test(attr.value)) {\n\t                        reporter.warn(`Inline script [ ${attr.raw} ] cannot be used.`, event.line, col + attr.index, this, attr.raw);\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar inlineStyleDisabled = {};\n\n\tObject.defineProperty(inlineStyleDisabled, \"__esModule\", { value: true });\n\tinlineStyleDisabled.default = {\n\t    id: 'inline-style-disabled',\n\t    description: 'Inline style cannot be used.',\n\t    init(parser, reporter) {\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            let attr;\n\t            const col = event.col + event.tagName.length + 1;\n\t            for (let i = 0, l = attrs.length; i < l; i++) {\n\t                attr = attrs[i];\n\t                if (attr.name.toLowerCase() === 'style') {\n\t                    reporter.warn(`Inline style [ ${attr.raw} ] cannot be used.`, event.line, col + attr.index, this, attr.raw);\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar inputRequiresLabel = {};\n\n\tObject.defineProperty(inputRequiresLabel, \"__esModule\", { value: true });\n\tinputRequiresLabel.default = {\n\t    id: 'input-requires-label',\n\t    description: 'All [ input ] tags must have a corresponding [ label ] tag. ',\n\t    init(parser, reporter) {\n\t        const labelTags = [];\n\t        const inputTags = [];\n\t        parser.addListener('tagstart', (event) => {\n\t            const tagName = event.tagName.toLowerCase();\n\t            const mapAttrs = parser.getMapAttrs(event.attrs);\n\t            const col = event.col + tagName.length + 1;\n\t            if (tagName === 'input') {\n\t                if (mapAttrs['type'] !== 'hidden') {\n\t                    inputTags.push({ event: event, col: col, id: mapAttrs['id'] });\n\t                }\n\t            }\n\t            if (tagName === 'label') {\n\t                if ('for' in mapAttrs && mapAttrs['for'] !== '') {\n\t                    labelTags.push({ event: event, col: col, forValue: mapAttrs['for'] });\n\t                }\n\t            }\n\t        });\n\t        parser.addListener('end', () => {\n\t            inputTags.forEach((inputTag) => {\n\t                if (!hasMatchingLabelTag(inputTag)) {\n\t                    reporter.warn('No matching [ label ] tag found.', inputTag.event.line, inputTag.col, this, inputTag.event.raw);\n\t                }\n\t            });\n\t        });\n\t        function hasMatchingLabelTag(inputTag) {\n\t            let found = false;\n\t            labelTags.forEach((labelTag) => {\n\t                if (inputTag.id && inputTag.id === labelTag.forValue) {\n\t                    found = true;\n\t                }\n\t            });\n\t            return found;\n\t        }\n\t    },\n\t};\n\n\tvar scriptDisabled = {};\n\n\tObject.defineProperty(scriptDisabled, \"__esModule\", { value: true });\n\tscriptDisabled.default = {\n\t    id: 'script-disabled',\n\t    description: 'The <script> tag cannot be used.',\n\t    init(parser, reporter) {\n\t        parser.addListener('tagstart', (event) => {\n\t            if (event.tagName.toLowerCase() === 'script') {\n\t                reporter.error('The <script> tag cannot be used.', event.line, event.col, this, event.raw);\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar spaceTabMixedDisabled = {};\n\n\tObject.defineProperty(spaceTabMixedDisabled, \"__esModule\", { value: true });\n\tspaceTabMixedDisabled.default = {\n\t    id: 'space-tab-mixed-disabled',\n\t    description: 'Do not mix tabs and spaces for indentation.',\n\t    init(parser, reporter, options) {\n\t        let indentMode = 'nomix';\n\t        let spaceLengthRequire = null;\n\t        if (typeof options === 'string') {\n\t            const match = /^([a-z]+)(\\d+)?/.exec(options);\n\t            if (match) {\n\t                indentMode = match[1];\n\t                spaceLengthRequire = match[2] && parseInt(match[2], 10);\n\t            }\n\t        }\n\t        parser.addListener('text', (event) => {\n\t            const raw = event.raw;\n\t            const reMixed = /(^|\\r?\\n)([ \\t]+)/g;\n\t            let match;\n\t            while ((match = reMixed.exec(raw))) {\n\t                const fixedPos = parser.fixPos(event, match.index + match[1].length);\n\t                if (fixedPos.col !== 1) {\n\t                    continue;\n\t                }\n\t                const whiteSpace = match[2];\n\t                if (indentMode === 'space') {\n\t                    if (spaceLengthRequire) {\n\t                        if (/^ +$/.test(whiteSpace) === false ||\n\t                            whiteSpace.length % spaceLengthRequire !== 0) {\n\t                            reporter.warn(`Please use space for indentation and keep ${spaceLengthRequire} length.`, fixedPos.line, 1, this, event.raw);\n\t                        }\n\t                    }\n\t                    else {\n\t                        if (/^ +$/.test(whiteSpace) === false) {\n\t                            reporter.warn('Please use space for indentation.', fixedPos.line, 1, this, event.raw);\n\t                        }\n\t                    }\n\t                }\n\t                else if (indentMode === 'tab' && /^\\t+$/.test(whiteSpace) === false) {\n\t                    reporter.warn('Please use tab for indentation.', fixedPos.line, 1, this, event.raw);\n\t                }\n\t                else if (/ +\\t|\\t+ /.test(whiteSpace) === true) {\n\t                    reporter.warn('Do not mix tabs and spaces for indentation.', fixedPos.line, 1, this, event.raw);\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar specCharEscape = {};\n\n\tObject.defineProperty(specCharEscape, \"__esModule\", { value: true });\n\tspecCharEscape.default = {\n\t    id: 'spec-char-escape',\n\t    description: 'Special characters must be escaped.',\n\t    init(parser, reporter) {\n\t        parser.addListener('text', (event) => {\n\t            const raw = event.raw;\n\t            const reSpecChar = /([<>])|( \\& )/g;\n\t            let match;\n\t            while ((match = reSpecChar.exec(raw))) {\n\t                const fixedPos = parser.fixPos(event, match.index);\n\t                reporter.error(`Special characters must be escaped : [ ${match[0]} ].`, fixedPos.line, fixedPos.col, this, event.raw);\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar srcNotEmpty = {};\n\n\tObject.defineProperty(srcNotEmpty, \"__esModule\", { value: true });\n\tsrcNotEmpty.default = {\n\t    id: 'src-not-empty',\n\t    description: 'The src attribute of an img(script,link) must have a value.',\n\t    init(parser, reporter) {\n\t        parser.addListener('tagstart', (event) => {\n\t            const tagName = event.tagName;\n\t            const attrs = event.attrs;\n\t            let attr;\n\t            const col = event.col + tagName.length + 1;\n\t            for (let i = 0, l = attrs.length; i < l; i++) {\n\t                attr = attrs[i];\n\t                if (((/^(img|script|embed|bgsound|iframe)$/.test(tagName) === true &&\n\t                    attr.name === 'src') ||\n\t                    (tagName === 'link' && attr.name === 'href') ||\n\t                    (tagName === 'object' && attr.name === 'data')) &&\n\t                    attr.value === '') {\n\t                    reporter.error(`The attribute [ ${attr.name} ] of the tag [ ${tagName} ] must have a value.`, event.line, col + attr.index, this, attr.raw);\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar styleDisabled = {};\n\n\tObject.defineProperty(styleDisabled, \"__esModule\", { value: true });\n\tstyleDisabled.default = {\n\t    id: 'style-disabled',\n\t    description: '<style> tags cannot be used.',\n\t    init(parser, reporter) {\n\t        parser.addListener('tagstart', (event) => {\n\t            if (event.tagName.toLowerCase() === 'style') {\n\t                reporter.warn('The <style> tag cannot be used.', event.line, event.col, this, event.raw);\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar tagPair = {};\n\n\tObject.defineProperty(tagPair, \"__esModule\", { value: true });\n\ttagPair.default = {\n\t    id: 'tag-pair',\n\t    description: 'Tag must be paired.',\n\t    init(parser, reporter) {\n\t        const stack = [];\n\t        const mapEmptyTags = parser.makeMap('area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,track,command,source,keygen,wbr');\n\t        parser.addListener('tagstart', (event) => {\n\t            const tagName = event.tagName.toLowerCase();\n\t            if (mapEmptyTags[tagName] === undefined && !event.close) {\n\t                stack.push({\n\t                    tagName: tagName,\n\t                    line: event.line,\n\t                    raw: event.raw,\n\t                });\n\t            }\n\t        });\n\t        parser.addListener('tagend', (event) => {\n\t            const tagName = event.tagName.toLowerCase();\n\t            let pos;\n\t            for (pos = stack.length - 1; pos >= 0; pos--) {\n\t                if (stack[pos].tagName === tagName) {\n\t                    break;\n\t                }\n\t            }\n\t            if (pos >= 0) {\n\t                const arrTags = [];\n\t                for (let i = stack.length - 1; i > pos; i--) {\n\t                    arrTags.push(`</${stack[i].tagName}>`);\n\t                }\n\t                if (arrTags.length > 0) {\n\t                    const lastEvent = stack[stack.length - 1];\n\t                    reporter.error(`Tag must be paired, missing: [ ${arrTags.join('')} ], start tag match failed [ ${lastEvent.raw} ] on line ${lastEvent.line}.`, event.line, event.col, this, event.raw);\n\t                }\n\t                stack.length = pos;\n\t            }\n\t            else {\n\t                reporter.error(`Tag must be paired, no start tag: [ ${event.raw} ]`, event.line, event.col, this, event.raw);\n\t            }\n\t        });\n\t        parser.addListener('end', (event) => {\n\t            const arrTags = [];\n\t            for (let i = stack.length - 1; i >= 0; i--) {\n\t                arrTags.push(`</${stack[i].tagName}>`);\n\t            }\n\t            if (arrTags.length > 0) {\n\t                const lastEvent = stack[stack.length - 1];\n\t                reporter.error(`Tag must be paired, missing: [ ${arrTags.join('')} ], open tag match failed [ ${lastEvent.raw} ] on line ${lastEvent.line}.`, event.line, event.col, this, '');\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar tagSelfClose = {};\n\n\tObject.defineProperty(tagSelfClose, \"__esModule\", { value: true });\n\ttagSelfClose.default = {\n\t    id: 'tag-self-close',\n\t    description: 'Empty tags must be self closed.',\n\t    init(parser, reporter) {\n\t        const mapEmptyTags = parser.makeMap('area,base,basefont,bgsound,br,col,frame,hr,img,input,isindex,link,meta,param,embed,track,command,source,keygen,wbr');\n\t        parser.addListener('tagstart', (event) => {\n\t            const tagName = event.tagName.toLowerCase();\n\t            if (mapEmptyTags[tagName] !== undefined) {\n\t                if (!event.close) {\n\t                    reporter.warn(`The empty tag : [ ${tagName} ] must be self closed.`, event.line, event.col, this, event.raw);\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar emptyTagNotSelfClosed = {};\n\n\tObject.defineProperty(emptyTagNotSelfClosed, \"__esModule\", { value: true });\n\temptyTagNotSelfClosed.default = {\n\t    id: 'empty-tag-not-self-closed',\n\t    description: 'Empty tags must not use self closed syntax.',\n\t    init(parser, reporter) {\n\t        const mapEmptyTags = parser.makeMap('area,base,basefont,bgsound,br,col,frame,hr,img,input,isindex,link,meta,param,embed,track,command,source,keygen,wbr');\n\t        parser.addListener('tagstart', (event) => {\n\t            const tagName = event.tagName.toLowerCase();\n\t            if (mapEmptyTags[tagName] !== undefined) {\n\t                if (event.close) {\n\t                    reporter.error(`The empty tag : [ ${tagName} ] must not use self closed syntax.`, event.line, event.col, this, event.raw);\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar tagnameLowercase = {};\n\n\tObject.defineProperty(tagnameLowercase, \"__esModule\", { value: true });\n\ttagnameLowercase.default = {\n\t    id: 'tagname-lowercase',\n\t    description: 'All html element names must be in lowercase.',\n\t    init(parser, reporter, options) {\n\t        const exceptions = Array.isArray(options)\n\t            ? options\n\t            : [];\n\t        parser.addListener('tagstart,tagend', (event) => {\n\t            const tagName = event.tagName;\n\t            if (exceptions.indexOf(tagName) === -1 &&\n\t                tagName !== tagName.toLowerCase()) {\n\t                reporter.error(`The html element name of [ ${tagName} ] must be in lowercase.`, event.line, event.col, this, event.raw);\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar tagnameSpecialchars = {};\n\n\tObject.defineProperty(tagnameSpecialchars, \"__esModule\", { value: true });\n\ttagnameSpecialchars.default = {\n\t    id: 'tagname-specialchars',\n\t    description: 'All special characters must be escaped.',\n\t    init(parser, reporter) {\n\t        const specialchars = /[^a-zA-Z0-9\\-:_]/;\n\t        parser.addListener('tagstart,tagend', (event) => {\n\t            const tagName = event.tagName;\n\t            if (specialchars.test(tagName)) {\n\t                reporter.error(`The html element name of [ ${tagName} ] contains special character.`, event.line, event.col, this, event.raw);\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar titleRequire = {};\n\n\tObject.defineProperty(titleRequire, \"__esModule\", { value: true });\n\ttitleRequire.default = {\n\t    id: 'title-require',\n\t    description: '<title> must be present in <head> tag.',\n\t    init(parser, reporter) {\n\t        let headBegin = false;\n\t        let hasTitle = false;\n\t        const onTagStart = (event) => {\n\t            const tagName = event.tagName.toLowerCase();\n\t            if (tagName === 'head') {\n\t                headBegin = true;\n\t            }\n\t            else if (tagName === 'title' && headBegin) {\n\t                hasTitle = true;\n\t            }\n\t        };\n\t        const onTagEnd = (event) => {\n\t            const tagName = event.tagName.toLowerCase();\n\t            if (hasTitle && tagName === 'title') {\n\t                const lastEvent = event.lastEvent;\n\t                if (lastEvent.type !== 'text' ||\n\t                    (lastEvent.type === 'text' && /^\\s*$/.test(lastEvent.raw) === true)) {\n\t                    reporter.error('<title></title> must not be empty.', event.line, event.col, this, event.raw);\n\t                }\n\t            }\n\t            else if (tagName === 'head') {\n\t                if (hasTitle === false) {\n\t                    reporter.error('<title> must be present in <head> tag.', event.line, event.col, this, event.raw);\n\t                }\n\t                parser.removeListener('tagstart', onTagStart);\n\t                parser.removeListener('tagend', onTagEnd);\n\t            }\n\t        };\n\t        parser.addListener('tagstart', onTagStart);\n\t        parser.addListener('tagend', onTagEnd);\n\t    },\n\t};\n\n\tvar tagsCheck = {};\n\n\tObject.defineProperty(tagsCheck, \"__esModule\", { value: true });\n\tlet tagsTypings = {\n\t    a: {\n\t        selfclosing: false,\n\t        attrsRequired: ['href', 'title'],\n\t        redundantAttrs: ['alt'],\n\t    },\n\t    div: {\n\t        selfclosing: false,\n\t    },\n\t    main: {\n\t        selfclosing: false,\n\t        redundantAttrs: ['role'],\n\t    },\n\t    nav: {\n\t        selfclosing: false,\n\t        redundantAttrs: ['role'],\n\t    },\n\t    script: {\n\t        attrsOptional: [\n\t            ['async', 'async'],\n\t            ['defer', 'defer'],\n\t        ],\n\t    },\n\t    img: {\n\t        selfclosing: true,\n\t        attrsRequired: ['src', 'alt', 'title'],\n\t    },\n\t};\n\ttagsCheck.default = {\n\t    id: 'tags-check',\n\t    description: 'Checks html tags.',\n\t    init(parser, reporter, options) {\n\t        tagsTypings = Object.assign(Object.assign({}, tagsTypings), options);\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            const col = event.col + event.tagName.length + 1;\n\t            const tagName = event.tagName.toLowerCase();\n\t            if (tagsTypings[tagName]) {\n\t                const currentTagType = tagsTypings[tagName];\n\t                if (currentTagType.selfclosing === true && !event.close) {\n\t                    reporter.warn(`The <${tagName}> tag must be selfclosing.`, event.line, event.col, this, event.raw);\n\t                }\n\t                else if (currentTagType.selfclosing === false && event.close) {\n\t                    reporter.warn(`The <${tagName}> tag must not be selfclosing.`, event.line, event.col, this, event.raw);\n\t                }\n\t                if (Array.isArray(currentTagType.attrsRequired)) {\n\t                    const attrsRequired = currentTagType.attrsRequired;\n\t                    attrsRequired.forEach((id) => {\n\t                        if (Array.isArray(id)) {\n\t                            const copyOfId = id.map((a) => a);\n\t                            const realID = copyOfId.shift();\n\t                            const values = copyOfId;\n\t                            if (attrs.some((attr) => attr.name === realID)) {\n\t                                attrs.forEach((attr) => {\n\t                                    if (attr.name === realID &&\n\t                                        values.indexOf(attr.value) === -1) {\n\t                                        reporter.error(`The <${tagName}> tag must have attr '${realID}' with one value of '${values.join(\"' or '\")}'.`, event.line, col, this, event.raw);\n\t                                    }\n\t                                });\n\t                            }\n\t                            else {\n\t                                reporter.error(`The <${tagName}> tag must have attr '${realID}'.`, event.line, col, this, event.raw);\n\t                            }\n\t                        }\n\t                        else if (!attrs.some((attr) => id.split('|').indexOf(attr.name) !== -1)) {\n\t                            reporter.error(`The <${tagName}> tag must have attr '${id}'.`, event.line, col, this, event.raw);\n\t                        }\n\t                    });\n\t                }\n\t                if (Array.isArray(currentTagType.attrsOptional)) {\n\t                    const attrsOptional = currentTagType.attrsOptional;\n\t                    attrsOptional.forEach((id) => {\n\t                        if (Array.isArray(id)) {\n\t                            const copyOfId = id.map((a) => a);\n\t                            const realID = copyOfId.shift();\n\t                            const values = copyOfId;\n\t                            if (attrs.some((attr) => attr.name === realID)) {\n\t                                attrs.forEach((attr) => {\n\t                                    if (attr.name === realID &&\n\t                                        values.indexOf(attr.value) === -1) {\n\t                                        reporter.error(`The <${tagName}> tag must have optional attr '${realID}' with one value of '${values.join(\"' or '\")}'.`, event.line, col, this, event.raw);\n\t                                    }\n\t                                });\n\t                            }\n\t                        }\n\t                    });\n\t                }\n\t                if (Array.isArray(currentTagType.redundantAttrs)) {\n\t                    const redundantAttrs = currentTagType.redundantAttrs;\n\t                    redundantAttrs.forEach((attrName) => {\n\t                        if (attrs.some((attr) => attr.name === attrName)) {\n\t                            reporter.error(`The attr '${attrName}' is redundant for <${tagName}> and should be omitted.`, event.line, col, this, event.raw);\n\t                        }\n\t                    });\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\tvar attrNoUnnecessaryWhitespace = {};\n\n\tObject.defineProperty(attrNoUnnecessaryWhitespace, \"__esModule\", { value: true });\n\tattrNoUnnecessaryWhitespace.default = {\n\t    id: 'attr-no-unnecessary-whitespace',\n\t    description: 'No spaces between attribute names and values.',\n\t    init(parser, reporter, options) {\n\t        const exceptions = Array.isArray(options) ? options : [];\n\t        parser.addListener('tagstart', (event) => {\n\t            const attrs = event.attrs;\n\t            const col = event.col + event.tagName.length + 1;\n\t            for (let i = 0; i < attrs.length; i++) {\n\t                if (exceptions.indexOf(attrs[i].name) === -1) {\n\t                    const match = /(\\s*)=(\\s*)/.exec(attrs[i].raw.trim());\n\t                    if (match && (match[1].length !== 0 || match[2].length !== 0)) {\n\t                        reporter.error(`The attribute '${attrs[i].name}' must not have spaces between the name and value.`, event.line, col + attrs[i].index, this, attrs[i].raw);\n\t                    }\n\t                }\n\t            }\n\t        });\n\t    },\n\t};\n\n\t(function (exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.attrNoUnnecessaryWhitespace = exports.tagsCheck = exports.titleRequire = exports.tagnameSpecialChars = exports.tagnameLowercase = exports.emptyTagNotSelfClosed = exports.tagSelfClose = exports.tagPair = exports.styleDisabled = exports.srcNotEmpty = exports.specCharEscape = exports.spaceTabMixedDisabled = exports.scriptDisabled = exports.inputRequiresLabel = exports.inlineStyleDisabled = exports.inlineScriptDisabled = exports.idUnique = exports.idClassValue = exports.idClsasAdDisabled = exports.htmlLangRequire = exports.hrefAbsOrRel = exports.headScriptDisabled = exports.doctypeHTML5 = exports.doctypeFirst = exports.attrWhitespace = exports.attrValueSingleQuotes = exports.attrValueNotEmpty = exports.attrValueDoubleQuotes = exports.attrUnsafeChars = exports.attrNoDuplication = exports.attrSort = exports.attrLowercase = exports.altRequire = void 0;\n\tvar alt_require_1 = altRequire;\n\tObject.defineProperty(exports, \"altRequire\", { enumerable: true, get: function () { return alt_require_1.default; } });\n\tvar attr_lowercase_1 = attrLowercase;\n\tObject.defineProperty(exports, \"attrLowercase\", { enumerable: true, get: function () { return attr_lowercase_1.default; } });\n\tvar attr_sorted_1 = attrSorted;\n\tObject.defineProperty(exports, \"attrSort\", { enumerable: true, get: function () { return attr_sorted_1.default; } });\n\tvar attr_no_duplication_1 = attrNoDuplication;\n\tObject.defineProperty(exports, \"attrNoDuplication\", { enumerable: true, get: function () { return attr_no_duplication_1.default; } });\n\tvar attr_unsafe_chars_1 = attrUnsafeChars;\n\tObject.defineProperty(exports, \"attrUnsafeChars\", { enumerable: true, get: function () { return attr_unsafe_chars_1.default; } });\n\tvar attr_value_double_quotes_1 = attrValueDoubleQuotes;\n\tObject.defineProperty(exports, \"attrValueDoubleQuotes\", { enumerable: true, get: function () { return attr_value_double_quotes_1.default; } });\n\tvar attr_value_not_empty_1 = attrValueNotEmpty;\n\tObject.defineProperty(exports, \"attrValueNotEmpty\", { enumerable: true, get: function () { return attr_value_not_empty_1.default; } });\n\tvar attr_value_single_quotes_1 = attrValueSingleQuotes;\n\tObject.defineProperty(exports, \"attrValueSingleQuotes\", { enumerable: true, get: function () { return attr_value_single_quotes_1.default; } });\n\tvar attr_whitespace_1 = attrWhitespace;\n\tObject.defineProperty(exports, \"attrWhitespace\", { enumerable: true, get: function () { return attr_whitespace_1.default; } });\n\tvar doctype_first_1 = doctypeFirst;\n\tObject.defineProperty(exports, \"doctypeFirst\", { enumerable: true, get: function () { return doctype_first_1.default; } });\n\tvar doctype_html5_1 = doctypeHtml5;\n\tObject.defineProperty(exports, \"doctypeHTML5\", { enumerable: true, get: function () { return doctype_html5_1.default; } });\n\tvar head_script_disabled_1 = headScriptDisabled;\n\tObject.defineProperty(exports, \"headScriptDisabled\", { enumerable: true, get: function () { return head_script_disabled_1.default; } });\n\tvar href_abs_or_rel_1 = hrefAbsOrRel;\n\tObject.defineProperty(exports, \"hrefAbsOrRel\", { enumerable: true, get: function () { return href_abs_or_rel_1.default; } });\n\tvar html_lang_require_1 = htmlLangRequire;\n\tObject.defineProperty(exports, \"htmlLangRequire\", { enumerable: true, get: function () { return html_lang_require_1.default; } });\n\tvar id_class_ad_disabled_1 = idClassAdDisabled;\n\tObject.defineProperty(exports, \"idClsasAdDisabled\", { enumerable: true, get: function () { return id_class_ad_disabled_1.default; } });\n\tvar id_class_value_1 = idClassValue;\n\tObject.defineProperty(exports, \"idClassValue\", { enumerable: true, get: function () { return id_class_value_1.default; } });\n\tvar id_unique_1 = idUnique;\n\tObject.defineProperty(exports, \"idUnique\", { enumerable: true, get: function () { return id_unique_1.default; } });\n\tvar inline_script_disabled_1 = inlineScriptDisabled;\n\tObject.defineProperty(exports, \"inlineScriptDisabled\", { enumerable: true, get: function () { return inline_script_disabled_1.default; } });\n\tvar inline_style_disabled_1 = inlineStyleDisabled;\n\tObject.defineProperty(exports, \"inlineStyleDisabled\", { enumerable: true, get: function () { return inline_style_disabled_1.default; } });\n\tvar input_requires_label_1 = inputRequiresLabel;\n\tObject.defineProperty(exports, \"inputRequiresLabel\", { enumerable: true, get: function () { return input_requires_label_1.default; } });\n\tvar script_disabled_1 = scriptDisabled;\n\tObject.defineProperty(exports, \"scriptDisabled\", { enumerable: true, get: function () { return script_disabled_1.default; } });\n\tvar space_tab_mixed_disabled_1 = spaceTabMixedDisabled;\n\tObject.defineProperty(exports, \"spaceTabMixedDisabled\", { enumerable: true, get: function () { return space_tab_mixed_disabled_1.default; } });\n\tvar spec_char_escape_1 = specCharEscape;\n\tObject.defineProperty(exports, \"specCharEscape\", { enumerable: true, get: function () { return spec_char_escape_1.default; } });\n\tvar src_not_empty_1 = srcNotEmpty;\n\tObject.defineProperty(exports, \"srcNotEmpty\", { enumerable: true, get: function () { return src_not_empty_1.default; } });\n\tvar style_disabled_1 = styleDisabled;\n\tObject.defineProperty(exports, \"styleDisabled\", { enumerable: true, get: function () { return style_disabled_1.default; } });\n\tvar tag_pair_1 = tagPair;\n\tObject.defineProperty(exports, \"tagPair\", { enumerable: true, get: function () { return tag_pair_1.default; } });\n\tvar tag_self_close_1 = tagSelfClose;\n\tObject.defineProperty(exports, \"tagSelfClose\", { enumerable: true, get: function () { return tag_self_close_1.default; } });\n\tvar empty_tag_not_self_closed_1 = emptyTagNotSelfClosed;\n\tObject.defineProperty(exports, \"emptyTagNotSelfClosed\", { enumerable: true, get: function () { return empty_tag_not_self_closed_1.default; } });\n\tvar tagname_lowercase_1 = tagnameLowercase;\n\tObject.defineProperty(exports, \"tagnameLowercase\", { enumerable: true, get: function () { return tagname_lowercase_1.default; } });\n\tvar tagname_specialchars_1 = tagnameSpecialchars;\n\tObject.defineProperty(exports, \"tagnameSpecialChars\", { enumerable: true, get: function () { return tagname_specialchars_1.default; } });\n\tvar title_require_1 = titleRequire;\n\tObject.defineProperty(exports, \"titleRequire\", { enumerable: true, get: function () { return title_require_1.default; } });\n\tvar tags_check_1 = tagsCheck;\n\tObject.defineProperty(exports, \"tagsCheck\", { enumerable: true, get: function () { return tags_check_1.default; } });\n\tvar attr_no_unnecessary_whitespace_1 = attrNoUnnecessaryWhitespace;\n\tObject.defineProperty(exports, \"attrNoUnnecessaryWhitespace\", { enumerable: true, get: function () { return attr_no_unnecessary_whitespace_1.default; } });\n\n\t}(rules));\n\n\t(function (exports) {\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\n\texports.HTMLParser = exports.Reporter = exports.HTMLRules = exports.HTMLHint = void 0;\n\tconst htmlparser_1 = htmlparser;\n\texports.HTMLParser = htmlparser_1.default;\n\tconst reporter_1 = reporter;\n\texports.Reporter = reporter_1.default;\n\tconst HTMLRules = rules;\n\texports.HTMLRules = HTMLRules;\n\tclass HTMLHintCore {\n\t    constructor() {\n\t        this.rules = {};\n\t        this.defaultRuleset = {\n\t            'tagname-lowercase': true,\n\t            'attr-lowercase': true,\n\t            'attr-value-double-quotes': true,\n\t            'doctype-first': true,\n\t            'tag-pair': true,\n\t            'spec-char-escape': true,\n\t            'id-unique': true,\n\t            'src-not-empty': true,\n\t            'attr-no-duplication': true,\n\t            'title-require': true,\n\t        };\n\t    }\n\t    addRule(rule) {\n\t        this.rules[rule.id] = rule;\n\t    }\n\t    verify(html, ruleset = this.defaultRuleset) {\n\t        if (Object.keys(ruleset).length === 0) {\n\t            ruleset = this.defaultRuleset;\n\t        }\n\t        html = html.replace(/^\\s*<!--\\s*htmlhint\\s+([^\\r\\n]+?)\\s*-->/i, (all, strRuleset) => {\n\t            strRuleset.replace(/(?:^|,)\\s*([^:,]+)\\s*(?:\\:\\s*([^,\\s]+))?/g, (all, ruleId, value) => {\n\t                ruleset[ruleId] =\n\t                    value !== undefined && value.length > 0 ? JSON.parse(value) : true;\n\t                return '';\n\t            });\n\t            return '';\n\t        });\n\t        const parser = new htmlparser_1.default();\n\t        const reporter = new reporter_1.default(html, ruleset);\n\t        const rules = this.rules;\n\t        let rule;\n\t        for (const id in ruleset) {\n\t            rule = rules[id];\n\t            if (rule !== undefined && ruleset[id] !== false) {\n\t                rule.init(parser, reporter, ruleset[id]);\n\t            }\n\t        }\n\t        parser.parse(html);\n\t        return reporter.messages;\n\t    }\n\t    format(arrMessages, options = {}) {\n\t        const arrLogs = [];\n\t        const colors = {\n\t            white: '',\n\t            grey: '',\n\t            red: '',\n\t            reset: '',\n\t        };\n\t        if (options.colors) {\n\t            colors.white = '\\x1b[37m';\n\t            colors.grey = '\\x1b[90m';\n\t            colors.red = '\\x1b[31m';\n\t            colors.reset = '\\x1b[39m';\n\t        }\n\t        const indent = options.indent || 0;\n\t        arrMessages.forEach((hint) => {\n\t            const leftWindow = 40;\n\t            const rightWindow = leftWindow + 20;\n\t            let evidence = hint.evidence;\n\t            const line = hint.line;\n\t            const col = hint.col;\n\t            const evidenceCount = evidence.length;\n\t            let leftCol = col > leftWindow + 1 ? col - leftWindow : 1;\n\t            let rightCol = evidence.length > col + rightWindow ? col + rightWindow : evidenceCount;\n\t            if (col < leftWindow + 1) {\n\t                rightCol += leftWindow - col + 1;\n\t            }\n\t            evidence = evidence.replace(/\\t/g, ' ').substring(leftCol - 1, rightCol);\n\t            if (leftCol > 1) {\n\t                evidence = `...${evidence}`;\n\t                leftCol -= 3;\n\t            }\n\t            if (rightCol < evidenceCount) {\n\t                evidence += '...';\n\t            }\n\t            arrLogs.push(`${colors.white + repeatStr(indent)}L${line} |${colors.grey}${evidence}${colors.reset}`);\n\t            let pointCol = col - leftCol;\n\t            const match = evidence.substring(0, pointCol).match(/[^\\u0000-\\u00ff]/g);\n\t            if (match !== null) {\n\t                pointCol += match.length;\n\t            }\n\t            arrLogs.push(`${colors.white +\n                repeatStr(indent) +\n                repeatStr(String(line).length + 3 + pointCol)}^ ${colors.red}${hint.message} (${hint.rule.id})${colors.reset}`);\n\t        });\n\t        return arrLogs;\n\t    }\n\t}\n\tfunction repeatStr(n, str) {\n\t    return new Array(n + 1).join(str || ' ');\n\t}\n\texports.HTMLHint = new HTMLHintCore();\n\tObject.keys(HTMLRules).forEach((key) => {\n\t    exports.HTMLHint.addRule(HTMLRules[key]);\n\t});\n\n\t}(core$1));\n\n\tvar core = /*@__PURE__*/getDefaultExportFromCjs(core$1);\n\n\treturn core;\n\n}));\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// Depends on csslint.js from https://github.com/stubbornella/csslint\n\n// declare global: CSSLint\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"lint\", \"css\", function(text, options) {\n  var found = [];\n  if (!window.CSSLint) {\n    if (window.console) {\n        window.console.error(\"Error: window.CSSLint not defined, CodeMirror CSS linting cannot run.\");\n    }\n    return found;\n  }\n  var results = CSSLint.verify(text, options), messages = results.messages, message = null;\n  for ( var i = 0; i < messages.length; i++) {\n    message = messages[i];\n    var startLine = message.line -1, endLine = message.line -1, startCol = message.col -1, endCol = message.col;\n    found.push({\n      from: CodeMirror.Pos(startLine, startCol),\n      to: CodeMirror.Pos(endLine, endCol),\n      message: message.message,\n      severity : message.type\n    });\n  }\n  return found;\n});\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// declare global: DOMRect\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\n  // This is the old interface, kept around for now to stay\n  // backwards-compatible.\n  CodeMirror.showHint = function(cm, getHints, options) {\n    if (!getHints) return cm.showHint(options);\n    if (options && options.async) getHints.async = true;\n    var newOpts = {hint: getHints};\n    if (options) for (var prop in options) newOpts[prop] = options[prop];\n    return cm.showHint(newOpts);\n  };\n\n  CodeMirror.defineExtension(\"showHint\", function(options) {\n    options = parseOptions(this, this.getCursor(\"start\"), options);\n    var selections = this.listSelections()\n    if (selections.length > 1) return;\n    // By default, don't allow completion when something is selected.\n    // A hint function can have a `supportsSelection` property to\n    // indicate that it can handle selections.\n    if (this.somethingSelected()) {\n      if (!options.hint.supportsSelection) return;\n      // Don't try with cross-line selections\n      for (var i = 0; i < selections.length; i++)\n        if (selections[i].head.line != selections[i].anchor.line) return;\n    }\n\n    if (this.state.completionActive) this.state.completionActive.close();\n    var completion = this.state.completionActive = new Completion(this, options);\n    if (!completion.options.hint) return;\n\n    CodeMirror.signal(this, \"startCompletion\", this);\n    completion.update(true);\n  });\n\n  CodeMirror.defineExtension(\"closeHint\", function() {\n    if (this.state.completionActive) this.state.completionActive.close()\n  })\n\n  function Completion(cm, options) {\n    this.cm = cm;\n    this.options = options;\n    this.widget = null;\n    this.debounce = 0;\n    this.tick = 0;\n    this.startPos = this.cm.getCursor(\"start\");\n    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;\n\n    if (this.options.updateOnCursorActivity) {\n      var self = this;\n      cm.on(\"cursorActivity\", this.activityFunc = function() { self.cursorActivity(); });\n    }\n  }\n\n  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n    return setTimeout(fn, 1000/60);\n  };\n  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\n  Completion.prototype = {\n    close: function() {\n      if (!this.active()) return;\n      this.cm.state.completionActive = null;\n      this.tick = null;\n      if (this.options.updateOnCursorActivity) {\n        this.cm.off(\"cursorActivity\", this.activityFunc);\n      }\n\n      if (this.widget && this.data) CodeMirror.signal(this.data, \"close\");\n      if (this.widget) this.widget.close();\n      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n    },\n\n    active: function() {\n      return this.cm.state.completionActive == this;\n    },\n\n    pick: function(data, i) {\n      var completion = data.list[i], self = this;\n      this.cm.operation(function() {\n        if (completion.hint)\n          completion.hint(self.cm, data, completion);\n        else\n          self.cm.replaceRange(getText(completion), completion.from || data.from,\n                               completion.to || data.to, \"complete\");\n        CodeMirror.signal(data, \"pick\", completion);\n        self.cm.scrollIntoView();\n      });\n      if (this.options.closeOnPick) {\n        this.close();\n      }\n    },\n\n    cursorActivity: function() {\n      if (this.debounce) {\n        cancelAnimationFrame(this.debounce);\n        this.debounce = 0;\n      }\n\n      var identStart = this.startPos;\n      if(this.data) {\n        identStart = this.data.from;\n      }\n\n      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);\n      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||\n          pos.ch < identStart.ch || this.cm.somethingSelected() ||\n          (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {\n        this.close();\n      } else {\n        var self = this;\n        this.debounce = requestAnimationFrame(function() {self.update();});\n        if (this.widget) this.widget.disable();\n      }\n    },\n\n    update: function(first) {\n      if (this.tick == null) return\n      var self = this, myTick = ++this.tick\n      fetchHints(this.options.hint, this.cm, this.options, function(data) {\n        if (self.tick == myTick) self.finishUpdate(data, first)\n      })\n    },\n\n    finishUpdate: function(data, first) {\n      if (this.data) CodeMirror.signal(this.data, \"update\");\n\n      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);\n      if (this.widget) this.widget.close();\n\n      this.data = data;\n\n      if (data && data.list.length) {\n        if (picked && data.list.length == 1) {\n          this.pick(data, 0);\n        } else {\n          this.widget = new Widget(this, data);\n          CodeMirror.signal(data, \"shown\");\n        }\n      }\n    }\n  };\n\n  function parseOptions(cm, pos, options) {\n    var editor = cm.options.hintOptions;\n    var out = {};\n    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];\n    if (editor) for (var prop in editor)\n      if (editor[prop] !== undefined) out[prop] = editor[prop];\n    if (options) for (var prop in options)\n      if (options[prop] !== undefined) out[prop] = options[prop];\n    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)\n    return out;\n  }\n\n  function getText(completion) {\n    if (typeof completion == \"string\") return completion;\n    else return completion.text;\n  }\n\n  function buildKeyMap(completion, handle) {\n    var baseMap = {\n      Up: function() {handle.moveFocus(-1);},\n      Down: function() {handle.moveFocus(1);},\n      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n      Home: function() {handle.setFocus(0);},\n      End: function() {handle.setFocus(handle.length - 1);},\n      Enter: handle.pick,\n      Tab: handle.pick,\n      Esc: handle.close\n    };\n\n    var mac = /Mac/.test(navigator.platform);\n\n    if (mac) {\n      baseMap[\"Ctrl-P\"] = function() {handle.moveFocus(-1);};\n      baseMap[\"Ctrl-N\"] = function() {handle.moveFocus(1);};\n    }\n\n    var custom = completion.options.customKeys;\n    var ourMap = custom ? {} : baseMap;\n    function addBinding(key, val) {\n      var bound;\n      if (typeof val != \"string\")\n        bound = function(cm) { return val(cm, handle); };\n      // This mechanism is deprecated\n      else if (baseMap.hasOwnProperty(val))\n        bound = baseMap[val];\n      else\n        bound = val;\n      ourMap[key] = bound;\n    }\n    if (custom)\n      for (var key in custom) if (custom.hasOwnProperty(key))\n        addBinding(key, custom[key]);\n    var extra = completion.options.extraKeys;\n    if (extra)\n      for (var key in extra) if (extra.hasOwnProperty(key))\n        addBinding(key, extra[key]);\n    return ourMap;\n  }\n\n  function getHintElement(hintsElement, el) {\n    while (el && el != hintsElement) {\n      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n      el = el.parentNode;\n    }\n  }\n\n  function Widget(completion, data) {\n    this.id = \"cm-complete-\" + Math.floor(Math.random(1e6))\n    this.completion = completion;\n    this.data = data;\n    this.picked = false;\n    var widget = this, cm = completion.cm;\n    var ownerDocument = cm.getInputField().ownerDocument;\n    var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;\n\n    var hints = this.hints = ownerDocument.createElement(\"ul\");\n    hints.setAttribute(\"role\", \"listbox\")\n    hints.setAttribute(\"aria-expanded\", \"true\")\n    hints.id = this.id\n    var theme = completion.cm.options.theme;\n    hints.className = \"CodeMirror-hints \" + theme;\n    this.selectedHint = data.selectedHint || 0;\n\n    var completions = data.list;\n    for (var i = 0; i < completions.length; ++i) {\n      var elt = hints.appendChild(ownerDocument.createElement(\"li\")), cur = completions[i];\n      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n      if (cur.className != null) className = cur.className + \" \" + className;\n      elt.className = className;\n      if (i == this.selectedHint) elt.setAttribute(\"aria-selected\", \"true\")\n      elt.id = this.id + \"-\" + i\n      elt.setAttribute(\"role\", \"option\")\n      if (cur.render) cur.render(elt, data, cur);\n      else elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));\n      elt.hintId = i;\n    }\n\n    var container = completion.options.container || ownerDocument.body;\n    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);\n    var left = pos.left, top = pos.bottom, below = true;\n    var offsetLeft = 0, offsetTop = 0;\n    if (container !== ownerDocument.body) {\n      // We offset the cursor position because left and top are relative to the offsetParent's top left corner.\n      var isContainerPositioned = ['absolute', 'relative', 'fixed'].indexOf(parentWindow.getComputedStyle(container).position) !== -1;\n      var offsetParent = isContainerPositioned ? container : container.offsetParent;\n      var offsetParentPosition = offsetParent.getBoundingClientRect();\n      var bodyPosition = ownerDocument.body.getBoundingClientRect();\n      offsetLeft = (offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft);\n      offsetTop = (offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop);\n    }\n    hints.style.left = (left - offsetLeft) + \"px\";\n    hints.style.top = (top - offsetTop) + \"px\";\n\n    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n    var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);\n    var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);\n    container.appendChild(hints);\n    cm.getInputField().setAttribute(\"aria-autocomplete\", \"list\")\n    cm.getInputField().setAttribute(\"aria-owns\", this.id)\n    cm.getInputField().setAttribute(\"aria-activedescendant\", this.id + \"-\" + this.selectedHint)\n\n    var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();\n    var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;\n\n    // Compute in the timeout to avoid reflow on init\n    var startScroll;\n    setTimeout(function() { startScroll = cm.getScrollInfo(); });\n\n    var overlapY = box.bottom - winH;\n    if (overlapY > 0) { // Does not fit below\n      var height = box.bottom - box.top, spaceAbove = box.top - (pos.bottom - pos.top) - 2\n      if (winH - box.top < spaceAbove) { // More room at the top\n        if (height > spaceAbove) hints.style.height = (height = spaceAbove) + \"px\";\n        hints.style.top = ((top = pos.top - height) + offsetTop) + \"px\";\n        below = false;\n      } else {\n        hints.style.height = (winH - box.top - 2) + \"px\";\n      }\n    }\n    var overlapX = box.right - winW;\n    if (scrolls) overlapX += cm.display.nativeBarWidth;\n    if (overlapX > 0) {\n      if (box.right - box.left > winW) {\n        hints.style.width = (winW - 5) + \"px\";\n        overlapX -= (box.right - box.left) - winW;\n      }\n      hints.style.left = (left = Math.max(pos.left - overlapX - offsetLeft, 0)) + \"px\";\n    }\n    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)\n      node.style.paddingRight = cm.display.nativeBarWidth + \"px\"\n\n    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {\n      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n      setFocus: function(n) { widget.changeActive(n); },\n      menuSize: function() { return widget.screenAmount(); },\n      length: completions.length,\n      close: function() { completion.close(); },\n      pick: function() { widget.pick(); },\n      data: data\n    }));\n\n    if (completion.options.closeOnUnfocus) {\n      var closingOnBlur;\n      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n    }\n\n    cm.on(\"scroll\", this.onScroll = function() {\n      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n      if (!startScroll) startScroll = cm.getScrollInfo();\n      var newTop = top + startScroll.top - curScroll.top;\n      var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);\n      if (!below) point += hints.offsetHeight;\n      if (point <= editor.top || point >= editor.bottom) return completion.close();\n      hints.style.top = newTop + \"px\";\n      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n    });\n\n    CodeMirror.on(hints, \"dblclick\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n    });\n\n    CodeMirror.on(hints, \"click\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {\n        widget.changeActive(t.hintId);\n        if (completion.options.completeOnSingleClick) widget.pick();\n      }\n    });\n\n    CodeMirror.on(hints, \"mousedown\", function() {\n      setTimeout(function(){cm.focus();}, 20);\n    });\n\n    // The first hint doesn't need to be scrolled to on init\n    var selectedHintRange = this.getSelectedHintRange();\n    if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {\n      this.scrollToActive();\n    }\n\n    CodeMirror.signal(data, \"select\", completions[this.selectedHint], hints.childNodes[this.selectedHint]);\n    return true;\n  }\n\n  Widget.prototype = {\n    close: function() {\n      if (this.completion.widget != this) return;\n      this.completion.widget = null;\n      if (this.hints.parentNode) this.hints.parentNode.removeChild(this.hints);\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var input = this.completion.cm.getInputField()\n      input.removeAttribute(\"aria-activedescendant\")\n      input.removeAttribute(\"aria-owns\")\n\n      var cm = this.completion.cm;\n      if (this.completion.options.closeOnUnfocus) {\n        cm.off(\"blur\", this.onBlur);\n        cm.off(\"focus\", this.onFocus);\n      }\n      cm.off(\"scroll\", this.onScroll);\n    },\n\n    disable: function() {\n      this.completion.cm.removeKeyMap(this.keyMap);\n      var widget = this;\n      this.keyMap = {Enter: function() { widget.picked = true; }};\n      this.completion.cm.addKeyMap(this.keyMap);\n    },\n\n    pick: function() {\n      this.completion.pick(this.data, this.selectedHint);\n    },\n\n    changeActive: function(i, avoidWrap) {\n      if (i >= this.data.list.length)\n        i = avoidWrap ? this.data.list.length - 1 : 0;\n      else if (i < 0)\n        i = avoidWrap ? 0  : this.data.list.length - 1;\n      if (this.selectedHint == i) return;\n      var node = this.hints.childNodes[this.selectedHint];\n      if (node) {\n        node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n        node.removeAttribute(\"aria-selected\")\n      }\n      node = this.hints.childNodes[this.selectedHint = i];\n      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n      node.setAttribute(\"aria-selected\", \"true\")\n      this.completion.cm.getInputField().setAttribute(\"aria-activedescendant\", node.id)\n      this.scrollToActive()\n      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n    },\n\n    scrollToActive: function() {\n      var selectedHintRange = this.getSelectedHintRange();\n      var node1 = this.hints.childNodes[selectedHintRange.from];\n      var node2 = this.hints.childNodes[selectedHintRange.to];\n      var firstNode = this.hints.firstChild;\n      if (node1.offsetTop < this.hints.scrollTop)\n        this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;\n      else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n        this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;\n    },\n\n    screenAmount: function() {\n      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n    },\n\n    getSelectedHintRange: function() {\n      var margin = this.completion.options.scrollMargin || 0;\n      return {\n        from: Math.max(0, this.selectedHint - margin),\n        to: Math.min(this.data.list.length - 1, this.selectedHint + margin),\n      };\n    }\n  };\n\n  function applicableHelpers(cm, helpers) {\n    if (!cm.somethingSelected()) return helpers\n    var result = []\n    for (var i = 0; i < helpers.length; i++)\n      if (helpers[i].supportsSelection) result.push(helpers[i])\n    return result\n  }\n\n  function fetchHints(hint, cm, options, callback) {\n    if (hint.async) {\n      hint(cm, callback, options)\n    } else {\n      var result = hint(cm, options)\n      if (result && result.then) result.then(callback)\n      else callback(result)\n    }\n  }\n\n  function resolveAutoHints(cm, pos) {\n    var helpers = cm.getHelpers(pos, \"hint\"), words\n    if (helpers.length) {\n      var resolved = function(cm, callback, options) {\n        var app = applicableHelpers(cm, helpers);\n        function run(i) {\n          if (i == app.length) return callback(null)\n          fetchHints(app[i], cm, options, function(result) {\n            if (result && result.list.length > 0) callback(result)\n            else run(i + 1)\n          })\n        }\n        run(0)\n      }\n      resolved.async = true\n      resolved.supportsSelection = true\n      return resolved\n    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }\n    } else if (CodeMirror.hint.anyword) {\n      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }\n    } else {\n      return function() {}\n    }\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"auto\", {\n    resolve: resolveAutoHints\n  });\n\n  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur)\n    var term, from = CodeMirror.Pos(cur.line, token.start), to = cur\n    if (token.start < cur.ch && /\\w/.test(token.string.charAt(cur.ch - token.start - 1))) {\n      term = token.string.substr(0, cur.ch - token.start)\n    } else {\n      term = \"\"\n      from = cur\n    }\n    var found = [];\n    for (var i = 0; i < options.words.length; i++) {\n      var word = options.words[i];\n      if (word.slice(0, term.length) == term)\n        found.push(word);\n    }\n\n    if (found.length) return {list: found, from: from, to: to};\n  });\n\n  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\n  var defaultOptions = {\n    hint: CodeMirror.hint.auto,\n    completeSingle: true,\n    alignWithWord: true,\n    closeCharacters: /[\\s()\\[\\]{};:>,]/,\n    closeOnPick: true,\n    closeOnUnfocus: true,\n    updateOnCursorActivity: true,\n    completeOnSingleClick: true,\n    container: null,\n    customKeys: null,\n    extraKeys: null,\n    paddingForScrollbar: true,\n    moveOnOverlap: true,\n  };\n\n  CodeMirror.defineOption(\"hintOptions\", null);\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var Pos = CodeMirror.Pos;\n\n  function forEach(arr, f) {\n    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);\n  }\n\n  function arrayContains(arr, item) {\n    if (!Array.prototype.indexOf) {\n      var i = arr.length;\n      while (i--) {\n        if (arr[i] === item) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return arr.indexOf(item) != -1;\n  }\n\n  function scriptHint(editor, keywords, getToken, options) {\n    // Find the token at the cursor\n    var cur = editor.getCursor(), token = getToken(editor, cur);\n    if (/\\b(?:string|comment)\\b/.test(token.type)) return;\n    var innerMode = CodeMirror.innerMode(editor.getMode(), token.state);\n    if (innerMode.mode.helperType === \"json\") return;\n    token.state = innerMode.state;\n\n    // If it's not a 'word-style' token, ignore the token.\n    if (!/^[\\w$_]*$/.test(token.string)) {\n      token = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\n               type: token.string == \".\" ? \"property\" : null};\n    } else if (token.end > cur.ch) {\n      token.end = cur.ch;\n      token.string = token.string.slice(0, cur.ch - token.start);\n    }\n\n    var tprop = token;\n    // If it is a property, find out what it is a property of.\n    while (tprop.type == \"property\") {\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (tprop.string != \".\") return;\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (!context) var context = [];\n      context.push(tprop);\n    }\n    return {list: getCompletions(token, context, keywords, options),\n            from: Pos(cur.line, token.start),\n            to: Pos(cur.line, token.end)};\n  }\n\n  function javascriptHint(editor, options) {\n    return scriptHint(editor, javascriptKeywords,\n                      function (e, cur) {return e.getTokenAt(cur);},\n                      options);\n  };\n  CodeMirror.registerHelper(\"hint\", \"javascript\", javascriptHint);\n\n  function getCoffeeScriptToken(editor, cur) {\n  // This getToken, it is for coffeescript, imitates the behavior of\n  // getTokenAt method in javascript.js, that is, returning \"property\"\n  // type and treat \".\" as independent token.\n    var token = editor.getTokenAt(cur);\n    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\n      token.end = token.start;\n      token.string = '.';\n      token.type = \"property\";\n    }\n    else if (/^\\.[\\w$_]*$/.test(token.string)) {\n      token.type = \"property\";\n      token.start++;\n      token.string = token.string.replace(/\\./, '');\n    }\n    return token;\n  }\n\n  function coffeescriptHint(editor, options) {\n    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\n  }\n  CodeMirror.registerHelper(\"hint\", \"coffeescript\", coffeescriptHint);\n\n  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" +\n                     \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\n  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" +\n                    \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\n  var funcProps = \"prototype apply call bind\".split(\" \");\n  var javascriptKeywords = (\"break case catch class const continue debugger default delete do else export extends false finally for function \" +\n                  \"if in import instanceof new null return super switch this throw true try typeof var void while with yield\").split(\" \");\n  var coffeescriptKeywords = (\"and break catch class continue delete do else extends false finally for \" +\n                  \"if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes\").split(\" \");\n\n  function forAllProps(obj, callback) {\n    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) {\n      for (var name in obj) callback(name)\n    } else {\n      for (var o = obj; o; o = Object.getPrototypeOf(o))\n        Object.getOwnPropertyNames(o).forEach(callback)\n    }\n  }\n\n  function getCompletions(token, context, keywords, options) {\n    var found = [], start = token.string, global = options && options.globalScope || window;\n    function maybeAdd(str) {\n      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);\n    }\n    function gatherCompletions(obj) {\n      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);\n      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);\n      else if (obj instanceof Function) forEach(funcProps, maybeAdd);\n      forAllProps(obj, maybeAdd)\n    }\n\n    if (context && context.length) {\n      // If this is a property, see if it belongs to some object we can\n      // find in the current environment.\n      var obj = context.pop(), base;\n      if (obj.type && obj.type.indexOf(\"variable\") === 0) {\n        if (options && options.additionalContext)\n          base = options.additionalContext[obj.string];\n        if (!options || options.useGlobalScope !== false)\n          base = base || global[obj.string];\n      } else if (obj.type == \"string\") {\n        base = \"\";\n      } else if (obj.type == \"atom\") {\n        base = 1;\n      } else if (obj.type == \"function\") {\n        if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&\n            (typeof global.jQuery == 'function'))\n          base = global.jQuery();\n        else if (global._ != null && (obj.string == '_') && (typeof global._ == 'function'))\n          base = global._();\n      }\n      while (base != null && context.length)\n        base = base[context.pop().string];\n      if (base != null) gatherCompletions(base);\n    } else {\n      // If not, just look in the global object, any local scope, and optional additional-context\n      // (reading into JS mode internals to get at the local and global variables)\n      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);\n      for (var c = token.state.context; c; c = c.prev)\n        for (var v = c.vars; v; v = v.next) maybeAdd(v.name)\n      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);\n      if (options && options.additionalContext != null)\n        for (var key in options.additionalContext)\n          maybeAdd(key);\n      if (!options || options.useGlobalScope !== false)\n        gatherCompletions(global);\n      forEach(keywords, maybeAdd);\n    }\n    return found;\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79), require(72));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"./xml-hint\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var langs = \"ab aa af ak sq am ar an hy as av ae ay az bm ba eu be bn bh bi bs br bg my ca ch ce ny zh cv kw co cr hr cs da dv nl dz en eo et ee fo fj fi fr ff gl ka de el gn gu ht ha he hz hi ho hu ia id ie ga ig ik io is it iu ja jv kl kn kr ks kk km ki rw ky kv kg ko ku kj la lb lg li ln lo lt lu lv gv mk mg ms ml mt mi mr mh mn na nv nb nd ne ng nn no ii nr oc oj cu om or os pa pi fa pl ps pt qu rm rn ro ru sa sc sd se sm sg sr gd sn si sk sl so st es su sw ss sv ta te tg th ti bo tk tl tn to tr ts tt tw ty ug uk ur uz ve vi vo wa cy wo fy xh yi yo za zu\".split(\" \");\n  var targets = [\"_blank\", \"_self\", \"_top\", \"_parent\"];\n  var charsets = [\"ascii\", \"utf-8\", \"utf-16\", \"latin1\", \"latin1\"];\n  var methods = [\"get\", \"post\", \"put\", \"delete\"];\n  var encs = [\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"];\n  var media = [\"all\", \"screen\", \"print\", \"embossed\", \"braille\", \"handheld\", \"print\", \"projection\", \"screen\", \"tty\", \"tv\", \"speech\",\n               \"3d-glasses\", \"resolution [>][<][=] [X]\", \"device-aspect-ratio: X/Y\", \"orientation:portrait\",\n               \"orientation:landscape\", \"device-height: [X]\", \"device-width: [X]\"];\n  var s = { attrs: {} }; // Simple tag, reused for a whole lot of tags\n\n  var data = {\n    a: {\n      attrs: {\n        href: null, ping: null, type: null,\n        media: media,\n        target: targets,\n        hreflang: langs\n      }\n    },\n    abbr: s,\n    acronym: s,\n    address: s,\n    applet: s,\n    area: {\n      attrs: {\n        alt: null, coords: null, href: null, target: null, ping: null,\n        media: media, hreflang: langs, type: null,\n        shape: [\"default\", \"rect\", \"circle\", \"poly\"]\n      }\n    },\n    article: s,\n    aside: s,\n    audio: {\n      attrs: {\n        src: null, mediagroup: null,\n        crossorigin: [\"anonymous\", \"use-credentials\"],\n        preload: [\"none\", \"metadata\", \"auto\"],\n        autoplay: [\"\", \"autoplay\"],\n        loop: [\"\", \"loop\"],\n        controls: [\"\", \"controls\"]\n      }\n    },\n    b: s,\n    base: { attrs: { href: null, target: targets } },\n    basefont: s,\n    bdi: s,\n    bdo: s,\n    big: s,\n    blockquote: { attrs: { cite: null } },\n    body: s,\n    br: s,\n    button: {\n      attrs: {\n        form: null, formaction: null, name: null, value: null,\n        autofocus: [\"\", \"autofocus\"],\n        disabled: [\"\", \"autofocus\"],\n        formenctype: encs,\n        formmethod: methods,\n        formnovalidate: [\"\", \"novalidate\"],\n        formtarget: targets,\n        type: [\"submit\", \"reset\", \"button\"]\n      }\n    },\n    canvas: { attrs: { width: null, height: null } },\n    caption: s,\n    center: s,\n    cite: s,\n    code: s,\n    col: { attrs: { span: null } },\n    colgroup: { attrs: { span: null } },\n    command: {\n      attrs: {\n        type: [\"command\", \"checkbox\", \"radio\"],\n        label: null, icon: null, radiogroup: null, command: null, title: null,\n        disabled: [\"\", \"disabled\"],\n        checked: [\"\", \"checked\"]\n      }\n    },\n    data: { attrs: { value: null } },\n    datagrid: { attrs: { disabled: [\"\", \"disabled\"], multiple: [\"\", \"multiple\"] } },\n    datalist: { attrs: { data: null } },\n    dd: s,\n    del: { attrs: { cite: null, datetime: null } },\n    details: { attrs: { open: [\"\", \"open\"] } },\n    dfn: s,\n    dir: s,\n    div: s,\n    dialog: { attrs: { open: null } },\n    dl: s,\n    dt: s,\n    em: s,\n    embed: { attrs: { src: null, type: null, width: null, height: null } },\n    eventsource: { attrs: { src: null } },\n    fieldset: { attrs: { disabled: [\"\", \"disabled\"], form: null, name: null } },\n    figcaption: s,\n    figure: s,\n    font: s,\n    footer: s,\n    form: {\n      attrs: {\n        action: null, name: null,\n        \"accept-charset\": charsets,\n        autocomplete: [\"on\", \"off\"],\n        enctype: encs,\n        method: methods,\n        novalidate: [\"\", \"novalidate\"],\n        target: targets\n      }\n    },\n    frame: s,\n    frameset: s,\n    h1: s, h2: s, h3: s, h4: s, h5: s, h6: s,\n    head: {\n      attrs: {},\n      children: [\"title\", \"base\", \"link\", \"style\", \"meta\", \"script\", \"noscript\", \"command\"]\n    },\n    header: s,\n    hgroup: s,\n    hr: s,\n    html: {\n      attrs: { manifest: null },\n      children: [\"head\", \"body\"]\n    },\n    i: s,\n    iframe: {\n      attrs: {\n        src: null, srcdoc: null, name: null, width: null, height: null,\n        sandbox: [\"allow-top-navigation\", \"allow-same-origin\", \"allow-forms\", \"allow-scripts\"],\n        seamless: [\"\", \"seamless\"]\n      }\n    },\n    img: {\n      attrs: {\n        alt: null, src: null, ismap: null, usemap: null, width: null, height: null,\n        crossorigin: [\"anonymous\", \"use-credentials\"]\n      }\n    },\n    input: {\n      attrs: {\n        alt: null, dirname: null, form: null, formaction: null,\n        height: null, list: null, max: null, maxlength: null, min: null,\n        name: null, pattern: null, placeholder: null, size: null, src: null,\n        step: null, value: null, width: null,\n        accept: [\"audio/*\", \"video/*\", \"image/*\"],\n        autocomplete: [\"on\", \"off\"],\n        autofocus: [\"\", \"autofocus\"],\n        checked: [\"\", \"checked\"],\n        disabled: [\"\", \"disabled\"],\n        formenctype: encs,\n        formmethod: methods,\n        formnovalidate: [\"\", \"novalidate\"],\n        formtarget: targets,\n        multiple: [\"\", \"multiple\"],\n        readonly: [\"\", \"readonly\"],\n        required: [\"\", \"required\"],\n        type: [\"hidden\", \"text\", \"search\", \"tel\", \"url\", \"email\", \"password\", \"datetime\", \"date\", \"month\",\n               \"week\", \"time\", \"datetime-local\", \"number\", \"range\", \"color\", \"checkbox\", \"radio\",\n               \"file\", \"submit\", \"image\", \"reset\", \"button\"]\n      }\n    },\n    ins: { attrs: { cite: null, datetime: null } },\n    kbd: s,\n    keygen: {\n      attrs: {\n        challenge: null, form: null, name: null,\n        autofocus: [\"\", \"autofocus\"],\n        disabled: [\"\", \"disabled\"],\n        keytype: [\"RSA\"]\n      }\n    },\n    label: { attrs: { \"for\": null, form: null } },\n    legend: s,\n    li: { attrs: { value: null } },\n    link: {\n      attrs: {\n        href: null, type: null,\n        hreflang: langs,\n        media: media,\n        sizes: [\"all\", \"16x16\", \"16x16 32x32\", \"16x16 32x32 64x64\"]\n      }\n    },\n    map: { attrs: { name: null } },\n    mark: s,\n    menu: { attrs: { label: null, type: [\"list\", \"context\", \"toolbar\"] } },\n    meta: {\n      attrs: {\n        content: null,\n        charset: charsets,\n        name: [\"viewport\", \"application-name\", \"author\", \"description\", \"generator\", \"keywords\"],\n        \"http-equiv\": [\"content-language\", \"content-type\", \"default-style\", \"refresh\"]\n      }\n    },\n    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },\n    nav: s,\n    noframes: s,\n    noscript: s,\n    object: {\n      attrs: {\n        data: null, type: null, name: null, usemap: null, form: null, width: null, height: null,\n        typemustmatch: [\"\", \"typemustmatch\"]\n      }\n    },\n    ol: { attrs: { reversed: [\"\", \"reversed\"], start: null, type: [\"1\", \"a\", \"A\", \"i\", \"I\"] } },\n    optgroup: { attrs: { disabled: [\"\", \"disabled\"], label: null } },\n    option: { attrs: { disabled: [\"\", \"disabled\"], label: null, selected: [\"\", \"selected\"], value: null } },\n    output: { attrs: { \"for\": null, form: null, name: null } },\n    p: s,\n    param: { attrs: { name: null, value: null } },\n    pre: s,\n    progress: { attrs: { value: null, max: null } },\n    q: { attrs: { cite: null } },\n    rp: s,\n    rt: s,\n    ruby: s,\n    s: s,\n    samp: s,\n    script: {\n      attrs: {\n        type: [\"text/javascript\"],\n        src: null,\n        async: [\"\", \"async\"],\n        defer: [\"\", \"defer\"],\n        charset: charsets\n      }\n    },\n    section: s,\n    select: {\n      attrs: {\n        form: null, name: null, size: null,\n        autofocus: [\"\", \"autofocus\"],\n        disabled: [\"\", \"disabled\"],\n        multiple: [\"\", \"multiple\"]\n      }\n    },\n    small: s,\n    source: { attrs: { src: null, type: null, media: null } },\n    span: s,\n    strike: s,\n    strong: s,\n    style: {\n      attrs: {\n        type: [\"text/css\"],\n        media: media,\n        scoped: null\n      }\n    },\n    sub: s,\n    summary: s,\n    sup: s,\n    table: s,\n    tbody: s,\n    td: { attrs: { colspan: null, rowspan: null, headers: null } },\n    textarea: {\n      attrs: {\n        dirname: null, form: null, maxlength: null, name: null, placeholder: null,\n        rows: null, cols: null,\n        autofocus: [\"\", \"autofocus\"],\n        disabled: [\"\", \"disabled\"],\n        readonly: [\"\", \"readonly\"],\n        required: [\"\", \"required\"],\n        wrap: [\"soft\", \"hard\"]\n      }\n    },\n    tfoot: s,\n    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: [\"row\", \"col\", \"rowgroup\", \"colgroup\"] } },\n    thead: s,\n    time: { attrs: { datetime: null } },\n    title: s,\n    tr: s,\n    track: {\n      attrs: {\n        src: null, label: null, \"default\": null,\n        kind: [\"subtitles\", \"captions\", \"descriptions\", \"chapters\", \"metadata\"],\n        srclang: langs\n      }\n    },\n    tt: s,\n    u: s,\n    ul: s,\n    \"var\": s,\n    video: {\n      attrs: {\n        src: null, poster: null, width: null, height: null,\n        crossorigin: [\"anonymous\", \"use-credentials\"],\n        preload: [\"auto\", \"metadata\", \"none\"],\n        autoplay: [\"\", \"autoplay\"],\n        mediagroup: [\"movie\"],\n        muted: [\"\", \"muted\"],\n        controls: [\"\", \"controls\"]\n      }\n    },\n    wbr: s\n  };\n\n  var globalAttrs = {\n    accesskey: [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n    \"class\": null,\n    contenteditable: [\"true\", \"false\"],\n    contextmenu: null,\n    dir: [\"ltr\", \"rtl\", \"auto\"],\n    draggable: [\"true\", \"false\", \"auto\"],\n    dropzone: [\"copy\", \"move\", \"link\", \"string:\", \"file:\"],\n    hidden: [\"hidden\"],\n    id: null,\n    inert: [\"inert\"],\n    itemid: null,\n    itemprop: null,\n    itemref: null,\n    itemscope: [\"itemscope\"],\n    itemtype: null,\n    lang: [\"en\", \"es\"],\n    spellcheck: [\"true\", \"false\"],\n    autocorrect: [\"true\", \"false\"],\n    autocapitalize: [\"true\", \"false\"],\n    style: null,\n    tabindex: [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n    title: null,\n    translate: [\"yes\", \"no\"],\n    onclick: null,\n    rel: [\"stylesheet\", \"alternate\", \"author\", \"bookmark\", \"help\", \"license\", \"next\", \"nofollow\", \"noreferrer\", \"prefetch\", \"prev\", \"search\", \"tag\"]\n  };\n  function populate(obj) {\n    for (var attr in globalAttrs) if (globalAttrs.hasOwnProperty(attr))\n      obj.attrs[attr] = globalAttrs[attr];\n  }\n\n  populate(s);\n  for (var tag in data) if (data.hasOwnProperty(tag) && data[tag] != s)\n    populate(data[tag]);\n\n  CodeMirror.htmlSchema = data;\n  function htmlHint(cm, options) {\n    var local = {schemaInfo: data};\n    if (options) for (var opt in options) local[opt] = options[opt];\n    return CodeMirror.hint.xml(cm, local);\n  }\n  CodeMirror.registerHelper(\"hint\", \"html\", htmlHint);\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n\n  function matches(hint, typed, matchInMiddle) {\n    if (matchInMiddle) return hint.indexOf(typed) >= 0;\n    else return hint.lastIndexOf(typed, 0) == 0;\n  }\n\n  function getHints(cm, options) {\n    var tags = options && options.schemaInfo;\n    var quote = (options && options.quoteChar) || '\"';\n    var matchInMiddle = options && options.matchInMiddle;\n    if (!tags) return;\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n    if (token.end > cur.ch) {\n      token.end = cur.ch;\n      token.string = token.string.slice(0, cur.ch - token.start);\n    }\n    var inner = CodeMirror.innerMode(cm.getMode(), token.state);\n    if (!inner.mode.xmlCurrentTag) return\n    var result = [], replaceToken = false, prefix;\n    var tag = /\\btag\\b/.test(token.type) && !/>$/.test(token.string);\n    var tagName = tag && /^\\w/.test(token.string), tagStart;\n\n    if (tagName) {\n      var before = cm.getLine(cur.line).slice(Math.max(0, token.start - 2), token.start);\n      var tagType = /<\\/$/.test(before) ? \"close\" : /<$/.test(before) ? \"open\" : null;\n      if (tagType) tagStart = token.start - (tagType == \"close\" ? 2 : 1);\n    } else if (tag && token.string == \"<\") {\n      tagType = \"open\";\n    } else if (tag && token.string == \"</\") {\n      tagType = \"close\";\n    }\n\n    var tagInfo = inner.mode.xmlCurrentTag(inner.state)\n    if (!tag && !tagInfo || tagType) {\n      if (tagName)\n        prefix = token.string;\n      replaceToken = tagType;\n      var context = inner.mode.xmlCurrentContext ? inner.mode.xmlCurrentContext(inner.state) : []\n      var inner = context.length && context[context.length - 1]\n      var curTag = inner && tags[inner]\n      var childList = inner ? curTag && curTag.children : tags[\"!top\"];\n      if (childList && tagType != \"close\") {\n        for (var i = 0; i < childList.length; ++i) if (!prefix || matches(childList[i], prefix, matchInMiddle))\n          result.push(\"<\" + childList[i]);\n      } else if (tagType != \"close\") {\n        for (var name in tags)\n          if (tags.hasOwnProperty(name) && name != \"!top\" && name != \"!attrs\" && (!prefix || matches(name, prefix, matchInMiddle)))\n            result.push(\"<\" + name);\n      }\n      if (inner && (!prefix || tagType == \"close\" && matches(inner, prefix, matchInMiddle)))\n        result.push(\"</\" + inner + \">\");\n    } else {\n      // Attribute completion\n      var curTag = tagInfo && tags[tagInfo.name], attrs = curTag && curTag.attrs;\n      var globalAttrs = tags[\"!attrs\"];\n      if (!attrs && !globalAttrs) return;\n      if (!attrs) {\n        attrs = globalAttrs;\n      } else if (globalAttrs) { // Combine tag-local and global attributes\n        var set = {};\n        for (var nm in globalAttrs) if (globalAttrs.hasOwnProperty(nm)) set[nm] = globalAttrs[nm];\n        for (var nm in attrs) if (attrs.hasOwnProperty(nm)) set[nm] = attrs[nm];\n        attrs = set;\n      }\n      if (token.type == \"string\" || token.string == \"=\") { // A value\n        var before = cm.getRange(Pos(cur.line, Math.max(0, cur.ch - 60)),\n                                 Pos(cur.line, token.type == \"string\" ? token.start : token.end));\n        var atName = before.match(/([^\\s\\u00a0=<>\\\"\\']+)=$/), atValues;\n        if (!atName || !attrs.hasOwnProperty(atName[1]) || !(atValues = attrs[atName[1]])) return;\n        if (typeof atValues == 'function') atValues = atValues.call(this, cm); // Functions can be used to supply values for autocomplete widget\n        if (token.type == \"string\") {\n          prefix = token.string;\n          var n = 0;\n          if (/['\"]/.test(token.string.charAt(0))) {\n            quote = token.string.charAt(0);\n            prefix = token.string.slice(1);\n            n++;\n          }\n          var len = token.string.length;\n          if (/['\"]/.test(token.string.charAt(len - 1))) {\n            quote = token.string.charAt(len - 1);\n            prefix = token.string.substr(n, len - 2);\n          }\n          if (n) { // an opening quote\n            var line = cm.getLine(cur.line);\n            if (line.length > token.end && line.charAt(token.end) == quote) token.end++; // include a closing quote\n          }\n          replaceToken = true;\n        }\n        var returnHintsFromAtValues = function(atValues) {\n          if (atValues)\n            for (var i = 0; i < atValues.length; ++i) if (!prefix || matches(atValues[i], prefix, matchInMiddle))\n              result.push(quote + atValues[i] + quote);\n          return returnHints();\n        };\n        if (atValues && atValues.then) return atValues.then(returnHintsFromAtValues);\n        return returnHintsFromAtValues(atValues);\n      } else { // An attribute name\n        if (token.type == \"attribute\") {\n          prefix = token.string;\n          replaceToken = true;\n        }\n        for (var attr in attrs) if (attrs.hasOwnProperty(attr) && (!prefix || matches(attr, prefix, matchInMiddle)))\n          result.push(attr);\n      }\n    }\n    function returnHints() {\n      return {\n        list: result,\n        from: replaceToken ? Pos(cur.line, tagStart == null ? token.start : tagStart) : cur,\n        to: replaceToken ? Pos(cur.line, token.end) : cur\n      };\n    }\n    return returnHints();\n  }\n\n  CodeMirror.registerHelper(\"hint\", \"xml\", getHints);\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79), require(80));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../../mode/css/css\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var pseudoClasses = {\"active\":1, \"after\":1, \"before\":1, \"checked\":1, \"default\":1,\n    \"disabled\":1, \"empty\":1, \"enabled\":1, \"first-child\":1, \"first-letter\":1,\n    \"first-line\":1, \"first-of-type\":1, \"focus\":1, \"hover\":1, \"in-range\":1,\n    \"indeterminate\":1, \"invalid\":1, \"lang\":1, \"last-child\":1, \"last-of-type\":1,\n    \"link\":1, \"not\":1, \"nth-child\":1, \"nth-last-child\":1, \"nth-last-of-type\":1,\n    \"nth-of-type\":1, \"only-of-type\":1, \"only-child\":1, \"optional\":1, \"out-of-range\":1,\n    \"placeholder\":1, \"read-only\":1, \"read-write\":1, \"required\":1, \"root\":1,\n    \"selection\":1, \"target\":1, \"valid\":1, \"visited\":1\n  };\n\n  CodeMirror.registerHelper(\"hint\", \"css\", function(cm) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n    var inner = CodeMirror.innerMode(cm.getMode(), token.state);\n    if (inner.mode.name != \"css\") return;\n\n    if (token.type == \"keyword\" && \"!important\".indexOf(token.string) == 0)\n      return {list: [\"!important\"], from: CodeMirror.Pos(cur.line, token.start),\n              to: CodeMirror.Pos(cur.line, token.end)};\n\n    var start = token.start, end = cur.ch, word = token.string.slice(0, end - start);\n    if (/[^\\w$_-]/.test(word)) {\n      word = \"\"; start = end = cur.ch;\n    }\n\n    var spec = CodeMirror.resolveMode(\"text/css\");\n\n    var result = [];\n    function add(keywords) {\n      for (var name in keywords)\n        if (!word || name.lastIndexOf(word, 0) == 0)\n          result.push(name);\n    }\n\n    var st = inner.state.state;\n    if (st == \"pseudo\" || token.type == \"variable-3\") {\n      add(pseudoClasses);\n    } else if (st == \"block\" || st == \"maybeprop\") {\n      add(spec.propertyKeywords);\n    } else if (st == \"prop\" || st == \"parens\" || st == \"at\" || st == \"params\") {\n      add(spec.valueKeywords);\n      add(spec.colorKeywords);\n    } else if (st == \"media\" || st == \"media_parens\") {\n      add(spec.mediaTypes);\n      add(spec.mediaFeatures);\n    }\n\n    if (result.length) return {\n      list: result,\n      from: CodeMirror.Pos(cur.line, start),\n      to: CodeMirror.Pos(cur.line, end)\n    };\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"css\", function(config, parserConfig) {\n  var inline = parserConfig.inline\n  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode(\"text/css\");\n\n  var indentUnit = config.indentUnit,\n      tokenHooks = parserConfig.tokenHooks,\n      documentTypes = parserConfig.documentTypes || {},\n      mediaTypes = parserConfig.mediaTypes || {},\n      mediaFeatures = parserConfig.mediaFeatures || {},\n      mediaValueKeywords = parserConfig.mediaValueKeywords || {},\n      propertyKeywords = parserConfig.propertyKeywords || {},\n      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},\n      fontProperties = parserConfig.fontProperties || {},\n      counterDescriptors = parserConfig.counterDescriptors || {},\n      colorKeywords = parserConfig.colorKeywords || {},\n      valueKeywords = parserConfig.valueKeywords || {},\n      allowNested = parserConfig.allowNested,\n      lineComment = parserConfig.lineComment,\n      supportsAtComponent = parserConfig.supportsAtComponent === true,\n      highlightNonStandardPropertyKeywords = config.highlightNonStandardPropertyKeywords !== false;\n\n  var type, override;\n  function ret(style, tp) { type = tp; return style; }\n\n  // Tokenizers\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (tokenHooks[ch]) {\n      var result = tokenHooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == \"@\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"def\", stream.current());\n    } else if (ch == \"=\" || (ch == \"~\" || ch == \"|\") && stream.eat(\"=\")) {\n      return ret(null, \"compare\");\n    } else if (ch == \"\\\"\" || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \"#\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"atom\", \"hash\");\n    } else if (ch == \"!\") {\n      stream.match(/^\\s*\\w*/);\n      return ret(\"keyword\", \"important\");\n    } else if (/\\d/.test(ch) || ch == \".\" && stream.eat(/\\d/)) {\n      stream.eatWhile(/[\\w.%]/);\n      return ret(\"number\", \"unit\");\n    } else if (ch === \"-\") {\n      if (/[\\d.]/.test(stream.peek())) {\n        stream.eatWhile(/[\\w.%]/);\n        return ret(\"number\", \"unit\");\n      } else if (stream.match(/^-[\\w\\\\\\-]*/)) {\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return ret(\"variable-2\", \"variable-definition\");\n        return ret(\"variable-2\", \"variable\");\n      } else if (stream.match(/^\\w+-/)) {\n        return ret(\"meta\", \"meta\");\n      }\n    } else if (/[,+>*\\/]/.test(ch)) {\n      return ret(null, \"select-op\");\n    } else if (ch == \".\" && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n      return ret(\"qualifier\", \"qualifier\");\n    } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n      return ret(null, ch);\n    } else if (stream.match(/^[\\w-.]+(?=\\()/)) {\n      if (/^(url(-prefix)?|domain|regexp)$/i.test(stream.current())) {\n        state.tokenize = tokenParenthesized;\n      }\n      return ret(\"variable callee\", \"variable\");\n    } else if (/[\\w\\\\\\-]/.test(ch)) {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"property\", \"word\");\n    } else {\n      return ret(null, null);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          if (quote == \")\") stream.backUp(1);\n          break;\n        }\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      if (ch == quote || !escaped && quote != \")\") state.tokenize = null;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenParenthesized(stream, state) {\n    stream.next(); // Must be '('\n    if (!stream.match(/^\\s*[\\\"\\')]/, false))\n      state.tokenize = tokenString(\")\");\n    else\n      state.tokenize = null;\n    return ret(null, \"(\");\n  }\n\n  // Context management\n\n  function Context(type, indent, prev) {\n    this.type = type;\n    this.indent = indent;\n    this.prev = prev;\n  }\n\n  function pushContext(state, stream, type, indent) {\n    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);\n    return type;\n  }\n\n  function popContext(state) {\n    if (state.context.prev)\n      state.context = state.context.prev;\n    return state.context.type;\n  }\n\n  function pass(type, stream, state) {\n    return states[state.context.type](type, stream, state);\n  }\n  function popAndPass(type, stream, state, n) {\n    for (var i = n || 1; i > 0; i--)\n      state.context = state.context.prev;\n    return pass(type, stream, state);\n  }\n\n  // Parser\n\n  function wordAsValue(stream) {\n    var word = stream.current().toLowerCase();\n    if (valueKeywords.hasOwnProperty(word))\n      override = \"atom\";\n    else if (colorKeywords.hasOwnProperty(word))\n      override = \"keyword\";\n    else\n      override = \"variable\";\n  }\n\n  var states = {};\n\n  states.top = function(type, stream, state) {\n    if (type == \"{\") {\n      return pushContext(state, stream, \"block\");\n    } else if (type == \"}\" && state.context.prev) {\n      return popContext(state);\n    } else if (supportsAtComponent && /@component/i.test(type)) {\n      return pushContext(state, stream, \"atComponentBlock\");\n    } else if (/^@(-moz-)?document$/i.test(type)) {\n      return pushContext(state, stream, \"documentTypes\");\n    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {\n      return pushContext(state, stream, \"atBlock\");\n    } else if (/^@(font-face|counter-style)/i.test(type)) {\n      state.stateArg = type;\n      return \"restricted_atBlock_before\";\n    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {\n      return \"keyframes\";\n    } else if (type && type.charAt(0) == \"@\") {\n      return pushContext(state, stream, \"at\");\n    } else if (type == \"hash\") {\n      override = \"builtin\";\n    } else if (type == \"word\") {\n      override = \"tag\";\n    } else if (type == \"variable-definition\") {\n      return \"maybeprop\";\n    } else if (type == \"interpolation\") {\n      return pushContext(state, stream, \"interpolation\");\n    } else if (type == \":\") {\n      return \"pseudo\";\n    } else if (allowNested && type == \"(\") {\n      return pushContext(state, stream, \"parens\");\n    }\n    return state.context.type;\n  };\n\n  states.block = function(type, stream, state) {\n    if (type == \"word\") {\n      var word = stream.current().toLowerCase();\n      if (propertyKeywords.hasOwnProperty(word)) {\n        override = \"property\";\n        return \"maybeprop\";\n      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {\n        override = highlightNonStandardPropertyKeywords ? \"string-2\" : \"property\";\n        return \"maybeprop\";\n      } else if (allowNested) {\n        override = stream.match(/^\\s*:(?:\\s|$)/, false) ? \"property\" : \"tag\";\n        return \"block\";\n      } else {\n        override += \" error\";\n        return \"maybeprop\";\n      }\n    } else if (type == \"meta\") {\n      return \"block\";\n    } else if (!allowNested && (type == \"hash\" || type == \"qualifier\")) {\n      override = \"error\";\n      return \"block\";\n    } else {\n      return states.top(type, stream, state);\n    }\n  };\n\n  states.maybeprop = function(type, stream, state) {\n    if (type == \":\") return pushContext(state, stream, \"prop\");\n    return pass(type, stream, state);\n  };\n\n  states.prop = function(type, stream, state) {\n    if (type == \";\") return popContext(state);\n    if (type == \"{\" && allowNested) return pushContext(state, stream, \"propBlock\");\n    if (type == \"}\" || type == \"{\") return popAndPass(type, stream, state);\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\n\n    if (type == \"hash\" && !/^#([0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/.test(stream.current())) {\n      override += \" error\";\n    } else if (type == \"word\") {\n      wordAsValue(stream);\n    } else if (type == \"interpolation\") {\n      return pushContext(state, stream, \"interpolation\");\n    }\n    return \"prop\";\n  };\n\n  states.propBlock = function(type, _stream, state) {\n    if (type == \"}\") return popContext(state);\n    if (type == \"word\") { override = \"property\"; return \"maybeprop\"; }\n    return state.context.type;\n  };\n\n  states.parens = function(type, stream, state) {\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n    if (type == \")\") return popContext(state);\n    if (type == \"(\") return pushContext(state, stream, \"parens\");\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n    if (type == \"word\") wordAsValue(stream);\n    return \"parens\";\n  };\n\n  states.pseudo = function(type, stream, state) {\n    if (type == \"meta\") return \"pseudo\";\n\n    if (type == \"word\") {\n      override = \"variable-3\";\n      return state.context.type;\n    }\n    return pass(type, stream, state);\n  };\n\n  states.documentTypes = function(type, stream, state) {\n    if (type == \"word\" && documentTypes.hasOwnProperty(stream.current())) {\n      override = \"tag\";\n      return state.context.type;\n    } else {\n      return states.atBlock(type, stream, state);\n    }\n  };\n\n  states.atBlock = function(type, stream, state) {\n    if (type == \"(\") return pushContext(state, stream, \"atBlock_parens\");\n    if (type == \"}\" || type == \";\") return popAndPass(type, stream, state);\n    if (type == \"{\") return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\");\n\n    if (type == \"interpolation\") return pushContext(state, stream, \"interpolation\");\n\n    if (type == \"word\") {\n      var word = stream.current().toLowerCase();\n      if (word == \"only\" || word == \"not\" || word == \"and\" || word == \"or\")\n        override = \"keyword\";\n      else if (mediaTypes.hasOwnProperty(word))\n        override = \"attribute\";\n      else if (mediaFeatures.hasOwnProperty(word))\n        override = \"property\";\n      else if (mediaValueKeywords.hasOwnProperty(word))\n        override = \"keyword\";\n      else if (propertyKeywords.hasOwnProperty(word))\n        override = \"property\";\n      else if (nonStandardPropertyKeywords.hasOwnProperty(word))\n        override = highlightNonStandardPropertyKeywords ? \"string-2\" : \"property\";\n      else if (valueKeywords.hasOwnProperty(word))\n        override = \"atom\";\n      else if (colorKeywords.hasOwnProperty(word))\n        override = \"keyword\";\n      else\n        override = \"error\";\n    }\n    return state.context.type;\n  };\n\n  states.atComponentBlock = function(type, stream, state) {\n    if (type == \"}\")\n      return popAndPass(type, stream, state);\n    if (type == \"{\")\n      return popContext(state) && pushContext(state, stream, allowNested ? \"block\" : \"top\", false);\n    if (type == \"word\")\n      override = \"error\";\n    return state.context.type;\n  };\n\n  states.atBlock_parens = function(type, stream, state) {\n    if (type == \")\") return popContext(state);\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state, 2);\n    return states.atBlock(type, stream, state);\n  };\n\n  states.restricted_atBlock_before = function(type, stream, state) {\n    if (type == \"{\")\n      return pushContext(state, stream, \"restricted_atBlock\");\n    if (type == \"word\" && state.stateArg == \"@counter-style\") {\n      override = \"variable\";\n      return \"restricted_atBlock_before\";\n    }\n    return pass(type, stream, state);\n  };\n\n  states.restricted_atBlock = function(type, stream, state) {\n    if (type == \"}\") {\n      state.stateArg = null;\n      return popContext(state);\n    }\n    if (type == \"word\") {\n      if ((state.stateArg == \"@font-face\" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||\n          (state.stateArg == \"@counter-style\" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))\n        override = \"error\";\n      else\n        override = \"property\";\n      return \"maybeprop\";\n    }\n    return \"restricted_atBlock\";\n  };\n\n  states.keyframes = function(type, stream, state) {\n    if (type == \"word\") { override = \"variable\"; return \"keyframes\"; }\n    if (type == \"{\") return pushContext(state, stream, \"top\");\n    return pass(type, stream, state);\n  };\n\n  states.at = function(type, stream, state) {\n    if (type == \";\") return popContext(state);\n    if (type == \"{\" || type == \"}\") return popAndPass(type, stream, state);\n    if (type == \"word\") override = \"tag\";\n    else if (type == \"hash\") override = \"builtin\";\n    return \"at\";\n  };\n\n  states.interpolation = function(type, stream, state) {\n    if (type == \"}\") return popContext(state);\n    if (type == \"{\" || type == \";\") return popAndPass(type, stream, state);\n    if (type == \"word\") override = \"variable\";\n    else if (type != \"variable\" && type != \"(\" && type != \")\") override = \"error\";\n    return \"interpolation\";\n  };\n\n  return {\n    startState: function(base) {\n      return {tokenize: null,\n              state: inline ? \"block\" : \"top\",\n              stateArg: null,\n              context: new Context(inline ? \"block\" : \"top\", base || 0, null)};\n    },\n\n    token: function(stream, state) {\n      if (!state.tokenize && stream.eatSpace()) return null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style && typeof style == \"object\") {\n        type = style[1];\n        style = style[0];\n      }\n      override = style;\n      if (type != \"comment\")\n        state.state = states[state.state](type, stream, state);\n      return override;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context, ch = textAfter && textAfter.charAt(0);\n      var indent = cx.indent;\n      if (cx.type == \"prop\" && (ch == \"}\" || ch == \")\")) cx = cx.prev;\n      if (cx.prev) {\n        if (ch == \"}\" && (cx.type == \"block\" || cx.type == \"top\" ||\n                          cx.type == \"interpolation\" || cx.type == \"restricted_atBlock\")) {\n          // Resume indentation from parent context.\n          cx = cx.prev;\n          indent = cx.indent;\n        } else if (ch == \")\" && (cx.type == \"parens\" || cx.type == \"atBlock_parens\") ||\n            ch == \"{\" && (cx.type == \"at\" || cx.type == \"atBlock\")) {\n          // Dedent relative to current context.\n          indent = Math.max(0, cx.indent - indentUnit);\n        }\n      }\n      return indent;\n    },\n\n    electricChars: \"}\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    blockCommentContinue: \" * \",\n    lineComment: lineComment,\n    fold: \"brace\"\n  };\n});\n\n  function keySet(array) {\n    var keys = {};\n    for (var i = 0; i < array.length; ++i) {\n      keys[array[i].toLowerCase()] = true;\n    }\n    return keys;\n  }\n\n  var documentTypes_ = [\n    \"domain\", \"regexp\", \"url\", \"url-prefix\"\n  ], documentTypes = keySet(documentTypes_);\n\n  var mediaTypes_ = [\n    \"all\", \"aural\", \"braille\", \"handheld\", \"print\", \"projection\", \"screen\",\n    \"tty\", \"tv\", \"embossed\"\n  ], mediaTypes = keySet(mediaTypes_);\n\n  var mediaFeatures_ = [\n    \"width\", \"min-width\", \"max-width\", \"height\", \"min-height\", \"max-height\",\n    \"device-width\", \"min-device-width\", \"max-device-width\", \"device-height\",\n    \"min-device-height\", \"max-device-height\", \"aspect-ratio\",\n    \"min-aspect-ratio\", \"max-aspect-ratio\", \"device-aspect-ratio\",\n    \"min-device-aspect-ratio\", \"max-device-aspect-ratio\", \"color\", \"min-color\",\n    \"max-color\", \"color-index\", \"min-color-index\", \"max-color-index\",\n    \"monochrome\", \"min-monochrome\", \"max-monochrome\", \"resolution\",\n    \"min-resolution\", \"max-resolution\", \"scan\", \"grid\", \"orientation\",\n    \"device-pixel-ratio\", \"min-device-pixel-ratio\", \"max-device-pixel-ratio\",\n    \"pointer\", \"any-pointer\", \"hover\", \"any-hover\", \"prefers-color-scheme\",\n    \"dynamic-range\", \"video-dynamic-range\"\n  ], mediaFeatures = keySet(mediaFeatures_);\n\n  var mediaValueKeywords_ = [\n    \"landscape\", \"portrait\", \"none\", \"coarse\", \"fine\", \"on-demand\", \"hover\",\n    \"interlace\", \"progressive\",\n    \"dark\", \"light\",\n    \"standard\", \"high\"\n  ], mediaValueKeywords = keySet(mediaValueKeywords_);\n\n  var propertyKeywords_ = [\n    \"align-content\", \"align-items\", \"align-self\", \"alignment-adjust\",\n    \"alignment-baseline\", \"all\", \"anchor-point\", \"animation\", \"animation-delay\",\n    \"animation-direction\", \"animation-duration\", \"animation-fill-mode\",\n    \"animation-iteration-count\", \"animation-name\", \"animation-play-state\",\n    \"animation-timing-function\", \"appearance\", \"azimuth\", \"backdrop-filter\",\n    \"backface-visibility\", \"background\", \"background-attachment\",\n    \"background-blend-mode\", \"background-clip\", \"background-color\",\n    \"background-image\", \"background-origin\", \"background-position\",\n    \"background-position-x\", \"background-position-y\", \"background-repeat\",\n    \"background-size\", \"baseline-shift\", \"binding\", \"bleed\", \"block-size\",\n    \"bookmark-label\", \"bookmark-level\", \"bookmark-state\", \"bookmark-target\",\n    \"border\", \"border-bottom\", \"border-bottom-color\", \"border-bottom-left-radius\",\n    \"border-bottom-right-radius\", \"border-bottom-style\", \"border-bottom-width\",\n    \"border-collapse\", \"border-color\", \"border-image\", \"border-image-outset\",\n    \"border-image-repeat\", \"border-image-slice\", \"border-image-source\",\n    \"border-image-width\", \"border-left\", \"border-left-color\", \"border-left-style\",\n    \"border-left-width\", \"border-radius\", \"border-right\", \"border-right-color\",\n    \"border-right-style\", \"border-right-width\", \"border-spacing\", \"border-style\",\n    \"border-top\", \"border-top-color\", \"border-top-left-radius\",\n    \"border-top-right-radius\", \"border-top-style\", \"border-top-width\",\n    \"border-width\", \"bottom\", \"box-decoration-break\", \"box-shadow\", \"box-sizing\",\n    \"break-after\", \"break-before\", \"break-inside\", \"caption-side\", \"caret-color\",\n    \"clear\", \"clip\", \"color\", \"color-profile\", \"column-count\", \"column-fill\",\n    \"column-gap\", \"column-rule\", \"column-rule-color\", \"column-rule-style\",\n    \"column-rule-width\", \"column-span\", \"column-width\", \"columns\", \"contain\",\n    \"content\", \"counter-increment\", \"counter-reset\", \"crop\", \"cue\", \"cue-after\",\n    \"cue-before\", \"cursor\", \"direction\", \"display\", \"dominant-baseline\",\n    \"drop-initial-after-adjust\", \"drop-initial-after-align\",\n    \"drop-initial-before-adjust\", \"drop-initial-before-align\", \"drop-initial-size\",\n    \"drop-initial-value\", \"elevation\", \"empty-cells\", \"fit\", \"fit-content\", \"fit-position\",\n    \"flex\", \"flex-basis\", \"flex-direction\", \"flex-flow\", \"flex-grow\",\n    \"flex-shrink\", \"flex-wrap\", \"float\", \"float-offset\", \"flow-from\", \"flow-into\",\n    \"font\", \"font-family\", \"font-feature-settings\", \"font-kerning\",\n    \"font-language-override\", \"font-optical-sizing\", \"font-size\",\n    \"font-size-adjust\", \"font-stretch\", \"font-style\", \"font-synthesis\",\n    \"font-variant\", \"font-variant-alternates\", \"font-variant-caps\",\n    \"font-variant-east-asian\", \"font-variant-ligatures\", \"font-variant-numeric\",\n    \"font-variant-position\", \"font-variation-settings\", \"font-weight\", \"gap\",\n    \"grid\", \"grid-area\", \"grid-auto-columns\", \"grid-auto-flow\", \"grid-auto-rows\",\n    \"grid-column\", \"grid-column-end\", \"grid-column-gap\", \"grid-column-start\",\n    \"grid-gap\", \"grid-row\", \"grid-row-end\", \"grid-row-gap\", \"grid-row-start\",\n    \"grid-template\", \"grid-template-areas\", \"grid-template-columns\",\n    \"grid-template-rows\", \"hanging-punctuation\", \"height\", \"hyphens\", \"icon\",\n    \"image-orientation\", \"image-rendering\", \"image-resolution\", \"inline-box-align\",\n    \"inset\", \"inset-block\", \"inset-block-end\", \"inset-block-start\", \"inset-inline\",\n    \"inset-inline-end\", \"inset-inline-start\", \"isolation\", \"justify-content\",\n    \"justify-items\", \"justify-self\", \"left\", \"letter-spacing\", \"line-break\",\n    \"line-height\", \"line-height-step\", \"line-stacking\", \"line-stacking-ruby\",\n    \"line-stacking-shift\", \"line-stacking-strategy\", \"list-style\",\n    \"list-style-image\", \"list-style-position\", \"list-style-type\", \"margin\",\n    \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\", \"marks\",\n    \"marquee-direction\", \"marquee-loop\", \"marquee-play-count\", \"marquee-speed\",\n    \"marquee-style\", \"mask-clip\", \"mask-composite\", \"mask-image\", \"mask-mode\",\n    \"mask-origin\", \"mask-position\", \"mask-repeat\", \"mask-size\",\"mask-type\",\n    \"max-block-size\", \"max-height\", \"max-inline-size\",\n    \"max-width\", \"min-block-size\", \"min-height\", \"min-inline-size\", \"min-width\",\n    \"mix-blend-mode\", \"move-to\", \"nav-down\", \"nav-index\", \"nav-left\", \"nav-right\",\n    \"nav-up\", \"object-fit\", \"object-position\", \"offset\", \"offset-anchor\",\n    \"offset-distance\", \"offset-path\", \"offset-position\", \"offset-rotate\",\n    \"opacity\", \"order\", \"orphans\", \"outline\", \"outline-color\", \"outline-offset\",\n    \"outline-style\", \"outline-width\", \"overflow\", \"overflow-style\",\n    \"overflow-wrap\", \"overflow-x\", \"overflow-y\", \"padding\", \"padding-bottom\",\n    \"padding-left\", \"padding-right\", \"padding-top\", \"page\", \"page-break-after\",\n    \"page-break-before\", \"page-break-inside\", \"page-policy\", \"pause\",\n    \"pause-after\", \"pause-before\", \"perspective\", \"perspective-origin\", \"pitch\",\n    \"pitch-range\", \"place-content\", \"place-items\", \"place-self\", \"play-during\",\n    \"position\", \"presentation-level\", \"punctuation-trim\", \"quotes\",\n    \"region-break-after\", \"region-break-before\", \"region-break-inside\",\n    \"region-fragment\", \"rendering-intent\", \"resize\", \"rest\", \"rest-after\",\n    \"rest-before\", \"richness\", \"right\", \"rotate\", \"rotation\", \"rotation-point\",\n    \"row-gap\", \"ruby-align\", \"ruby-overhang\", \"ruby-position\", \"ruby-span\",\n    \"scale\", \"scroll-behavior\", \"scroll-margin\", \"scroll-margin-block\",\n    \"scroll-margin-block-end\", \"scroll-margin-block-start\", \"scroll-margin-bottom\",\n    \"scroll-margin-inline\", \"scroll-margin-inline-end\",\n    \"scroll-margin-inline-start\", \"scroll-margin-left\", \"scroll-margin-right\",\n    \"scroll-margin-top\", \"scroll-padding\", \"scroll-padding-block\",\n    \"scroll-padding-block-end\", \"scroll-padding-block-start\",\n    \"scroll-padding-bottom\", \"scroll-padding-inline\", \"scroll-padding-inline-end\",\n    \"scroll-padding-inline-start\", \"scroll-padding-left\", \"scroll-padding-right\",\n    \"scroll-padding-top\", \"scroll-snap-align\", \"scroll-snap-type\",\n    \"shape-image-threshold\", \"shape-inside\", \"shape-margin\", \"shape-outside\",\n    \"size\", \"speak\", \"speak-as\", \"speak-header\", \"speak-numeral\",\n    \"speak-punctuation\", \"speech-rate\", \"stress\", \"string-set\", \"tab-size\",\n    \"table-layout\", \"target\", \"target-name\", \"target-new\", \"target-position\",\n    \"text-align\", \"text-align-last\", \"text-combine-upright\", \"text-decoration\",\n    \"text-decoration-color\", \"text-decoration-line\", \"text-decoration-skip\",\n    \"text-decoration-skip-ink\", \"text-decoration-style\", \"text-emphasis\",\n    \"text-emphasis-color\", \"text-emphasis-position\", \"text-emphasis-style\",\n    \"text-height\", \"text-indent\", \"text-justify\", \"text-orientation\",\n    \"text-outline\", \"text-overflow\", \"text-rendering\", \"text-shadow\",\n    \"text-size-adjust\", \"text-space-collapse\", \"text-transform\",\n    \"text-underline-position\", \"text-wrap\", \"top\", \"touch-action\", \"transform\", \"transform-origin\",\n    \"transform-style\", \"transition\", \"transition-delay\", \"transition-duration\",\n    \"transition-property\", \"transition-timing-function\", \"translate\",\n    \"unicode-bidi\", \"user-select\", \"vertical-align\", \"visibility\", \"voice-balance\",\n    \"voice-duration\", \"voice-family\", \"voice-pitch\", \"voice-range\", \"voice-rate\",\n    \"voice-stress\", \"voice-volume\", \"volume\", \"white-space\", \"widows\", \"width\",\n    \"will-change\", \"word-break\", \"word-spacing\", \"word-wrap\", \"writing-mode\", \"z-index\",\n    // SVG-specific\n    \"clip-path\", \"clip-rule\", \"mask\", \"enable-background\", \"filter\", \"flood-color\",\n    \"flood-opacity\", \"lighting-color\", \"stop-color\", \"stop-opacity\", \"pointer-events\",\n    \"color-interpolation\", \"color-interpolation-filters\",\n    \"color-rendering\", \"fill\", \"fill-opacity\", \"fill-rule\", \"image-rendering\",\n    \"marker\", \"marker-end\", \"marker-mid\", \"marker-start\", \"paint-order\", \"shape-rendering\", \"stroke\",\n    \"stroke-dasharray\", \"stroke-dashoffset\", \"stroke-linecap\", \"stroke-linejoin\",\n    \"stroke-miterlimit\", \"stroke-opacity\", \"stroke-width\", \"text-rendering\",\n    \"baseline-shift\", \"dominant-baseline\", \"glyph-orientation-horizontal\",\n    \"glyph-orientation-vertical\", \"text-anchor\", \"writing-mode\",\n  ], propertyKeywords = keySet(propertyKeywords_);\n\n  var nonStandardPropertyKeywords_ = [\n    \"accent-color\", \"aspect-ratio\", \"border-block\", \"border-block-color\", \"border-block-end\",\n    \"border-block-end-color\", \"border-block-end-style\", \"border-block-end-width\",\n    \"border-block-start\", \"border-block-start-color\", \"border-block-start-style\",\n    \"border-block-start-width\", \"border-block-style\", \"border-block-width\",\n    \"border-inline\", \"border-inline-color\", \"border-inline-end\",\n    \"border-inline-end-color\", \"border-inline-end-style\",\n    \"border-inline-end-width\", \"border-inline-start\", \"border-inline-start-color\",\n    \"border-inline-start-style\", \"border-inline-start-width\",\n    \"border-inline-style\", \"border-inline-width\", \"content-visibility\", \"margin-block\",\n    \"margin-block-end\", \"margin-block-start\", \"margin-inline\", \"margin-inline-end\",\n    \"margin-inline-start\", \"overflow-anchor\", \"overscroll-behavior\", \"padding-block\", \"padding-block-end\",\n    \"padding-block-start\", \"padding-inline\", \"padding-inline-end\",\n    \"padding-inline-start\", \"scroll-snap-stop\", \"scrollbar-3d-light-color\",\n    \"scrollbar-arrow-color\", \"scrollbar-base-color\", \"scrollbar-dark-shadow-color\",\n    \"scrollbar-face-color\", \"scrollbar-highlight-color\", \"scrollbar-shadow-color\",\n    \"scrollbar-track-color\", \"searchfield-cancel-button\", \"searchfield-decoration\",\n    \"searchfield-results-button\", \"searchfield-results-decoration\", \"shape-inside\", \"zoom\"\n  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);\n\n  var fontProperties_ = [\n    \"font-display\", \"font-family\", \"src\", \"unicode-range\", \"font-variant\",\n     \"font-feature-settings\", \"font-stretch\", \"font-weight\", \"font-style\"\n  ], fontProperties = keySet(fontProperties_);\n\n  var counterDescriptors_ = [\n    \"additive-symbols\", \"fallback\", \"negative\", \"pad\", \"prefix\", \"range\",\n    \"speak-as\", \"suffix\", \"symbols\", \"system\"\n  ], counterDescriptors = keySet(counterDescriptors_);\n\n  var colorKeywords_ = [\n    \"aliceblue\", \"antiquewhite\", \"aqua\", \"aquamarine\", \"azure\", \"beige\",\n    \"bisque\", \"black\", \"blanchedalmond\", \"blue\", \"blueviolet\", \"brown\",\n    \"burlywood\", \"cadetblue\", \"chartreuse\", \"chocolate\", \"coral\", \"cornflowerblue\",\n    \"cornsilk\", \"crimson\", \"cyan\", \"darkblue\", \"darkcyan\", \"darkgoldenrod\",\n    \"darkgray\", \"darkgreen\", \"darkgrey\", \"darkkhaki\", \"darkmagenta\", \"darkolivegreen\",\n    \"darkorange\", \"darkorchid\", \"darkred\", \"darksalmon\", \"darkseagreen\",\n    \"darkslateblue\", \"darkslategray\", \"darkslategrey\", \"darkturquoise\", \"darkviolet\",\n    \"deeppink\", \"deepskyblue\", \"dimgray\", \"dimgrey\", \"dodgerblue\", \"firebrick\",\n    \"floralwhite\", \"forestgreen\", \"fuchsia\", \"gainsboro\", \"ghostwhite\",\n    \"gold\", \"goldenrod\", \"gray\", \"grey\", \"green\", \"greenyellow\", \"honeydew\",\n    \"hotpink\", \"indianred\", \"indigo\", \"ivory\", \"khaki\", \"lavender\",\n    \"lavenderblush\", \"lawngreen\", \"lemonchiffon\", \"lightblue\", \"lightcoral\",\n    \"lightcyan\", \"lightgoldenrodyellow\", \"lightgray\", \"lightgreen\", \"lightgrey\", \"lightpink\",\n    \"lightsalmon\", \"lightseagreen\", \"lightskyblue\", \"lightslategray\", \"lightslategrey\",\n    \"lightsteelblue\", \"lightyellow\", \"lime\", \"limegreen\", \"linen\", \"magenta\",\n    \"maroon\", \"mediumaquamarine\", \"mediumblue\", \"mediumorchid\", \"mediumpurple\",\n    \"mediumseagreen\", \"mediumslateblue\", \"mediumspringgreen\", \"mediumturquoise\",\n    \"mediumvioletred\", \"midnightblue\", \"mintcream\", \"mistyrose\", \"moccasin\",\n    \"navajowhite\", \"navy\", \"oldlace\", \"olive\", \"olivedrab\", \"orange\", \"orangered\",\n    \"orchid\", \"palegoldenrod\", \"palegreen\", \"paleturquoise\", \"palevioletred\",\n    \"papayawhip\", \"peachpuff\", \"peru\", \"pink\", \"plum\", \"powderblue\",\n    \"purple\", \"rebeccapurple\", \"red\", \"rosybrown\", \"royalblue\", \"saddlebrown\",\n    \"salmon\", \"sandybrown\", \"seagreen\", \"seashell\", \"sienna\", \"silver\", \"skyblue\",\n    \"slateblue\", \"slategray\", \"slategrey\", \"snow\", \"springgreen\", \"steelblue\", \"tan\",\n    \"teal\", \"thistle\", \"tomato\", \"turquoise\", \"violet\", \"wheat\", \"white\",\n    \"whitesmoke\", \"yellow\", \"yellowgreen\"\n  ], colorKeywords = keySet(colorKeywords_);\n\n  var valueKeywords_ = [\n    \"above\", \"absolute\", \"activeborder\", \"additive\", \"activecaption\", \"afar\",\n    \"after-white-space\", \"ahead\", \"alias\", \"all\", \"all-scroll\", \"alphabetic\", \"alternate\",\n    \"always\", \"amharic\", \"amharic-abegede\", \"antialiased\", \"appworkspace\",\n    \"arabic-indic\", \"armenian\", \"asterisks\", \"attr\", \"auto\", \"auto-flow\", \"avoid\", \"avoid-column\", \"avoid-page\",\n    \"avoid-region\", \"axis-pan\", \"background\", \"backwards\", \"baseline\", \"below\", \"bidi-override\", \"binary\",\n    \"bengali\", \"blink\", \"block\", \"block-axis\", \"blur\", \"bold\", \"bolder\", \"border\", \"border-box\",\n    \"both\", \"bottom\", \"break\", \"break-all\", \"break-word\", \"brightness\", \"bullets\", \"button\",\n    \"buttonface\", \"buttonhighlight\", \"buttonshadow\", \"buttontext\", \"calc\", \"cambodian\",\n    \"capitalize\", \"caps-lock-indicator\", \"caption\", \"captiontext\", \"caret\",\n    \"cell\", \"center\", \"checkbox\", \"circle\", \"cjk-decimal\", \"cjk-earthly-branch\",\n    \"cjk-heavenly-stem\", \"cjk-ideographic\", \"clear\", \"clip\", \"close-quote\",\n    \"col-resize\", \"collapse\", \"color\", \"color-burn\", \"color-dodge\", \"column\", \"column-reverse\",\n    \"compact\", \"condensed\", \"conic-gradient\", \"contain\", \"content\", \"contents\",\n    \"content-box\", \"context-menu\", \"continuous\", \"contrast\", \"copy\", \"counter\", \"counters\", \"cover\", \"crop\",\n    \"cross\", \"crosshair\", \"cubic-bezier\", \"currentcolor\", \"cursive\", \"cyclic\", \"darken\", \"dashed\", \"decimal\",\n    \"decimal-leading-zero\", \"default\", \"default-button\", \"dense\", \"destination-atop\",\n    \"destination-in\", \"destination-out\", \"destination-over\", \"devanagari\", \"difference\",\n    \"disc\", \"discard\", \"disclosure-closed\", \"disclosure-open\", \"document\",\n    \"dot-dash\", \"dot-dot-dash\",\n    \"dotted\", \"double\", \"down\", \"drop-shadow\", \"e-resize\", \"ease\", \"ease-in\", \"ease-in-out\", \"ease-out\",\n    \"element\", \"ellipse\", \"ellipsis\", \"embed\", \"end\", \"ethiopic\", \"ethiopic-abegede\",\n    \"ethiopic-abegede-am-et\", \"ethiopic-abegede-gez\", \"ethiopic-abegede-ti-er\",\n    \"ethiopic-abegede-ti-et\", \"ethiopic-halehame-aa-er\",\n    \"ethiopic-halehame-aa-et\", \"ethiopic-halehame-am-et\",\n    \"ethiopic-halehame-gez\", \"ethiopic-halehame-om-et\",\n    \"ethiopic-halehame-sid-et\", \"ethiopic-halehame-so-et\",\n    \"ethiopic-halehame-ti-er\", \"ethiopic-halehame-ti-et\", \"ethiopic-halehame-tig\",\n    \"ethiopic-numeric\", \"ew-resize\", \"exclusion\", \"expanded\", \"extends\", \"extra-condensed\",\n    \"extra-expanded\", \"fantasy\", \"fast\", \"fill\", \"fill-box\", \"fixed\", \"flat\", \"flex\", \"flex-end\", \"flex-start\", \"footnotes\",\n    \"forwards\", \"from\", \"geometricPrecision\", \"georgian\", \"grayscale\", \"graytext\", \"grid\", \"groove\",\n    \"gujarati\", \"gurmukhi\", \"hand\", \"hangul\", \"hangul-consonant\", \"hard-light\", \"hebrew\",\n    \"help\", \"hidden\", \"hide\", \"higher\", \"highlight\", \"highlighttext\",\n    \"hiragana\", \"hiragana-iroha\", \"horizontal\", \"hsl\", \"hsla\", \"hue\", \"hue-rotate\", \"icon\", \"ignore\",\n    \"inactiveborder\", \"inactivecaption\", \"inactivecaptiontext\", \"infinite\",\n    \"infobackground\", \"infotext\", \"inherit\", \"initial\", \"inline\", \"inline-axis\",\n    \"inline-block\", \"inline-flex\", \"inline-grid\", \"inline-table\", \"inset\", \"inside\", \"intrinsic\", \"invert\",\n    \"italic\", \"japanese-formal\", \"japanese-informal\", \"justify\", \"kannada\",\n    \"katakana\", \"katakana-iroha\", \"keep-all\", \"khmer\",\n    \"korean-hangul-formal\", \"korean-hanja-formal\", \"korean-hanja-informal\",\n    \"landscape\", \"lao\", \"large\", \"larger\", \"left\", \"level\", \"lighter\", \"lighten\",\n    \"line-through\", \"linear\", \"linear-gradient\", \"lines\", \"list-item\", \"listbox\", \"listitem\",\n    \"local\", \"logical\", \"loud\", \"lower\", \"lower-alpha\", \"lower-armenian\",\n    \"lower-greek\", \"lower-hexadecimal\", \"lower-latin\", \"lower-norwegian\",\n    \"lower-roman\", \"lowercase\", \"ltr\", \"luminosity\", \"malayalam\", \"manipulation\", \"match\", \"matrix\", \"matrix3d\",\n    \"media-play-button\", \"media-slider\", \"media-sliderthumb\",\n    \"media-volume-slider\", \"media-volume-sliderthumb\", \"medium\",\n    \"menu\", \"menulist\", \"menulist-button\",\n    \"menutext\", \"message-box\", \"middle\", \"min-intrinsic\",\n    \"mix\", \"mongolian\", \"monospace\", \"move\", \"multiple\", \"multiple_mask_images\", \"multiply\", \"myanmar\", \"n-resize\",\n    \"narrower\", \"ne-resize\", \"nesw-resize\", \"no-close-quote\", \"no-drop\",\n    \"no-open-quote\", \"no-repeat\", \"none\", \"normal\", \"not-allowed\", \"nowrap\",\n    \"ns-resize\", \"numbers\", \"numeric\", \"nw-resize\", \"nwse-resize\", \"oblique\", \"octal\", \"opacity\", \"open-quote\",\n    \"optimizeLegibility\", \"optimizeSpeed\", \"oriya\", \"oromo\", \"outset\",\n    \"outside\", \"outside-shape\", \"overlay\", \"overline\", \"padding\", \"padding-box\",\n    \"painted\", \"page\", \"paused\", \"persian\", \"perspective\", \"pinch-zoom\", \"plus-darker\", \"plus-lighter\",\n    \"pointer\", \"polygon\", \"portrait\", \"pre\", \"pre-line\", \"pre-wrap\", \"preserve-3d\",\n    \"progress\", \"push-button\", \"radial-gradient\", \"radio\", \"read-only\",\n    \"read-write\", \"read-write-plaintext-only\", \"rectangle\", \"region\",\n    \"relative\", \"repeat\", \"repeating-linear-gradient\", \"repeating-radial-gradient\",\n    \"repeating-conic-gradient\", \"repeat-x\", \"repeat-y\", \"reset\", \"reverse\",\n    \"rgb\", \"rgba\", \"ridge\", \"right\", \"rotate\", \"rotate3d\", \"rotateX\", \"rotateY\",\n    \"rotateZ\", \"round\", \"row\", \"row-resize\", \"row-reverse\", \"rtl\", \"run-in\", \"running\",\n    \"s-resize\", \"sans-serif\", \"saturate\", \"saturation\", \"scale\", \"scale3d\", \"scaleX\", \"scaleY\", \"scaleZ\", \"screen\",\n    \"scroll\", \"scrollbar\", \"scroll-position\", \"se-resize\", \"searchfield\",\n    \"searchfield-cancel-button\", \"searchfield-decoration\",\n    \"searchfield-results-button\", \"searchfield-results-decoration\", \"self-start\", \"self-end\",\n    \"semi-condensed\", \"semi-expanded\", \"separate\", \"sepia\", \"serif\", \"show\", \"sidama\",\n    \"simp-chinese-formal\", \"simp-chinese-informal\", \"single\",\n    \"skew\", \"skewX\", \"skewY\", \"skip-white-space\", \"slide\", \"slider-horizontal\",\n    \"slider-vertical\", \"sliderthumb-horizontal\", \"sliderthumb-vertical\", \"slow\",\n    \"small\", \"small-caps\", \"small-caption\", \"smaller\", \"soft-light\", \"solid\", \"somali\",\n    \"source-atop\", \"source-in\", \"source-out\", \"source-over\", \"space\", \"space-around\", \"space-between\", \"space-evenly\", \"spell-out\", \"square\",\n    \"square-button\", \"start\", \"static\", \"status-bar\", \"stretch\", \"stroke\", \"stroke-box\", \"sub\",\n    \"subpixel-antialiased\", \"svg_masks\", \"super\", \"sw-resize\", \"symbolic\", \"symbols\", \"system-ui\", \"table\",\n    \"table-caption\", \"table-cell\", \"table-column\", \"table-column-group\",\n    \"table-footer-group\", \"table-header-group\", \"table-row\", \"table-row-group\",\n    \"tamil\",\n    \"telugu\", \"text\", \"text-bottom\", \"text-top\", \"textarea\", \"textfield\", \"thai\",\n    \"thick\", \"thin\", \"threeddarkshadow\", \"threedface\", \"threedhighlight\",\n    \"threedlightshadow\", \"threedshadow\", \"tibetan\", \"tigre\", \"tigrinya-er\",\n    \"tigrinya-er-abegede\", \"tigrinya-et\", \"tigrinya-et-abegede\", \"to\", \"top\",\n    \"trad-chinese-formal\", \"trad-chinese-informal\", \"transform\",\n    \"translate\", \"translate3d\", \"translateX\", \"translateY\", \"translateZ\",\n    \"transparent\", \"ultra-condensed\", \"ultra-expanded\", \"underline\", \"unidirectional-pan\", \"unset\", \"up\",\n    \"upper-alpha\", \"upper-armenian\", \"upper-greek\", \"upper-hexadecimal\",\n    \"upper-latin\", \"upper-norwegian\", \"upper-roman\", \"uppercase\", \"urdu\", \"url\",\n    \"var\", \"vertical\", \"vertical-text\", \"view-box\", \"visible\", \"visibleFill\", \"visiblePainted\",\n    \"visibleStroke\", \"visual\", \"w-resize\", \"wait\", \"wave\", \"wider\",\n    \"window\", \"windowframe\", \"windowtext\", \"words\", \"wrap\", \"wrap-reverse\", \"x-large\", \"x-small\", \"xor\",\n    \"xx-large\", \"xx-small\"\n  ], valueKeywords = keySet(valueKeywords_);\n\n  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)\n    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)\n    .concat(valueKeywords_);\n  CodeMirror.registerHelper(\"hintWords\", \"css\", allWords);\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == \"/\") {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return [\"comment\", \"comment\"];\n  }\n\n  CodeMirror.defineMIME(\"text/css\", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: \"css\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-scss\", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    lineComment: \"//\",\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return [\"comment\", \"comment\"];\n        } else if (stream.eat(\"*\")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return [\"operator\", \"operator\"];\n        }\n      },\n      \":\": function(stream) {\n        if (stream.match(/^\\s*\\{/, false))\n          return [null, null]\n        return false;\n      },\n      \"$\": function(stream) {\n        stream.match(/^[\\w-]+/);\n        if (stream.match(/^\\s*:/, false))\n          return [\"variable-2\", \"variable-definition\"];\n        return [\"variable-2\", \"variable\"];\n      },\n      \"#\": function(stream) {\n        if (!stream.eat(\"{\")) return false;\n        return [null, \"interpolation\"];\n      }\n    },\n    name: \"css\",\n    helperType: \"scss\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-less\", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    mediaValueKeywords: mediaValueKeywords,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    lineComment: \"//\",\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return [\"comment\", \"comment\"];\n        } else if (stream.eat(\"*\")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return [\"operator\", \"operator\"];\n        }\n      },\n      \"@\": function(stream) {\n        if (stream.eat(\"{\")) return [null, \"interpolation\"];\n        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\\b/i, false)) return false;\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return [\"variable-2\", \"variable-definition\"];\n        return [\"variable-2\", \"variable\"];\n      },\n      \"&\": function() {\n        return [\"atom\", \"atom\"];\n      }\n    },\n    name: \"css\",\n    helperType: \"less\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-gss\", {\n    documentTypes: documentTypes,\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    nonStandardPropertyKeywords: nonStandardPropertyKeywords,\n    fontProperties: fontProperties,\n    counterDescriptors: counterDescriptors,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    supportsAtComponent: true,\n    tokenHooks: {\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: \"css\",\n    helperType: \"gss\"\n  });\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var WORD = /[\\w$]+/, RANGE = 500;\n\n  CodeMirror.registerHelper(\"hint\", \"anyword\", function(editor, options) {\n    var word = options && options.word || WORD;\n    var range = options && options.range || RANGE;\n    var cur = editor.getCursor(), curLine = editor.getLine(cur.line);\n    var end = cur.ch, start = end;\n    while (start && word.test(curLine.charAt(start - 1))) --start;\n    var curWord = start != end && curLine.slice(start, end);\n\n    var list = options && options.list || [], seen = {};\n    var re = new RegExp(word.source, \"g\");\n    for (var dir = -1; dir <= 1; dir += 2) {\n      var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;\n      for (; line != endLine; line += dir) {\n        var text = editor.getLine(line), m;\n        while (m = re.exec(text)) {\n          if (line == cur.line && m[0] === curWord) continue;\n          if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {\n            seen[m[0]] = true;\n            list.push(m[0]);\n          }\n        }\n      }\n    }\n    return {list: list, from: CodeMirror.Pos(cur.line, start), to: CodeMirror.Pos(cur.line, end)};\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  CodeMirror.defineOption(\"showTrailingSpace\", false, function(cm, val, prev) {\n    if (prev == CodeMirror.Init) prev = false;\n    if (prev && !val)\n      cm.removeOverlay(\"trailingspace\");\n    else if (!prev && val)\n      cm.addOverlay({\n        token: function(stream) {\n          for (var l = stream.string.length, i = l; i && /\\s/.test(stream.string.charAt(i - 1)); --i) {}\n          if (i > stream.pos) { stream.pos = i; return null; }\n          stream.pos = l;\n          return \"trailingspace\";\n        },\n        name: \"trailingspace\"\n      });\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79), require(66));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../fold/xml-fold\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"matchTags\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchTags);\n      cm.off(\"viewportChange\", maybeUpdateMatch);\n      clear(cm);\n    }\n    if (val) {\n      cm.state.matchBothTags = typeof val == \"object\" && val.bothTags;\n      cm.on(\"cursorActivity\", doMatchTags);\n      cm.on(\"viewportChange\", maybeUpdateMatch);\n      doMatchTags(cm);\n    }\n  });\n\n  function clear(cm) {\n    if (cm.state.tagHit) cm.state.tagHit.clear();\n    if (cm.state.tagOther) cm.state.tagOther.clear();\n    cm.state.tagHit = cm.state.tagOther = null;\n  }\n\n  function doMatchTags(cm) {\n    cm.state.failedTagMatch = false;\n    cm.operation(function() {\n      clear(cm);\n      if (cm.somethingSelected()) return;\n      var cur = cm.getCursor(), range = cm.getViewport();\n      range.from = Math.min(range.from, cur.line); range.to = Math.max(cur.line + 1, range.to);\n      var match = CodeMirror.findMatchingTag(cm, cur, range);\n      if (!match) return;\n      if (cm.state.matchBothTags) {\n        var hit = match.at == \"open\" ? match.open : match.close;\n        if (hit) cm.state.tagHit = cm.markText(hit.from, hit.to, {className: \"CodeMirror-matchingtag\"});\n      }\n      var other = match.at == \"close\" ? match.open : match.close;\n      if (other)\n        cm.state.tagOther = cm.markText(other.from, other.to, {className: \"CodeMirror-matchingtag\"});\n      else\n        cm.state.failedTagMatch = true;\n    });\n  }\n\n  function maybeUpdateMatch(cm) {\n    if (cm.state.failedTagMatch) doMatchTags(cm);\n  }\n\n  CodeMirror.commands.toMatchingTag = function(cm) {\n    var found = CodeMirror.findMatchingTag(cm, cm.getCursor());\n    if (found) {\n      var other = found.at == \"close\" ? found.open : found.close;\n      if (other) cm.extendSelection(other.to, other.from);\n    }\n  };\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\", \"<\": \">>\", \">\": \"<<\"};\n\n  function bracketRegex(config) {\n    return config && config.bracketRegex || /[(){}[\\]]/\n  }\n\n  function findMatchingBracket(cm, where, config) {\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\n    var afterCursor = config && config.afterCursor\n    if (afterCursor == null)\n      afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className)\n    var re = bracketRegex(config)\n\n    // A cursor is defined as between two characters, but in in vim command mode\n    // (i.e. not insert mode), the cursor is visually represented as a\n    // highlighted box on top of the 2nd character. Otherwise, we allow matches\n    // from before or after the cursor.\n    var match = (!afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)]) ||\n        re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var dir = match.charAt(1) == \">\" ? 1 : -1;\n    if (config && config.strict && (dir > 0) != (pos == where.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\n\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);\n    if (found == null) return null;\n    return {from: Pos(where.line, pos), to: found && found.pos,\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\n  }\n\n  // bracketRegex is used to specify which type of bracket to scan\n  // should be a regexp, e.g. /[[\\]]/\n  //\n  // Note: If \"where\" is on an open bracket, then this bracket is ignored.\n  //\n  // Returns false when no bracket was found, null when it reached\n  // maxScanLines and gave up\n  function scanForBracket(cm, where, dir, style, config) {\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\n    var maxScanLines = (config && config.maxScanLines) || 1000;\n\n    var stack = [];\n    var re = bracketRegex(config)\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\n      var line = cm.getLine(lineNo);\n      if (!line) continue;\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\n      if (line.length > maxScanLen) continue;\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\n      for (; pos != end; pos += dir) {\n        var ch = line.charAt(pos);\n        if (re.test(ch) && (style === undefined ||\n                            (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || \"\") == (style || \"\"))) {\n          var match = matching[ch];\n          if (match && (match.charAt(1) == \">\") == (dir > 0)) stack.push(ch);\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\n          else stack.pop();\n        }\n      }\n    }\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\n  }\n\n  function matchBrackets(cm, autoclear, config) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000,\n      highlightNonMatching = config && config.highlightNonMatching;\n    var marks = [], ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);\n      if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {\n        var style = match.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\n      }\n    }\n\n    if (marks.length) {\n      // Kludge to work around the IE bug from issue #1193, where text\n      // input stops going to the textarea whenever this fires.\n      if (ie_lt8 && cm.state.focused) cm.focus();\n\n      var clear = function() {\n        cm.operation(function() {\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\n        });\n      };\n      if (autoclear) setTimeout(clear, 800);\n      else return clear;\n    }\n  }\n\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (cm.state.matchBrackets.currentlyHighlighted) {\n        cm.state.matchBrackets.currentlyHighlighted();\n        cm.state.matchBrackets.currentlyHighlighted = null;\n      }\n      cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\n    });\n  }\n\n  function clearHighlighted(cm) {\n    if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {\n      cm.state.matchBrackets.currentlyHighlighted();\n      cm.state.matchBrackets.currentlyHighlighted = null;\n    }\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.off(\"cursorActivity\", doMatchBrackets);\n      cm.off(\"focus\", doMatchBrackets)\n      cm.off(\"blur\", clearHighlighted)\n      clearHighlighted(cm);\n    }\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n      cm.on(\"focus\", doMatchBrackets)\n      cm.on(\"blur\", clearHighlighted)\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, config, oldConfig){\n    // Backwards-compatibility kludge\n    if (oldConfig || typeof config == \"boolean\") {\n      if (!oldConfig) {\n        config = config ? {strict: true} : null\n      } else {\n        oldConfig.strict = config\n        config = oldConfig\n      }\n    }\n    return findMatchingBracket(this, pos, config)\n  });\n  CodeMirror.defineExtension(\"scanForBracket\", function(pos, dir, style, config){\n    return scanForBracket(this, pos, dir, style, config);\n  });\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var listRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]\\s|[*+-]\\s|(\\d+)([.)]))(\\s*)/,\n      emptyListRE = /^(\\s*)(>[> ]*|[*+-] \\[[x ]\\]|[*+-]|(\\d+)[.)])(\\s*)$/,\n      unorderedListRE = /[*+-]\\s/;\n\n  CodeMirror.commands.newlineAndIndentContinueMarkdownList = function(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    var ranges = cm.listSelections(), replacements = [];\n    for (var i = 0; i < ranges.length; i++) {\n      var pos = ranges[i].head;\n\n      // If we're not in Markdown mode, fall back to normal newlineAndIndent\n      var eolState = cm.getStateAfter(pos.line);\n      var inner = CodeMirror.innerMode(cm.getMode(), eolState);\n      if (inner.mode.name !== \"markdown\" && inner.mode.helperType !== \"markdown\") {\n        cm.execCommand(\"newlineAndIndent\");\n        return;\n      } else {\n        eolState = inner.state;\n      }\n\n      var inList = eolState.list !== false;\n      var inQuote = eolState.quote !== 0;\n\n      var line = cm.getLine(pos.line), match = listRE.exec(line);\n      var cursorBeforeBullet = /^\\s*$/.test(line.slice(0, pos.ch));\n      if (!ranges[i].empty() || (!inList && !inQuote) || !match || cursorBeforeBullet) {\n        cm.execCommand(\"newlineAndIndent\");\n        return;\n      }\n      if (emptyListRE.test(line)) {\n        var endOfQuote = inQuote && />\\s*$/.test(line)\n        var endOfList = !/>\\s*$/.test(line)\n        if (endOfQuote || endOfList) cm.replaceRange(\"\", {\n          line: pos.line, ch: 0\n        }, {\n          line: pos.line, ch: pos.ch + 1\n        });\n        replacements[i] = \"\\n\";\n      } else {\n        var indent = match[1], after = match[5];\n        var numbered = !(unorderedListRE.test(match[2]) || match[2].indexOf(\">\") >= 0);\n        var bullet = numbered ? (parseInt(match[3], 10) + 1) + match[4] : match[2].replace(\"x\", \" \");\n        replacements[i] = \"\\n\" + indent + bullet + after;\n\n        if (numbered) incrementRemainingMarkdownListNumbers(cm, pos);\n      }\n    }\n\n    cm.replaceSelections(replacements);\n  };\n\n  // Auto-updating Markdown list numbers when a new item is added to the\n  // middle of a list\n  function incrementRemainingMarkdownListNumbers(cm, pos) {\n    var startLine = pos.line, lookAhead = 0, skipCount = 0;\n    var startItem = listRE.exec(cm.getLine(startLine)), startIndent = startItem[1];\n\n    do {\n      lookAhead += 1;\n      var nextLineNumber = startLine + lookAhead;\n      var nextLine = cm.getLine(nextLineNumber), nextItem = listRE.exec(nextLine);\n\n      if (nextItem) {\n        var nextIndent = nextItem[1];\n        var newNumber = (parseInt(startItem[3], 10) + lookAhead - skipCount);\n        var nextNumber = (parseInt(nextItem[3], 10)), itemNumber = nextNumber;\n\n        if (startIndent === nextIndent && !isNaN(nextNumber)) {\n          if (newNumber === nextNumber) itemNumber = nextNumber + 1;\n          if (newNumber > nextNumber) itemNumber = newNumber + 1;\n          cm.replaceRange(\n            nextLine.replace(listRE, nextIndent + itemNumber + nextItem[4] + nextItem[5]),\n          {\n            line: nextLineNumber, ch: 0\n          }, {\n            line: nextLineNumber, ch: nextLine.length\n          });\n        } else {\n          if (startIndent.length > nextIndent.length) return;\n          // This doesn't run if the next line immediately indents, as it is\n          // not clear of the users intention (new indented item or same level)\n          if ((startIndent.length < nextIndent.length) && (lookAhead === 1)) return;\n          skipCount += 1;\n        }\n      }\n    } while (nextItem);\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n/**\n * Tag-closer extension for CodeMirror.\n *\n * This extension adds an \"autoCloseTags\" option that can be set to\n * either true to get the default behavior, or an object to further\n * configure its behavior.\n *\n * These are supported options:\n *\n * `whenClosing` (default true)\n *   Whether to autoclose when the '/' of a closing tag is typed.\n * `whenOpening` (default true)\n *   Whether to autoclose the tag when the final '>' of an opening\n *   tag is typed.\n * `dontCloseTags` (default is empty tags for HTML, none for XML)\n *   An array of tag names that should not be autoclosed.\n * `indentTags` (default is block tags for HTML, none for XML)\n *   An array of tag names that should, when opened, cause a\n *   blank line to be added inside the tag, and the blank line and\n *   closing line to be indented.\n * `emptyTags` (default is none)\n *   An array of XML tag names that should be autoclosed with '/>'.\n *\n * See demos/closetag.html for a usage example.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79), require(66));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../fold/xml-fold\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  CodeMirror.defineOption(\"autoCloseTags\", false, function(cm, val, old) {\n    if (old != CodeMirror.Init && old)\n      cm.removeKeyMap(\"autoCloseTags\");\n    if (!val) return;\n    var map = {name: \"autoCloseTags\"};\n    if (typeof val != \"object\" || val.whenClosing !== false)\n      map[\"'/'\"] = function(cm) { return autoCloseSlash(cm); };\n    if (typeof val != \"object\" || val.whenOpening !== false)\n      map[\"'>'\"] = function(cm) { return autoCloseGT(cm); };\n    cm.addKeyMap(map);\n  });\n\n  var htmlDontClose = [\"area\", \"base\", \"br\", \"col\", \"command\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\",\n                       \"source\", \"track\", \"wbr\"];\n  var htmlIndent = [\"applet\", \"blockquote\", \"body\", \"button\", \"div\", \"dl\", \"fieldset\", \"form\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\",\n                    \"h5\", \"h6\", \"head\", \"html\", \"iframe\", \"layer\", \"legend\", \"object\", \"ol\", \"p\", \"select\", \"table\", \"ul\"];\n\n  function autoCloseGT(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    var ranges = cm.listSelections(), replacements = [];\n    var opt = cm.getOption(\"autoCloseTags\");\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n      var tagInfo = inner.mode.xmlCurrentTag && inner.mode.xmlCurrentTag(state)\n      var tagName = tagInfo && tagInfo.name\n      if (!tagName) return CodeMirror.Pass\n\n      var html = inner.mode.configuration == \"html\";\n      var dontCloseTags = (typeof opt == \"object\" && opt.dontCloseTags) || (html && htmlDontClose);\n      var indentTags = (typeof opt == \"object\" && opt.indentTags) || (html && htmlIndent);\n\n      if (tok.end > pos.ch) tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);\n      var lowerTagName = tagName.toLowerCase();\n      // Don't process the '>' at the end of an end-tag or self-closing tag\n      if (!tagName ||\n          tok.type == \"string\" && (tok.end != pos.ch || !/[\\\"\\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) ||\n          tok.type == \"tag\" && tagInfo.close ||\n          tok.string.indexOf(\"/\") == (pos.ch - tok.start - 1) || // match something like <someTagName />\n          dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 ||\n          closingTagExists(cm, inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state) || [], tagName, pos, true))\n        return CodeMirror.Pass;\n\n      var emptyTags = typeof opt == \"object\" && opt.emptyTags;\n      if (emptyTags && indexOf(emptyTags, tagName) > -1) {\n        replacements[i] = { text: \"/>\", newPos: CodeMirror.Pos(pos.line, pos.ch + 2) };\n        continue;\n      }\n\n      var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;\n      replacements[i] = {indent: indent,\n                         text: \">\" + (indent ? \"\\n\\n\" : \"\") + \"</\" + tagName + \">\",\n                         newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1)};\n    }\n\n    var dontIndentOnAutoClose = (typeof opt == \"object\" && opt.dontIndentOnAutoClose);\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var info = replacements[i];\n      cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, \"+insert\");\n      var sel = cm.listSelections().slice(0);\n      sel[i] = {head: info.newPos, anchor: info.newPos};\n      cm.setSelections(sel);\n      if (!dontIndentOnAutoClose && info.indent) {\n        cm.indentLine(info.newPos.line, null, true);\n        cm.indentLine(info.newPos.line + 1, null, true);\n      }\n    }\n  }\n\n  function autoCloseCurrent(cm, typingSlash) {\n    var ranges = cm.listSelections(), replacements = [];\n    var head = typingSlash ? \"/\" : \"</\";\n    var opt = cm.getOption(\"autoCloseTags\");\n    var dontIndentOnAutoClose = (typeof opt == \"object\" && opt.dontIndentOnSlash);\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\n      if (typingSlash && (tok.type == \"string\" || tok.string.charAt(0) != \"<\" ||\n                          tok.start != pos.ch - 1))\n        return CodeMirror.Pass;\n      // Kludge to get around the fact that we are not in XML mode\n      // when completing in JS/CSS snippet in htmlmixed mode. Does not\n      // work for other XML embedded languages (there is no general\n      // way to go from a mixed mode to its current XML state).\n      var replacement, mixed = inner.mode.name != \"xml\" && cm.getMode().name == \"htmlmixed\"\n      if (mixed && inner.mode.name == \"javascript\") {\n        replacement = head + \"script\";\n      } else if (mixed && inner.mode.name == \"css\") {\n        replacement = head + \"style\";\n      } else {\n        var context = inner.mode.xmlCurrentContext && inner.mode.xmlCurrentContext(state)\n        var top = context.length ? context[context.length - 1] : \"\"\n        if (!context || (context.length && closingTagExists(cm, context, top, pos)))\n          return CodeMirror.Pass;\n        replacement = head + top\n      }\n      if (cm.getLine(pos.line).charAt(tok.end) != \">\") replacement += \">\";\n      replacements[i] = replacement;\n    }\n    cm.replaceSelections(replacements);\n    ranges = cm.listSelections();\n    if (!dontIndentOnAutoClose) {\n        for (var i = 0; i < ranges.length; i++)\n            if (i == ranges.length - 1 || ranges[i].head.line < ranges[i + 1].head.line)\n                cm.indentLine(ranges[i].head.line);\n    }\n  }\n\n  function autoCloseSlash(cm) {\n    if (cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n    return autoCloseCurrent(cm, true);\n  }\n\n  CodeMirror.commands.closeTag = function(cm) { return autoCloseCurrent(cm); };\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n\n  // If xml-fold is loaded, we use its functionality to try and verify\n  // whether a given tag is actually unclosed.\n  function closingTagExists(cm, context, tagName, pos, newTag) {\n    if (!CodeMirror.scanForClosingTag) return false;\n    var end = Math.min(cm.lastLine() + 1, pos.line + 500);\n    var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);\n    if (!nextClose || nextClose.tag != tagName) return false;\n    // If the immediate wrapping context contains onCx instances of\n    // the same tag, a closing tag only exists if there are at least\n    // that many closing tags of that type following.\n    var onCx = newTag ? 1 : 0\n    for (var i = context.length - 1; i >= 0; i--) {\n      if (context[i] == tagName) ++onCx\n      else break\n    }\n    pos = nextClose.to;\n    for (var i = 1; i < onCx; i++) {\n      var next = CodeMirror.scanForClosingTag(cm, pos, null, end);\n      if (!next || next.tag != tagName) return false;\n      pos = next.to;\n    }\n    return true;\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch; }\n\n  var nameStartChar = \"A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n  var nameChar = nameStartChar + \"\\-\\:\\.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n  var xmlTagStart = new RegExp(\"<(/?)([\" + nameStartChar + \"][\" + nameChar + \"]*)\", \"g\");\n\n  function Iter(cm, line, ch, range) {\n    this.line = line; this.ch = ch;\n    this.cm = cm; this.text = cm.getLine(line);\n    this.min = range ? Math.max(range.from, cm.firstLine()) : cm.firstLine();\n    this.max = range ? Math.min(range.to - 1, cm.lastLine()) : cm.lastLine();\n  }\n\n  function tagAt(iter, ch) {\n    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));\n    return type && /\\btag\\b/.test(type);\n  }\n\n  function nextLine(iter) {\n    if (iter.line >= iter.max) return;\n    iter.ch = 0;\n    iter.text = iter.cm.getLine(++iter.line);\n    return true;\n  }\n  function prevLine(iter) {\n    if (iter.line <= iter.min) return;\n    iter.text = iter.cm.getLine(--iter.line);\n    iter.ch = iter.text.length;\n    return true;\n  }\n\n  function toTagEnd(iter) {\n    for (;;) {\n      var gt = iter.text.indexOf(\">\", iter.ch);\n      if (gt == -1) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt + 1; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n  function toTagStart(iter) {\n    for (;;) {\n      var lt = iter.ch ? iter.text.lastIndexOf(\"<\", iter.ch - 1) : -1;\n      if (lt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, lt + 1)) { iter.ch = lt; continue; }\n      xmlTagStart.lastIndex = lt;\n      iter.ch = lt;\n      var match = xmlTagStart.exec(iter.text);\n      if (match && match.index == lt) return match;\n    }\n  }\n\n  function toNextTag(iter) {\n    for (;;) {\n      xmlTagStart.lastIndex = iter.ch;\n      var found = xmlTagStart.exec(iter.text);\n      if (!found) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, found.index + 1)) { iter.ch = found.index + 1; continue; }\n      iter.ch = found.index + found[0].length;\n      return found;\n    }\n  }\n  function toPrevTag(iter) {\n    for (;;) {\n      var gt = iter.ch ? iter.text.lastIndexOf(\">\", iter.ch - 1) : -1;\n      if (gt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n\n  function findMatchingClose(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var next = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next ? next[0].length : 0);\n      if (!next || !(end = toTagEnd(iter))) return;\n      if (end == \"selfClose\") continue;\n      if (next[1]) { // closing tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == next[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == next[2])) return {\n          tag: next[2],\n          from: Pos(startLine, startCh),\n          to: Pos(iter.line, iter.ch)\n        };\n      } else { // opening tag\n        stack.push(next[2]);\n      }\n    }\n  }\n  function findMatchingOpen(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var prev = toPrevTag(iter);\n      if (!prev) return;\n      if (prev == \"selfClose\") { toTagStart(iter); continue; }\n      var endLine = iter.line, endCh = iter.ch;\n      var start = toTagStart(iter);\n      if (!start) return;\n      if (start[1]) { // closing tag\n        stack.push(start[2]);\n      } else { // opening tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == start[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == start[2])) return {\n          tag: start[2],\n          from: Pos(iter.line, iter.ch),\n          to: Pos(endLine, endCh)\n        };\n      }\n    }\n  }\n\n  CodeMirror.registerHelper(\"fold\", \"xml\", function(cm, start) {\n    var iter = new Iter(cm, start.line, 0);\n    for (;;) {\n      var openTag = toNextTag(iter)\n      if (!openTag || iter.line != start.line) return\n      var end = toTagEnd(iter)\n      if (!end) return\n      if (!openTag[1] && end != \"selfClose\") {\n        var startPos = Pos(iter.line, iter.ch);\n        var endPos = findMatchingClose(iter, openTag[2]);\n        return endPos && cmp(endPos.from, startPos) > 0 ? {from: startPos, to: endPos.from} : null\n      }\n    }\n  });\n  CodeMirror.findMatchingTag = function(cm, pos, range) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    if (iter.text.indexOf(\">\") == -1 && iter.text.indexOf(\"<\") == -1) return;\n    var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);\n    var start = end && toTagStart(iter);\n    if (!end || !start || cmp(iter, pos) > 0) return;\n    var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};\n    if (end == \"selfClose\") return {open: here, close: null, at: \"open\"};\n\n    if (start[1]) { // closing tag\n      return {open: findMatchingOpen(iter, start[2]), close: here, at: \"close\"};\n    } else { // opening tag\n      iter = new Iter(cm, to.line, to.ch, range);\n      return {open: here, close: findMatchingClose(iter, start[2]), at: \"open\"};\n    }\n  };\n\n  CodeMirror.findEnclosingTag = function(cm, pos, range, tag) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    for (;;) {\n      var open = findMatchingOpen(iter, tag);\n      if (!open) break;\n      var forward = new Iter(cm, pos.line, pos.ch, range);\n      var close = findMatchingClose(forward, open.tag);\n      if (close) return {open: open, close: close};\n    }\n  };\n\n  // Used by addon/edit/closetag.js\n  CodeMirror.scanForClosingTag = function(cm, pos, name, end) {\n    var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);\n    return findMatchingClose(iter, name);\n  };\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(79));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  var defaults = {\n    pairs: \"()[]{}''\\\"\\\"\",\n    closeBefore: \")]}'\\\":;>\",\n    triples: \"\",\n    explode: \"[]{}\"\n  };\n\n  var Pos = CodeMirror.Pos;\n\n  CodeMirror.defineOption(\"autoCloseBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.removeKeyMap(keyMap);\n      cm.state.closeBrackets = null;\n    }\n    if (val) {\n      ensureBound(getOption(val, \"pairs\"))\n      cm.state.closeBrackets = val;\n      cm.addKeyMap(keyMap);\n    }\n  });\n\n  function getOption(conf, name) {\n    if (name == \"pairs\" && typeof conf == \"string\") return conf;\n    if (typeof conf == \"object\" && conf[name] != null) return conf[name];\n    return defaults[name];\n  }\n\n  var keyMap = {Backspace: handleBackspace, Enter: handleEnter};\n  function ensureBound(chars) {\n    for (var i = 0; i < chars.length; i++) {\n      var ch = chars.charAt(i), key = \"'\" + ch + \"'\"\n      if (!keyMap[key]) keyMap[key] = handler(ch)\n    }\n  }\n  ensureBound(defaults.pairs + \"`\")\n\n  function handler(ch) {\n    return function(cm) { return handleChar(cm, ch); };\n  }\n\n  function getConfig(cm) {\n    var deflt = cm.state.closeBrackets;\n    if (!deflt || deflt.override) return deflt;\n    var mode = cm.getModeAt(cm.getCursor());\n    return mode.closeBrackets || deflt;\n  }\n\n  function handleBackspace(cm) {\n    var conf = getConfig(cm);\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var pairs = getOption(conf, \"pairs\");\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var around = charsAround(cm, ranges[i].head);\n      if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n    }\n    for (var i = ranges.length - 1; i >= 0; i--) {\n      var cur = ranges[i].head;\n      cm.replaceRange(\"\", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), \"+delete\");\n    }\n  }\n\n  function handleEnter(cm) {\n    var conf = getConfig(cm);\n    var explode = conf && getOption(conf, \"explode\");\n    if (!explode || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++) {\n      if (!ranges[i].empty()) return CodeMirror.Pass;\n      var around = charsAround(cm, ranges[i].head);\n      if (!around || explode.indexOf(around) % 2 != 0) return CodeMirror.Pass;\n    }\n    cm.operation(function() {\n      var linesep = cm.lineSeparator() || \"\\n\";\n      cm.replaceSelection(linesep + linesep, null);\n      moveSel(cm, -1)\n      ranges = cm.listSelections();\n      for (var i = 0; i < ranges.length; i++) {\n        var line = ranges[i].head.line;\n        cm.indentLine(line, null, true);\n        cm.indentLine(line + 1, null, true);\n      }\n    });\n  }\n\n  function moveSel(cm, dir) {\n    var newRanges = [], ranges = cm.listSelections(), primary = 0\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i]\n      if (range.head == cm.getCursor()) primary = i\n      var pos = range.head.ch || dir > 0 ? {line: range.head.line, ch: range.head.ch + dir} : {line: range.head.line - 1}\n      newRanges.push({anchor: pos, head: pos})\n    }\n    cm.setSelections(newRanges, primary)\n  }\n\n  function contractSelection(sel) {\n    var inverted = CodeMirror.cmpPos(sel.anchor, sel.head) > 0;\n    return {anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),\n            head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))};\n  }\n\n  function handleChar(cm, ch) {\n    var conf = getConfig(cm);\n    if (!conf || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\n    var pairs = getOption(conf, \"pairs\");\n    var pos = pairs.indexOf(ch);\n    if (pos == -1) return CodeMirror.Pass;\n\n    var closeBefore = getOption(conf,\"closeBefore\");\n\n    var triples = getOption(conf, \"triples\");\n\n    var identical = pairs.charAt(pos + 1) == ch;\n    var ranges = cm.listSelections();\n    var opening = pos % 2 == 0;\n\n    var type;\n    for (var i = 0; i < ranges.length; i++) {\n      var range = ranges[i], cur = range.head, curType;\n      var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));\n      if (opening && !range.empty()) {\n        curType = \"surround\";\n      } else if ((identical || !opening) && next == ch) {\n        if (identical && stringStartsAfter(cm, cur))\n          curType = \"both\";\n        else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)\n          curType = \"skipThree\";\n        else\n          curType = \"skip\";\n      } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 &&\n                 cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {\n        if (cur.ch > 2 && /\\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2)))) return CodeMirror.Pass;\n        curType = \"addFour\";\n      } else if (identical) {\n        var prev = cur.ch == 0 ? \" \" : cm.getRange(Pos(cur.line, cur.ch - 1), cur)\n        if (!CodeMirror.isWordChar(next) && prev != ch && !CodeMirror.isWordChar(prev)) curType = \"both\";\n        else return CodeMirror.Pass;\n      } else if (opening && (next.length === 0 || /\\s/.test(next) || closeBefore.indexOf(next) > -1)) {\n        curType = \"both\";\n      } else {\n        return CodeMirror.Pass;\n      }\n      if (!type) type = curType;\n      else if (type != curType) return CodeMirror.Pass;\n    }\n\n    var left = pos % 2 ? pairs.charAt(pos - 1) : ch;\n    var right = pos % 2 ? ch : pairs.charAt(pos + 1);\n    cm.operation(function() {\n      if (type == \"skip\") {\n        moveSel(cm, 1)\n      } else if (type == \"skipThree\") {\n        moveSel(cm, 3)\n      } else if (type == \"surround\") {\n        var sels = cm.getSelections();\n        for (var i = 0; i < sels.length; i++)\n          sels[i] = left + sels[i] + right;\n        cm.replaceSelections(sels, \"around\");\n        sels = cm.listSelections().slice();\n        for (var i = 0; i < sels.length; i++)\n          sels[i] = contractSelection(sels[i]);\n        cm.setSelections(sels);\n      } else if (type == \"both\") {\n        cm.replaceSelection(left + right, null);\n        cm.triggerElectric(left + right);\n        moveSel(cm, -1)\n      } else if (type == \"addFour\") {\n        cm.replaceSelection(left + left + left + left, \"before\");\n        moveSel(cm, 1)\n      }\n    });\n  }\n\n  function charsAround(cm, pos) {\n    var str = cm.getRange(Pos(pos.line, pos.ch - 1),\n                          Pos(pos.line, pos.ch + 1));\n    return str.length == 2 ? str : null;\n  }\n\n  function stringStartsAfter(cm, pos) {\n    var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1))\n    return /\\bstring/.test(token.type) && token.start == pos.ch &&\n      (pos.ch == 0 || !/\\bstring/.test(cm.getTokenTypeAt(pos)))\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/5/LICENSE\n\n// This is CodeMirror (https://codemirror.net/5), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\/(\\d+)/.exec(userAgent);\n  var chrome_version = chrome && +chrome[1];\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n  var android = /Android/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) { presto_version = Number(presto_version[1]); }\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\n  var rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      { e.removeChild(e.firstChild); }\n    return e\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e)\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) { e.className = className; }\n    if (style) { e.style.cssText = style; }\n    if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n    return e\n  }\n  // wrapper for elt, which removes the elt from the accessibility tree\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e\n  }\n\n  var range;\n  if (document.createRange) { range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r\n  }; }\n  else { range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r\n  }; }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      { child = child.parentNode; }\n    if (parent.contains)\n      { return parent.contains(child) }\n    do {\n      if (child.nodeType == 11) { child = child.host; }\n      if (child == parent) { return true }\n    } while (child = child.parentNode)\n  }\n\n  function activeElt(rootNode) {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var doc = rootNode.ownerDocument || rootNode;\n    var activeElement;\n    try {\n      activeElement = rootNode.activeElement;\n    } catch(e) {\n      activeElement = doc.body || null;\n    }\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      { activeElement = activeElement.shadowRoot.activeElement; }\n    return activeElement\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n  }\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n    return b\n  }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\n  else if (ie) // Suppress mysterious IE10 errors\n    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\n  function doc(cm) { return cm.display.wrapper.ownerDocument }\n\n  function root(cm) {\n    return rootNode(cm.display.wrapper)\n  }\n\n  function rootNode(element) {\n    // Detect modern browsers (2017+).\n    return element.getRootNode ? element.getRootNode() : element.ownerDocument\n  }\n\n  function win(cm) { return doc(cm).defaultView }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args)}\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) { target = {}; }\n    for (var prop in obj)\n      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        { target[prop] = obj[prop]; } }\n    return target\n  }\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) { end = string.length; }\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        { return n + (end - i) }\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function() {\n    this.id = null;\n    this.f = null;\n    this.time = 0;\n    this.handler = bind(this.onTimeout, this);\n  };\n  Delayed.prototype.onTimeout = function (self) {\n    self.id = 0;\n    if (self.time <= +new Date) {\n      self.f();\n    } else {\n      setTimeout(self.handler, self.time - +new Date);\n    }\n  };\n  Delayed.prototype.set = function (ms, f) {\n    this.f = f;\n    var time = +new Date + ms;\n    if (!this.id || time < this.time) {\n      clearTimeout(this.id);\n      this.id = setTimeout(this.handler, ms);\n      this.time = time;\n    }\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      { if (array[i] == elt) { return i } }\n    return -1\n  }\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 50;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) { nextTab = string.length; }\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        { return pos + Math.min(skipped, goal - col) }\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) { return pos }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      { spaceStrs.push(lst(spaceStrs) + \" \"); }\n    return spaceStrs[n]\n  }\n\n  function lst(arr) { return arr[arr.length-1] }\n\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n    return out\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0, priority = score(value);\n    while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) { copyObj(props, inst); }\n    return inst\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n  }\n  function isWordChar(ch, helper) {\n    if (!helper) { return isWordCharBasic(ch) }\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n    return helper.test(ch)\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n    return true\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n    return pos\n  }\n\n  // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n    for (;;) {\n      if (from == to) { return from }\n      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n      if (mid == from) { return pred(mid) ? from : to }\n      if (pred(mid)) { to = mid; }\n      else { from = mid + dir; }\n    }\n  }\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) { return f(from, to, \"ltr\", 0) }\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n    if (!found) { f(from, to, \"ltr\"); }\n  }\n\n  var bidiOther = null;\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < ch && cur.to > ch) { return i }\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n    }\n    return found != null ? found : bidiOther\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6f9\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n    function charType(code) {\n      if (code <= 0xf7) { return lowTypes.charAt(code) }\n      else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n      else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n      else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n      else if (code == 0x200c) { return \"b\" }\n      else { return \"L\" }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n      var len = str.length, types = [];\n      for (var i = 0; i < len; ++i)\n        { types.push(charType(str.charCodeAt(i))); }\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n        if (type == \"m\") { types[i$1] = prev; }\n        else { prev = type; }\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n        if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n        if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n        else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n                 (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n        prev$1 = type$2;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n        if (type$3 == \",\") { types[i$4] = \"N\"; }\n        else if (type$3 == \"%\") {\n          var end = (void 0);\n          for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i$4; j < end; ++j) { types[j] = replace; }\n          i$4 = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n        if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n        else if (isStrong.test(type$4)) { cur$1 = type$4; }\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = (void 0);\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n          var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n          var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n          i$6 = end$1 - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7, at = order.length, isRTL = direction == \"rtl\" ? 1 : 0;\n          for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }\n              var nstart = j$2;\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              at += isRTL;\n              pos = j$2;\n            } else { ++j$2; }\n          }\n          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n        }\n      }\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order\n    }\n  })();\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line, direction) {\n    var order = line.order;\n    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n    return order\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var noHandlers = [];\n\n  var on = function(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      map[type] = (map[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers, arr = map && map[type];\n      if (arr) {\n        var index = indexOf(arr, f);\n        if (index > -1)\n          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n      }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type);\n    if (!handlers.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) { return }\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n      { set.push(arr[i]); } }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) { e.stopPropagation(); }\n    else { e.cancelBubble = true; }\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\n  function e_target(e) {return e.target || e.srcElement}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) { b = 1; }\n      else if (e.button & 2) { b = 3; }\n      else if (e.button & 4) { b = 2; }\n    }\n    if (mac && e.ctrlKey && b == 1) { b = 3; }\n    return b\n  }\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) { return false }\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) { return badBidiRects }\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right < 3)\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) { nl = string.length; }\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result\n  } : function (string) { return string.split(/\\r\\n?|\\n/); };\n\n  var hasSelection = window.getSelection ? function (te) {\n    try { return te.selectionStart != te.selectionEnd }\n    catch(e) { return false }\n  } : function (te) {\n    var range;\n    try {range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) { return false }\n    return range.compareEndPoints(\"StartToEnd\", range) != 0\n  };\n\n  var hasCopyEvent = (function () {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) { return true }\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\"\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) { return badZoomedRects }\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n  }\n\n  // Known modes, by name and by MIME\n  var modes = {}, mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  function defineMode(name, mode) {\n    if (arguments.length > 2)\n      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  }\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") { found = {name: found}; }\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\")\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\")\n    }\n    if (typeof spec == \"string\") { return {name: spec} }\n    else { return spec || {name: \"null\"} }\n  }\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) { return getMode(options, \"text/plain\") }\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) { continue }\n        if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) { modeObj.helperType = spec.helperType; }\n    if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n      { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n    return modeObj\n  }\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = {};\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) { return state }\n    if (mode.copyState) { return mode.copyState(state) }\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) { val = val.concat([]); }\n      nstate[n] = val;\n    }\n    return nstate\n  }\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  function innerMode(mode, state) {\n    var info;\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n      if (!info || info.mode == mode) { break }\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state}\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true\n  }\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = function(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {return this.pos >= this.string.length};\n  StringStream.prototype.sol = function () {return this.pos == this.lineStart};\n  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length)\n      { return this.string.charAt(this.pos++) }\n  };\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n    if (typeof match == \"string\") { ok = ch == match; }\n    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n    if (ok) {++this.pos; return ch}\n  };\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start\n  };\n  StringStream.prototype.eatSpace = function () {\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }\n    return this.pos > start\n  };\n  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true}\n  };\n  StringStream.prototype.backUp = function (n) {this.pos -= n;};\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) { this.pos += pattern.length; }\n        return true\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) { return null }\n      if (match && consume !== false) { this.pos += match[0].length; }\n      return match\n    }\n  };\n  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n    try { return inner() }\n    finally { this.lineStart -= n; }\n  };\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n)\n  };\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos)\n  };\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n    var chunk = doc;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n]\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n      if (n == end.line) { text = text.slice(0, end.ch); }\n      if (n == start.line) { text = text.slice(start.ch); }\n      out.push(text);\n      ++n;\n    });\n    return out\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n    return out\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) { return null }\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) { break }\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1], ch = child.height;\n        if (h < ch) { chunk = child; continue outer }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n\n    } while (!chunk.lines)\n    var i = 0;\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) { break }\n      h -= lh;\n    }\n    return n + i\n  }\n\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber))\n  }\n\n  // A Pos instance represents a position within the text.\n  function Pos(line, ch, sticky) {\n    if ( sticky === void 0 ) sticky = null;\n\n    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  }\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\n  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\n  function copyPos(x) {return Pos(x.line, x.ch)}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) { return Pos(doc.first, 0) }\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n    return clipToLen(pos, getLine(doc, pos.line).text.length)\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n    else if (ch < 0) { return Pos(pos.line, 0) }\n    else { return pos }\n  }\n  function clipPosArray(doc, array) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n    return out\n  }\n\n  var SavedContext = function(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n    return line\n  };\n\n  Context.prototype.baseToken = function (n) {\n    if (!this.baseTokens) { return null }\n    while (this.baseTokens[this.baseTokenPos] <= n)\n      { this.baseTokenPos += 2; }\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n            size: this.baseTokens[this.baseTokenPos] - n}\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n    if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext)\n      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n    else\n      { return new Context(doc, copyState(doc.mode, saved), line) }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n  };\n\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n            lineClasses, forceToEnd);\n    var state = context.state;\n\n    // Run overlays, adjust style array.\n    var loop = function ( o ) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            { st.splice(i, 1, end, st[i+1], i_end); }\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) { return }\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n      if (resetState) { context.state = resetState; }\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n      if (result.classes) { line.styleClasses = result.classes; }\n      else if (line.styleClasses) { line.styleClasses = null; }\n      if (updateFrontier === cm.doc.highlightFrontier)\n        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n    }\n    return line.styles\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) { return new Context(doc, true, n) }\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n    if (precise) { doc.modeFrontier = context.line; }\n    return context\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") { callBlankLine(mode, context.state); }\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) { return mode.blankLine(state) }\n    if (!mode.innerMode) { return }\n    var inner = innerMode(mode, state);\n    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) { inner[0] = innerMode(mode, state).mode; }\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) { return style }\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n  }\n\n  var Token = function(stream, type, state) {\n    this.start = stream.start; this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  };\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n    if (asArray) { tokens = []; }\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n    }\n    return asArray ? tokens : new Token(stream, style, context.state)\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) { for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) { break }\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        { output[prop] = lineClass[2]; }\n      else if (!(new RegExp(\"(?:^|\\\\s)\" + lineClass[2] + \"(?:$|\\\\s)\")).test(output[prop]))\n        { output[prop] += \" \" + lineClass[2]; }\n    } }\n    return type\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) { return doc.first }\n      var line = getLine(doc, search - 1), after = line.stateAfter;\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n        { return search }\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n    if (doc.highlightFrontier < n - 10) { return }\n    var start = doc.first;\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter;\n      // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break\n      }\n    }\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  }\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) { return span }\n    } }\n  }\n\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    var r;\n    for (var i = 0; i < spans.length; ++i)\n      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n    return r\n  }\n\n  // Add a span to a line.\n  function addMarkedSpan(line, span, op) {\n    var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet));\n    if (inThisOp && line.markedSpans && inThisOp.has(line.markedSpans)) {\n      line.markedSpans.push(span);\n    } else {\n      line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n      if (inThisOp) { inThisOp.add(line.markedSpans); }\n    }\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    } }\n    return nw\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    } }\n    return nw\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) { return null }\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) { return null }\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) { span.to = startCh; }\n          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n        if (span$1.to != null) { span$1.to += offset; }\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n          if (!found$1) {\n            span$1.from = offset;\n            if (sameLine) { (first || (first = [])).push(span$1); }\n          }\n        } else {\n          span$1.from += offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) { first = clearEmptySpans(first); }\n    if (last && last != first) { last = clearEmptySpans(last); }\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        { for (var i$2 = 0; i$2 < first.length; ++i$2)\n          { if (first[i$2].to == null)\n            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n      for (var i$3 = 0; i$3 < gap; ++i$3)\n        { newMarkers.push(gapMarkers); }\n      newMarkers.push(last);\n    }\n    return newMarkers\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        { spans.splice(i--, 1); }\n    }\n    if (!spans.length) { return null }\n    return spans\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          { (markers || (markers = [])).push(mark); }\n      } }\n    });\n    if (!markers) { return null }\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          { newParts.push({from: p.from, to: m.from}); }\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          { newParts.push({from: m.to, to: p.to}); }\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n    return parts\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.detachLine(line); }\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.attachLine(line); }\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) { return lenDiff }\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) { return -fromCmp }\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) { return toCmp }\n    return b.id - a.id\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        { found = sp.marker; }\n    } }\n    return found\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }\n    } }\n    return found\n  }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n        { return true }\n    } }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      { line = merged.find(-1, true).line; }\n    return line\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return line\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line\n      ;(lines || (lines = [])).push(line);\n    }\n    return lines\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) { return lineN }\n    return lineNo(vis)\n  }\n\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) { return lineN }\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) { return lineN }\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return lineNo(line) + 1\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      if (sp.from == null) { return true }\n      if (sp.marker.widgetNode) { continue }\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        { return true }\n    } }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      { return true }\n    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) { return true }\n    }\n  }\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) { break }\n      else { h += line.height; }\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n        if (cur == chunk) { break }\n        else { h += cur.height; }\n      }\n    }\n    return h\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) { return 0 }\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n    return len\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () { return lineNo(this) };\n  eventMixin(Line);\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n    if (line.order != null) { line.order = null; }\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) { return null }\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n        if (line.styleClasses.textClass)\n          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild;\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n        { builder.content.className = \"cm-tab-wrap-hack\"; }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n    return builder\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) { return }\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    var content;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) { mustWrap = true; }\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n          else { content.appendChild(txt); }\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) { break }\n        pos += skipped + 1;\n        var txt$1 = (void 0);\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n          else { content.appendChild(txt$1); }\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n    if (style || startStyle || endStyle || mustWrap || css || attributes) {\n      var fullStyle = style || \"\";\n      if (startStyle) { fullStyle += startStyle; }\n      if (endStyle) { fullStyle += endStyle; }\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (attributes) {\n        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\")\n          { token.setAttribute(attr, attributes[attr]); } }\n      }\n      return builder.content.appendChild(token)\n    }\n    builder.content.appendChild(content);\n  }\n\n  // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) { return text }\n    var spaceBefore = trailingBefore, result = \"\";\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        { ch = \"\\u00a0\"; }\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = (void 0);\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n          if (part.to > start && part.from <= start) { break }\n        }\n        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    }\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        { widget = builder.content.appendChild(document.createElement(\"span\")); }\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n      return\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles = (void 0);\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) { spanStyle += \" \" + m.className; }\n            if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n            if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n            // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n            if (m.title) { (attributes || (attributes = {})).title = m.title; }\n            if (m.attributes) {\n              for (var attr in m.attributes)\n                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }\n            }\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              { collapsed = sp; }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) { return }\n          if (collapsed.to == pos) { collapsed = false; }\n        }\n      }\n      if (pos >= len) { break }\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        { callbacks[i].call(null); }\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n      }\n    } while (i < callbacks.length)\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n    if (!group) { return }\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type);\n    if (!arr.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    var loop = function ( i ) {\n      list.push(function () { return arr[i].apply(null, args); });\n    };\n\n    for (var i = 0; i < arr.length; ++i)\n      loop( i );\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") { updateLineText(cm, lineView); }\n      else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n      else if (type == \"class\") { updateLineClasses(cm, lineView); }\n      else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n    }\n    return lineView.node\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) { cls += \" CodeMirror-linebackground\"; }\n    if (lineView.background) {\n      if (cls) { lineView.background.className = cls; }\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built\n    }\n    return buildLineContent(cm, lineView)\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) { lineView.node = built.pre; }\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n    if (lineView.line.wrapClass)\n      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n    else if (lineView.node != lineView.text)\n      { lineView.node.className = \"\"; }\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n      gutterWrap.setAttribute(\"aria-hidden\", \"true\");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        { lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                     (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n      } }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) { lineView.alignable = null; }\n    var isWidget = classTest(\"CodeMirror-linewidget\");\n    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n      next = node.nextSibling;\n      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) { lineView.bgClass = built.bgClass; }\n    if (built.textClass) { lineView.textClass = built.textClass; }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) { return }\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\" + (widget.className ? \" \" + widget.className : \"\"));\n      if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n      else\n        { wrap.appendChild(node); }\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n  (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) { return widget.height }\n    var cm = widget.doc.cm;\n    if (!cm) { return 0 }\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n      if (widget.noHScroll)\n        { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight\n  }\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        { return true }\n    }\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\n  function paddingH(display) {\n    if (display.cachedPaddingH) { return display.cachedPaddingH }\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\", \"CodeMirror-line-like\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n    return data\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n    if (lineView.rest) {\n      for (var i = 0; i < lineView.rest.length; i++)\n        { if (lineView.rest[i] == line)\n          { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n      for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n        { if (lineNo(lineView.rest[i$1]) > lineN)\n          { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n    }\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      { return cm.display.view[findViewIndex(cm, lineN)] }\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      { return ext }\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      { view = updateExternalMeasurement(cm, line); }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    }\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) { ch = -1; }\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) { prepared.cache[key] = found; }\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom}\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      mStart = map[i];\n      mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) { collapse = \"right\"; }\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          { collapse = bias; }\n        if (bias == \"left\" && start == 0)\n          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          } }\n        if (bias == \"right\" && start == mEnd - mStart)\n          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          } }\n        break\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n    if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) { break }\n    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n      if ((rect = rects[i$1]).left != rect.right) { break }\n    } }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n          { rect = node.parentNode.getBoundingClientRect(); }\n        else\n          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n        if (rect.left || rect.right || start == 0) { break }\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) { collapse = bias = \"right\"; }\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n      else\n        { rect = node.getBoundingClientRect(); }\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n      else\n        { rect = nullRect; }\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n    for (; i < heights.length - 1; i++)\n      { if (mid < heights[i]) { break } }\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) { result.bogus = true; }\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      { return rect }\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n        { lineView.measure.caches[i] = {}; } }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      { clearLineMeasurementCacheFor(cm.display.view[i]); }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX(doc) {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) { return -(doc.body.getBoundingClientRect().left - parseInt(getComputedStyle(doc.body).marginLeft)) }\n    return doc.defaultView.pageXOffset || (doc.documentElement || doc.body).scrollLeft\n  }\n  function pageScrollY(doc) {\n    if (chrome && android) { return -(doc.body.getBoundingClientRect().top - parseInt(getComputedStyle(doc.body).marginTop)) }\n    return doc.defaultView.pageYOffset || (doc.documentElement || doc.body).scrollTop\n  }\n\n  function widgetTopHeight(lineObj) {\n    var ref = visualLine(lineObj);\n    var widgets = ref.widgets;\n    var height = 0;\n    if (widgets) { for (var i = 0; i < widgets.length; ++i) { if (widgets[i].above)\n      { height += widgetHeight(widgets[i]); } } }\n    return height\n  }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height; rect.bottom += height;\n    }\n    if (context == \"line\") { return rect }\n    if (!context) { context = \"local\"; }\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") { yOff += paddingTop(cm.display); }\n    else { yOff -= cm.display.viewOffset; }\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY(doc(cm)));\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX(doc(cm)));\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") { return coords }\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX(doc(cm));\n      top -= pageScrollY(doc(cm));\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) { m.left = m.right; } else { m.right = m.left; }\n      return intoCoordSystem(cm, lineObj, m, context)\n    }\n    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n    if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos], right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert)\n    }\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n    if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n    return val\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height}\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n    if (outside) { pos.outside = outside; }\n    return pos\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }\n    if (x < 0) { x = 0; }\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n      if (!collapsed) { return found }\n      var rangeEnd = collapsed.find(1);\n      if (rangeEnd.line == lineN) { return rangeEnd }\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n    return {begin: begin, end: end}\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n  }\n\n  // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    // Move y into line-local coordinate space\n    y -= heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n    var widgetHeight = widgetTopHeight(lineObj);\n    var begin = 0, end = lineObj.text.length, ltr = true;\n\n    var order = getOrder(lineObj, cm.doc.direction);\n    // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);\n      ltr = part.level != 1;\n      // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    }\n\n    // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n    var chAround = null, boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight; box.bottom += widgetHeight;\n      if (!boxIsAfter(box, x, y, false)) { return false }\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n      return true\n    }, begin, end);\n\n    var baseX, sticky, outside = false;\n    // If a box around the coordinates was found, use that\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) { ch++; }\n      // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?\n        \"after\" : \"before\";\n      // Now get accurate coordinates for this place, in order to get a\n      // base X position\n      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), \"line\", lineObj, preparedMeasure);\n      baseX = coords.left;\n      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i], ltr = part.level != 1;\n      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                     \"line\", lineObj, preparedMeasure), x, y, true)\n    }, 0, order.length - 1);\n    var part = order[index];\n    // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n    if (index > 0) {\n      var ltr = part.level != 1;\n      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                               \"line\", lineObj, preparedMeasure);\n      if (boxIsAfter(start, x, y, true) && start.top > y)\n        { part = order[index - 1]; }\n    }\n    return part\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n    var part = null, closestDist = null;\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n      if (p.from >= end || p.to <= begin) { continue }\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n      // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n    if (!part) { part = order[order.length - 1]; }\n    // Clip the part to the wrapped line.\n    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n    return part\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n    if (measureText == null) {\n      measureText = elt(\"pre\", null, \"CodeMirror-line-like\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) { display.cachedTextHeight = height; }\n    removeChildren(display.measure);\n    return height || 1\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor], \"CodeMirror-line-like\");\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) { display.cachedCharWidth = width; }\n    return width || 10\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      var id = cm.display.gutterSpecs[i].className;\n      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[id] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth}\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) { return 0 }\n\n      var widgetsHeight = 0;\n      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n      } }\n\n      if (wrapping)\n        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n      else\n        { return widgetsHeight + th }\n    }\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n    });\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e$1) { return null }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) { return null }\n    n -= cm.display.viewFrom;\n    if (n < 0) { return null }\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) { return i }\n    }\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) { from = cm.doc.first; }\n    if (to == null) { to = cm.doc.first + cm.doc.size; }\n    if (!lendiff) { lendiff = 0; }\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      { display.updateLineNumbers = from; }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        { resetView(cm); }\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        { ext.lineN += lendiff; }\n      else if (from < ext.lineN + ext.size)\n        { display.externalMeasured = null; }\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n\n    if (line < display.viewFrom || line >= display.viewTo) { return }\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) { return }\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) { arr.push(type); }\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      { return {index: index, lineN: newN} }\n    var n = cm.display.viewFrom;\n    for (var i = 0; i < index; i++)\n      { n += view[i].size; }\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) { return null }\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN}\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n      else if (display.viewFrom < from)\n        { display.view = display.view.slice(findViewIndex(cm, from)); }\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n      else if (display.viewTo > to)\n        { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n    }\n    return dirty\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if ( primary === void 0 ) primary = true;\n\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    var customCursor = cm.options.$customCursor;\n    if (customCursor) { primary = true; }\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) { continue }\n      var range = doc.sel.ranges[i];\n      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }\n      var collapsed = range.empty();\n      if (customCursor) {\n        var head = customCursor(cm, range);\n        if (head) { drawSelectionCursor(cm, head, curFragment); }\n      } else if (collapsed || cm.options.showCursorWhenSelecting) {\n        drawSelectionCursor(cm, range.head, curFragment);\n      }\n      if (!collapsed)\n        { drawSelectionRange(cm, range, selFragment); }\n    }\n    return result\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (/\\bcm-fat-cursor\\b/.test(cm.getWrapperElement().className)) {\n      var charPos = charCoords(cm, head, \"div\", null, null);\n      var width = charPos.right - charPos.left;\n      cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + \"px\";\n    }\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) { top = 0; }\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop]\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n        var first = i == 0, last = !order || i == order.length - 1;\n        if (toPos.top - fromPos.top <= 3) { // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else { // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n        if (cmpCoords(toPos, start) < 0) { start = toPos; }\n        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n        if (cmpCoords(toPos, end) < 0) { end = toPos; }\n      });\n      return {start: start, end: end}\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) { return }\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      { display.blinker = setInterval(function () {\n        if (!cm.hasFocus()) { onBlur(cm); }\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate); }\n    else if (cm.options.cursorBlinkRate < 0)\n      { display.cursorDiv.style.visibility = \"hidden\"; }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.hasFocus()) {\n      cm.display.input.focus();\n      if (!cm.state.focused) { onFocus(cm); }\n    }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { if (cm.state.delayingBlurEvent) {\n      cm.state.delayingBlurEvent = false;\n      if (cm.state.focused) { onBlur(cm); }\n    } }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }\n\n    if (cm.options.readOnly == \"nocursor\") { return }\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) { return }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);\n    var oldHeight = display.lineDiv.getBoundingClientRect().top;\n    var mustScroll = 0;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], wrapping = cm.options.lineWrapping;\n      var height = (void 0), width = 0;\n      if (cur.hidden) { continue }\n      oldHeight += cur.line.height;\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n        // Check that lines don't extend past the right of the current\n        // editor width\n        if (!wrapping && cur.text.firstChild)\n          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }\n      }\n      var diff = cur.line.height - height;\n      if (diff > .005 || diff < -.005) {\n        if (oldHeight < viewTop) { mustScroll -= diff; }\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n          { updateWidgetHeight(cur.rest[j]); } }\n      }\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n    if (Math.abs(mustScroll) > 2) { display.scroller.scrollTop += mustScroll; }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\n      var w = line.widgets[i], parent = w.node.parentNode;\n      if (parent) { w.height = parent.offsetHeight; }\n    } }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)}\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    var doc = display.wrapper.ownerDocument;\n    if (rect.top + box.top < 0) { doScroll = true; }\n    else if (rect.bottom + box.top > (doc.defaultView.innerHeight || doc.documentElement.clientHeight)) { doScroll = false; }\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) { margin = 0; }\n    var rect;\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n    }\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n      var coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      rect = {left: Math.min(coords.left, endCoords.left),\n              top: Math.min(coords.top, endCoords.top) - margin,\n              right: Math.max(coords.left, endCoords.left),\n              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n      }\n      if (!changed) { break }\n    }\n    return rect\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (rect.top < 0) { rect.top = 0; }\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n      if (newTop != screentop) { result.scrollTop = newTop; }\n    }\n\n    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n    var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n    var tooWide = rect.right - rect.left > screenw;\n    if (tooWide) { rect.right = rect.left + screenw; }\n    if (rect.left < 10)\n      { result.scrollLeft = 0; }\n    else if (rect.left < screenleft)\n      { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }\n    else if (rect.right > screenw + screenleft - 3)\n      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n    return result\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollTop(cm, top) {\n    if (top == null) { return }\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) { resolveScrollToPos(cm); }\n    if (x != null) { cm.curOp.scrollLeft = x; }\n    if (y != null) { cm.curOp.scrollTop = y; }\n  }\n\n  function scrollToRange(cm, range) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range;\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      scrollToCoordsRange(cm, from, to, range.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  }\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n    if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n    setScrollTop(cm, val, true);\n    if (gecko) { updateDisplaySimple(cm); }\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n  }\n\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    }\n  }\n\n  var NativeScrollbars = function(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      this.vert.firstChild.style.height =\n        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.scrollTop = 0;\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width =\n        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) { this.zeroWidthHack(); }\n      this.checkedZeroWidth = true;\n    }\n\n    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.visibility = this.vert.style.visibility = \"hidden\";\n    this.disableHoriz = new Delayed;\n    this.disableVert = new Delayed;\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.visibility = \"\";\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n      if (elt != bar) { bar.style.visibility = \"hidden\"; }\n      else { delay.set(1000, maybeDisable); }\n    }\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function () {};\n\n  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\n  NullScrollbars.prototype.setScrollLeft = function () {};\n  NullScrollbars.prototype.setScrollTop = function () {};\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) { measure = measureForScrollbars(cm); }\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        { updateHeightsInViewport(cm); }\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else { d.scrollbarFiller.style.display = \"\"; }\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else { d.gutterFiller.style.display = \"\"; }\n  }\n\n  var scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n      else { updateScrollTop(cm, pos); }\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: 0,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId,          // Unique ID\n      markArrays: null         // Used by addMarkedSpan\n    };\n    pushOperation(cm.curOp);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp;\n    if (op) { finishOperation(op, function (group) {\n      for (var i = 0; i < group.ops.length; i++)\n        { group.ops[i].cm.curOp = null; }\n      endOperations(group);\n    }); }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      { endOperation_R1(ops[i]); }\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n      { endOperation_W1(ops[i$1]); }\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n      { endOperation_R2(ops[i$2]); }\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n      { endOperation_W2(ops[i$3]); }\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n      { endOperation_finish(ops[i$4]); }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) { findMaxLine(cm); }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      { op.preparedSelection = display.input.prepareSelection(); }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt(root(cm));\n    if (op.preparedSelection)\n      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      { updateScrollbars(cm, op.barMeasure); }\n    if (op.updatedDisplay)\n      { setDocumentHeight(cm, op.barMeasure); }\n\n    if (op.selectionChanged) { restartBlink(cm); }\n\n    if (cm.state.focused && op.updateInput)\n      { cm.display.input.reset(op.typing); }\n    if (takeFocus) { ensureFocus(op.cm); }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      { display.wheelStartX = display.wheelStartY = null; }\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) { for (var i = 0; i < hidden.length; ++i)\n      { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n    if (display.wrapper.offsetHeight)\n      { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      { signal(cm, \"changes\", cm, op.changeObjs); }\n    if (op.update)\n      { op.update.finish(); }\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) { return f() }\n    startOperation(cm);\n    try { return f() }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) { return f.apply(cm, arguments) }\n      startOperation(cm);\n      try { return f.apply(cm, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) { return f.apply(this, arguments) }\n      startOperation(this);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(this); }\n    }\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) { return f.apply(this, arguments) }\n      startOperation(cm);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo)\n      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.highlightFrontier >= cm.display.viewTo) { return }\n    var end = +new Date + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n        if (resetState) { context.state = resetState; }\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) { line.styleClasses = newCls; }\n        else if (oldCls) { line.styleClasses = null; }\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n        if (ischange) { changedLines.push(context.line); }\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          { processLine(cm, line.text, context); }\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n    if (changedLines.length) { runInOp(cm, function () {\n      for (var i = 0; i < changedLines.length; i++)\n        { regLineChange(cm, changedLines[i], \"text\"); }\n    }); }\n  }\n\n  // DISPLAY DRAWING\n\n  var DisplayUpdate = function(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type))\n      { this.events.push(arguments); }\n  };\n  DisplayUpdate.prototype.finish = function () {\n    for (var i = 0; i < this.events.length; i++)\n      { signal.apply(null, this.events[i]); }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) { return null }\n    var active = activeElt(root(cm));\n    if (!active || !contains(cm.display.lineDiv, active)) { return null }\n    var result = {activeElt: active};\n    if (window.getSelection) {\n      var sel = win(cm).getSelection();\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n    return result\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt(rootNode(snapshot.activeElt))) { return }\n    snapshot.activeElt.focus();\n    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&\n        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var doc = snapshot.activeElt.ownerDocument;\n      var sel = doc.defaultView.getSelection(), range = doc.createRange();\n      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      { return false }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      { return false }\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var selSnapshot = selectionSnapshot(cm);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    restoreSelection(selSnapshot);\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          { break }\n      } else if (first) {\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n      }\n      if (!updateDisplayIfNeeded(cm, update)) { break }\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        { node.style.display = \"none\"; }\n      else\n        { node.parentNode.removeChild(node); }\n      return next\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) { cur = rm(cur); }\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) { cur = rm(cur); }\n  }\n\n  function updateGutterSpace(display) {\n    var width = display.gutters.offsetWidth;\n    display.sizer.style.marginLeft = width + \"px\";\n    // Send an event to consumers responding to changes in gutter width.\n    signalLater(display, \"gutterChanged\", display);\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n  }\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n      if (cm.options.fixedGutter) {\n        if (view[i].gutter)\n          { view[i].gutter.style.left = left; }\n        if (view[i].gutterBackground)\n          { view[i].gutterBackground.style.left = left; }\n      }\n      var align = view[i].alignable;\n      if (align) { for (var j = 0; j < align.length; j++)\n        { align[j].style.left = left; } }\n    } }\n    if (cm.options.fixedGutter)\n      { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) { return false }\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm.display);\n      return true\n    }\n    return false\n  }\n\n  function getGutters(gutters, lineNumbers) {\n    var result = [], sawLineNumbers = false;\n    for (var i = 0; i < gutters.length; i++) {\n      var name = gutters[i], style = null;\n      if (typeof name != \"string\") { style = name.style; name = name.className; }\n      if (name == \"CodeMirror-linenumbers\") {\n        if (!lineNumbers) { continue }\n        else { sawLineNumbers = true; }\n      }\n      result.push({className: name, style: style});\n    }\n    if (lineNumbers && !sawLineNumbers) { result.push({className: \"CodeMirror-linenumbers\", style: null}); }\n    return result\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function renderGutters(display) {\n    var gutters = display.gutters, specs = display.gutterSpecs;\n    removeChildren(gutters);\n    display.lineGutter = null;\n    for (var i = 0; i < specs.length; ++i) {\n      var ref = specs[i];\n      var className = ref.className;\n      var style = ref.style;\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + className));\n      if (style) { gElt.style.cssText = style; }\n      if (className == \"CodeMirror-linenumbers\") {\n        display.lineGutter = gElt;\n        gElt.style.width = (display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = specs.length ? \"\" : \"none\";\n    updateGutterSpace(display);\n  }\n\n  function updateGutters(cm) {\n    renderGutters(cm.display);\n    regChange(cm);\n    alignHorizontally(cm);\n  }\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input, options) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [lines], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n    // See #6982. FIXME remove when this has been fixed for a while in Chrome\n    if (chrome && chrome_version >= 105) { d.wrapper.style.clipPath = \"inset(0px)\"; }\n\n    // This attribute is respected by automatic translation systems such as Google Translate,\n    // and may also be respected by tools used by human translators.\n    d.wrapper.setAttribute('translate', 'no');\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n    if (place) {\n      if (place.appendChild) { place.appendChild(d.wrapper); }\n      else { place(d.wrapper); }\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n    renderGutters(d);\n\n    input.init(d);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) { wheelPixelsPerUnit = -.53; }\n  else if (gecko) { wheelPixelsPerUnit = 15; }\n  else if (chrome) { wheelPixelsPerUnit = -.7; }\n  else if (safari) { wheelPixelsPerUnit = -1/3; }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n    else if (dy == null) { dy = e.wheelDelta; }\n    return {x: dx, y: dy}\n  }\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta\n  }\n\n  function onScrollWheel(cm, e) {\n    // On Chrome 102, viewport updates somehow stop wheel-based\n    // scrolling. Turning off pointer events during the scroll seems\n    // to avoid the issue.\n    if (chrome && chrome_version == 102) {\n      if (cm.display.chromeScrollHack == null) { cm.display.sizer.style.pointerEvents = \"none\"; }\n      else { clearTimeout(cm.display.chromeScrollHack); }\n      cm.display.chromeScrollHack = setTimeout(function () {\n        cm.display.chromeScrollHack = null;\n        cm.display.sizer.style.pointerEvents = \"\";\n      }, 100);\n    }\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n    var pixelsPerUnit = wheelPixelsPerUnit;\n    if (e.deltaMode === 0) {\n      dx = e.deltaX;\n      dy = e.deltaY;\n      pixelsPerUnit = 1;\n    }\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && pixelsPerUnit != null) {\n      if (dy && canScrollY)\n        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit)); }\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        { e_preventDefault(e); }\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && pixelsPerUnit != null) {\n      var pixels = dy * pixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20 && e.deltaMode !== 0) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) { return }\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) { return }\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  var Selection = function(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\n  Selection.prototype.equals = function (other) {\n    if (other == this) { return true }\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this.ranges[i], there = other.ranges[i];\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n    }\n    return true\n  };\n\n  Selection.prototype.deepCopy = function () {\n    var out = [];\n    for (var i = 0; i < this.ranges.length; i++)\n      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }\n    return new Selection(out, this.primIndex)\n  };\n\n  Selection.prototype.somethingSelected = function () {\n    for (var i = 0; i < this.ranges.length; i++)\n      { if (!this.ranges[i].empty()) { return true } }\n    return false\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n    if (!end) { end = pos; }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this.ranges[i];\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n        { return i }\n    }\n    return -1\n  };\n\n  var Range = function(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  };\n\n  Range.prototype.from = function () { return minPos(this.anchor, this.head) };\n  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };\n  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) { --primIndex; }\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex)\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0)\n  }\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  function changeEnd(change) {\n    if (!change.text) { return change.to }\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n  }\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) { return pos }\n    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n    return Pos(line, ch)\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex)\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n    else\n      { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex)\n  }\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) { line.stateAfter = null; }\n      if (line.styles) { line.styles = null; }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) { regChange(cm); }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      var result = [];\n      for (var i = start; i < end; ++i)\n        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }\n      return result\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) { doc.remove(from.line, nlines); }\n      if (added.length) { doc.insert(from.line, added); }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) { continue }\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) { continue }\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      } }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) { throw new Error(\"This document is already in use.\") }\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n    cm.options.direction = doc.direction;\n    if (!cm.options.lineWrapping) { findMaxLine(cm); }\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(prev) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = prev ? prev.undoDepth : Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n    return histChange\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) { array.pop(); }\n      else { break }\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done)\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done)\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done)\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n    var last;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        { pushSelectionToHistory(doc.sel, hist.done); }\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) { hist.done.shift(); }\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) { signal(doc, \"historyAdded\"); }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      { hist.done[hist.done.length - 1] = sel; }\n    else\n      { pushSelectionToHistory(sel, hist.done); }\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      { clearSelectionEvents(hist.undone); }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      { dest.push(sel); }\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans)\n        { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) { return null }\n    var out;\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n      else if (out) { out.push(spans[i]); }\n    }\n    return !out ? spans : out.length ? out : null\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) { return null }\n    var nw = [];\n    for (var i = 0; i < change.text.length; ++i)\n      { nw.push(removeClearedSpans(found[i])); }\n    return nw\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) { return stretched }\n    if (!stretched) { return old }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            { if (oldCur[k].marker == span.marker) { continue spans } }\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m = (void 0);\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        } } }\n      }\n    }\n    return copy\n  }\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head)\n    } else {\n      return new Range(other || head, head)\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    for (var i = 0; i < doc.sel.ranges.length; i++)\n      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head)); }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }\n    else { return sel }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      { sel = filterSelectionChange(doc, sel, options); }\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption(\"readOnly\") != \"nocursor\")\n      { ensureCursorVisible(doc.cm); }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) { return }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = range.head == range.anchor ? newAnchor : skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) { out = sel.ranges.slice(0, i); }\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n\n      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker\n      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it\n      // is with selectLeft/Right\n      var preventCursorLeft = (\"selectLeft\" in m) ? !m.selectLeft : m.inclusiveLeft;\n      var preventCursorRight = (\"selectRight\" in m) ? !m.selectRight : m.inclusiveRight;\n\n      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) { break }\n            else {--i; continue}\n          }\n        }\n        if (!m.atomic) { continue }\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n          if (dir < 0 ? preventCursorRight : preventCursorLeft)\n            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? preventCursorLeft : preventCursorRight)\n          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n      }\n    } }\n    return pos\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0)\n    }\n    return found\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n      else { return null }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n      else { return null }\n    } else {\n      return new Pos(pos.line, pos.ch + dir)\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  }\n\n  // UPDATING\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function () { return obj.canceled = true; }\n    };\n    if (update) { obj.update = function (from, to, text, origin) {\n      if (from) { obj.from = clipPos(doc, from); }\n      if (to) { obj.to = clipPos(doc, to); }\n      if (text) { obj.text = text; }\n      if (origin !== undefined) { obj.origin = origin; }\n    }; }\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n    if (obj.canceled) {\n      if (doc.cm) { doc.cm.curOp.updateInput = 2; }\n      return null\n    }\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n      if (doc.cm.state.suppressEdits) { return }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) { return }\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n    if (suppress && !allowSelectionOnly) { return }\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    var i = 0;\n    for (; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        { break }\n    }\n    if (i == source.length) { return }\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return\n        }\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return\n      } else { break }\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function ( i ) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {}\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop( i$1 );\n\n      if ( returned ) return returned.v;\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) { return }\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n      Pos(range.anchor.line + distance, range.anchor.ch),\n      Pos(range.head.line + distance, range.head.ch)\n    ); }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        { regLineChange(doc.cm, l, \"gutter\"); }\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return\n    }\n    if (change.from.line > doc.lastLine()) { return }\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n    else { updateDoc(doc, change, spans); }\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\n    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))\n      { doc.cantEdit = false; }\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      { signalCursorActivity(cm); }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      { regChange(cm); }\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      { regLineChange(cm, from.line, \"text\"); }\n    else\n      { regChange(cm, from.line, to.line + 1, lendiff); }\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) { to = from; }\n    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }\n    if (typeof code == \"string\") { code = doc.splitLines(code); }\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue\n      }\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n    else { no = lineNo(handle); }\n    if (no == null) { return null }\n    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n    return line\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length },\n\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }\n    },\n\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        { if (op(this.lines[at])) { return true } }\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size },\n\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }\n    },\n\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this.children.splice(++i, 0, leaf);\n              leaf.parent = this;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this.maybeSpill();\n          }\n          break\n        }\n        at -= sz;\n      }\n    },\n\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) { return }\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10)\n      me.parent.maybeSpill();\n    },\n\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) { return true }\n          if ((n -= used) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n    }\n  };\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function(doc, node, options) {\n    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n      { this[opt] = options[opt]; } } }\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) { return }\n    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }\n    if (!ws.length) { line.widgets = null; }\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n      var this$1 = this;\n\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) { return }\n    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      { addToScrollTop(cm, diff); }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) { widgets.push(widget); }\n      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) { addToScrollTop(cm, widget.height); }\n        cm.curOp.forceUpdate = true;\n      }\n      return true\n    });\n    if (cm) { signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle)); }\n    return widget\n  }\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  var TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) { startOperation(cm); }\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) { signalLater(this, \"clear\", found.from, found.to); }\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n      else if (cm) {\n        if (span.to != null) { max = lineNo(line); }\n        if (span.from != null) { min = lineNo(line); }\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        { updateLineHeight(line, textHeight(cm.display)); }\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    } }\n\n    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) { reCheckSelection(cm.doc); }\n    }\n    if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n    if (withOp) { endOperation(cm); }\n    if (this.parent) { this.parent.clear(); }\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function (side, lineObj) {\n    if (side == null && this.type == \"bookmark\") { side = 1; }\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) { return from }\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) { return to }\n      }\n    }\n    return from && {from: from, to: to}\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function () {\n      var this$1 = this;\n\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) { return }\n    runInOp(cm, function () {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          { updateLineHeight(line, line.height + dHeight); }\n      }\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n    }\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp\n      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n  eventMixin(TextMarker);\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) { copyObj(options, marker, false); }\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      { return marker }\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory)\n      { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        { updateMaxLine = true; }\n      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n    }); }\n\n    if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n      if (doc.history.done.length || doc.history.undone.length)\n        { doc.clearHistory(); }\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n      if (marker.collapsed)\n        { regChange(cm, from.line, to.line + 1); }\n      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||\n               marker.attributes || marker.title)\n        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n      if (marker.atomic) { reCheckSelection(cm.doc); }\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      { markers[i].parent = this; }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      { this.markers[i].clear(); }\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj)\n  };\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) { options.widgetNode = widget.cloneNode(true); }\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        { if (doc.linked[i].isParent) { return } }\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary)\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function ( i ) {\n      var marker = markers[i], linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) loop( i );\n  }\n\n  var nextDocId = 0;\n  var Doc = function(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n    if (firstLine == null) { firstLine = 0; }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") { text = this.splitLines(text); }\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) { this.iterN(from - this.first, to - from, op); }\n      else { this.iterN(this.first, this.first + this.size, from); }\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) { return lines }\n      if (lineSep === '') { return lines.join('') }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n    getLineNumber: function(line) {return lineNo(line)},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") { line = getLine(this, line); }\n      return visualLine(line)\n    },\n\n    lineCount: function() {return this.size},\n    firstLine: function() {return this.first},\n    lastLine: function() {return this.first + this.size - 1},\n\n    clipPos: function(pos) {return clipPos(this, pos)},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") { pos = range.head; }\n      else if (start == \"anchor\") { pos = range.anchor; }\n      else if (start == \"end\" || start == \"to\" || start === false) { pos = range.to(); }\n      else { pos = range.from(); }\n      return pos\n    },\n    listSelections: function() { return this.sel.ranges },\n    somethingSelected: function() {return this.sel.somethingSelected()},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) { return }\n      var out = [];\n      for (var i = 0; i < ranges.length; i++)\n        { out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head || ranges[i].anchor)); }\n      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) { return lines }\n      else { return lines.join(lineSep || this.lineSeparator()) }\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }\n        parts[i] = sel;\n      }\n      return parts\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        { dup[i] = code; }\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n        { makeChange(this, changes[i$1]); }\n      if (newSel) { setSelectionReplaceHistory(this, newSel); }\n      else if (this.cm) { ensureCursorVisible(this.cm); }\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n      return {undo: done, redo: undone}\n    },\n    clearHistory: function() {\n      var this$1 = this;\n\n      this.history = new History(this.history);\n      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);\n    },\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n      return this.history.generation\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration)\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)}\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    setGutterMarker: docMethodOp(function(line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n        return true\n      })\n    }),\n\n    clearGutter: docMethodOp(function(gutterID) {\n      var this$1 = this;\n\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n            return true\n          });\n        }\n      });\n    }),\n\n    lineInfo: function(line) {\n      var n;\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) { return null }\n        n = line;\n        line = getLine(this, line);\n        if (!line) { return null }\n      } else {\n        n = lineNo(line);\n        if (n == null) { return null }\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets}\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) { line[prop] = cls; }\n        else if (classTest(cls).test(line[prop])) { return false }\n        else { line[prop] += \" \" + cls; }\n        return true\n      })\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) { return false }\n        else if (cls == null) { line[prop] = null; }\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) { return false }\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true\n      })\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options)\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\")\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          { markers.push(span.marker.parent || span.marker); }\n      } }\n      return markers\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n        if (spans) { for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\n                span.from == null && lineNo != from.line ||\n                span.from != null && lineNo == to.line && span.from >= to.ch) &&\n              (!filter || filter(span.marker)))\n            { found.push(span.marker.parent || span.marker); }\n        } }\n        ++lineNo;\n      });\n      return found\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n        if (sps) { for (var i = 0; i < sps.length; ++i)\n          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n      });\n      return markers\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n        if (sz > off) { ch = off; return true }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch))\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) { return 0 }\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc\n    },\n\n    linkedDoc: function(options) {\n      if (!options) { options = {}; }\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) { from = options.from; }\n      if (options.to != null && options.to < to) { to = options.to; }\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n      if (options.sharedHist) { copy.history = this.history\n      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) { other = other.doc; }\n      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) { continue }\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break\n      } }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode},\n    getEditor: function() {return this.cm},\n\n    splitLines: function(str) {\n      if (this.lineSep) { return str.split(this.lineSep) }\n      return splitLinesAuto(str)\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") { dir = \"ltr\"; }\n      if (dir == this.direction) { return }\n      this.direction = dir;\n      this.iter(function (line) { return line.order = null; });\n      if (this.cm) { directionChanged(this.cm); }\n    })\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      { return }\n    e_preventDefault(e);\n    if (ie) { lastDrop = +new Date; }\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) { return }\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var markAsReadAndPasteIfAllFilesAreRead = function () {\n        if (++read == n) {\n          operation(cm, function () {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(\n                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));\n          })();\n        }\n      };\n      var readTextFromFile = function (file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n          markAsReadAndPasteIfAllFilesAreRead();\n          return\n        }\n        var reader = new FileReader;\n        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };\n        reader.onload = function () {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n            markAsReadAndPasteIfAllFilesAreRead();\n            return\n          }\n          text[i] = content;\n          markAsReadAndPasteIfAllFilesAreRead();\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function () { return cm.display.input.focus(); }, 20);\n        return\n      }\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n        if (text$1) {\n          var selected;\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\n            { selected = cm.listSelections(); }\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n            { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e$1){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\";\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) { img.parentNode.removeChild(img); }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) { return }\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) { return }\n    var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) { editors.push(cm); }\n    }\n    if (editors.length) { editors[0].operation(function () {\n      for (var i = 0; i < editors.length; i++) { f(editors[i]); }\n    }); }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) { return }\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100); }\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n  }\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 145: \"ScrollLock\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 224: \"Mod\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n\n  // Number keys\n  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n  // Alphabetic keys\n  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n  // Function keys\n  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\n  var keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\", \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\",\n    \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\",\n    \"Ctrl-T\": \"transposeChars\", \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n      else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n      else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n      else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n    }\n    if (alt) { name = \"Alt-\" + name; }\n    if (ctrl) { name = \"Ctrl-\" + name; }\n    if (cmd) { name = \"Cmd-\" + name; }\n    if (shift) { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n      if (value == \"...\") { delete keymap[keyname]; continue }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val = (void 0), name = (void 0);\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) { copy[name] = val; }\n        else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n      }\n      delete keymap[keyname];\n    } }\n    for (var prop in copy) { keymap[prop] = copy[prop]; }\n    return keymap\n  }\n\n  function lookupKey(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n    if (found === false) { return \"nothing\" }\n    if (found === \"...\") { return \"multi\" }\n    if (found != null && handle(found)) { return \"handled\" }\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n        { return lookupKey(key, map.fallthrough, handle, context) }\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n        if (result) { return result }\n      }\n    }\n  }\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n    if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Mod\") { name = \"Cmd-\" + name; }\n    if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // Look up the name of a key as indicated by an event object.\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) { return false }\n    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n    if (event.keyCode == 3 && event.code) { name = event.code; }\n    return addModifierNames(name, event, noShift)\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      if (cm.doc.direction == \"rtl\") { dir = -dir; }\n      var order = getOrder(lineObj, cm.doc.direction);\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = (dir < 0) == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch;\n        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n        if (part.level > 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n          if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n        } else { ch = dir < 0 ? part.to : part.from; }\n        return new Pos(lineNo, ch, sticky)\n      }\n    }\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n    if (!bidi) { return moveLogically(line, start, dir) }\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n    if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir)\n    }\n\n    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n    var prep;\n    var getWrappedLineExtent = function (ch) {\n      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch)\n    };\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = (part.level == 1) == (dir < 0);\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky)\n      }\n    }\n\n    // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n        ? new Pos(start.line, mv(ch, 1), \"before\")\n        : new Pos(start.line, ch, \"after\"); };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = (dir > 0) == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n      }\n    };\n\n    // Case 3a: Look for other bidi parts on the same visual line\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n    if (res) { return res }\n\n    // Case 3b: Look for other bidi parts on the next visual line\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n      if (res) { return res }\n    }\n\n    // Case 4: Nowhere to move\n    return null\n  }\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n    killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n      if (range.empty()) {\n        var len = getLine(cm.doc, range.head.line).text.length;\n        if (range.head.ch == len && range.head.line < cm.lastLine())\n          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n        else\n          { return {from: range.head, to: Pos(range.head.line, len)} }\n      } else {\n        return {from: range.from(), to: range.to()}\n      }\n    }); },\n    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0),\n      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n    }); }); },\n    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0), to: range.from()\n    }); }); },\n    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n      return {from: leftPos, to: range.from()}\n    }); },\n    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      return {from: range.from(), to: rightPos }\n    }); },\n    undo: function (cm) { return cm.undo(); },\n    redo: function (cm) { return cm.redo(); },\n    undoSelection: function (cm) { return cm.undoSelection(); },\n    redoSelection: function (cm) { return cm.redoSelection(); },\n    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n      {origin: \"+move\", bias: -1}\n    ); },\n    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: 0, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n      if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n      return pos\n    }, sel_move); },\n    goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n    goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n    goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n    goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n    goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n    goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n    goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n    goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n    goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n    goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n    goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n    goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n    delCharBefore: function (cm) { return cm.deleteH(-1, \"codepoint\"); },\n    delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n    delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n    delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n    delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n    delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n    indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n    indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n    indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n    insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n    insertSoftTab: function (cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function (cm) {\n      if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n      else { cm.execCommand(\"insertTab\"); }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function (cm) { return runInOp(cm, function () {\n      var ranges = cm.listSelections(), newSel = [];\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty()) { continue }\n        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n        if (line) {\n          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n          if (cur.ch > 0) {\n            cur = new Pos(cur.line, cur.ch + 1);\n            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                            Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n          } else if (cur.line > cm.doc.first) {\n            var prev = getLine(cm.doc, cur.line - 1).text;\n            if (prev) {\n              cur = new Pos(cur.line, 1);\n              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                              prev.charAt(prev.length - 1),\n                              Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n            }\n          }\n        }\n        newSel.push(new Range(cur, cur));\n      }\n      cm.setSelections(newSel);\n    }); },\n    newlineAndIndent: function (cm) { return runInOp(cm, function () {\n      var sels = cm.listSelections();\n      for (var i = sels.length - 1; i >= 0; i--)\n        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n      sels = cm.listSelections();\n      for (var i$1 = 0; i$1 < sels.length; i$1++)\n        { cm.indentLine(sels[i$1].from().line, null, true); }\n      ensureCursorVisible(cm);\n    }); },\n    openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n  };\n\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, visual, lineN, 1)\n  }\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, line, lineN, -1)\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n    }\n    return start\n  }\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) { return false }\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      if (dropShift) { cm.display.shift = false; }\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) { return result }\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm)\n  }\n\n  // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n  var stopSeq = new Delayed;\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) { return \"handled\" }\n      if (/\\'$/.test(name))\n        { cm.state.keySeq = null; }\n      else\n        { stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        }); }\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\n    }\n    return dispatchKeyInner(cm, name, e, handle)\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      { cm.state.keySeq = name; }\n    if (result == \"handled\")\n      { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) { return false }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n          || dispatchKey(cm, name, e, function (b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 { return doHandleBinding(cm, b) }\n             })\n    } else {\n      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    cm.curOp.focus = activeElt(root(cm));\n    if (signalDOMEvent(cm, e)) { return }\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        { cm.replaceSelection(\"\", null, \"cut\"); }\n    }\n    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)\n      { document.execCommand(\"cut\"); }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      { showCrossHair(cm); }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) { this.doc.sel.shift = false; }\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    // Some browsers fire keypress events for backspace\n    if (ch == \"\\x08\") { return }\n    if (handleCharBinding(cm, e, ch)) { return }\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time &&\n      cmp(pos, this.pos) == 0 && button == this.button\n  };\n\n  var lastClick, lastDoubleClick;\n  function clickRepeat(pos, button) {\n    var now = +new Date;\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\"\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\"\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\"\n    }\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () { return display.scroller.draggable = true; }, 100);\n      }\n      return\n    }\n    if (clickInGutter(cm, e)) { return }\n    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n    win(cm).focus();\n\n    // #3261: make sure, that we're not starting a second selection\n    if (button == 1 && cm.state.selectingText)\n      { cm.state.selectingText(e); }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n    if (button == 1) {\n      if (pos) { leftButtonDown(cm, pos, repeat, e); }\n      else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n    } else if (button == 2) {\n      if (pos) { extendSelection(cm.doc, pos); }\n      setTimeout(function () { return display.input.focus(); }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) { cm.display.input.onContextMenu(e); }\n      else { delayBlurEvent(cm); }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n    if (repeat == \"double\") { name = \"Double\" + name; }\n    else if (repeat == \"triple\") { name = \"Triple\" + name; }\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") { bound = commands[bound]; }\n      if (!bound) { return false }\n      var done = false;\n      try {\n        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n      return done\n    })\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n    return value\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n    else { cm.curOp.focus = activeElt(root(cm)); }\n\n    var behavior = configureMouse(cm, repeat, event);\n\n    var sel = cm.doc.sel, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n      { leftButtonStartDrag(cm, event, pos, behavior); }\n    else\n      { leftButtonSelect(cm, event, pos, behavior); }\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display, moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) { display.scroller.draggable = false; }\n      cm.state.draggingText = false;\n      if (cm.state.delayingBlurEvent) {\n        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }\n        else { delayBlurEvent(cm); }\n      }\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n      if (!moved) {\n        e_preventDefault(e);\n        if (!behavior.addNew)\n          { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if ((webkit && !safari) || ie && ie_version == 9)\n          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }\n        else\n          { display.input.focus(); }\n      }\n    });\n    var mouseMove = function(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n    var dragStart = function () { return moved = true; };\n    // Let the drag handler handle this.\n    if (webkit) { display.scroller.draggable = true; }\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { return display.input.focus(); }, 20);\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") { return new Range(pos, pos) }\n    if (unit == \"word\") { return cm.findWordAt(pos) }\n    if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to)\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, event, start, behavior) {\n    if (ie) { delayBlurEvent(cm); }\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(event);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        { ourRange = ranges[ourIndex]; }\n      else\n        { ourRange = new Range(start, start); }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) { ourRange = new Range(start, start); }\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range = rangeForUnit(cm, start, behavior.unit);\n      if (behavior.extend)\n        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }\n      else\n        { ourRange = range; }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) { return }\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n          else if (text.length > leftPos)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n        }\n        if (!ranges.length) { ranges.push(new Range(start, start)); }\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor, head;\n        if (cmp(range.anchor, anchor) > 0) {\n          head = range.head;\n          anchor = minPos(oldRange.from(), range.anchor);\n        } else {\n          head = range.anchor;\n          anchor = maxPos(oldRange.to(), range.head);\n        }\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n      if (!cur) { return }\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt(root(cm));\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) { setTimeout(operation(cm, function () {\n          if (counter != curCount) { return }\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50); }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      // If e is null or undefined we interpret this as someone trying\n      // to explicitly cancel the selection rather than the user\n      // letting go of the mouse button.\n      if (e) {\n        e_preventDefault(e);\n        display.input.focus();\n      }\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) { done(e); }\n      else { extend(e); }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  }\n\n  // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n  function bidiSimplify(cm, range) {\n    var anchor = range.anchor;\n    var head = range.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }\n    var order = getOrder(anchorLine);\n    if (!order) { return range }\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n    if (part.from != anchor.ch && part.to != anchor.ch) { return range }\n    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n    if (boundary == 0 || boundary == order.length) { return range }\n\n    // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n    var leftSide;\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n      if (headIndex == boundary - 1 || headIndex == boundary)\n        { leftSide = dir < 0; }\n      else\n        { leftSide = dir > 0; }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)\n  }\n\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try { mX = e.clientX; mY = e.clientY; }\n      catch(e$1) { return false }\n    }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n    if (prevent) { e_preventDefault(e); }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.display.gutterSpecs[i];\n        signal(cm, type, cm, line, gutter.className, e);\n        return e_defaultPrevented(e)\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true)\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n    if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n    if (!captureRightClick) { cm.display.input.onContextMenu(e); }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n    return gutterEvent(cm, e, \"gutterContextMenu\", false)\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {toString: function(){return \"CodeMirror.Init\"}};\n\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n      if (handle) { optionHandlers[name] =\n        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n    }\n\n    CodeMirror.defineOption = option;\n\n    // Passed to option handlers when there is no old value.\n    CodeMirror.Init = Init;\n\n    // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n    option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n      if (!val) { return }\n      var newBreaks = [], lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n          if (found == -1) { break }\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n        lineNo++;\n      });\n      for (var i = newBreaks.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b\\u200e\\u200f\\u2028\\u2029\\u202d\\u202e\\u2066\\u2067\\u2069\\ufeff\\ufff9-\\ufffc]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n      if (old != Init) { cm.refresh(); }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n    option(\"autocorrect\", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);\n    option(\"autocapitalize\", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      updateGutters(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n      if (prev && prev.detach) { prev.detach(cm, next); }\n      if (next.attach) { next.attach(cm, prev || null); }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm, val) {\n      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n      updateGutters(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm, val) {\n      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n      updateGutters(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, updateGutters, true);\n    option(\"lineNumberFormatter\", function (integer) { return integer; }, updateGutters, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n      cm.display.input.readOnlyChanged(val);\n    });\n\n    option(\"screenReaderLabel\", null, function (cm, val) {\n      val = (val === '') ? null : val;\n      cm.display.input.screenReaderLabelChanged(val);\n    });\n\n    option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) { cm.display.input.resetPosition(); }\n    });\n\n    option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n    option(\"phrases\", null);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () { return updateScrollbars(cm); }, 100);\n  }\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n    else if (options.mode) { doc.modeOption = options.mode; }\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input, options);\n    display.wrapper.CodeMirror = this;\n    themeChanged(this);\n    if (options.lineWrapping)\n      { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) { display.input.focus(); }\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || this.hasFocus())\n      { setTimeout(function () {\n        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }\n      }, 20); }\n    else\n      { onBlur(this); }\n\n    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n      { optionHandlers[opt](this, options[opt], Init); } }\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) { options.finishInit(this); }\n    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      { display.lineDiv.style.textRendering = \"auto\"; }\n  }\n\n  // The default configuration options.\n  CodeMirror.defaults = defaults;\n  // Functions to run when options are changed.\n  CodeMirror.optionHandlers = optionHandlers;\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) { return }\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      })); }\n    else\n      { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); });\n    on(d.input.getField(), \"contextmenu\", function (e) {\n      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }\n    });\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    }\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) { return false }\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1\n    }\n    function farAway(touch, other) {\n      if (other.left == null) { return true }\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20\n    }\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) { d.activeTouch.moved = true; }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          { range = new Range(pos, pos); }\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          { range = cm.findWordAt(pos); }\n        else // Triple tap\n          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n    on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function (e) { return onDragStart(cm, e); },\n      drop: operation(cm, onDrop),\n      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n    on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n  }\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) { how = \"add\"; }\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) { how = \"prev\"; }\n      else { state = getContextBefore(cm, n).state; }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) { line.stateAfter = null; }\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) { return }\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n      else { indentation = 0; }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n    if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break\n        }\n      }\n    }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) { sel = doc.sel; }\n\n    var recent = +new Date - 200;\n    var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n    var textLines = splitLinesAuto(inserted), multiPaste = null;\n    // When pasting N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.text.length; i++)\n            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) { return [l]; });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput;\n    // Normal behavior is to insert the new text into every selection\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range = sel.ranges[i$1];\n      var from = range.from(), to = range.to();\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          { from = Pos(from.line, from.ch - deleted); }\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == textLines.join(\"\\n\"))\n          { from = to = Pos(from.line, 0); }\n      }\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      { triggerElectric(cm, inserted); }\n\n    ensureCursorVisible(cm);\n    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput && cm.hasFocus())\n        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n      return true\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break\n          } }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n          { indented = indentLine(cm, range.head.line, \"smart\"); }\n      }\n      if (indented) { signalLater(cm, \"electricInput\", cm, range.head.line); }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges}\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute(\"autocorrect\", autocorrect ? \"on\" : \"off\");\n    field.setAttribute(\"autocapitalize\", autocapitalize ? \"on\" : \"off\");\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) { te.style.width = \"1000px\"; }\n    else { te.setAttribute(\"wrap\", \"off\"); }\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) { te.style.border = \"1px solid black\"; }\n    return div\n  }\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    var helpers = CodeMirror.helpers = {};\n\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function(){win(this).focus(); this.display.input.focus();},\n\n      setOption: function(option, value) {\n        var options = this.options, old = options[option];\n        if (options[option] == value && option != \"mode\") { return }\n        options[option] = value;\n        if (optionHandlers.hasOwnProperty(option))\n          { operation(this, optionHandlers[option])(this, value, old); }\n        signal(this, \"optionChange\", this, option);\n      },\n\n      getOption: function(option) {return this.options[option]},\n      getDoc: function() {return this.doc},\n\n      addKeyMap: function(map, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n      },\n      removeKeyMap: function(map) {\n        var maps = this.state.keyMaps;\n        for (var i = 0; i < maps.length; ++i)\n          { if (maps[i] == map || maps[i].name == map) {\n            maps.splice(i, 1);\n            return true\n          } }\n      },\n\n      addOverlay: methodOp(function(spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n        if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n        insertSorted(this.state.overlays,\n                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                      priority: (options && options.priority) || 0},\n                     function (overlay) { return overlay.priority; });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function(spec) {\n        var overlays = this.state.overlays;\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n          if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this.state.modeGen++;\n            regChange(this);\n            return\n          }\n        }\n      }),\n\n      indentLine: methodOp(function(n, dir, aggressive) {\n        if (typeof dir != \"string\" && typeof dir != \"number\") {\n          if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n          else { dir = dir ? \"add\" : \"subtract\"; }\n        }\n        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n      }),\n      indentSelection: methodOp(function(how) {\n        var ranges = this.doc.sel.ranges, end = -1;\n        for (var i = 0; i < ranges.length; i++) {\n          var range = ranges[i];\n          if (!range.empty()) {\n            var from = range.from(), to = range.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n            for (var j = start; j < end; ++j)\n              { indentLine(this, j, how); }\n            var newRanges = this.doc.sel.ranges;\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n          } else if (range.head.line > end) {\n            indentLine(this, range.head.line, how, true);\n            end = range.head.line;\n            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }\n          }\n        }\n      }),\n\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function(pos, precise) {\n        return takeToken(this, pos, precise)\n      },\n\n      getLineTokens: function(line, precise) {\n        return takeToken(this, Pos(line), precise, true)\n      },\n\n      getTokenTypeAt: function(pos) {\n        pos = clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n        var type;\n        if (ch == 0) { type = styles[2]; }\n        else { for (;;) {\n          var mid = (before + after) >> 1;\n          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n          else { type = styles[mid * 2 + 2]; break }\n        } }\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n      },\n\n      getModeAt: function(pos) {\n        var mode = this.doc.mode;\n        if (!mode.innerMode) { return mode }\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n      },\n\n      getHelper: function(pos, type) {\n        return this.getHelpers(pos, type)[0]\n      },\n\n      getHelpers: function(pos, type) {\n        var found = [];\n        if (!helpers.hasOwnProperty(type)) { return found }\n        var help = helpers[type], mode = this.getModeAt(pos);\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) { found.push(help[mode[type]]); }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n            if (val) { found.push(val); }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n            { found.push(cur.val); }\n        }\n        return found\n      },\n\n      getStateAfter: function(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n        return getContextBefore(this, line + 1, precise).state\n      },\n\n      cursorCoords: function(start, mode) {\n        var pos, range = this.doc.sel.primary();\n        if (start == null) { pos = range.head; }\n        else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n        else { pos = start ? range.from() : range.to(); }\n        return cursorCoords(this, pos, mode || \"page\")\n      },\n\n      charCoords: function(pos, mode) {\n        return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n      },\n\n      coordsChar: function(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return coordsChar(this, coords.left, coords.top)\n      },\n\n      lineAtHeight: function(height, mode) {\n        height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n        return lineAtHeight(this.doc, height + this.display.viewOffset)\n      },\n      heightAtLine: function(line, mode, includeWidgets) {\n        var end = false, lineObj;\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n          if (line < this.doc.first) { line = this.doc.first; }\n          else if (line > last) { line = last; end = true; }\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n          (end ? this.doc.height - heightAtLine(lineObj) : 0)\n      },\n\n      defaultTextHeight: function() { return textHeight(this.display) },\n      defaultCharWidth: function() { return charWidth(this.display) },\n\n      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = cursorCoords(this, clipPos(this.doc, pos));\n        var top = pos.bottom, left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n          // Default to positioning above (if specified and possible); otherwise default to positioning below\n          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n            { top = pos.top - node.offsetHeight; }\n          else if (pos.bottom + node.offsetHeight <= vspace)\n            { top = pos.bottom; }\n          if (left + node.offsetWidth > hspace)\n            { left = hspace - node.offsetWidth; }\n        }\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") { left = 0; }\n          else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n          node.style.left = left + \"px\";\n        }\n        if (scroll)\n          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n      },\n\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n\n      execCommand: function(cmd) {\n        if (commands.hasOwnProperty(cmd))\n          { return commands[cmd].call(null, this) }\n      },\n\n      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n      findPosH: function(from, amount, unit, visually) {\n        var dir = 1;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          cur = findPosH(this.doc, cur, dir, unit, visually);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveH: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        this.extendSelectionsBy(function (range) {\n          if (this$1.display.shift || this$1.doc.extend || range.empty())\n            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }\n          else\n            { return dir < 0 ? range.from() : range.to() }\n        }, sel_move);\n      }),\n\n      deleteH: methodOp(function(dir, unit) {\n        var sel = this.doc.sel, doc = this.doc;\n        if (sel.somethingSelected())\n          { doc.replaceSelection(\"\", null, \"+delete\"); }\n        else\n          { deleteNearSelection(this, function (range) {\n            var other = findPosH(doc, range.head, dir, unit, false);\n            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}\n          }); }\n      }),\n\n      findPosV: function(from, amount, unit, goalColumn) {\n        var dir = 1, x = goalColumn;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          var coords = cursorCoords(this, cur, \"div\");\n          if (x == null) { x = coords.left; }\n          else { coords.left = x; }\n          cur = findPosV(this, coords, dir, unit);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveV: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        var doc = this.doc, goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range) {\n          if (collapse)\n            { return dir < 0 ? range.from() : range.to() }\n          var headPos = cursorCoords(this$1, range.head, \"div\");\n          if (range.goalColumn != null) { headPos.left = range.goalColumn; }\n          goals.push(headPos.left);\n          var pos = findPosV(this$1, headPos, dir, unit);\n          if (unit == \"page\" && range == doc.sel.primary())\n            { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n          return pos\n        }, sel_move);\n        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n          { doc.sel.ranges[i].goalColumn = goals[i]; } }\n      }),\n\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function(pos) {\n        var doc = this.doc, line = getLine(doc, pos.line).text;\n        var start = pos.ch, end = pos.ch;\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n          if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper)\n            ? function (ch) { return isWordChar(ch, helper); }\n            : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n            : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n          while (start > 0 && check(line.charAt(start - 1))) { --start; }\n          while (end < line.length && check(line.charAt(end))) { ++end; }\n        }\n        return new Range(Pos(pos.line, start), Pos(pos.line, end))\n      },\n\n      toggleOverwrite: function(value) {\n        if (value != null && value == this.state.overwrite) { return }\n        if (this.state.overwrite = !this.state.overwrite)\n          { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n        else\n          { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function() { return this.display.input.getField() == activeElt(root(this)) },\n      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n      getScrollInfo: function() {\n        var scroller = this.display.scroller;\n        return {left: scroller.scrollLeft, top: scroller.scrollTop,\n                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n      },\n\n      scrollIntoView: methodOp(function(range, margin) {\n        if (range == null) {\n          range = {from: this.doc.sel.primary().head, to: null};\n          if (margin == null) { margin = this.options.cursorScrollMargin; }\n        } else if (typeof range == \"number\") {\n          range = {from: Pos(range, 0), to: null};\n        } else if (range.from == null) {\n          range = {from: range, to: null};\n        }\n        if (!range.to) { range.to = range.from; }\n        range.margin = margin || 0;\n\n        if (range.from.line != null) {\n          scrollToRange(this, range);\n        } else {\n          scrollToCoordsRange(this, range.from, range.to, range.margin);\n        }\n      }),\n\n      setSize: methodOp(function(width, height) {\n        var this$1 = this;\n\n        var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n        if (width != null) { this.display.wrapper.style.width = interpret(width); }\n        if (height != null) { this.display.wrapper.style.height = interpret(height); }\n        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n        var lineNo = this.display.viewFrom;\n        this.doc.iter(lineNo, this.display.viewTo, function (line) {\n          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, \"widget\"); break } } }\n          ++lineNo;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n\n      operation: function(f){return runInOp(this, f)},\n      startOperation: function(){return startOperation(this)},\n      endOperation: function(){return endOperation(this)},\n\n      refresh: methodOp(function() {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this.display);\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)\n          { estimateLineHeights(this); }\n        signal(this, \"refresh\", this);\n      }),\n\n      swapDoc: methodOp(function(doc) {\n        var old = this.doc;\n        old.cm = null;\n        // Cancel the current text selection if any (#5821)\n        if (this.state.selectingText) { this.state.selectingText(); }\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old\n      }),\n\n      phrase: function(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText\n      },\n\n      getInputField: function(){return this.display.input.getField()},\n      getWrapperElement: function(){return this.display.wrapper},\n      getScrollerElement: function(){return this.display.scroller},\n      getGutterElement: function(){return this.display.gutters}\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function(type, name, value) {\n      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n      helpers[type][name] = value;\n    };\n    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n      helpers[type]._global.push({pred: predicate, val: value});\n    };\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"codepoint\", \"char\", \"column\" (like char, but\n  // doesn't cross line boundaries), \"word\" (across next word), or\n  // \"group\" (to the start of next group of word or\n  // non-word-non-whitespace chars). The visually param controls\n  // whether, in right-to-left text, direction 1 means to move towards\n  // the next index in the string, or towards the character to the right\n  // of the current position. The resulting position will have a\n  // hitSide=true property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    var lineDir = visually && doc.direction == \"rtl\" ? -dir : dir;\n    function findNextLine() {\n      var l = pos.line + lineDir;\n      if (l < doc.first || l >= doc.first + doc.size) { return false }\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l)\n    }\n    function moveOnce(boundToLine) {\n      var next;\n      if (unit == \"codepoint\") {\n        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));\n        if (isNaN(ch)) {\n          next = null;\n        } else {\n          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;\n          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);\n        }\n      } else if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n      if (next == null) {\n        if (!boundToLine && findNextLine())\n          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }\n        else\n          { return false }\n      } else {\n        pos = next;\n      }\n      return true\n    }\n\n    if (unit == \"char\" || unit == \"codepoint\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) { break }\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) { type = \"s\"; }\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n          break\n        }\n\n        if (type) { sawType = type; }\n        if (dir > 0 && !moveOnce(!first)) { break }\n      }\n    }\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n    return result\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, win(cm).innerHeight || doc(cm).documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    var target;\n    for (;;) {\n      target = coordsChar(cm, x, y);\n      if (!target.outside) { break }\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n      y += dir * 5;\n    }\n    return target\n  }\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  var ContentEditableInput = function(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = input.cm;\n    var div = input.div = display.lineDiv;\n    div.contentEditable = true;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n\n    function belongsToInput(e) {\n      for (var t = e.target; t; t = t.parentNode) {\n        if (t == div) { return true }\n        if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) { break }\n      }\n      return false\n    }\n\n    on(div, \"paste\", function (e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n      // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n    });\n\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {data: e.data, done: false};\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n        this$1.composing.done = true;\n      }\n    });\n\n    on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n    on(div, \"input\", function () {\n      if (!this$1.composing) { this$1.readFromDOMSoon(); }\n    });\n\n    function onCopyCut(e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n        if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\");\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        e.clipboardData.setData(\"Text\", content);\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return\n        }\n      }\n      // Old-fashioned briefly-focus-a-textarea hack\n      var kludge = hiddenTextarea(), te = kludge.firstChild;\n      disableBrowserMagic(te);\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = activeElt(rootNode(div));\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n        if (hadFocus == div) { input.showPrimarySelection(); }\n      }, 50);\n    }\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.div.setAttribute('aria-label', label);\n    } else {\n      this.div.removeAttribute('aria-label');\n    }\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = activeElt(rootNode(this.div)) == this.div;\n    return result\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) { return }\n    if (info.focus || takeFocus) { this.showPrimarySelection(); }\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection()\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n    var from = prim.from(), to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n        cmp(minPos(curAnchor, curFocus), from) == 0 &&\n        cmp(maxPos(curAnchor, curFocus), to) == 0)\n      { return }\n\n    var view = cm.display.view;\n    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n        {node: view[0].measure.map[2], offset: 0};\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0), rng;\n    try { rng = range(start.node, start.offset, end.offset, end.node); }\n    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n      if (old && sel.anchorNode == null) { sel.addRange(old); }\n      else if (gecko) { this.startGracePeriod(); }\n    }\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n      var this$1 = this;\n\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n      if (this$1.selectionChanged())\n        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n    if (!sel.rangeCount) { return false }\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node)\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor() || activeElt(rootNode(this.div)) != this.div)\n        { this.showSelection(this.prepareSelection(), true); }\n      this.div.focus();\n    }\n  };\n  ContentEditableInput.prototype.blur = function () { this.div.blur(); };\n  ContentEditableInput.prototype.getField = function () { return this.div };\n\n  ContentEditableInput.prototype.supportsTouch = function () { return true };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n      var this$1 = this;\n\n    var input = this;\n    if (this.selectionInEditor())\n      { setTimeout(function () { return this$1.pollSelection(); }, 20); }\n    else\n      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n    var sel = this.getSelection(), cm = this.cm;\n    // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n      this.blur();\n      this.focus();\n      return\n    }\n    if (this.composing) { return }\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (anchor && head) { runInOp(cm, function () {\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n    }); }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n    var from = sel.from(), to = sel.to();\n    if (from.ch == 0 && from.line > cm.firstLine())\n      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n      { to = Pos(to.line + 1, 0); }\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n    var fromIndex, fromLine, fromNode;\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) { return false }\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n      else { break }\n    }\n\n    var cutFront = 0, cutEnd = 0;\n    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n      { ++cutFront; }\n    var newBot = lst(newText), oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                             oldBot.length - (oldText.length == 1 ? cutFront : 0));\n    while (cutEnd < maxCutEnd &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n      { ++cutEnd; }\n    // Try to move start of change to start of selection if ambiguous\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n      return true\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) { return }\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n      var this$1 = this;\n\n    if (this.readDOMTimeout != null) { return }\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n      if (this$1.composing) {\n        if (this$1.composing.done) { this$1.composing = null; }\n        else { return }\n      }\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n      var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent())\n      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) { return }\n    e.preventDefault();\n    if (!this.cm.isReadOnly())\n      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) { return null }\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line, cm.doc.direction), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode)\n      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n    return false\n  }\n\n  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n    function close() {\n      if (closing) {\n        text += lineSep;\n        if (extraLinebreak) { text += lineSep; }\n        closing = extraLinebreak = false;\n      }\n    }\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText) {\n          addText(cmText);\n          return\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range = found[0].find(0)))\n            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }\n          return\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }\n\n        if (isBlock) { close(); }\n        for (var i = 0; i < node.childNodes.length; i++)\n          { walk(node.childNodes[i]); }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }\n        if (isBlock) { closing = true; }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) { break }\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n    return text\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        { return locateNodeInLineView(lineView, node, offset) }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad)\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) { offset = textNode.nodeValue.length; }\n    }\n    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }\n            return Pos(line, ch)\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) { return badPos(found, bad) }\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        { return badPos(Pos(found.line, found.ch - dist), bad) }\n      else\n        { dist += after.textContent.length; }\n    }\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n      else\n        { dist$1 += before.textContent.length; }\n    }\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  var TextareaInput = function(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n    this.resetting = false;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n    if (ios) { te.style.width = \"0px\"; }\n\n    on(te, \"input\", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n      input.poll();\n    });\n\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n      cm.state.pasteIncoming = +new Date;\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n      if (e.type == \"cut\") { cm.state.cutIncoming = +new Date; }\n    }\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date;\n        input.focus();\n        return\n      }\n\n      // Pass the `paste` event to the textarea so it's handled by its event listener.\n      var event = new Event(\"paste\");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    });\n\n    // Prevent normal selection in the editor (we handle our own)\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) { e_preventDefault(e); }\n    });\n\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n      if (input.composing) { input.composing.range.clear(); }\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea();\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    this.textarea = this.wrapper.firstChild;\n    var opts = this.cm.options;\n    disableBrowserMagic(this.textarea, opts.spellcheck, opts.autocorrect, opts.autocapitalize);\n  };\n\n  TextareaInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.textarea.setAttribute('aria-label', label);\n    } else {\n      this.textarea.removeAttribute('aria-label');\n    }\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm, display = cm.display, doc = cm.doc;\n    var result = prepareSelection(cm);\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm, display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  };\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing && typing) { return }\n    var cm = this.cm;\n    this.resetting = true;\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n      if (cm.state.focused) { selectInput(this.textarea); }\n      if (ie && ie_version >= 9) { this.hasSelection = content; }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n      if (ie && ie_version >= 9) { this.hasSelection = null; }\n    }\n    this.resetting = false;\n  };\n\n  TextareaInput.prototype.getField = function () { return this.textarea };\n\n  TextareaInput.prototype.supportsTouch = function () { return false };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt(rootNode(this.textarea)) != this.textarea)) {\n      try { this.textarea.focus(); }\n      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n    }\n  };\n\n  TextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  TextareaInput.prototype.slowPoll = function () {\n      var this$1 = this;\n\n    if (this.pollingFast) { return }\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n      if (this$1.cm.state.focused) { this$1.slowPoll(); }\n    });\n  };\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false, input = this;\n    input.pollingFast = true;\n    function p() {\n      var changed = input.poll();\n      if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n      else {input.pollingFast = false; input.slowPoll();}\n    }\n    input.polling.set(20, p);\n  };\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  TextareaInput.prototype.poll = function () {\n      var this$1 = this;\n\n    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (this.contextMenuPending || this.resetting || !cm.state.focused ||\n        (hasSelection(input) && !prevInput && !this.composing) ||\n        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n      { return false }\n\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput && !cm.somethingSelected()) { return false }\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie && ie_version >= 9 && this.hasSelection === text ||\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n      if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n      if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n    }\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same,\n                     null, this$1.composing ? \"*compose\" : null);\n\n      // Don't leave long text in the textarea, since it makes further polling slow\n      if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n      else { this$1.prevInput = text; }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                           {className: \"CodeMirror-composing\"});\n      }\n    });\n    return true\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n    if (input.contextMenuPending) { input.contextMenuPending(); }\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) { return } // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && cm.doc.sel.contains(pos) == -1)\n      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n    if (webkit) { oldScrollY = te.ownerDocument.defaultView.scrollY; } // Work around Chrome issue (#2712)\n    display.input.focus();\n    if (webkit) { te.ownerDocument.defaultView.scrollTo(null, oldScrollY); }\n    display.input.reset();\n    // Adds \"Select all\" to context menu in FF\n    if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200b\" + (selected ? te.value : \"\");\n        te.value = \"\\u21da\"; // Used to catch context-menu undo\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200b\";\n        te.selectionStart = 1; te.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      if (input.contextMenuPending != rehide) { return }\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n      // Try to detect the user choosing select-all\n      if (te.selectionStart != null) {\n        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n        var i = 0, poll = function () {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n              te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function () {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) { this.reset(); }\n    this.textarea.disabled = val == \"nocursor\";\n    this.textarea.readOnly = !!val;\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      { options.tabindex = textarea.tabIndex; }\n    if (!options.placeholder && textarea.placeholder)\n      { options.placeholder = textarea.placeholder; }\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt(rootNode(textarea));\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n\n    var realSubmit;\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n      cm.getTextArea = function () { return textarea; };\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == \"function\")\n            { textarea.form.submit = realSubmit; }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n      options);\n    return cm\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  }\n\n  // EDITOR CONSTRUCTOR\n\n  defineOptions(CodeMirror);\n\n  addEditorMethods(CodeMirror);\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    { CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments)}\n    })(Doc.prototype[prop]); } }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name/*, mode, …*/) {\n    if (!CodeMirror.defaults.mode && name != \"null\") { CodeMirror.defaults.mode = name; }\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME;\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n\n  addLegacyProps(CodeMirror);\n\n  CodeMirror.version = \"5.65.16\";\n\n  return CodeMirror;\n\n})));\n"]}